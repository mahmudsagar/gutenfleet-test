{"version":3,"sources":["@wordpress/block-editor/src/components/font-sizes/fluid-utils.js"],"names":["DEFAULT_MAXIMUM_VIEWPORT_WIDTH","DEFAULT_MINIMUM_VIEWPORT_WIDTH","DEFAULT_SCALE_FACTOR","DEFAULT_MINIMUM_FONT_SIZE_FACTOR","DEFAULT_MAXIMUM_FONT_SIZE_FACTOR","DEFAULT_MINIMUM_FONT_SIZE_LIMIT","getComputedFluidTypographyValue","minimumFontSize","maximumFontSize","fontSize","minimumViewPortWidth","maximumViewPortWidth","scaleFactor","minimumFontSizeFactor","maximumFontSizeFactor","minimumFontSizeLimit","minimumFontSizeValue","fontSizeParsed","getTypographyValueAndUnit","unit","roundToPrecision","value","minimumFontSizeLimitParsed","coerceTo","minimumFontSizeParsed","fontSizeUnit","maximumFontSizeParsed","minimumFontSizeRem","maximumViewPortWidthParsed","minumumViewPortWidthParsed","minViewPortWidthOffsetValue","viewPortWidthOffset","linearFactor","linearFactorScaled","fluidTargetFontSize","rawValue","options","isFinite","rootSizeValue","acceptableUnits","acceptableUnitsGroup","join","regexUnits","RegExp","matches","match","length","returnValue","parseFloat","digits","base","Math","pow","Number","round","undefined"],"mappings":"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","sourcesContent":["/**\n * The fluid utilities must match the backend equivalent.\n * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php\n * ---------------------------------------------------------------\n */\n\n// Defaults.\nconst DEFAULT_MAXIMUM_VIEWPORT_WIDTH = '1600px';\nconst DEFAULT_MINIMUM_VIEWPORT_WIDTH = '768px';\nconst DEFAULT_SCALE_FACTOR = 1;\nconst DEFAULT_MINIMUM_FONT_SIZE_FACTOR = 0.75;\nconst DEFAULT_MAXIMUM_FONT_SIZE_FACTOR = 1.5;\nconst DEFAULT_MINIMUM_FONT_SIZE_LIMIT = '14px';\n\n/**\n * Computes a fluid font-size value that uses clamp(). A minimum and maxinmum\n * font size OR a single font size can be specified.\n *\n * If a single font size is specified, it is scaled up and down by\n * minimumFontSizeFactor and maximumFontSizeFactor to arrive at the minimum and\n * maximum sizes.\n *\n * @example\n * ```js\n * // Calculate fluid font-size value from a minimum and maximum value.\n * const fontSize = getComputedFluidTypographyValue( {\n *     minimumFontSize: '20px',\n *     maximumFontSize: '45px'\n * } );\n * // Calculate fluid font-size value from a single font size.\n * const fontSize = getComputedFluidTypographyValue( {\n *     fontSize: '30px',\n * } );\n * ```\n *\n * @param {Object}        args\n * @param {?string}       args.minimumViewPortWidth  Minimum viewport size from which type will have fluidity. Optional if fontSize is specified.\n * @param {?string}       args.maximumViewPortWidth  Maximum size up to which type will have fluidity. Optional if fontSize is specified.\n * @param {string|number} [args.fontSize]            Size to derive maximumFontSize and minimumFontSize from, if necessary. Optional if minimumFontSize and maximumFontSize are specified.\n * @param {?string}       args.maximumFontSize       Maximum font size for any clamp() calculation. Optional.\n * @param {?string}       args.minimumFontSize       Minimum font size for any clamp() calculation. Optional.\n * @param {?number}       args.scaleFactor           A scale factor to determine how fast a font scales within boundaries. Optional.\n * @param {?number}       args.minimumFontSizeFactor How much to scale defaultFontSize by to derive minimumFontSize. Optional.\n * @param {?number}       args.maximumFontSizeFactor How much to scale defaultFontSize by to derive maximumFontSize. Optional.\n *\n * @return {string|null} A font-size value using clamp().\n */\nexport function getComputedFluidTypographyValue( {\n\tminimumFontSize,\n\tmaximumFontSize,\n\tfontSize,\n\tminimumViewPortWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,\n\tmaximumViewPortWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,\n\tscaleFactor = DEFAULT_SCALE_FACTOR,\n\tminimumFontSizeFactor = DEFAULT_MINIMUM_FONT_SIZE_FACTOR,\n\tmaximumFontSizeFactor = DEFAULT_MAXIMUM_FONT_SIZE_FACTOR,\n\tminimumFontSizeLimit = DEFAULT_MINIMUM_FONT_SIZE_LIMIT,\n} ) {\n\t/*\n\t * Caches minimumFontSize in minimumFontSizeValue\n\t * so we can check if minimumFontSize exists later.\n\t */\n\tlet minimumFontSizeValue = minimumFontSize;\n\n\t/*\n\t * Calculates missing minimumFontSize and maximumFontSize from\n\t * defaultFontSize if provided.\n\t */\n\tif ( fontSize ) {\n\t\t// Parses default font size.\n\t\tconst fontSizeParsed = getTypographyValueAndUnit( fontSize );\n\n\t\t// Protect against invalid units.\n\t\tif ( ! fontSizeParsed?.unit ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If no minimumFontSize is provided, derive using min scale factor.\n\t\tif ( ! minimumFontSizeValue ) {\n\t\t\tminimumFontSizeValue =\n\t\t\t\troundToPrecision(\n\t\t\t\t\tfontSizeParsed.value * minimumFontSizeFactor,\n\t\t\t\t\t3\n\t\t\t\t) + fontSizeParsed.unit;\n\t\t}\n\n\t\t// Parses the minimum font size limit, so we can perform checks using it.\n\t\tconst minimumFontSizeLimitParsed = getTypographyValueAndUnit(\n\t\t\tminimumFontSizeLimit,\n\t\t\t{\n\t\t\t\tcoerceTo: fontSizeParsed.unit,\n\t\t\t}\n\t\t);\n\n\t\tif ( !! minimumFontSizeLimitParsed?.value ) {\n\t\t\t/*\n\t\t\t * If a minimum size was not passed to this function\n\t\t\t * and the user-defined font size is lower than `minimumFontSizeLimit`,\n\t\t\t * then uses the user-defined font size as the minimum font-size.\n\t\t\t */\n\t\t\tif (\n\t\t\t\t! minimumFontSize &&\n\t\t\t\tfontSizeParsed?.value < minimumFontSizeLimitParsed?.value\n\t\t\t) {\n\t\t\t\tminimumFontSizeValue = `${ fontSizeParsed.value }${ fontSizeParsed.unit }`;\n\t\t\t} else {\n\t\t\t\tconst minimumFontSizeParsed = getTypographyValueAndUnit(\n\t\t\t\t\tminimumFontSizeValue,\n\t\t\t\t\t{\n\t\t\t\t\t\tcoerceTo: fontSizeParsed.unit,\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, if the passed or calculated minimum font size is lower than `minimumFontSizeLimit`\n\t\t\t\t * use `minimumFontSizeLimit` instead.\n\t\t\t\t */\n\t\t\t\tif (\n\t\t\t\t\t!! minimumFontSizeParsed?.value &&\n\t\t\t\t\tminimumFontSizeParsed.value <\n\t\t\t\t\t\tminimumFontSizeLimitParsed.value\n\t\t\t\t) {\n\t\t\t\t\tminimumFontSizeValue = `${ minimumFontSizeLimitParsed.value }${ minimumFontSizeLimitParsed.unit }`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If no maximumFontSize is provided, derive using max scale factor.\n\t\tif ( ! maximumFontSize ) {\n\t\t\tmaximumFontSize =\n\t\t\t\troundToPrecision(\n\t\t\t\t\tfontSizeParsed.value * maximumFontSizeFactor,\n\t\t\t\t\t3\n\t\t\t\t) + fontSizeParsed.unit;\n\t\t}\n\t}\n\n\t// Return early if one of the provided inputs is not provided.\n\tif ( ! minimumFontSizeValue || ! maximumFontSize ) {\n\t\treturn null;\n\t}\n\n\t// Grab the minimum font size and normalize it in order to use the value for calculations.\n\tconst minimumFontSizeParsed =\n\t\tgetTypographyValueAndUnit( minimumFontSizeValue );\n\n\t// We get a 'preferred' unit to keep units consistent when calculating,\n\t// otherwise the result will not be accurate.\n\tconst fontSizeUnit = minimumFontSizeParsed?.unit || 'rem';\n\n\t// Grabs the maximum font size and normalize it in order to use the value for calculations.\n\tconst maximumFontSizeParsed = getTypographyValueAndUnit( maximumFontSize, {\n\t\tcoerceTo: fontSizeUnit,\n\t} );\n\n\t// Checks for mandatory min and max sizes, and protects against unsupported units.\n\tif ( ! minimumFontSizeParsed || ! maximumFontSizeParsed ) {\n\t\treturn null;\n\t}\n\n\t// Uses rem for accessible fluid target font scaling.\n\tconst minimumFontSizeRem = getTypographyValueAndUnit(\n\t\tminimumFontSizeValue,\n\t\t{\n\t\t\tcoerceTo: 'rem',\n\t\t}\n\t);\n\n\t// Viewport widths defined for fluid typography. Normalize units\n\tconst maximumViewPortWidthParsed = getTypographyValueAndUnit(\n\t\tmaximumViewPortWidth,\n\t\t{ coerceTo: fontSizeUnit }\n\t);\n\tconst minumumViewPortWidthParsed = getTypographyValueAndUnit(\n\t\tminimumViewPortWidth,\n\t\t{ coerceTo: fontSizeUnit }\n\t);\n\n\t// Protect against unsupported units.\n\tif (\n\t\t! maximumViewPortWidthParsed ||\n\t\t! minumumViewPortWidthParsed ||\n\t\t! minimumFontSizeRem\n\t) {\n\t\treturn null;\n\t}\n\n\t// Build CSS rule.\n\t// Borrowed from https://websemantics.uk/tools/responsive-font-calculator/.\n\tconst minViewPortWidthOffsetValue = roundToPrecision(\n\t\tminumumViewPortWidthParsed.value / 100,\n\t\t3\n\t);\n\n\tconst viewPortWidthOffset =\n\t\troundToPrecision( minViewPortWidthOffsetValue, 3 ) + fontSizeUnit;\n\tconst linearFactor =\n\t\t100 *\n\t\t( ( maximumFontSizeParsed.value - minimumFontSizeParsed.value ) /\n\t\t\t( maximumViewPortWidthParsed.value -\n\t\t\t\tminumumViewPortWidthParsed.value ) );\n\tconst linearFactorScaled = roundToPrecision(\n\t\t( linearFactor || 1 ) * scaleFactor,\n\t\t3\n\t);\n\tconst fluidTargetFontSize = `${ minimumFontSizeRem.value }${ minimumFontSizeRem.unit } + ((1vw - ${ viewPortWidthOffset }) * ${ linearFactorScaled })`;\n\n\treturn `clamp(${ minimumFontSizeValue }, ${ fluidTargetFontSize }, ${ maximumFontSize })`;\n}\n\n/**\n * Internal method that checks a string for a unit and value and returns an array consisting of `'value'` and `'unit'`, e.g., [ '42', 'rem' ].\n * A raw font size of `value + unit` is expected. If the value is an integer, it will convert to `value + 'px'`.\n *\n * @param {string|number}    rawValue Raw size value from theme.json.\n * @param {Object|undefined} options  Calculation options.\n *\n * @return {{ unit: string, value: number }|null} An object consisting of `'value'` and `'unit'` properties.\n */\nexport function getTypographyValueAndUnit( rawValue, options = {} ) {\n\tif ( typeof rawValue !== 'string' && typeof rawValue !== 'number' ) {\n\t\treturn null;\n\t}\n\n\t// Converts numeric values to pixel values by default.\n\tif ( isFinite( rawValue ) ) {\n\t\trawValue = `${ rawValue }px`;\n\t}\n\n\tconst { coerceTo, rootSizeValue, acceptableUnits } = {\n\t\tcoerceTo: '',\n\t\t// Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( \"html\" ) ).fontSize`.\n\t\trootSizeValue: 16,\n\t\tacceptableUnits: [ 'rem', 'px', 'em' ],\n\t\t...options,\n\t};\n\n\tconst acceptableUnitsGroup = acceptableUnits?.join( '|' );\n\tconst regexUnits = new RegExp(\n\t\t`^(\\\\d*\\\\.?\\\\d+)(${ acceptableUnitsGroup }){1,1}$`\n\t);\n\n\tconst matches = rawValue.match( regexUnits );\n\n\t// We need a number value and a unit.\n\tif ( ! matches || matches.length < 3 ) {\n\t\treturn null;\n\t}\n\n\tlet [ , value, unit ] = matches;\n\n\tlet returnValue = parseFloat( value );\n\n\tif ( 'px' === coerceTo && ( 'em' === unit || 'rem' === unit ) ) {\n\t\treturnValue = returnValue * rootSizeValue;\n\t\tunit = coerceTo;\n\t}\n\n\tif ( 'px' === unit && ( 'em' === coerceTo || 'rem' === coerceTo ) ) {\n\t\treturnValue = returnValue / rootSizeValue;\n\t\tunit = coerceTo;\n\t}\n\n\t/*\n\t * No calculation is required if swapping between em and rem yet,\n\t * since we assume a root size value. Later we might like to differentiate between\n\t * :root font size (rem) and parent element font size (em) relativity.\n\t */\n\tif (\n\t\t( 'em' === coerceTo || 'rem' === coerceTo ) &&\n\t\t( 'em' === unit || 'rem' === unit )\n\t) {\n\t\tunit = coerceTo;\n\t}\n\n\treturn {\n\t\tvalue: roundToPrecision( returnValue, 3 ),\n\t\tunit,\n\t};\n}\n\n/**\n * Returns a value rounded to defined precision.\n * Returns `undefined` if the value is not a valid finite number.\n *\n * @param {number} value  Raw value.\n * @param {number} digits The number of digits to appear after the decimal point\n *\n * @return {number|undefined} Value rounded to standard precision.\n */\nexport function roundToPrecision( value, digits = 3 ) {\n\tconst base = Math.pow( 10, digits );\n\treturn Number.isFinite( value )\n\t\t? parseFloat( Math.round( value * base ) / base )\n\t\t: undefined;\n}\n"]}