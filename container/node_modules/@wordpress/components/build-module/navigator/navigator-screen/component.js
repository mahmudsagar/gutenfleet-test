import _extends from "@babel/runtime/helpers/esm/extends";
import { createElement } from "@wordpress/element";

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports
import { motion } from 'framer-motion';
import { css } from '@emotion/react';
/**
 * WordPress dependencies
 */

import { focus } from '@wordpress/dom';
import { useContext, useEffect, useMemo, useRef } from '@wordpress/element';
import { useReducedMotion, useMergeRefs, usePrevious } from '@wordpress/compose';
import { isRTL } from '@wordpress/i18n';
import { escapeAttribute } from '@wordpress/escape-html';
/**
 * Internal dependencies
 */

import { contextConnect, useContextSystem } from '../../ui/context';
import { useCx } from '../../utils/hooks/use-cx';
import { View } from '../../view';
import { NavigatorContext } from '../context';
const animationEnterDelay = 0;
const animationEnterDuration = 0.14;
const animationExitDuration = 0.14;
const animationExitDelay = 0; // Props specific to `framer-motion` can't be currently passed to `NavigatorScreen`,
// as some of them would overlap with HTML props (e.g. `onAnimationStart`, ...)

var _ref = process.env.NODE_ENV === "production" ? {
  name: "14x3t6z",
  styles: "overflow-x:auto;max-height:100%"
} : {
  name: "1ulogbc-classes",
  styles: "overflow-x:auto;max-height:100%;label:classes;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbmF2aWdhdG9yL25hdmlnYXRvci1zY3JlZW4vY29tcG9uZW50LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrRUkiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9uYXZpZ2F0b3IvbmF2aWdhdG9yLXNjcmVlbi9jb21wb25lbnQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBGb3J3YXJkZWRSZWYgfSBmcm9tICdyZWFjdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgeyBtb3Rpb24sIE1vdGlvblByb3BzIH0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBmb2N1cyB9IGZyb20gJ0B3b3JkcHJlc3MvZG9tJztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcbmltcG9ydCB7XG5cdHVzZVJlZHVjZWRNb3Rpb24sXG5cdHVzZU1lcmdlUmVmcyxcblx0dXNlUHJldmlvdXMsXG59IGZyb20gJ0B3b3JkcHJlc3MvY29tcG9zZSc7XG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5pbXBvcnQgeyBlc2NhcGVBdHRyaWJ1dGUgfSBmcm9tICdAd29yZHByZXNzL2VzY2FwZS1odG1sJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHtcblx0Y29udGV4dENvbm5lY3QsXG5cdHVzZUNvbnRleHRTeXN0ZW0sXG5cdFdvcmRQcmVzc0NvbXBvbmVudFByb3BzLFxufSBmcm9tICcuLi8uLi91aS9jb250ZXh0JztcbmltcG9ydCB7IHVzZUN4IH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9va3MvdXNlLWN4JztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi8uLi92aWV3JztcbmltcG9ydCB7IE5hdmlnYXRvckNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB0eXBlIHsgTmF2aWdhdG9yU2NyZWVuUHJvcHMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGFuaW1hdGlvbkVudGVyRGVsYXkgPSAwO1xuY29uc3QgYW5pbWF0aW9uRW50ZXJEdXJhdGlvbiA9IDAuMTQ7XG5jb25zdCBhbmltYXRpb25FeGl0RHVyYXRpb24gPSAwLjE0O1xuY29uc3QgYW5pbWF0aW9uRXhpdERlbGF5ID0gMDtcblxuLy8gUHJvcHMgc3BlY2lmaWMgdG8gYGZyYW1lci1tb3Rpb25gIGNhbid0IGJlIGN1cnJlbnRseSBwYXNzZWQgdG8gYE5hdmlnYXRvclNjcmVlbmAsXG4vLyBhcyBzb21lIG9mIHRoZW0gd291bGQgb3ZlcmxhcCB3aXRoIEhUTUwgcHJvcHMgKGUuZy4gYG9uQW5pbWF0aW9uU3RhcnRgLCAuLi4pXG50eXBlIFByb3BzID0gT21pdDxcblx0V29yZFByZXNzQ29tcG9uZW50UHJvcHM8IE5hdmlnYXRvclNjcmVlblByb3BzLCAnZGl2JywgZmFsc2UgPixcblx0a2V5b2YgTW90aW9uUHJvcHNcbj47XG5cbmZ1bmN0aW9uIFVuY29ubmVjdGVkTmF2aWdhdG9yU2NyZWVuKFxuXHRwcm9wczogUHJvcHMsXG5cdGZvcndhcmRlZFJlZjogRm9yd2FyZGVkUmVmPCBhbnkgPlxuKSB7XG5cdGNvbnN0IHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgcGF0aCwgLi4ub3RoZXJQcm9wcyB9ID0gdXNlQ29udGV4dFN5c3RlbShcblx0XHRwcm9wcyxcblx0XHQnTmF2aWdhdG9yU2NyZWVuJ1xuXHQpO1xuXG5cdGNvbnN0IHByZWZlcnNSZWR1Y2VkTW90aW9uID0gdXNlUmVkdWNlZE1vdGlvbigpO1xuXHRjb25zdCB7IGxvY2F0aW9uIH0gPSB1c2VDb250ZXh0KCBOYXZpZ2F0b3JDb250ZXh0ICk7XG5cdGNvbnN0IGlzTWF0Y2ggPSBsb2NhdGlvbi5wYXRoID09PSBlc2NhcGVBdHRyaWJ1dGUoIHBhdGggKTtcblx0Y29uc3Qgd3JhcHBlclJlZiA9IHVzZVJlZjwgSFRNTERpdkVsZW1lbnQgPiggbnVsbCApO1xuXG5cdGNvbnN0IHByZXZpb3VzTG9jYXRpb24gPSB1c2VQcmV2aW91cyggbG9jYXRpb24gKTtcblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cdGNvbnN0IGNsYXNzZXMgPSB1c2VNZW1vKFxuXHRcdCgpID0+XG5cdFx0XHRjeChcblx0XHRcdFx0Y3NzKCB7XG5cdFx0XHRcdFx0Ly8gRW5zdXJlcyBob3Jpem9udGFsIG92ZXJmbG93IGlzIHZpc3VhbGx5IGFjY2Vzc2libGUuXG5cdFx0XHRcdFx0b3ZlcmZsb3dYOiAnYXV0bycsXG5cdFx0XHRcdFx0Ly8gSW4gY2FzZSB0aGUgcm9vdCBoYXMgYSBoZWlnaHQsIGl0IHNob3VsZCBub3QgYmUgZXhjZWVkZWQuXG5cdFx0XHRcdFx0bWF4SGVpZ2h0OiAnMTAwJScsXG5cdFx0XHRcdH0gKSxcblx0XHRcdFx0Y2xhc3NOYW1lXG5cdFx0XHQpLFxuXHRcdFsgY2xhc3NOYW1lLCBjeCBdXG5cdCk7XG5cblx0Ly8gRm9jdXMgcmVzdG9yYXRpb25cblx0Y29uc3QgaXNJbml0aWFsTG9jYXRpb24gPSBsb2NhdGlvbi5pc0luaXRpYWwgJiYgISBsb2NhdGlvbi5pc0JhY2s7XG5cdHVzZUVmZmVjdCggKCkgPT4ge1xuXHRcdC8vIE9ubHkgYXR0ZW1wdCB0byByZXN0b3JlIGZvY3VzOlxuXHRcdC8vIC0gaWYgdGhlIGN1cnJlbnQgbG9jYXRpb24gaXMgbm90IHRoZSBpbml0aWFsIG9uZSAodG8gYXZvaWQgbW92aW5nIGZvY3VzIG9uIHBhZ2UgbG9hZClcblx0XHQvLyAtIHdoZW4gdGhlIHNjcmVlbiBiZWNvbWVzIHZpc2libGVcblx0XHQvLyAtIGlmIHRoZSB3cmFwcGVyIHJlZiBoYXMgYmVlbiBhc3NpZ25lZFxuXHRcdC8vIC0gaWYgZm9jdXMgaGFzbid0IGFscmVhZHkgYmVlbiByZXN0b3JlZCBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb25cblx0XHRpZiAoXG5cdFx0XHRpc0luaXRpYWxMb2NhdGlvbiB8fFxuXHRcdFx0ISBpc01hdGNoIHx8XG5cdFx0XHQhIHdyYXBwZXJSZWYuY3VycmVudCB8fFxuXHRcdFx0bG9jYXRpb24uaGFzUmVzdG9yZWRGb2N1c1xuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB3cmFwcGVyUmVmLmN1cnJlbnQub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0Ly8gSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQgd2l0aGluIHRoZSB3cmFwcGVyIGRvIG5vdCBmb2N1cyB0aGVcblx0XHQvLyBlbGVtZW50LiBUaGlzIHByZXZlbnRzIGlucHV0cyBvciBidXR0b25zIGZyb20gbG9zaW5nIGZvY3VzIHVubmVjZXNzYXJpbHkuXG5cdFx0aWYgKCB3cmFwcGVyUmVmLmN1cnJlbnQuY29udGFpbnMoIGFjdGl2ZUVsZW1lbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgZWxlbWVudFRvRm9jdXM6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0XHQvLyBXaGVuIG5hdmlnYXRpbmcgYmFjaywgaWYgYSBzZWxlY3RvciBpcyBwcm92aWRlZCwgdXNlIGl0IHRvIGxvb2sgZm9yIHRoZVxuXHRcdC8vIHRhcmdldCBlbGVtZW50IChhc3N1bWVkIHRvIGJlIGEgbm9kZSBpbnNpZGUgdGhlIGN1cnJlbnQgTmF2aWdhdG9yU2NyZWVuKVxuXHRcdGlmICggbG9jYXRpb24uaXNCYWNrICYmIHByZXZpb3VzTG9jYXRpb24/LmZvY3VzVGFyZ2V0U2VsZWN0b3IgKSB7XG5cdFx0XHRlbGVtZW50VG9Gb2N1cyA9IHdyYXBwZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKFxuXHRcdFx0XHRwcmV2aW91c0xvY2F0aW9uLmZvY3VzVGFyZ2V0U2VsZWN0b3Jcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHByZXZpb3VzIHF1ZXJ5IGRpZG4ndCBydW4gb3IgZmluZCBhbnkgZWxlbWVudCB0byBmb2N1cywgZmFsbGJhY2tcblx0XHQvLyB0byB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBpbiB0aGUgc2NyZWVuIChvciB0aGUgc2NyZWVuIGl0c2VsZikuXG5cdFx0aWYgKCAhIGVsZW1lbnRUb0ZvY3VzICkge1xuXHRcdFx0Y29uc3QgZmlyc3RUYWJiYWJsZSA9IChcblx0XHRcdFx0Zm9jdXMudGFiYmFibGUuZmluZCggd3JhcHBlclJlZi5jdXJyZW50ICkgYXMgSFRNTEVsZW1lbnRbXVxuXHRcdFx0IClbIDAgXTtcblx0XHRcdGVsZW1lbnRUb0ZvY3VzID0gZmlyc3RUYWJiYWJsZSA/PyB3cmFwcGVyUmVmLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0bG9jYXRpb24uaGFzUmVzdG9yZWRGb2N1cyA9IHRydWU7XG5cdFx0ZWxlbWVudFRvRm9jdXMuZm9jdXMoKTtcblx0fSwgW1xuXHRcdGlzSW5pdGlhbExvY2F0aW9uLFxuXHRcdGlzTWF0Y2gsXG5cdFx0bG9jYXRpb24uaGFzUmVzdG9yZWRGb2N1cyxcblx0XHRsb2NhdGlvbi5pc0JhY2ssXG5cdFx0cHJldmlvdXNMb2NhdGlvbj8uZm9jdXNUYXJnZXRTZWxlY3Rvcixcblx0XSApO1xuXG5cdGNvbnN0IG1lcmdlZFdyYXBwZXJSZWYgPSB1c2VNZXJnZVJlZnMoIFsgZm9yd2FyZGVkUmVmLCB3cmFwcGVyUmVmIF0gKTtcblxuXHRpZiAoICEgaXNNYXRjaCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICggcHJlZmVyc1JlZHVjZWRNb3Rpb24gKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxWaWV3XG5cdFx0XHRcdHJlZj17IG1lcmdlZFdyYXBwZXJSZWYgfVxuXHRcdFx0XHRjbGFzc05hbWU9eyBjbGFzc2VzIH1cblx0XHRcdFx0eyAuLi5vdGhlclByb3BzIH1cblx0XHRcdD5cblx0XHRcdFx0eyBjaGlsZHJlbiB9XG5cdFx0XHQ8L1ZpZXc+XG5cdFx0KTtcblx0fVxuXG5cdGNvbnN0IGFuaW1hdGUgPSB7XG5cdFx0b3BhY2l0eTogMSxcblx0XHR0cmFuc2l0aW9uOiB7XG5cdFx0XHRkZWxheTogYW5pbWF0aW9uRW50ZXJEZWxheSxcblx0XHRcdGR1cmF0aW9uOiBhbmltYXRpb25FbnRlckR1cmF0aW9uLFxuXHRcdFx0ZWFzZTogJ2Vhc2VJbk91dCcsXG5cdFx0fSxcblx0XHR4OiAwLFxuXHR9O1xuXHRjb25zdCBpbml0aWFsID0ge1xuXHRcdG9wYWNpdHk6IDAsXG5cdFx0eDpcblx0XHRcdCggaXNSVEwoKSAmJiBsb2NhdGlvbi5pc0JhY2sgKSB8fCAoICEgaXNSVEwoKSAmJiAhIGxvY2F0aW9uLmlzQmFjayApXG5cdFx0XHRcdD8gNTBcblx0XHRcdFx0OiAtNTAsXG5cdH07XG5cdGNvbnN0IGV4aXQgPSB7XG5cdFx0ZGVsYXk6IGFuaW1hdGlvbkV4aXREZWxheSxcblx0XHRvcGFjaXR5OiAwLFxuXHRcdHg6XG5cdFx0XHQoICEgaXNSVEwoKSAmJiBsb2NhdGlvbi5pc0JhY2sgKSB8fCAoIGlzUlRMKCkgJiYgISBsb2NhdGlvbi5pc0JhY2sgKVxuXHRcdFx0XHQ/IDUwXG5cdFx0XHRcdDogLTUwLFxuXHRcdHRyYW5zaXRpb246IHtcblx0XHRcdGR1cmF0aW9uOiBhbmltYXRpb25FeGl0RHVyYXRpb24sXG5cdFx0XHRlYXNlOiAnZWFzZUluT3V0Jyxcblx0XHR9LFxuXHR9O1xuXG5cdGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB7XG5cdFx0YW5pbWF0ZSxcblx0XHRleGl0LFxuXHRcdGluaXRpYWwsXG5cdH07XG5cblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdlxuXHRcdFx0cmVmPXsgbWVyZ2VkV3JhcHBlclJlZiB9XG5cdFx0XHRjbGFzc05hbWU9eyBjbGFzc2VzIH1cblx0XHRcdHsgLi4ub3RoZXJQcm9wcyB9XG5cdFx0XHR7IC4uLmFuaW1hdGVkUHJvcHMgfVxuXHRcdD5cblx0XHRcdHsgY2hpbGRyZW4gfVxuXHRcdDwvbW90aW9uLmRpdj5cblx0KTtcbn1cblxuLyoqXG4gKiBUaGUgYE5hdmlnYXRvclNjcmVlbmAgY29tcG9uZW50IHJlcHJlc2VudHMgYSBzaW5nbGUgdmlldy9zY3JlZW4vcGFuZWwgYW5kXG4gKiBzaG91bGQgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBgTmF2aWdhdG9yUHJvdmlkZXJgLCB0aGVcbiAqIGBOYXZpZ2F0b3JCdXR0b25gIGFuZCB0aGUgYE5hdmlnYXRvckJhY2tCdXR0b25gIGNvbXBvbmVudHMgKG9yIHRoZSBgdXNlTmF2aWdhdG9yYFxuICogaG9vaykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHtcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JQcm92aWRlciBhcyBOYXZpZ2F0b3JQcm92aWRlcixcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JTY3JlZW4gYXMgTmF2aWdhdG9yU2NyZWVuLFxuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvckJ1dHRvbiBhcyBOYXZpZ2F0b3JCdXR0b24sXG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yQmFja0J1dHRvbiBhcyBOYXZpZ2F0b3JCYWNrQnV0dG9uLFxuICogfSBmcm9tICdAd29yZHByZXNzL2NvbXBvbmVudHMnO1xuICpcbiAqIGNvbnN0IE15TmF2aWdhdGlvbiA9ICgpID0+IChcbiAqICAgPE5hdmlnYXRvclByb3ZpZGVyIGluaXRpYWxQYXRoPVwiL1wiPlxuICogICAgIDxOYXZpZ2F0b3JTY3JlZW4gcGF0aD1cIi9cIj5cbiAqICAgICAgIDxwPlRoaXMgaXMgdGhlIGhvbWUgc2NyZWVuLjwvcD5cbiAqICAgICAgICA8TmF2aWdhdG9yQnV0dG9uIHBhdGg9XCIvY2hpbGRcIj5cbiAqICAgICAgICAgIE5hdmlnYXRlIHRvIGNoaWxkIHNjcmVlbi5cbiAqICAgICAgIDwvTmF2aWdhdG9yQnV0dG9uPlxuICogICAgIDwvTmF2aWdhdG9yU2NyZWVuPlxuICpcbiAqICAgICA8TmF2aWdhdG9yU2NyZWVuIHBhdGg9XCIvY2hpbGRcIj5cbiAqICAgICAgIDxwPlRoaXMgaXMgdGhlIGNoaWxkIHNjcmVlbi48L3A+XG4gKiAgICAgICA8TmF2aWdhdG9yQmFja0J1dHRvbj5cbiAqICAgICAgICAgR28gYmFja1xuICogICAgICAgPC9OYXZpZ2F0b3JCYWNrQnV0dG9uPlxuICogICAgIDwvTmF2aWdhdG9yU2NyZWVuPlxuICogICA8L05hdmlnYXRvclByb3ZpZGVyPlxuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgTmF2aWdhdG9yU2NyZWVuID0gY29udGV4dENvbm5lY3QoXG5cdFVuY29ubmVjdGVkTmF2aWdhdG9yU2NyZWVuLFxuXHQnTmF2aWdhdG9yU2NyZWVuJ1xuKTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdG9yU2NyZWVuO1xuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};

function UnconnectedNavigatorScreen(props, forwardedRef) {
  const {
    children,
    className,
    path,
    ...otherProps
  } = useContextSystem(props, 'NavigatorScreen');
  const prefersReducedMotion = useReducedMotion();
  const {
    location
  } = useContext(NavigatorContext);
  const isMatch = location.path === escapeAttribute(path);
  const wrapperRef = useRef(null);
  const previousLocation = usePrevious(location);
  const cx = useCx();
  const classes = useMemo(() => cx(_ref, className), [className, cx]); // Focus restoration

  const isInitialLocation = location.isInitial && !location.isBack;
  useEffect(() => {
    // Only attempt to restore focus:
    // - if the current location is not the initial one (to avoid moving focus on page load)
    // - when the screen becomes visible
    // - if the wrapper ref has been assigned
    // - if focus hasn't already been restored for the current location
    if (isInitialLocation || !isMatch || !wrapperRef.current || location.hasRestoredFocus) {
      return;
    }

    const activeElement = wrapperRef.current.ownerDocument.activeElement; // If an element is already focused within the wrapper do not focus the
    // element. This prevents inputs or buttons from losing focus unnecessarily.

    if (wrapperRef.current.contains(activeElement)) {
      return;
    }

    let elementToFocus = null; // When navigating back, if a selector is provided, use it to look for the
    // target element (assumed to be a node inside the current NavigatorScreen)

    if (location.isBack && previousLocation !== null && previousLocation !== void 0 && previousLocation.focusTargetSelector) {
      elementToFocus = wrapperRef.current.querySelector(previousLocation.focusTargetSelector);
    } // If the previous query didn't run or find any element to focus, fallback
    // to the first tabbable element in the screen (or the screen itself).


    if (!elementToFocus) {
      const firstTabbable = focus.tabbable.find(wrapperRef.current)[0];
      elementToFocus = firstTabbable !== null && firstTabbable !== void 0 ? firstTabbable : wrapperRef.current;
    }

    location.hasRestoredFocus = true;
    elementToFocus.focus();
  }, [isInitialLocation, isMatch, location.hasRestoredFocus, location.isBack, previousLocation === null || previousLocation === void 0 ? void 0 : previousLocation.focusTargetSelector]);
  const mergedWrapperRef = useMergeRefs([forwardedRef, wrapperRef]);

  if (!isMatch) {
    return null;
  }

  if (prefersReducedMotion) {
    return createElement(View, _extends({
      ref: mergedWrapperRef,
      className: classes
    }, otherProps), children);
  }

  const animate = {
    opacity: 1,
    transition: {
      delay: animationEnterDelay,
      duration: animationEnterDuration,
      ease: 'easeInOut'
    },
    x: 0
  };
  const initial = {
    opacity: 0,
    x: isRTL() && location.isBack || !isRTL() && !location.isBack ? 50 : -50
  };
  const exit = {
    delay: animationExitDelay,
    opacity: 0,
    x: !isRTL() && location.isBack || isRTL() && !location.isBack ? 50 : -50,
    transition: {
      duration: animationExitDuration,
      ease: 'easeInOut'
    }
  };
  const animatedProps = {
    animate,
    exit,
    initial
  };
  return createElement(motion.div, _extends({
    ref: mergedWrapperRef,
    className: classes
  }, otherProps, animatedProps), children);
}
/**
 * The `NavigatorScreen` component represents a single view/screen/panel and
 * should be used in combination with the `NavigatorProvider`, the
 * `NavigatorButton` and the `NavigatorBackButton` components (or the `useNavigator`
 * hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */


export const NavigatorScreen = contextConnect(UnconnectedNavigatorScreen, 'NavigatorScreen');
export default NavigatorScreen;
//# sourceMappingURL=component.js.map