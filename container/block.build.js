(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb2, mod) => function __require() {
    return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/turbo-combine-reducers/index.js
  var require_turbo_combine_reducers = __commonJS({
    "node_modules/turbo-combine-reducers/index.js"(exports, module) {
      function combineReducers3(reducers) {
        var keys = Object.keys(reducers), getNextState;
        getNextState = function() {
          var fn, i5, key;
          fn = "return {";
          for (i5 = 0; i5 < keys.length; i5++) {
            key = JSON.stringify(keys[i5]);
            fn += key + ":r[" + key + "](s[" + key + "],a),";
          }
          fn += "}";
          return new Function("r,s,a", fn);
        }();
        return function combinedReducer(state, action) {
          var nextState, i5, key;
          if (state === void 0) {
            return getNextState(reducers, {}, action);
          }
          nextState = getNextState(reducers, state, action);
          i5 = keys.length;
          while (i5--) {
            key = keys[i5];
            if (state[key] !== nextState[key]) {
              return nextState;
            }
          }
          return state;
        };
      }
      module.exports = combineReducers3;
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule && freeModule.require && freeModule.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e4) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            var value = array[index2];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (iteratee(array[index2], index2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (!predicate(array[index2], index2, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (comparator(value, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array[index2], index2, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index2 = -1, length = values.length, offset4 = array.length;
          while (++index2 < length) {
            array[offset4 + index2] = values[index2];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array[index2], index2, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string2) {
          return string2.split("");
        }
        function asciiWords(string2) {
          return string2.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (comparator(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index2 = -1, length = array.length;
          while (++index2 < length) {
            var current = iteratee(array[index2]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n5, iteratee) {
          var index2 = -1, result = Array(n5);
          while (++index2 < n5) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string2) {
          return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        function hasUnicodeWord(string2) {
          return reHasUnicodeWord.test(string2);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map9) {
          var index2 = -1, result = Array(map9.size);
          map9.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index2 = -1, length = array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string2) {
          return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function trimmedEndIndex(string2) {
          var index2 = string2.length;
          while (index2-- && reWhitespace.test(string2.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string2) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string2)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function unicodeWords(string2) {
          return string2.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context2) {
          context2 = context2 == null ? root : _.defaults(root.Object(), context2, _.pick(root, contextProps));
          var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context2["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e4) {
            }
          }();
          var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike2(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto) {
              if (!isObject5(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index2 = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined2 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index2 = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array, n5) {
            return shuffleSelf(copyArray(array), baseClamp(n5, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
            while (++index2 < length) {
              result2[index2] = skip ? undefined2 : get11(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number2, lower, upper) {
            if (number2 === number2) {
              if (upper !== undefined2) {
                number2 = number2 <= upper ? number2 : upper;
              }
              if (lower !== undefined2) {
                number2 = number2 >= lower ? number2 : lower;
              }
            }
            return number2;
          }
          function baseClone(value, bitmask, customizer, key, object, stack4) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack4) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject5(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack4 || (stack4 = new Stack());
            var stacked = stack4.get(value);
            if (stacked) {
              return stacked;
            }
            stack4.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack4));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack4));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack4));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout3(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index2 = -1, length = array.length;
            while (++index2 < length) {
              var value = array[index2], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start2, end) {
            var length = array.length;
            start2 = toInteger(start2);
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start2 > end ? 0 : toLength(end);
            while (start2 < end) {
              array[start2++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction4(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index2 = 0, length = path.length;
            while (object != null && index2 < length) {
              object = object[toKey(path[index2++])];
            }
            return index2 && index2 == length ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number2, start2, end) {
            return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike2(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike2(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike2(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack4) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack4);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack4) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack4 || (stack4 = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack4) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack4);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack4 || (stack4 = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack4);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack4 || (stack4 = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack4);
          }
          function baseIsMap(value) {
            return isObjectLike2(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object2(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack4 = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack4);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack4) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject5(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction4(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike2(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike2(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity4;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject5(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get11(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack4) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack4 || (stack4 = new Stack());
              if (isObject5(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack4);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack4) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack4) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack4.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack4) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject4(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject5(objValue) || isFunction4(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack4.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack4);
              stack4["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n5) {
            var length = array.length;
            if (!length) {
              return;
            }
            n5 += n5 < 0 ? length : 0;
            return isIndex(n5, length) ? array[n5] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity4];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path = paths[index2], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex(index2)) {
                  splice.call(array, index2, 1);
                } else {
                  baseUnset(array, index2);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start2, end, step, fromRight) {
            var index2 = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start2;
              start2 += step;
            }
            return result2;
          }
          function baseRepeat(string2, n5) {
            var result2 = "";
            if (!string2 || n5 < 1 || n5 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n5 % 2) {
                result2 += string2;
              }
              n5 = nativeFloor(n5 / 2);
              if (n5) {
                string2 += string2;
              }
            } while (n5);
            return result2;
          }
          function baseRest(func, start2) {
            return setToString(overRest(func, start2, identity4), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n5) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n5, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject5(object)) {
              return object;
            }
            path = castPath(path, object);
            var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index2 < length) {
              var key = toKey(path[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject5(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity4 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity4 : function(func, string2) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string2),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start2, end) {
            var index2 = -1, length = array.length;
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start2 > end ? 0 : end - start2 >>> 0;
            start2 >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array[index2 + start2];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity4, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index2 = -1, length = array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions2) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions2, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values2[index2] : undefined2;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity4;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start2, end) {
            var length = array.length;
            end = end === undefined2 ? length : end;
            return !start2 && end >= length ? array : baseSlice(array, start2, end);
          }
          var clearTimeout3 = ctxClearTimeout || function(id2) {
            return root.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp2) {
            var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
            result2.lastIndex = regexp2.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol2) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol2)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order2 = orders[index2];
                return result2 * (order2 == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset4 = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset4 + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset4 + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index2 = -1, length = source.length;
            array || (array = Array2(length));
            while (++index2 < length) {
              array[index2] = source[index2];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object = Object2(object);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string2) {
              string2 = toString(string2);
              var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string2) {
              return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject5(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start2, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
                end = step = undefined2;
              }
              start2 = toFinite(start2);
              if (end === undefined2) {
                end = start2;
                start2 = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
              return baseRange(start2, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number2, precision) {
              number2 = toNumber(number2);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number2)) {
                var pair = (toString(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number2);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop16 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack4) {
            if (isObject5(objValue) && isObject5(srcValue)) {
              stack4.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack4);
              stack4["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject4(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack4) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack4.get(array);
            var othStacked = stack4.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack4.set(array, other);
            stack4.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack4) : customizer(arrValue, othValue, index2, array, other, stack4);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack4))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack4))) {
                result2 = false;
                break;
              }
            }
            stack4["delete"](array);
            stack4["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack4) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack4.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack4.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack4);
                stack4["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack4) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack4.get(object);
            var othStacked = stack4.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack4.set(object, other);
            stack4.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack4) : customizer(objValue, othValue, key, object, other, stack4);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack4) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack4["delete"](object);
            stack4["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten3), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop16 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map10, key) {
            var data = map10.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length = result2.length;
            while (length--) {
              var key = result2[length], value = object[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e4) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol2) {
              return propertyIsEnumerable.call(object, symbol2);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start2, end, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data = transforms[index2], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start2 += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start2 + size2);
                  break;
                case "takeRight":
                  start2 = nativeMax(start2, end - size2);
                  break;
              }
            }
            return { "start": start2, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index2 = -1, length = path.length, result2 = false;
            while (++index2 < length) {
              var key = toKey(path[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result2 = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index2, object) {
            if (!isObject5(object)) {
              return false;
            }
            var type = typeof index2;
            if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
              return eq(object[index2], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction4 : stubFalse2;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject5(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize7(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start2, transform2) {
            start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
              while (++index2 < length) {
                array[index2] = args[start2 + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start2 + 1);
              while (++index2 < start2) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start2] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index2 = indexes[length];
              array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout3 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index2 = -1, length = array.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index2 < size2) {
              var rand = baseRandom(index2, lastIndex), value = array[rand];
              array[rand] = array[index2];
              array[index2] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string2) {
            var result2 = [];
            if (string2.charCodeAt(0) === 46) {
              result2.push("");
            }
            string2.replace(rePropName, function(match, number2, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e4) {
              }
              try {
                return func + "";
              } catch (e4) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk2(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array, index2, index2 += size2);
            }
            return result2;
          }
          function compact(array) {
            var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n5, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
            return baseSlice(array, n5 < 0 ? 0 : n5, length);
          }
          function dropRight(array, n5, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
            n5 = length - n5;
            return baseSlice(array, 0, n5 < 0 ? 0 : n5);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start2, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
              start2 = 0;
              end = length;
            }
            return baseFill(array, value, start2, end);
          }
          function findIndex2(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
          }
          function flatten3(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseIndexOf(array, value, index2);
          }
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
          }
          function nth(array, n5) {
            return array && array.length ? baseNth(array, toInteger(n5)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index2) {
              return isIndex(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove4(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array[index2];
              if (predicate(value, index2, array)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse2(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice(array, start2, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
              start2 = 0;
              end = length;
            } else {
              start2 = start2 == null ? 0 : toInteger(start2);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array, start2, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value);
              if (index2 < length && eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index2 = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n5, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
            return baseSlice(array, 0, n5 < 0 ? 0 : n5);
          }
          function takeRight(array, n5, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
            n5 = length - n5;
            return baseSlice(array, n5 < 0 ? 0 : n5, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function(group2) {
              if (isArrayLikeObject(group2)) {
                length = nativeMax(group2.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index2) {
              return arrayMap(array, baseProperty(index2));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group2) {
              return apply(iteratee2, undefined2, group2);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain2(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
              return this.thru(interceptor);
            }
            value = value.slice(start2, +start2 + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain2(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray3(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone3 = wrapperClone(parent2);
              clone3.__index__ = 0;
              clone3.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone3;
              } else {
                result2 = clone3;
              }
              var previous = clone3;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse2],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse2);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter5(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find9 = createFind(findIndex2);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map9(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map9(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map9(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy3 = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map9(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy4(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce4(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n5, guard) {
            if (guard ? isIterateeCall(collection, n5, guard) : n5 === undefined2) {
              n5 = 1;
            } else {
              n5 = toInteger(n5);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n5);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n5, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n5 = toInteger(n5);
            return function() {
              if (--n5 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n5, guard) {
            n5 = guard ? undefined2 : n5;
            n5 = func && n5 == null ? func.length : n5;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n5);
          }
          function before(n5, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n5 = toInteger(n5);
            return function() {
              if (--n5 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n5 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce2(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject5(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout3(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout3(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout3(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush2() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout3(timerId);
                  timerId = setTimeout3(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout3(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush2;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize7(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize7.Cache || MapCache)();
            return memoized;
          }
          memoize7.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length = nativeMin(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 === undefined2 ? start2 : toInteger(start2);
            return baseRest(func, start2);
          }
          function spread(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
            return baseRest(function(args) {
              var array = args[start2], otherArgs = castSlice(args, 0, start2);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle2(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject5(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce2(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap3(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray3() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction4(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike2(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike2(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse2;
          var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement2(value) {
            return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject4(value);
          }
          function isEmpty8(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual6(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError2(value) {
            if (!isObjectLike2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject4(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction4(value) {
            if (!isObject5(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject5(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike2(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike2(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject4(value) {
            if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString2(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike2(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike2(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike2(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray3(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString2(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject5(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject5(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create3(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults2 = baseRest(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith2, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get11(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity4));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues11(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge2 = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit3 = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick3 = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop2) {
              return [prop2];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index2 = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined2;
            }
            while (++index2 < length) {
              var value = object == null ? undefined2 : object[toKey(path[index2])];
              if (value === undefined2) {
                index2 = length;
                value = defaultValue;
              }
              object = isFunction4(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith2(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject5(object)) {
                accumulator = isFunction4(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update3(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp5(number2, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number2), lower, upper);
          }
          function inRange(number2, start2, end) {
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            number2 = toNumber(number2);
            return baseInRange(number2, start2, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize2(word) : word);
          });
          function capitalize2(string2) {
            return upperFirst2(toString(string2).toLowerCase());
          }
          function deburr(string2) {
            string2 = toString(string2);
            return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string2, target, position) {
            string2 = toString(string2);
            target = baseToString(target);
            var length = string2.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string2.slice(position, end) == target;
          }
          function escape(string2) {
            string2 = toString(string2);
            return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
          }
          function escapeRegExp(string2) {
            string2 = toString(string2);
            return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
          }
          var kebabCase4 = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase2 = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string2, length, chars) {
            string2 = toString(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            if (!length || strLength >= length) {
              return string2;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string2, length, chars) {
            string2 = toString(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
          }
          function padStart(string2, length, chars) {
            string2 = toString(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
          }
          function parseInt3(string2, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string2).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string2, n5, guard) {
            if (guard ? isIterateeCall(string2, n5, guard) : n5 === undefined2) {
              n5 = 1;
            } else {
              n5 = toInteger(n5);
            }
            return baseRepeat(toString(string2), n5);
          }
          function replace4() {
            var args = arguments, string2 = toString(args[0]);
            return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string2, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string2 = toString(string2);
            if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string2)) {
                return castSlice(stringToArray(string2), 0, limit);
              }
            }
            return string2.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst2(word);
          });
          function startsWith(string2, target, position) {
            string2 = toString(string2);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
            target = baseToString(target);
            return string2.slice(position, position + target.length) == target;
          }
          function template2(string2, options, guard) {
            var settings2 = lodash.templateSettings;
            if (guard && isIterateeCall(string2, options, guard)) {
              options = undefined2;
            }
            string2 = toString(string2);
            options = assignInWith({}, options, settings2, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate3 = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate3.source + "|" + (interpolate3 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset4) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string2.slice(index2, offset4).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset4 + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError2(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim2(string2, chars, guard) {
            string2 = toString(string2);
            if (string2 && (guard || chars === undefined2)) {
              return baseTrim(string2);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start2, end).join("");
          }
          function trimEnd(string2, chars, guard) {
            string2 = toString(string2);
            if (string2 && (guard || chars === undefined2)) {
              return string2.slice(0, trimmedEndIndex(string2) + 1);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string2, chars, guard) {
            string2 = toString(string2);
            if (string2 && (guard || chars === undefined2)) {
              return string2.replace(reTrimStart, "");
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start2).join("");
          }
          function truncate(string2, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject5(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string2 = toString(string2);
            var strLength = string2.length;
            if (hasUnicode(string2)) {
              var strSymbols = stringToArray(string2);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string2;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string2.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string2.indexOf(baseToString(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape(string2) {
            string2 = toString(string2);
            return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
          }
          var upperCase2 = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst2 = createCaseFirst("toUpperCase");
          function words(string2, pattern, guard) {
            string2 = toString(string2);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
            }
            return string2.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e4) {
              return isError2(e4) ? e4 : new Error2(e4);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair = pairs[index2];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity4(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches2(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject5(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain3 = !(isObject5(options) && "chain" in options) || !!options.chain, isFunc = isFunction4(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain3 || chainAll) {
                    var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                    actions2.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop16() {
          }
          function nthArg(n5) {
            n5 = toInteger(n5);
            return baseRest(function(args) {
              return baseNth(args, n5);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse2() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n5, iteratee2) {
            n5 = toInteger(n5);
            if (n5 < 1 || n5 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n5, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n5 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index2 < n5) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId2(prefix2) {
            var id2 = ++idCounter;
            return toString(prefix2) + id2;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity4, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity4);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity4, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract2 = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity4) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray3;
          lodash.chain = chain2;
          lodash.chunk = chunk2;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create3;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce2;
          lodash.defaults = defaults2;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter5;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten3;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy3;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map9;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues11;
          lodash.matches = matches2;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize7;
          lodash.merge = merge2;
          lodash.mergeWith = mergeWith2;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit3;
          lodash.omitBy = omitBy;
          lodash.once = once2;
          lodash.orderBy = orderBy4;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick3;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove4;
          lodash.rest = rest;
          lodash.reverse = reverse2;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith2;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle2;
          lodash.thru = thru;
          lodash.toArray = toArray3;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update3;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap3;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add2;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize2;
          lodash.ceil = ceil;
          lodash.clamp = clamp5;
          lodash.clone = clone2;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find9;
          lodash.findIndex = findIndex2;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get11;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity4;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate2;
          lodash.isElement = isElement2;
          lodash.isEmpty = isEmpty8;
          lodash.isEqual = isEqual6;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError2;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction4;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject5;
          lodash.isObjectLike = isObjectLike2;
          lodash.isPlainObject = isPlainObject4;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString2;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase4;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase2;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse2;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop16;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt3;
          lodash.random = random;
          lodash.reduce = reduce4;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace4;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract2;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template2;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim2;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId2;
          lodash.upperCase = upperCase2;
          lodash.upperFirst = upperFirst2;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n5) {
              n5 = n5 === undefined2 ? 1 : nativeMax(toInteger(n5), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n5, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n5, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n5) {
              return this.reverse()[methodName](n5).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity4);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start2, end) {
            start2 = toInteger(start2);
            var result2 = this;
            if (result2.__filtered__ && (start2 > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start2 < 0) {
              result2 = result2.takeRight(-start2);
            } else if (start2) {
              result2 = result2.drop(start2);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _ = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else {
          root._ = _;
        }
      }).call(exports);
    }
  });

  // node_modules/equivalent-key-map/equivalent-key-map.js
  var require_equivalent_key_map = __commonJS({
    "node_modules/equivalent-key-map/equivalent-key-map.js"(exports, module) {
      "use strict";
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i5 = 0; i5 < props.length; i5++) {
          var descriptor = props[i5];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function getValuePair(instance, key) {
        var _map = instance._map, _arrayTreeMap = instance._arrayTreeMap, _objectTreeMap = instance._objectTreeMap;
        if (_map.has(key)) {
          return _map.get(key);
        }
        var properties = Object.keys(key).sort();
        var map9 = Array.isArray(key) ? _arrayTreeMap : _objectTreeMap;
        for (var i5 = 0; i5 < properties.length; i5++) {
          var property = properties[i5];
          map9 = map9.get(property);
          if (map9 === void 0) {
            return;
          }
          var propertyValue = key[property];
          map9 = map9.get(propertyValue);
          if (map9 === void 0) {
            return;
          }
        }
        var valuePair = map9.get("_ekm_value");
        if (!valuePair) {
          return;
        }
        _map.delete(valuePair[0]);
        valuePair[0] = key;
        map9.set("_ekm_value", valuePair);
        _map.set(key, valuePair);
        return valuePair;
      }
      var EquivalentKeyMap3 = /* @__PURE__ */ function() {
        function EquivalentKeyMap4(iterable) {
          _classCallCheck(this, EquivalentKeyMap4);
          this.clear();
          if (iterable instanceof EquivalentKeyMap4) {
            var iterablePairs = [];
            iterable.forEach(function(value, key) {
              iterablePairs.push([key, value]);
            });
            iterable = iterablePairs;
          }
          if (iterable != null) {
            for (var i5 = 0; i5 < iterable.length; i5++) {
              this.set(iterable[i5][0], iterable[i5][1]);
            }
          }
        }
        _createClass(EquivalentKeyMap4, [{
          key: "set",
          value: function set(key, value) {
            if (key === null || _typeof(key) !== "object") {
              this._map.set(key, value);
              return this;
            }
            var properties = Object.keys(key).sort();
            var valuePair = [key, value];
            var map9 = Array.isArray(key) ? this._arrayTreeMap : this._objectTreeMap;
            for (var i5 = 0; i5 < properties.length; i5++) {
              var property = properties[i5];
              if (!map9.has(property)) {
                map9.set(property, new EquivalentKeyMap4());
              }
              map9 = map9.get(property);
              var propertyValue = key[property];
              if (!map9.has(propertyValue)) {
                map9.set(propertyValue, new EquivalentKeyMap4());
              }
              map9 = map9.get(propertyValue);
            }
            var previousValuePair = map9.get("_ekm_value");
            if (previousValuePair) {
              this._map.delete(previousValuePair[0]);
            }
            map9.set("_ekm_value", valuePair);
            this._map.set(key, valuePair);
            return this;
          }
        }, {
          key: "get",
          value: function get11(key) {
            if (key === null || _typeof(key) !== "object") {
              return this._map.get(key);
            }
            var valuePair = getValuePair(this, key);
            if (valuePair) {
              return valuePair[1];
            }
          }
        }, {
          key: "has",
          value: function has(key) {
            if (key === null || _typeof(key) !== "object") {
              return this._map.has(key);
            }
            return getValuePair(this, key) !== void 0;
          }
        }, {
          key: "delete",
          value: function _delete(key) {
            if (!this.has(key)) {
              return false;
            }
            this.set(key, void 0);
            return true;
          }
        }, {
          key: "forEach",
          value: function forEach(callback) {
            var _this = this;
            var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this;
            this._map.forEach(function(value, key) {
              if (key !== null && _typeof(key) === "object") {
                value = value[1];
              }
              callback.call(thisArg, value, key, _this);
            });
          }
        }, {
          key: "clear",
          value: function clear2() {
            this._map = /* @__PURE__ */ new Map();
            this._arrayTreeMap = /* @__PURE__ */ new Map();
            this._objectTreeMap = /* @__PURE__ */ new Map();
          }
        }, {
          key: "size",
          get: function get11() {
            return this._map.size;
          }
        }]);
        return EquivalentKeyMap4;
      }();
      module.exports = EquivalentKeyMap3;
    }
  });

  // node_modules/rungen/dist/utils/keys.js
  var require_keys = __commonJS({
    "node_modules/rungen/dist/utils/keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var keys = {
        all: Symbol("all"),
        error: Symbol("error"),
        fork: Symbol("fork"),
        join: Symbol("join"),
        race: Symbol("race"),
        call: Symbol("call"),
        cps: Symbol("cps"),
        subscribe: Symbol("subscribe")
      };
      exports.default = keys;
    }
  });

  // node_modules/rungen/dist/utils/helpers.js
  var require_helpers = __commonJS({
    "node_modules/rungen/dist/utils/helpers.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.createChannel = exports.subscribe = exports.cps = exports.apply = exports.call = exports.invoke = exports.delay = exports.race = exports.join = exports.fork = exports.error = exports.all = void 0;
      var _keys = require_keys();
      var _keys2 = _interopRequireDefault(_keys);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var all = exports.all = function all2(value) {
        return {
          type: _keys2.default.all,
          value
        };
      };
      var error2 = exports.error = function error3(err) {
        return {
          type: _keys2.default.error,
          error: err
        };
      };
      var fork = exports.fork = function fork2(iterator) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return {
          type: _keys2.default.fork,
          iterator,
          args
        };
      };
      var join = exports.join = function join2(task) {
        return {
          type: _keys2.default.join,
          task
        };
      };
      var race = exports.race = function race2(competitors) {
        return {
          type: _keys2.default.race,
          competitors
        };
      };
      var delay = exports.delay = function delay2(timeout) {
        return new Promise(function(resolve) {
          setTimeout(function() {
            return resolve(true);
          }, timeout);
        });
      };
      var invoke = exports.invoke = function invoke2(func) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return {
          type: _keys2.default.call,
          func,
          context: null,
          args
        };
      };
      var call3 = exports.call = function call4(func, context2) {
        for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          args[_key3 - 2] = arguments[_key3];
        }
        return {
          type: _keys2.default.call,
          func,
          context: context2,
          args
        };
      };
      var apply = exports.apply = function apply2(func, context2, args) {
        return {
          type: _keys2.default.call,
          func,
          context: context2,
          args
        };
      };
      var cps = exports.cps = function cps2(func) {
        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        return {
          type: _keys2.default.cps,
          func,
          args
        };
      };
      var subscribe4 = exports.subscribe = function subscribe5(channel) {
        return {
          type: _keys2.default.subscribe,
          channel
        };
      };
      var createChannel = exports.createChannel = function createChannel2(callback) {
        var listeners = [];
        var subscribe5 = function subscribe6(l5) {
          listeners.push(l5);
          return function() {
            return listeners.splice(listeners.indexOf(l5), 1);
          };
        };
        var next2 = function next3(val) {
          return listeners.forEach(function(l5) {
            return l5(val);
          });
        };
        callback(next2);
        return {
          subscribe: subscribe5
        };
      };
    }
  });

  // node_modules/rungen/dist/utils/is.js
  var require_is = __commonJS({
    "node_modules/rungen/dist/utils/is.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
      };
      var _keys = require_keys();
      var _keys2 = _interopRequireDefault(_keys);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var is2 = {
        obj: function obj(value) {
          return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && !!value;
        },
        all: function all(value) {
          return is2.obj(value) && value.type === _keys2.default.all;
        },
        error: function error2(value) {
          return is2.obj(value) && value.type === _keys2.default.error;
        },
        array: Array.isArray,
        func: function func(value) {
          return typeof value === "function";
        },
        promise: function promise(value) {
          return value && is2.func(value.then);
        },
        iterator: function iterator(value) {
          return value && is2.func(value.next) && is2.func(value.throw);
        },
        fork: function fork(value) {
          return is2.obj(value) && value.type === _keys2.default.fork;
        },
        join: function join(value) {
          return is2.obj(value) && value.type === _keys2.default.join;
        },
        race: function race(value) {
          return is2.obj(value) && value.type === _keys2.default.race;
        },
        call: function call3(value) {
          return is2.obj(value) && value.type === _keys2.default.call;
        },
        cps: function cps(value) {
          return is2.obj(value) && value.type === _keys2.default.cps;
        },
        subscribe: function subscribe4(value) {
          return is2.obj(value) && value.type === _keys2.default.subscribe;
        },
        channel: function channel(value) {
          return is2.obj(value) && is2.func(value.subscribe);
        }
      };
      exports.default = is2;
    }
  });

  // node_modules/rungen/dist/controls/builtin.js
  var require_builtin = __commonJS({
    "node_modules/rungen/dist/controls/builtin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.iterator = exports.array = exports.object = exports.error = exports.any = void 0;
      var _is = require_is();
      var _is2 = _interopRequireDefault(_is);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var any = exports.any = function any2(value, next2, rungen, yieldNext) {
        yieldNext(value);
        return true;
      };
      var error2 = exports.error = function error3(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.error(value))
          return false;
        raiseNext(value.error);
        return true;
      };
      var object = exports.object = function object2(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.all(value) || !_is2.default.obj(value.value))
          return false;
        var result = {};
        var keys = Object.keys(value.value);
        var count = 0;
        var hasError = false;
        var gotResultSuccess = function gotResultSuccess2(key, ret) {
          if (hasError)
            return;
          result[key] = ret;
          count++;
          if (count === keys.length) {
            yieldNext(result);
          }
        };
        var gotResultError = function gotResultError2(key, error3) {
          if (hasError)
            return;
          hasError = true;
          raiseNext(error3);
        };
        keys.map(function(key) {
          rungen(value.value[key], function(ret) {
            return gotResultSuccess(key, ret);
          }, function(err) {
            return gotResultError(key, err);
          });
        });
        return true;
      };
      var array = exports.array = function array2(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.all(value) || !_is2.default.array(value.value))
          return false;
        var result = [];
        var count = 0;
        var hasError = false;
        var gotResultSuccess = function gotResultSuccess2(key, ret) {
          if (hasError)
            return;
          result[key] = ret;
          count++;
          if (count === value.value.length) {
            yieldNext(result);
          }
        };
        var gotResultError = function gotResultError2(key, error3) {
          if (hasError)
            return;
          hasError = true;
          raiseNext(error3);
        };
        value.value.map(function(v5, key) {
          rungen(v5, function(ret) {
            return gotResultSuccess(key, ret);
          }, function(err) {
            return gotResultError(key, err);
          });
        });
        return true;
      };
      var iterator = exports.iterator = function iterator2(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.iterator(value))
          return false;
        rungen(value, next2, raiseNext);
        return true;
      };
      exports.default = [error2, iterator, array, object, any];
    }
  });

  // node_modules/rungen/dist/create.js
  var require_create = __commonJS({
    "node_modules/rungen/dist/create.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _builtin = require_builtin();
      var _builtin2 = _interopRequireDefault(_builtin);
      var _is = require_is();
      var _is2 = _interopRequireDefault(_is);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i5 = 0, arr2 = Array(arr.length); i5 < arr.length; i5++) {
            arr2[i5] = arr[i5];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var create3 = function create4() {
        var userControls = arguments.length <= 0 || arguments[0] === void 0 ? [] : arguments[0];
        var controls = [].concat(_toConsumableArray(userControls), _toConsumableArray(_builtin2.default));
        var runtime = function runtime2(input) {
          var success = arguments.length <= 1 || arguments[1] === void 0 ? function() {
          } : arguments[1];
          var error2 = arguments.length <= 2 || arguments[2] === void 0 ? function() {
          } : arguments[2];
          var iterate = function iterate2(gen) {
            var yieldValue = function yieldValue2(isError2) {
              return function(ret) {
                try {
                  var _ref8 = isError2 ? gen.throw(ret) : gen.next(ret);
                  var value = _ref8.value;
                  var done = _ref8.done;
                  if (done)
                    return success(value);
                  next2(value);
                } catch (e4) {
                  return error2(e4);
                }
              };
            };
            var next2 = function next3(ret) {
              controls.some(function(control) {
                return control(ret, next3, runtime2, yieldValue(false), yieldValue(true));
              });
            };
            yieldValue(false)();
          };
          var iterator = _is2.default.iterator(input) ? input : regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return input;
                  case 2:
                    return _context.abrupt("return", _context.sent);
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          })();
          iterate(iterator, success, error2);
        };
        return runtime;
      };
      exports.default = create3;
    }
  });

  // node_modules/rungen/dist/utils/dispatcher.js
  var require_dispatcher = __commonJS({
    "node_modules/rungen/dist/utils/dispatcher.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var createDispatcher = function createDispatcher2() {
        var listeners = [];
        return {
          subscribe: function subscribe4(listener2) {
            listeners.push(listener2);
            return function() {
              listeners = listeners.filter(function(l5) {
                return l5 !== listener2;
              });
            };
          },
          dispatch: function dispatch2(action) {
            listeners.slice().forEach(function(listener2) {
              return listener2(action);
            });
          }
        };
      };
      exports.default = createDispatcher;
    }
  });

  // node_modules/rungen/dist/controls/async.js
  var require_async = __commonJS({
    "node_modules/rungen/dist/controls/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.race = exports.join = exports.fork = exports.promise = void 0;
      var _is = require_is();
      var _is2 = _interopRequireDefault(_is);
      var _helpers = require_helpers();
      var _dispatcher = require_dispatcher();
      var _dispatcher2 = _interopRequireDefault(_dispatcher);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var promise = exports.promise = function promise2(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.promise(value))
          return false;
        value.then(next2, raiseNext);
        return true;
      };
      var forkedTasks = /* @__PURE__ */ new Map();
      var fork = exports.fork = function fork2(value, next2, rungen) {
        if (!_is2.default.fork(value))
          return false;
        var task = Symbol("fork");
        var dispatcher = (0, _dispatcher2.default)();
        forkedTasks.set(task, dispatcher);
        rungen(value.iterator.apply(null, value.args), function(result) {
          return dispatcher.dispatch(result);
        }, function(err) {
          return dispatcher.dispatch((0, _helpers.error)(err));
        });
        var unsubscribe = dispatcher.subscribe(function() {
          unsubscribe();
          forkedTasks.delete(task);
        });
        next2(task);
        return true;
      };
      var join = exports.join = function join2(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.join(value))
          return false;
        var dispatcher = forkedTasks.get(value.task);
        if (!dispatcher) {
          raiseNext("join error : task not found");
        } else {
          (function() {
            var unsubscribe = dispatcher.subscribe(function(result) {
              unsubscribe();
              next2(result);
            });
          })();
        }
        return true;
      };
      var race = exports.race = function race2(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.race(value))
          return false;
        var finished = false;
        var success = function success2(result, k3, v5) {
          if (finished)
            return;
          finished = true;
          result[k3] = v5;
          next2(result);
        };
        var fail = function fail2(err) {
          if (finished)
            return;
          raiseNext(err);
        };
        if (_is2.default.array(value.competitors)) {
          (function() {
            var result = value.competitors.map(function() {
              return false;
            });
            value.competitors.forEach(function(competitor, index2) {
              rungen(competitor, function(output3) {
                return success(result, index2, output3);
              }, fail);
            });
          })();
        } else {
          (function() {
            var result = Object.keys(value.competitors).reduce(function(p5, c6) {
              p5[c6] = false;
              return p5;
            }, {});
            Object.keys(value.competitors).forEach(function(index2) {
              rungen(value.competitors[index2], function(output3) {
                return success(result, index2, output3);
              }, fail);
            });
          })();
        }
        return true;
      };
      var subscribe4 = function subscribe5(value, next2) {
        if (!_is2.default.subscribe(value))
          return false;
        if (!_is2.default.channel(value.channel)) {
          throw new Error('the first argument of "subscribe" must be a valid channel');
        }
        var unsubscribe = value.channel.subscribe(function(ret) {
          unsubscribe && unsubscribe();
          next2(ret);
        });
        return true;
      };
      exports.default = [promise, fork, join, race, subscribe4];
    }
  });

  // node_modules/rungen/dist/controls/wrap.js
  var require_wrap = __commonJS({
    "node_modules/rungen/dist/controls/wrap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.cps = exports.call = void 0;
      var _is = require_is();
      var _is2 = _interopRequireDefault(_is);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i5 = 0, arr2 = Array(arr.length); i5 < arr.length; i5++) {
            arr2[i5] = arr[i5];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var call3 = exports.call = function call4(value, next2, rungen, yieldNext, raiseNext) {
        if (!_is2.default.call(value))
          return false;
        try {
          next2(value.func.apply(value.context, value.args));
        } catch (err) {
          raiseNext(err);
        }
        return true;
      };
      var cps = exports.cps = function cps2(value, next2, rungen, yieldNext, raiseNext) {
        var _value$func;
        if (!_is2.default.cps(value))
          return false;
        (_value$func = value.func).call.apply(_value$func, [null].concat(_toConsumableArray(value.args), [function(err, result) {
          if (err)
            raiseNext(err);
          else
            next2(result);
        }]));
        return true;
      };
      exports.default = [call3, cps];
    }
  });

  // node_modules/rungen/dist/index.js
  var require_dist = __commonJS({
    "node_modules/rungen/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.wrapControls = exports.asyncControls = exports.create = void 0;
      var _helpers = require_helpers();
      Object.keys(_helpers).forEach(function(key) {
        if (key === "default")
          return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get11() {
            return _helpers[key];
          }
        });
      });
      var _create = require_create();
      var _create2 = _interopRequireDefault(_create);
      var _async = require_async();
      var _async2 = _interopRequireDefault(_async);
      var _wrap = require_wrap();
      var _wrap2 = _interopRequireDefault(_wrap);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      exports.create = _create2.default;
      exports.asyncControls = _async2.default;
      exports.wrapControls = _wrap2.default;
    }
  });

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/tslib/tslib.js"(exports, module) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __classPrivateFieldIn2;
      var __createBinding2;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id2, v5) {
            return exports2[id2] = previous ? previous(id2, v5) : v5;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b6) {
          d4.__proto__ = b6;
        } || function(d4, b6) {
          for (var p5 in b6)
            if (Object.prototype.hasOwnProperty.call(b6, p5))
              d4[p5] = b6[p5];
        };
        __extends2 = function(d4, b6) {
          if (typeof b6 !== "function" && b6 !== null)
            throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
          extendStatics(d4, b6);
          function __2() {
            this.constructor = d4;
          }
          d4.prototype = b6 === null ? Object.create(b6) : (__2.prototype = b6.prototype, new __2());
        };
        __assign2 = Object.assign || function(t5) {
          for (var s5, i5 = 1, n5 = arguments.length; i5 < n5; i5++) {
            s5 = arguments[i5];
            for (var p5 in s5)
              if (Object.prototype.hasOwnProperty.call(s5, p5))
                t5[p5] = s5[p5];
          }
          return t5;
        };
        __rest2 = function(s5, e4) {
          var t5 = {};
          for (var p5 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p5) && e4.indexOf(p5) < 0)
              t5[p5] = s5[p5];
          if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s5); i5 < p5.length; i5++) {
              if (e4.indexOf(p5[i5]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p5[i5]))
                t5[p5[i5]] = s5[p5[i5]];
            }
          return t5;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c6 = arguments.length, r5 = c6 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r5 = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i5 = decorators.length - 1; i5 >= 0; i5--)
              if (d4 = decorators[i5])
                r5 = (c6 < 3 ? d4(r5) : c6 > 3 ? d4(target, key, r5) : d4(target, key)) || r5;
          return c6 > 3 && r5 && Object.defineProperty(target, key, r5), r5;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e4) {
                reject(e4);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e4) {
                reject(e4);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t5[0] & 1)
              throw t5[1];
            return t5[1];
          }, trys: [], ops: [] }, f5, y5, t5, g5;
          return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
            return this;
          }), g5;
          function verb(n5) {
            return function(v5) {
              return step([n5, v5]);
            };
          }
          function step(op) {
            if (f5)
              throw new TypeError("Generator is already executing.");
            while (g5 && (g5 = 0, op[0] && (_ = 0)), _)
              try {
                if (f5 = 1, y5 && (t5 = op[0] & 2 ? y5["return"] : op[0] ? y5["throw"] || ((t5 = y5["return"]) && t5.call(y5), 0) : y5.next) && !(t5 = t5.call(y5, op[1])).done)
                  return t5;
                if (y5 = 0, t5)
                  op = [op[0] & 2, t5.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t5 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y5 = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t5 = _.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t5[1]) {
                      _.label = t5[1];
                      t5 = op;
                      break;
                    }
                    if (t5 && _.label < t5[2]) {
                      _.label = t5[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t5[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e4) {
                op = [6, e4];
                y5 = 0;
              } finally {
                f5 = t5 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m4, o6) {
          for (var p5 in m4)
            if (p5 !== "default" && !Object.prototype.hasOwnProperty.call(o6, p5))
              __createBinding2(o6, m4, p5);
        };
        __createBinding2 = Object.create ? function(o6, m4, k3, k22) {
          if (k22 === void 0)
            k22 = k3;
          var desc = Object.getOwnPropertyDescriptor(m4, k3);
          if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m4[k3];
            } };
          }
          Object.defineProperty(o6, k22, desc);
        } : function(o6, m4, k3, k22) {
          if (k22 === void 0)
            k22 = k3;
          o6[k22] = m4[k3];
        };
        __values2 = function(o6) {
          var s5 = typeof Symbol === "function" && Symbol.iterator, m4 = s5 && o6[s5], i5 = 0;
          if (m4)
            return m4.call(o6);
          if (o6 && typeof o6.length === "number")
            return {
              next: function() {
                if (o6 && i5 >= o6.length)
                  o6 = void 0;
                return { value: o6 && o6[i5++], done: !o6 };
              }
            };
          throw new TypeError(s5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o6, n5) {
          var m4 = typeof Symbol === "function" && o6[Symbol.iterator];
          if (!m4)
            return o6;
          var i5 = m4.call(o6), r5, ar = [], e4;
          try {
            while ((n5 === void 0 || n5-- > 0) && !(r5 = i5.next()).done)
              ar.push(r5.value);
          } catch (error2) {
            e4 = { error: error2 };
          } finally {
            try {
              if (r5 && !r5.done && (m4 = i5["return"]))
                m4.call(i5);
            } finally {
              if (e4)
                throw e4.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i5 = 0; i5 < arguments.length; i5++)
            ar = ar.concat(__read2(arguments[i5]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s5 = 0, i5 = 0, il = arguments.length; i5 < il; i5++)
            s5 += arguments[i5].length;
          for (var r5 = Array(s5), k3 = 0, i5 = 0; i5 < il; i5++)
            for (var a6 = arguments[i5], j2 = 0, jl = a6.length; j2 < jl; j2++, k3++)
              r5[k3] = a6[j2];
          return r5;
        };
        __spreadArray2 = function(to2, from, pack) {
          if (pack || arguments.length === 2)
            for (var i5 = 0, l5 = from.length, ar; i5 < l5; i5++) {
              if (ar || !(i5 in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i5);
                ar[i5] = from[i5];
              }
            }
          return to2.concat(ar || Array.prototype.slice.call(from));
        };
        __await2 = function(v5) {
          return this instanceof __await2 ? (this.v = v5, this) : new __await2(v5);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g5 = generator.apply(thisArg, _arguments || []), i5, q = [];
          return i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
            return this;
          }, i5;
          function verb(n5) {
            if (g5[n5])
              i5[n5] = function(v5) {
                return new Promise(function(a6, b6) {
                  q.push([n5, v5, a6, b6]) > 1 || resume(n5, v5);
                });
              };
          }
          function resume(n5, v5) {
            try {
              step(g5[n5](v5));
            } catch (e4) {
              settle(q[0][3], e4);
            }
          }
          function step(r5) {
            r5.value instanceof __await2 ? Promise.resolve(r5.value.v).then(fulfill, reject) : settle(q[0][2], r5);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f5, v5) {
            if (f5(v5), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o6) {
          var i5, p5;
          return i5 = {}, verb("next"), verb("throw", function(e4) {
            throw e4;
          }), verb("return"), i5[Symbol.iterator] = function() {
            return this;
          }, i5;
          function verb(n5, f5) {
            i5[n5] = o6[n5] ? function(v5) {
              return (p5 = !p5) ? { value: __await2(o6[n5](v5)), done: n5 === "return" } : f5 ? f5(v5) : v5;
            } : f5;
          }
        };
        __asyncValues2 = function(o6) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m4 = o6[Symbol.asyncIterator], i5;
          return m4 ? m4.call(o6) : (o6 = typeof __values2 === "function" ? __values2(o6) : o6[Symbol.iterator](), i5 = {}, verb("next"), verb("throw"), verb("return"), i5[Symbol.asyncIterator] = function() {
            return this;
          }, i5);
          function verb(n5) {
            i5[n5] = o6[n5] && function(v5) {
              return new Promise(function(resolve, reject) {
                v5 = o6[n5](v5), settle(resolve, reject, v5.done, v5.value);
              });
            };
          }
          function settle(resolve, reject, d4, v5) {
            Promise.resolve(v5).then(function(v6) {
              resolve({ value: v6, done: d4 });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o6, v5) {
          Object.defineProperty(o6, "default", { enumerable: true, value: v5 });
        } : function(o6, v5) {
          o6["default"] = v5;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k3 in mod)
              if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
                __createBinding2(result, mod, k3);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, state, kind, f5) {
          if (kind === "a" && !f5)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, state, value, kind, f5) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f5)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn2 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
      });
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i5 = 0; i5 < 10; i5++) {
            test2["_" + String.fromCharCode(i5)] = i5;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n5) {
            return test2[n5];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to2 = toObject(target);
        var symbols;
        for (var s5 = 1; s5 < arguments.length; s5++) {
          from = Object(arguments[s5]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to2[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i5 = 0; i5 < symbols.length; i5++) {
              if (propIsEnumerable.call(from, symbols[i5])) {
                to2[symbols[i5]] = from[symbols[i5]];
              }
            }
          }
        }
        return to2;
      };
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var _assign = require_object_assign();
          var ReactVersion = "17.0.2";
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          exports.Fragment = 60107;
          exports.StrictMode = 60108;
          exports.Profiler = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          exports.Suspense = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            exports.Fragment = symbolFor("react.fragment");
            exports.StrictMode = symbolFor("react.strict_mode");
            exports.Profiler = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            exports.Suspense = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: 0
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack4) {
            {
              currentExtraStackFrame = stack4;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack4) {
              {
                currentExtraStackFrame = stack4;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack4 = "";
              if (currentExtraStackFrame) {
                stack4 += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack4 += impl() || "";
              }
              return stack4;
            };
          }
          var IsSomeRendererActing = {
            current: false
          };
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner,
            IsSomeRendererActing,
            assign: _assign
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          }
          function warn2(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error2(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack4 = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack4 !== "") {
                format += "%s";
                args = args.concat([stack4]);
              }
              var argsWithFormat = args.map(function(item2) {
                return "" + item2;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context2, updater) {
            this.props = props;
            this.context = context2;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
              {
                throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
              }
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent(props, context2, updater) {
            this.props = props;
            this.context = context2;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          _assign(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef2() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case exports.Fragment:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case exports.Profiler:
                return "Profiler";
              case exports.StrictMode:
                return "StrictMode";
              case exports.Suspense:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context2 = type;
                  return getContextName(context2) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentName(init(payload));
                  } catch (x4) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS2 = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentName(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref2, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref: ref2,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement10(type, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref2 = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref2 = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS2.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i5 = 0; i5 < childrenLength; i5++) {
                childArray[i5] = arguments[i5 + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref2) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref2) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref2, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement2(element, config2, children) {
            if (!!(element === null || element === void 0)) {
              {
                throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
              }
            }
            var propName;
            var props = _assign({}, element.props);
            var key = element.key;
            var ref2 = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref2 = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                key = "" + config2.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS2.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i5 = 0; i5 < childrenLength; i5++) {
                childArray[i5] = arguments[i5 + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref2, self2, source, owner, props);
          }
          function isValidElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text3) {
            return text3.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index2) {
            if (typeof element === "object" && element !== null && element.key != null) {
              return escape("" + element.key);
            }
            return index2.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (Array.isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c6) {
                  return c6;
                });
              } else if (mappedChild != null) {
                if (isValidElement2(mappedChild)) {
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (Array.isArray(children)) {
              for (var i5 = 0; i5 < children.length; i5++) {
                child = children[i5];
                nextName = nextNamePrefix + getElementKey(child, i5);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = "" + children;
                {
                  {
                    throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                  }
                }
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context2) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context2, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n5 = 0;
            mapChildren(children, function() {
              n5++;
            });
            return n5;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray3(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement2(children)) {
              {
                throw Error("React.Children.only expected to receive a single React element child.");
              }
            }
            return children;
          }
          function createContext11(defaultValue, calculateChangedBits) {
            if (calculateChangedBits === void 0) {
              calculateChangedBits = null;
            } else {
              {
                if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                  error2("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
                }
              }
            }
            var context2 = {
              $$typeof: REACT_CONTEXT_TYPE,
              _calculateChangedBits: calculateChangedBits,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null
            };
            context2.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context2
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer5 = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context2,
                _calculateChangedBits: context2._calculateChangedBits
              };
              Object.defineProperties(Consumer5, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context2.Provider;
                  },
                  set: function(_Provider) {
                    context2.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context2._currentValue;
                  },
                  set: function(_currentValue) {
                    context2._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context2._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context2._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context2._threadCount;
                  },
                  set: function(_threadCount) {
                    context2._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context2.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context2.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context2.Consumer = Consumer5;
            }
            {
              context2._currentRenderer = null;
              context2._currentRenderer2 = null;
            }
            return context2;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
              thenable.then(function(moduleObject) {
                if (payload._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === void 0) {
                      error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = defaultExport;
                }
              }, function(error3) {
                if (payload._status === Pending) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error3;
                }
              });
            }
            if (payload._status === Resolved) {
              return payload._result;
            } else {
              throw payload._result;
            }
          }
          function lazy2(ctor) {
            var payload = {
              _status: -1,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef5(render2) {
            {
              if (render2 != null && render2.$$typeof === REACT_MEMO_TYPE) {
                error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render2 !== "function") {
                error2("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2);
              } else {
                if (render2.length !== 0 && render2.length !== 2) {
                  error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render2 != null) {
                if (render2.defaultProps != null || render2.propTypes != null) {
                  error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render: render2
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (render2.displayName == null) {
                    render2.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var enableScopeAPI = false;
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }
            return false;
          }
          function memo3(type, compare) {
            {
              if (!isValidElementType(type)) {
                error2("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (type.displayName == null) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            if (!(dispatcher !== null)) {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext19(Context6, unstable_observedBits) {
            var dispatcher = resolveDispatcher();
            {
              if (unstable_observedBits !== void 0) {
                error2("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
              }
              if (Context6._context !== void 0) {
                var realContext = Context6._context;
                if (realContext.Consumer === Context6) {
                  error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context6) {
                  error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context6, unstable_observedBits);
          }
          function useState15(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer4(reducer3, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer3, initialArg, init);
          }
          function useRef22(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect22(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create3, deps);
          }
          function useLayoutEffect6(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create3, deps);
          }
          function useCallback13(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo11(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create3, deps);
          }
          function useImperativeHandle2(ref2, create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref2, create3, deps);
          }
          function useDebugValue6(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x4) {
                  var match = x4.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match && match[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x4) {
                    control = x4;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x4) {
                    control = x4;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x4) {
                  control = x4;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s5 = sampleLines.length - 1;
                var c6 = controlLines.length - 1;
                while (s5 >= 1 && c6 >= 0 && sampleLines[s5] !== controlLines[c6]) {
                  c6--;
                }
                for (; s5 >= 1 && c6 >= 0; s5--, c6--) {
                  if (sampleLines[s5] !== controlLines[c6]) {
                    if (s5 !== 1 || c6 !== 1) {
                      do {
                        s5--;
                        c6--;
                        if (c6 < 0 || sampleLines[s5] !== controlLines[c6]) {
                          var _frame = "\n" + sampleLines[s5].replace(" at new ", " at ");
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s5 >= 1 && c6 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case exports.Suspense:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x4) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack4 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack4);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack4 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack4);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentName(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (Array.isArray(node)) {
              for (var i5 = 0; i5 < node.length; i5++) {
                var child = node[i5];
                if (isValidElement2(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement2(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement2(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentName(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentName(type);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i5 = 0; i5 < keys.length; i5++) {
                var key = keys[i5];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (Array.isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement10.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i5 = 2; i5 < arguments.length; i5++) {
                validateChildKeys(arguments[i5], type);
              }
            }
            if (type === exports.Fragment) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement2.apply(this, arguments);
            for (var i5 = 2; i5 < arguments.length; i5++) {
              validateChildKeys(arguments[i5], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          {
            try {
              var frozenObject = Object.freeze({});
              /* @__PURE__ */ new Map([[frozenObject, null]]);
              /* @__PURE__ */ new Set([frozenObject]);
            } catch (e4) {
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children2 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray3,
            only: onlyChild
          };
          exports.Children = Children2;
          exports.Component = Component2;
          exports.PureComponent = PureComponent;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext11;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef2;
          exports.forwardRef = forwardRef5;
          exports.isValidElement = isValidElement2;
          exports.lazy = lazy2;
          exports.memo = memo3;
          exports.useCallback = useCallback13;
          exports.useContext = useContext19;
          exports.useDebugValue = useDebugValue6;
          exports.useEffect = useEffect22;
          exports.useImperativeHandle = useImperativeHandle2;
          exports.useLayoutEffect = useLayoutEffect6;
          exports.useMemo = useMemo11;
          exports.useReducer = useReducer4;
          exports.useRef = useRef22;
          exports.useState = useState15;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var requestHostCallback;
          var requestHostTimeout;
          var cancelHostTimeout;
          var requestPaint;
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          if (typeof window === "undefined" || typeof MessageChannel !== "function") {
            var _callback = null;
            var _timeoutID = null;
            var _flushCallback = function() {
              if (_callback !== null) {
                try {
                  var currentTime = exports.unstable_now();
                  var hasRemainingTime = true;
                  _callback(hasRemainingTime, currentTime);
                  _callback = null;
                } catch (e4) {
                  setTimeout(_flushCallback, 0);
                  throw e4;
                }
              }
            };
            requestHostCallback = function(cb2) {
              if (_callback !== null) {
                setTimeout(requestHostCallback, 0, cb2);
              } else {
                _callback = cb2;
                setTimeout(_flushCallback, 0);
              }
            };
            requestHostTimeout = function(cb2, ms) {
              _timeoutID = setTimeout(cb2, ms);
            };
            cancelHostTimeout = function() {
              clearTimeout(_timeoutID);
            };
            exports.unstable_shouldYield = function() {
              return false;
            };
            requestPaint = exports.unstable_forceFrameRate = function() {
            };
          } else {
            var _setTimeout = window.setTimeout;
            var _clearTimeout = window.clearTimeout;
            if (typeof console !== "undefined") {
              var requestAnimationFrame2 = window.requestAnimationFrame;
              var cancelAnimationFrame2 = window.cancelAnimationFrame;
              if (typeof requestAnimationFrame2 !== "function") {
                console["error"]("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
              if (typeof cancelAnimationFrame2 !== "function") {
                console["error"]("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
            }
            var isMessageLoopRunning = false;
            var scheduledHostCallback = null;
            var taskTimeoutID = -1;
            var yieldInterval = 5;
            var deadline = 0;
            {
              exports.unstable_shouldYield = function() {
                return exports.unstable_now() >= deadline;
              };
              requestPaint = function() {
              };
            }
            exports.unstable_forceFrameRate = function(fps) {
              if (fps < 0 || fps > 125) {
                console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                return;
              }
              if (fps > 0) {
                yieldInterval = Math.floor(1e3 / fps);
              } else {
                yieldInterval = 5;
              }
            };
            var performWorkUntilDeadline = function() {
              if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now();
                deadline = currentTime + yieldInterval;
                var hasTimeRemaining = true;
                try {
                  var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                  if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                  } else {
                    port.postMessage(null);
                  }
                } catch (error2) {
                  port.postMessage(null);
                  throw error2;
                }
              } else {
                isMessageLoopRunning = false;
              }
            };
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            requestHostCallback = function(callback) {
              scheduledHostCallback = callback;
              if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
              }
            };
            requestHostTimeout = function(callback, ms) {
              taskTimeoutID = _setTimeout(function() {
                callback(exports.unstable_now());
              }, ms);
            };
            cancelHostTimeout = function() {
              _clearTimeout(taskTimeoutID);
              taskTimeoutID = -1;
            };
          }
          function push(heap, node) {
            var index2 = heap.length;
            heap.push(node);
            siftUp(heap, node, index2);
          }
          function peek(heap) {
            var first = heap[0];
            return first === void 0 ? null : first;
          }
          function pop(heap) {
            var first = heap[0];
            if (first !== void 0) {
              var last = heap.pop();
              if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
              }
              return first;
            } else {
              return null;
            }
          }
          function siftUp(heap, node, i5) {
            var index2 = i5;
            while (true) {
              var parentIndex = index2 - 1 >>> 1;
              var parent = heap[parentIndex];
              if (parent !== void 0 && compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index2] = parent;
                index2 = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i5) {
            var index2 = i5;
            var length = heap.length;
            while (index2 < length) {
              var leftIndex = (index2 + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (left !== void 0 && compare(left, node) < 0) {
                if (right !== void 0 && compare(right, left) < 0) {
                  heap[index2] = right;
                  heap[rightIndex] = node;
                  index2 = rightIndex;
                } else {
                  heap[index2] = left;
                  heap[leftIndex] = node;
                  index2 = leftIndex;
                }
              } else if (right !== void 0 && compare(right, node) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a6, b6) {
            var diff = a6.sortIndex - b6.sortIndex;
            return diff !== 0 ? diff : a6.id - b6.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error2) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error2;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime = currentTime + delay;
              } else {
                startTime = currentTime;
              }
            } else {
              startTime = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime,
              expirationTime,
              sortIndex: -1
            };
            if (startTime > currentTime) {
              newTask.sortIndex = startTime;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_wrapCallback = unstable_wrapCallback;
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler-tracing.development.js
  var require_scheduler_tracing_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler-tracing.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var DEFAULT_THREAD_ID = 0;
          var interactionIDCounter = 0;
          var threadIDCounter = 0;
          exports.__interactionsRef = null;
          exports.__subscriberRef = null;
          {
            exports.__interactionsRef = {
              current: /* @__PURE__ */ new Set()
            };
            exports.__subscriberRef = {
              current: null
            };
          }
          function unstable_clear(callback) {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = /* @__PURE__ */ new Set();
            try {
              return callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;
            }
          }
          function unstable_getCurrent() {
            {
              return exports.__interactionsRef.current;
            }
          }
          function unstable_getThreadID() {
            return ++threadIDCounter;
          }
          function unstable_trace(name, timestamp, callback) {
            var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_THREAD_ID;
            var interaction = {
              __count: 1,
              id: interactionIDCounter++,
              name,
              timestamp
            };
            var prevInteractions = exports.__interactionsRef.current;
            var interactions = new Set(prevInteractions);
            interactions.add(interaction);
            exports.__interactionsRef.current = interactions;
            var subscriber = exports.__subscriberRef.current;
            var returnValue;
            try {
              if (subscriber !== null) {
                subscriber.onInteractionTraced(interaction);
              }
            } finally {
              try {
                if (subscriber !== null) {
                  subscriber.onWorkStarted(interactions, threadID);
                }
              } finally {
                try {
                  returnValue = callback();
                } finally {
                  exports.__interactionsRef.current = prevInteractions;
                  try {
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(interactions, threadID);
                    }
                  } finally {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  }
                }
              }
            }
            return returnValue;
          }
          function unstable_wrap(callback) {
            var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_THREAD_ID;
            var wrappedInteractions = exports.__interactionsRef.current;
            var subscriber = exports.__subscriberRef.current;
            if (subscriber !== null) {
              subscriber.onWorkScheduled(wrappedInteractions, threadID);
            }
            wrappedInteractions.forEach(function(interaction) {
              interaction.__count++;
            });
            var hasRun = false;
            function wrapped() {
              var prevInteractions = exports.__interactionsRef.current;
              exports.__interactionsRef.current = wrappedInteractions;
              subscriber = exports.__subscriberRef.current;
              try {
                var returnValue;
                try {
                  if (subscriber !== null) {
                    subscriber.onWorkStarted(wrappedInteractions, threadID);
                  }
                } finally {
                  try {
                    returnValue = callback.apply(void 0, arguments);
                  } finally {
                    exports.__interactionsRef.current = prevInteractions;
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(wrappedInteractions, threadID);
                    }
                  }
                }
                return returnValue;
              } finally {
                if (!hasRun) {
                  hasRun = true;
                  wrappedInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  });
                }
              }
            }
            wrapped.cancel = function cancel() {
              subscriber = exports.__subscriberRef.current;
              try {
                if (subscriber !== null) {
                  subscriber.onWorkCanceled(wrappedInteractions, threadID);
                }
              } finally {
                wrappedInteractions.forEach(function(interaction) {
                  interaction.__count--;
                  if (subscriber && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                });
              }
            };
            return wrapped;
          }
          var subscribers = null;
          {
            subscribers = /* @__PURE__ */ new Set();
          }
          function unstable_subscribe(subscriber) {
            {
              subscribers.add(subscriber);
              if (subscribers.size === 1) {
                exports.__subscriberRef.current = {
                  onInteractionScheduledWorkCompleted,
                  onInteractionTraced,
                  onWorkCanceled,
                  onWorkScheduled,
                  onWorkStarted,
                  onWorkStopped
                };
              }
            }
          }
          function unstable_unsubscribe(subscriber) {
            {
              subscribers.delete(subscriber);
              if (subscribers.size === 0) {
                exports.__subscriberRef.current = null;
              }
            }
          }
          function onInteractionTraced(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionTraced(interaction);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onInteractionScheduledWorkCompleted(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkScheduled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkScheduled(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStarted(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStopped(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStopped(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkCanceled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkCanceled(interactions, threadID);
              } catch (error2) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error2;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          exports.unstable_clear = unstable_clear;
          exports.unstable_getCurrent = unstable_getCurrent;
          exports.unstable_getThreadID = unstable_getThreadID;
          exports.unstable_subscribe = unstable_subscribe;
          exports.unstable_trace = unstable_trace;
          exports.unstable_unsubscribe = unstable_unsubscribe;
          exports.unstable_wrap = unstable_wrap;
        })();
      }
    }
  });

  // node_modules/scheduler/tracing.js
  var require_tracing = __commonJS({
    "node_modules/scheduler/tracing.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_tracing_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React8 = require_react();
          var _assign = require_object_assign();
          var Scheduler = require_scheduler();
          var tracing = require_tracing();
          var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn2(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error2(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack4 = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack4 !== "") {
                format += "%s";
                args = args.concat([stack4]);
              }
              var argsWithFormat = args.map(function(item2) {
                return "" + item2;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          if (!React8) {
            {
              throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment3 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef2 = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var FundamentalComponent = 20;
          var ScopeComponent = 21;
          var Block3 = 22;
          var OffscreenComponent = 23;
          var LegacyHiddenComponent = 24;
          var enableProfilerTimer = true;
          var enableFundamentalAPI = false;
          var enableNewReconciler = false;
          var warnAboutStringRefs = false;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i5 = 0; i5 < dependencies.length; i5++) {
              allNativeEvents.add(dependencies[i5]);
            }
          }
          var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var ROOT_ATTRIBUTE_NAME = "data-reactroot";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error2("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix3 = name.toLowerCase().slice(0, 5);
                  return prefix3 !== "data-" && prefix3 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              RESERVED,
              false,
              name,
              null,
              false,
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref8) {
            var name = _ref8[0], attributeName = _ref8[1];
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              name.toLowerCase(),
              null,
              false,
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              name,
              null,
              false,
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              false,
              name.toLowerCase(),
              null,
              false,
              false
            );
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              true,
              name,
              null,
              false,
              false
            );
          });
          [
            "capture",
            "download"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              OVERLOADED_BOOLEAN,
              false,
              name,
              null,
              false,
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              POSITIVE_NUMERIC,
              false,
              name,
              null,
              false,
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              NUMERIC,
              false,
              name.toLowerCase(),
              null,
              false,
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize2 = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize2);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize2);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize2);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              false,
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              true,
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name, expected) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (isOpaqueHydratingObject(expected)) {
                return expected;
              }
              if (!node.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name);
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          var REACT_FRAGMENT_TYPE = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x4) {
                  var match = x4.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match && match[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame2 = componentFrameCache.get(fn);
              if (frame2 !== void 0) {
                return frame2;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x4) {
                    control = x4;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x4) {
                    control = x4;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x4) {
                  control = x4;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s5 = sampleLines.length - 1;
                var c6 = controlLines.length - 1;
                while (s5 >= 1 && c6 >= 0 && sampleLines[s5] !== controlLines[c6]) {
                  c6--;
                }
                for (; s5 >= 1 && c6 >= 0; s5--, c6--) {
                  if (sampleLines[s5] !== controlLines[c6]) {
                    if (s5 !== 1 || c6 !== 1) {
                      do {
                        s5--;
                        c6--;
                        if (c6 < 0 || sampleLines[s5] !== controlLines[c6]) {
                          var _frame = "\n" + sampleLines[s5].replace(" at new ", " at ");
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s5 >= 1 && c6 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x4) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef2:
                return describeFunctionComponentFrame(fiber.type.render);
              case Block3:
                return describeFunctionComponentFrame(fiber.type._render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x4) {
              return "\nError generating stack: " + x4.message + "\n" + x4.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context2 = type;
                  return getContextName(context2) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentName(init(payload));
                  } catch (x4) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentName(owner.type);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function getIsRendering() {
            {
              return isRendering;
            }
          }
          function toString(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "object":
              case "string":
              case "undefined":
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get12 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get12.call(this);
              },
              set: function(value) {
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement2(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e4) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = _assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || node.value != value) {
                  node.value = toString(value);
                }
              } else if (node.value !== toString(value)) {
                node.value = toString(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton2 = type === "submit" || type === "reset";
              if (isButton2 && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name = node.name;
            if (name !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== "") {
              node.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              var group2 = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i5 = 0; i5 < group2.length; i5++) {
                var otherNode = group2[i5];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  {
                    throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                  }
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (type !== "number" || getActiveElement2(node.ownerDocument) !== node) {
              if (value == null) {
                node.defaultValue = toString(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString(value)) {
                node.defaultValue = toString(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          function flattenChildren(children) {
            var content = "";
            React8.Children.forEach(children, function(child) {
              if (child == null) {
                return;
              }
              content += child;
            });
            return content;
          }
          function validateProps(element, props) {
            {
              if (typeof props.children === "object" && props.children !== null) {
                React8.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (typeof child.type !== "string") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error2("Only strings and numbers are supported as <option> children.");
                  }
                });
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString(getToStringValue(props.value)));
            }
          }
          function getHostProps$1(element, props) {
            var hostProps = _assign({
              children: void 0
            }, props);
            var content = flattenChildren(props.children);
            if (content) {
              hostProps.children = content;
            }
            return hostProps;
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i5 = 0; i5 < valuePropNames.length; i5++) {
                var propName = valuePropNames[i5];
                if (props[propName] == null) {
                  continue;
                }
                var isArray2 = Array.isArray(props[propName]);
                if (props.multiple && !isArray2) {
                  error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && isArray2) {
                  error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options2 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i5 = 0; i5 < selectedValues.length; i5++) {
                selectedValue["$" + selectedValues[i5]] = true;
              }
              for (var _i = 0; _i < options2.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
                if (options2[_i].selected !== selected) {
                  options2[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                if (options2[_i2].value === _selectedValue) {
                  options2[_i2].selected = true;
                  if (setDefaultSelected) {
                    options2[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i2].disabled) {
                  defaultSelected = options2[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$2(element, props) {
            return _assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$3(element, props) {
            var node = element;
            if (!(props.dangerouslySetInnerHTML == null)) {
              {
                throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              }
            }
            var hostProps = _assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(children)) {
                    if (!(children.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var Namespaces = {
            html: HTML_NAMESPACE,
            mathml: MATH_NAMESPACE,
            svg: SVG_NAMESPACE
          };
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html2) {
            if (node.namespaceURI === Namespaces.svg) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html2.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html2;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text3) {
            if (text3) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text3;
                return;
              }
            }
            node.textContent = text3;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber2 = {
            animationIterationCount: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey2(prefix3, key) {
            return prefix3 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes2 = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber2).forEach(function(prop2) {
            prefixes2.forEach(function(prefix3) {
              isUnitlessNumber2[prefixKey2(prefix3, prop2)] = isUnitlessNumber2[prop2];
            });
          });
          function dangerousStyleValue2(name, value, isCustomProperty) {
            var isEmpty8 = value == null || typeof value === "boolean" || value === "";
            if (isEmpty8) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber2.hasOwnProperty(name) && isUnitlessNumber2[name])) {
              return value + "px";
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string2) {
              return string2.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error2(
                "Unsupported style property %s. Did you mean %s?",
                name,
                camelize(name.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error2("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error2("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue2(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue2(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty2(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i5 = 0; i5 < longhands.length; i5++) {
                expanded[longhands[i5]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty2(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var voidElementTags = _assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
                {
                  throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                }
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (!(props.children == null)) {
                {
                  throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                }
              }
              if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
                {
                  throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
                }
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (!(props.style == null || typeof props.style === "object")) {
              {
                throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop2) {
                return "`" + prop2 + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error2("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop2) {
                return "`" + prop2 + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var IS_REPLAYED = 1 << 4;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (!(typeof restoreImpl === "function")) {
              {
                throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i5 = 0; i5 < queuedTargets.length; i5++) {
                restoreStateOfTarget(queuedTargets[i5]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn, bookkeeping) {
            return fn(bookkeeping);
          };
          var discreteUpdatesImpl = function(fn, a6, b6, c6, d4) {
            return fn(a6, b6, c6, d4);
          };
          var flushDiscreteUpdatesImpl = function() {
          };
          var batchedEventUpdatesImpl = batchedUpdatesImpl;
          var isInsideEventHandler = false;
          var isBatchingEventUpdates = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushDiscreteUpdatesImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn, bookkeeping) {
            if (isInsideEventHandler) {
              return fn(bookkeeping);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn, bookkeeping);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function batchedEventUpdates(fn, a6, b6) {
            if (isBatchingEventUpdates) {
              return fn(a6, b6);
            }
            isBatchingEventUpdates = true;
            try {
              return batchedEventUpdatesImpl(fn, a6, b6);
            } finally {
              isBatchingEventUpdates = false;
              finishEventHandler();
            }
          }
          function discreteUpdates(fn, a6, b6, c6, d4) {
            var prevIsInsideEventHandler = isInsideEventHandler;
            isInsideEventHandler = true;
            try {
              return discreteUpdatesImpl(fn, a6, b6, c6, d4);
            } finally {
              isInsideEventHandler = prevIsInsideEventHandler;
              if (!isInsideEventHandler) {
                finishEventHandler();
              }
            }
          }
          function flushDiscreteUpdatesIfNeeded(timeStamp) {
            {
              if (!isInsideEventHandler) {
                flushDiscreteUpdatesImpl();
              }
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            discreteUpdatesImpl = _discreteUpdatesImpl;
            flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
            batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener2 = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (!(!listener2 || typeof listener2 === "function")) {
              {
                throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener2 + "` type.");
              }
            }
            return listener2;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM2) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e4) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name, func, context2, a6, b6, c6, d4, e4, f5) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context2, funcArgs);
            } catch (error3) {
              this.onError(error3);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context2, a6, b6, c6, d4, e4, f5) {
                if (!(typeof document !== "undefined")) {
                  {
                    throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                  }
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context2, funcArgs);
                  didError = false;
                }
                var error3;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error3 = event.error;
                  didSetError = true;
                  if (error3 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error3 != null && typeof error3 === "object") {
                      try {
                        error3._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error3);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error3) {
              hasError = true;
              caughtError = error3;
            }
          };
          function invokeGuardedCallback(name, func, context2, a6, b6, c6, d4, e4, f5) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context2, a6, b6, c6, d4, e4, f5) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error3 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error3;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error3 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error3;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error3 = caughtError;
              hasError = false;
              caughtError = null;
              return error3;
            } else {
              {
                {
                  throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          function get11(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var PlacementAndUpdate = 6;
          var Deletion = 8;
          var ContentReset = 16;
          var Callback = 32;
          var DidCapture = 64;
          var Ref = 128;
          var Snapshot = 256;
          var Passive = 512;
          var PassiveUnmountPendingDev = 8192;
          var Hydrating = 1024;
          var HydratingAndUpdate = 1028;
          var LifecycleEffectMask = 932;
          var HostEffectMask = 2047;
          var Incomplete = 2048;
          var ShouldCapture = 4096;
          var ForceUpdateForLegacySuspense = 16384;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get11(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (!(getNearestMountedFiber(fiber) === fiber)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (!(nearestMounted !== null)) {
                {
                  throw Error("Unable to find node on an unmounted component.");
                }
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a6 = fiber;
            var b6 = alternate;
            while (true) {
              var parentA = a6.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a6 = b6 = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a6) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b6) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                {
                  {
                    throw Error("Unable to find node on an unmounted component.");
                  }
                }
              }
              if (a6.return !== b6.return) {
                a6 = parentA;
                b6 = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a6) {
                    didFindChild = true;
                    a6 = parentA;
                    b6 = parentB;
                    break;
                  }
                  if (_child === b6) {
                    didFindChild = true;
                    b6 = parentA;
                    a6 = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a6) {
                      didFindChild = true;
                      a6 = parentB;
                      b6 = parentA;
                      break;
                    }
                    if (_child === b6) {
                      didFindChild = true;
                      b6 = parentB;
                      a6 = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    {
                      throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                    }
                  }
                }
              }
              if (!(a6.alternate === b6)) {
                {
                  throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (!(a6.tag === HostRoot)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
            if (a6.stateNode.current === a6) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText) {
                return node;
              } else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {
                return node;
              } else if (node.child && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function doesFiberContain(parentFiber, childFiber) {
            var node = childFiber;
            var parentFiberAlternate = parentFiber.alternate;
            while (node !== null) {
              if (node === parentFiber || node === parentFiberAlternate) {
                return true;
              }
              node = node.return;
            }
            return false;
          }
          var attemptUserBlockingHydration;
          function setAttemptUserBlockingHydration(fn) {
            attemptUserBlockingHydration = fn;
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn) {
            attemptHydrationAtPriority = fn;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          function hasQueuedDiscreteEvents() {
            return queuedDiscreteEvents.length > 0;
          }
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isReplayableDiscreteEvent(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags: eventSystemFlags | IS_REPLAYED,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            queuedDiscreteEvents.push(queuedEvent);
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId2 = nativeEvent.pointerId;
                queuedPointers.delete(pointerId2);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId2 = pointerEvent.pointerId;
                queuedPointers.set(pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.lanePriority, function() {
                      Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                        attemptHydrationAtCurrentPriority(nearestMounted);
                      });
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (root2.hydrate) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn !== null) {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map9) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map9.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            while (queuedDiscreteEvents.length > 0) {
              var nextDiscreteEvent = queuedDiscreteEvents[0];
              if (nextDiscreteEvent.blockedOn !== null) {
                var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);
                if (_fiber4 !== null) {
                  attemptUserBlockingHydration(_fiber4);
                }
                break;
              }
              var targetContainers = nextDiscreteEvent.targetContainers;
              while (targetContainers.length > 0) {
                var targetContainer = targetContainers[0];
                var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);
                if (nextBlockedOn !== null) {
                  nextDiscreteEvent.blockedOn = nextBlockedOn;
                  break;
                }
                targetContainers.shift();
              }
              if (nextDiscreteEvent.blockedOn === null) {
                queuedDiscreteEvents.shift();
              }
            }
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i5 = 1; i5 < queuedDiscreteEvents.length; i5++) {
                var queuedEvent = queuedDiscreteEvents[i5];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var DiscreteEvent = 0;
          var UserBlockingEvent = 1;
          var ContinuousEvent = 2;
          function makePrefixMap(styleProp, eventName) {
            var prefixes3 = {};
            prefixes3[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes3["Webkit" + styleProp] = "webkit" + eventName;
            prefixes3["Moz" + styleProp] = "moz" + eventName;
            return prefixes3;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM2) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var eventPriorities = /* @__PURE__ */ new Map();
          var discreteEventPairsForSimpleEventPlugin = [
            "cancel",
            "cancel",
            "click",
            "click",
            "close",
            "close",
            "contextmenu",
            "contextMenu",
            "copy",
            "copy",
            "cut",
            "cut",
            "auxclick",
            "auxClick",
            "dblclick",
            "doubleClick",
            "dragend",
            "dragEnd",
            "dragstart",
            "dragStart",
            "drop",
            "drop",
            "focusin",
            "focus",
            "focusout",
            "blur",
            "input",
            "input",
            "invalid",
            "invalid",
            "keydown",
            "keyDown",
            "keypress",
            "keyPress",
            "keyup",
            "keyUp",
            "mousedown",
            "mouseDown",
            "mouseup",
            "mouseUp",
            "paste",
            "paste",
            "pause",
            "pause",
            "play",
            "play",
            "pointercancel",
            "pointerCancel",
            "pointerdown",
            "pointerDown",
            "pointerup",
            "pointerUp",
            "ratechange",
            "rateChange",
            "reset",
            "reset",
            "seeked",
            "seeked",
            "submit",
            "submit",
            "touchcancel",
            "touchCancel",
            "touchend",
            "touchEnd",
            "touchstart",
            "touchStart",
            "volumechange",
            "volumeChange"
          ];
          var otherDiscreteEvents = ["change", "selectionchange", "textInput", "compositionstart", "compositionend", "compositionupdate"];
          var userBlockingPairsForSimpleEventPlugin = ["drag", "drag", "dragenter", "dragEnter", "dragexit", "dragExit", "dragleave", "dragLeave", "dragover", "dragOver", "mousemove", "mouseMove", "mouseout", "mouseOut", "mouseover", "mouseOver", "pointermove", "pointerMove", "pointerout", "pointerOut", "pointerover", "pointerOver", "scroll", "scroll", "toggle", "toggle", "touchmove", "touchMove", "wheel", "wheel"];
          var continuousPairsForSimpleEventPlugin = ["abort", "abort", ANIMATION_END, "animationEnd", ANIMATION_ITERATION, "animationIteration", ANIMATION_START, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", TRANSITION_END, "transitionEnd", "waiting", "waiting"];
          function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority2) {
            for (var i5 = 0; i5 < eventTypes.length; i5 += 2) {
              var topEvent = eventTypes[i5];
              var event = eventTypes[i5 + 1];
              var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
              var reactName = "on" + capitalizedEvent;
              eventPriorities.set(topEvent, priority2);
              topLevelEventsToReactNames.set(topEvent, reactName);
              registerTwoPhaseEvent(reactName, [topEvent]);
            }
          }
          function setEventPriorities(eventTypes, priority2) {
            for (var i5 = 0; i5 < eventTypes.length; i5++) {
              eventPriorities.set(eventTypes[i5], priority2);
            }
          }
          function getEventPriorityForPluginSystem(domEventName) {
            var priority2 = eventPriorities.get(domEventName);
            return priority2 === void 0 ? ContinuousEvent : priority2;
          }
          function registerSimpleEvents() {
            registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
            registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
            registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
            setEventPriorities(otherDiscreteEvents, DiscreteEvent);
          }
          var Scheduler_now = Scheduler.unstable_now;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
              }
            }
          }
          var ImmediatePriority = 99;
          var UserBlockingPriority = 98;
          var NormalPriority = 97;
          var LowPriority = 96;
          var IdlePriority = 95;
          var NoPriority = 90;
          var initialTimeMs = Scheduler_now();
          var SyncLanePriority = 15;
          var SyncBatchedLanePriority = 14;
          var InputDiscreteHydrationLanePriority = 13;
          var InputDiscreteLanePriority = 12;
          var InputContinuousHydrationLanePriority = 11;
          var InputContinuousLanePriority = 10;
          var DefaultHydrationLanePriority = 9;
          var DefaultLanePriority = 8;
          var TransitionHydrationPriority = 7;
          var TransitionPriority = 6;
          var RetryLanePriority = 5;
          var SelectiveHydrationLanePriority = 4;
          var IdleHydrationLanePriority = 3;
          var IdleLanePriority = 2;
          var OffscreenLanePriority = 1;
          var NoLanePriority = 0;
          var TotalLanes = 31;
          var NoLanes = 0;
          var NoLane = 0;
          var SyncLane = 1;
          var SyncBatchedLane = 2;
          var InputDiscreteHydrationLane = 4;
          var InputDiscreteLanes = 24;
          var InputContinuousHydrationLane = 32;
          var InputContinuousLanes = 192;
          var DefaultHydrationLane = 256;
          var DefaultLanes = 3584;
          var TransitionHydrationLane = 4096;
          var TransitionLanes = 4186112;
          var RetryLanes = 62914560;
          var SomeRetryLane = 33554432;
          var SelectiveHydrationLane = 67108864;
          var NonIdleLanes = 134217727;
          var IdleHydrationLane = 134217728;
          var IdleLanes = 805306368;
          var OffscreenLane = 1073741824;
          var NoTimestamp = -1;
          function setCurrentUpdateLanePriority(newLanePriority) {
          }
          var return_highestLanePriority = DefaultLanePriority;
          function getHighestPriorityLanes(lanes) {
            if ((SyncLane & lanes) !== NoLanes) {
              return_highestLanePriority = SyncLanePriority;
              return SyncLane;
            }
            if ((SyncBatchedLane & lanes) !== NoLanes) {
              return_highestLanePriority = SyncBatchedLanePriority;
              return SyncBatchedLane;
            }
            if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
              return_highestLanePriority = InputDiscreteHydrationLanePriority;
              return InputDiscreteHydrationLane;
            }
            var inputDiscreteLanes = InputDiscreteLanes & lanes;
            if (inputDiscreteLanes !== NoLanes) {
              return_highestLanePriority = InputDiscreteLanePriority;
              return inputDiscreteLanes;
            }
            if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
              return_highestLanePriority = InputContinuousHydrationLanePriority;
              return InputContinuousHydrationLane;
            }
            var inputContinuousLanes = InputContinuousLanes & lanes;
            if (inputContinuousLanes !== NoLanes) {
              return_highestLanePriority = InputContinuousLanePriority;
              return inputContinuousLanes;
            }
            if ((lanes & DefaultHydrationLane) !== NoLanes) {
              return_highestLanePriority = DefaultHydrationLanePriority;
              return DefaultHydrationLane;
            }
            var defaultLanes = DefaultLanes & lanes;
            if (defaultLanes !== NoLanes) {
              return_highestLanePriority = DefaultLanePriority;
              return defaultLanes;
            }
            if ((lanes & TransitionHydrationLane) !== NoLanes) {
              return_highestLanePriority = TransitionHydrationPriority;
              return TransitionHydrationLane;
            }
            var transitionLanes = TransitionLanes & lanes;
            if (transitionLanes !== NoLanes) {
              return_highestLanePriority = TransitionPriority;
              return transitionLanes;
            }
            var retryLanes = RetryLanes & lanes;
            if (retryLanes !== NoLanes) {
              return_highestLanePriority = RetryLanePriority;
              return retryLanes;
            }
            if (lanes & SelectiveHydrationLane) {
              return_highestLanePriority = SelectiveHydrationLanePriority;
              return SelectiveHydrationLane;
            }
            if ((lanes & IdleHydrationLane) !== NoLanes) {
              return_highestLanePriority = IdleHydrationLanePriority;
              return IdleHydrationLane;
            }
            var idleLanes = IdleLanes & lanes;
            if (idleLanes !== NoLanes) {
              return_highestLanePriority = IdleLanePriority;
              return idleLanes;
            }
            if ((OffscreenLane & lanes) !== NoLanes) {
              return_highestLanePriority = OffscreenLanePriority;
              return OffscreenLane;
            }
            {
              error2("Should have found matching lanes. This is a bug in React.");
            }
            return_highestLanePriority = DefaultLanePriority;
            return lanes;
          }
          function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
            switch (schedulerPriorityLevel) {
              case ImmediatePriority:
                return SyncLanePriority;
              case UserBlockingPriority:
                return InputContinuousLanePriority;
              case NormalPriority:
              case LowPriority:
                return DefaultLanePriority;
              case IdlePriority:
                return IdleLanePriority;
              default:
                return NoLanePriority;
            }
          }
          function lanePriorityToSchedulerPriority(lanePriority) {
            switch (lanePriority) {
              case SyncLanePriority:
              case SyncBatchedLanePriority:
                return ImmediatePriority;
              case InputDiscreteHydrationLanePriority:
              case InputDiscreteLanePriority:
              case InputContinuousHydrationLanePriority:
              case InputContinuousLanePriority:
                return UserBlockingPriority;
              case DefaultHydrationLanePriority:
              case DefaultLanePriority:
              case TransitionHydrationPriority:
              case TransitionPriority:
              case SelectiveHydrationLanePriority:
              case RetryLanePriority:
                return NormalPriority;
              case IdleHydrationLanePriority:
              case IdleLanePriority:
              case OffscreenLanePriority:
                return IdlePriority;
              case NoLanePriority:
                return NoPriority;
              default: {
                {
                  throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
                }
              }
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return_highestLanePriority = NoLanePriority;
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var nextLanePriority = NoLanePriority;
            var expiredLanes = root2.expiredLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            if (expiredLanes !== NoLanes) {
              nextLanes = expiredLanes;
              nextLanePriority = return_highestLanePriority = SyncLanePriority;
            } else {
              var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
              if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                  nextLanePriority = return_highestLanePriority;
                } else {
                  var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                  if (nonIdlePingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                    nextLanePriority = return_highestLanePriority;
                  }
                }
              } else {
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(unblockedLanes);
                  nextLanePriority = return_highestLanePriority;
                } else {
                  if (pingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(pingedLanes);
                    nextLanePriority = return_highestLanePriority;
                  }
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes);
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
              getHighestPriorityLanes(wipLanes);
              var wipLanePriority = return_highestLanePriority;
              if (nextLanePriority <= wipLanePriority) {
                return wipLanes;
              } else {
                return_highestLanePriority = nextLanePriority;
              }
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index3 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index3;
                nextLanes |= entanglements[index3];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var eventTime = eventTimes[index3];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            getHighestPriorityLanes(lane);
            var priority2 = return_highestLanePriority;
            if (priority2 >= InputContinuousLanePriority) {
              return currentTime + 250;
            } else if (priority2 >= TransitionPriority) {
              return currentTime + 5e3;
            } else {
              return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var expirationTime = expirationTimes[index3];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index3] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function returnNextLanesPriority() {
            return return_highestLanePriority;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function findUpdateLane(lanePriority, wipLanes) {
            switch (lanePriority) {
              case NoLanePriority:
                break;
              case SyncLanePriority:
                return SyncLane;
              case SyncBatchedLanePriority:
                return SyncBatchedLane;
              case InputDiscreteLanePriority: {
                var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
                if (_lane === NoLane) {
                  return findUpdateLane(InputContinuousLanePriority, wipLanes);
                }
                return _lane;
              }
              case InputContinuousLanePriority: {
                var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
                if (_lane2 === NoLane) {
                  return findUpdateLane(DefaultLanePriority, wipLanes);
                }
                return _lane2;
              }
              case DefaultLanePriority: {
                var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
                if (_lane3 === NoLane) {
                  _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
                  if (_lane3 === NoLane) {
                    _lane3 = pickArbitraryLane(DefaultLanes);
                  }
                }
                return _lane3;
              }
              case TransitionPriority:
              case RetryLanePriority:
                break;
              case IdleLanePriority:
                var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
                if (lane === NoLane) {
                  lane = pickArbitraryLane(IdleLanes);
                }
                return lane;
            }
            {
              {
                throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
              }
            }
          }
          function findTransitionLane(wipLanes, pendingLanes) {
            var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
              if (lane === NoLane) {
                lane = pickArbitraryLane(TransitionLanes);
              }
            }
            return lane;
          }
          function findRetryLane(wipLanes) {
            var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(RetryLanes);
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function getLowestPriorityLane(lanes) {
            var index3 = 31 - clz32(lanes);
            return index3 < 0 ? NoLanes : 1 << index3;
          }
          function getEqualOrHigherPriorityLanes(lanes) {
            return (getLowestPriorityLane(lanes) << 1) - 1;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a6, b6) {
            return (a6 & b6) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a6, b6) {
            return a6 | b6;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a6, b6) {
            return a6 !== NoLane && a6 < b6 ? a6 : b6;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i5 = 0; i5 < TotalLanes; i5++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            var higherPriorityLanes = updateLane - 1;
            root2.suspendedLanes &= higherPriorityLanes;
            root2.pingedLanes &= higherPriorityLanes;
            var eventTimes = root2.eventTimes;
            var index3 = laneToIndex(updateLane);
            eventTimes[index3] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markDiscreteUpdatesExpired(root2) {
            root2.expiredLanes |= InputDiscreteLanes & root2.pendingLanes;
          }
          function hasDiscreteLanes(lanes) {
            return (lanes & InputDiscreteLanes) !== NoLanes;
          }
          function markRootMutableRead(root2, updateLane) {
            root2.mutableReadLanes |= updateLane & root2.pendingLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = 0;
            root2.pingedLanes = 0;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              entanglements[index3] = NoLanes;
              eventTimes[index3] = NoTimestamp;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = entangledLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              entanglements[index3] |= entangledLanes;
              lanes &= ~lane;
            }
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(lanes) {
            if (lanes === 0) {
              return 32;
            }
            return 31 - (log(lanes) / LN2 | 0) | 0;
          }
          var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriorityForPluginSystem(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEvent:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case UserBlockingEvent:
                listenerWrapper = dispatchUserBlockingUpdate;
                break;
              case ContinuousEvent:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            {
              flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
            }
            discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
          }
          function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
            {
              runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            var allowReplay = true;
            {
              allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
            }
            if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
              queueDiscreteEvent(
                null,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              );
              return;
            }
            var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              if (allowReplay) {
                clearIfContinuousEvent(domEventName, nativeEvent);
              }
              return;
            }
            if (allowReplay) {
              if (isReplayableDiscreteEvent(domEventName)) {
                queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
                return;
              }
              if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
                return;
              }
              clearIfContinuousEvent(domEventName, nativeEvent);
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (root2.hydrate) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
            return null;
          }
          function addEventBubbleListener(target, eventType, listener2) {
            target.addEventListener(eventType, listener2, false);
            return listener2;
          }
          function addEventCaptureListener(target, eventType, listener2) {
            target.addEventListener(eventType, listener2, true);
            return listener2;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener2, passive) {
            target.addEventListener(eventType, listener2, {
              capture: true,
              passive
            });
            return listener2;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener2, passive) {
            target.addEventListener(eventType, listener2, {
              passive
            });
            return listener2;
          }
          var root = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText2();
            return true;
          }
          function reset2() {
            root = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start2;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText2();
            var endLength = endValue.length;
            for (start2 = 0; start2 < startLength; start2++) {
              if (startValue[start2] !== endValue[start2]) {
                break;
              }
            }
            var minEnd = startLength - start2;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start2, sliceTail);
            return fallbackText;
          }
          function getText2() {
            if ("value" in root) {
              return root.value;
            }
            return root.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize = Interface[_propName];
                if (normalize) {
                  this[_propName] = normalize(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            _assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              persist: function() {
              },
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = _assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = _assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = _assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = _assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = _assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = _assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = _assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = _assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = _assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = _assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = _assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = _assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM2 && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset2();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM2) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM2) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from;
            var to2;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from = targetInst;
              to2 = _related ? getClosestInstanceFromNode(_related) : null;
              if (to2 !== null) {
                var nearestMounted = getNearestMountedFiber(to2);
                if (to2 !== nearestMounted || to2.tag !== HostComponent && to2.tag !== HostText) {
                  to2 = null;
                }
              }
            } else {
              from = null;
              to2 = targetInst;
            }
            if (from === to2) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to2 == null ? win : getNodeFromInstance(to2);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to2, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to2);
          }
          function is2(x4, y5) {
            return x4 === y5 && (x4 !== 0 || 1 / x4 === 1 / y5) || x4 !== x4 && y5 !== y5;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is2;
          var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
          function shallowEqual2(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i5 = 0; i5 < keysA.length; i5++) {
              if (!hasOwnProperty$2.call(objB, keysA[i5]) || !objectIs(objA[keysA[i5]], objB[keysA[i5]])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root2, offset4) {
            var node = getLeafNode(root2);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset4 && nodeEnd >= offset4) {
                  return {
                    node,
                    offset: offset4 - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection2 = win.getSelection && win.getSelection();
            if (!selection2 || selection2.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection2.anchorNode, anchorOffset = selection2.anchorOffset, focusNode = selection2.focusNode, focusOffset = selection2.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e4) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start2 = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next2 = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start2 = length + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next2 = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next2;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start2 = length;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length;
                  }
                  if ((next2 = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next2;
              }
            if (start2 === -1 || end === -1) {
              return null;
            }
            return {
              start: start2,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection2 = win.getSelection();
            var length = node.textContent.length;
            var start2 = Math.min(offsets.start, length);
            var end = offsets.end === void 0 ? start2 : Math.min(offsets.end, length);
            if (!selection2.extend && start2 > end) {
              var temp = end;
              end = start2;
              start2 = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start2);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection2.rangeCount === 1 && selection2.anchorNode === startMarker.node && selection2.anchorOffset === startMarker.offset && selection2.focusNode === endMarker.node && selection2.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection2.removeAllRanges();
              if (start2 > end) {
                selection2.addRange(range);
                selection2.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection2.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement2();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement2(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i5 = 0; i5 < ancestors.length; i5++) {
                var info = ancestors[i5];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection2;
            if ("selectionStart" in input) {
              selection2 = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection2 = getOffsets(input);
            }
            return selection2 || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start2 = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start2;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start2;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection2 = win.getSelection();
              return {
                anchorNode: selection2.anchorNode,
                anchorOffset: selection2.anchorOffset,
                focusNode: selection2.focusNode,
                focusOffset: selection2.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement2(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual2(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener2, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener2, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i5 = dispatchListeners.length - 1; i5 >= 0; i5--) {
                var _dispatchListeners$i = dispatchListeners[i5], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener2 = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener2, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i5 = 0; i5 < dispatchQueue.length; i5++) {
              var _dispatchQueue$i = dispatchQueue[i5], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            {
              if (rootContainerElement[listeningMarker]) {
                return;
              }
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement, null);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement, null);
              });
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
            var eventSystemFlags = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
            var target = rootContainerElement;
            if (domEventName === "selectionchange" && rootContainerElement.nodeType !== DOCUMENT_NODE) {
              target = rootContainerElement.ownerDocument;
            }
            if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
              if (domEventName !== "scroll") {
                return;
              }
              eventSystemFlags |= IS_NON_DELEGATED;
              target = targetElement;
            }
            var listenerSet = getEventListenerSet(target);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              if (isCapturePhaseListener) {
                eventSystemFlags |= IS_CAPTURE_PHASE;
              }
              addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener2 = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener2, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener2);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener2, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener2);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container !== null) {
                        var parentNode = getClosestInstanceFromNode(container);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container = container.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedEventUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener2, currentTarget) {
            return {
              instance,
              listener: listener2,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener2 = getListener(instance, reactEventName);
                  if (listener2 != null) {
                    listeners.push(createDispatchListener(instance, listener2, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent2(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent2(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent2(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent2(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent2(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent2(nodeA);
              nodeB = getParent2(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to2) {
            var common = from && to2 ? getLowestCommonAncestor(from, to2) : null;
            if (from !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to2 !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to2, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var HTML_NAMESPACE$1 = Namespaces.html;
          var warnedUnknownTags;
          var suppressHydrationWarning;
          var validatePropertiesInDevelopment;
          var warnForTextDifference;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeMarkupForTextOrAttribute;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              dialog: true,
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;
            var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
            var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
            normalizeMarkupForTextOrAttribute = function(markup) {
              var markupString = typeof markup === "string" ? markup : "" + markup;
              return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
            };
            warnForTextDifference = function(serverText, clientText) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
              var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
              if (normalizedServerText === normalizedClientText) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            };
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names2 = [];
              attributeNames.forEach(function(name) {
                names2.push(name);
              });
              error2("Extra attributes from the server: %s", names2);
            };
            warnForInvalidEventListener = function(registrationName, listener2) {
              if (listener2 === false) {
                error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener2);
              }
            };
            normalizeHTML = function(parent, html2) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html2;
              return testElement.innerHTML;
            };
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop16() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop16;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i5 = 0; i5 < updatePayload.length; i5 += 2) {
              var propKey = updatePayload[i5];
              var propValue = updatePayload[i5 + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement10(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE$1) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE$1) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE$1) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text3, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text3);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i5 = 0; i5 < mediaEventTypes.length; i5++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i5], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$3(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "option":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$3(domElement, lastRawProps);
                nextProps = getHostProps$3(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else if (typeof nextProp === "object" && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
                nextProp.toString();
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i5 = 0; i5 < mediaEventTypes.length; i5++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i5], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name = attributes[_i].name.toLowerCase();
                switch (name) {
                  case "data-reactroot":
                    break;
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (!suppressHydrationWarning) {
                      warnForTextDifference(domElement.textContent, nextProp);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (!suppressHydrationWarning) {
                      warnForTextDifference(domElement.textContent, nextProp);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = getPropertyInfo(propKey);
                if (suppressHydrationWarning)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE$1) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE$1) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text3) {
            var isDifferent = textNode.nodeValue !== text3;
            return isDifferent;
          }
          function warnForUnmatchedText(textNode, text3) {
            {
              warnForTextDifference(textNode.nodeValue, text3);
            }
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text3) {
            {
              if (text3 === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text3, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error2("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1;
          {
            SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          }
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function shouldAutoFocusHostComponent(type, props) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
            }
            return false;
          }
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root2 = rootContainerInstance.documentElement;
                namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string2 = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement10(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            return shouldAutoFocusHostComponent(type, props);
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string2 = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "option" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text3, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text3, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text3, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            if (shouldAutoFocusHostComponent(type, newProps)) {
              domElement.focus();
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateFiberProps(domElement, newProps);
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue2("display", display);
          }
          function unhideTextInstance(textInstance, text3) {
            textInstance.nodeValue = text3;
          }
          function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
              container.textContent = "";
            } else if (container.nodeType === DOCUMENT_NODE) {
              var body = container.body;
              if (body != null) {
                body.textContent = "";
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text3) {
            if (text3 === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            return diffHydratedProperties(instance, type, props, parentNamespace);
          }
          function hydrateTextInstance(textInstance, text3, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            return diffHydratedText(textInstance, text3);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text3) {
            {
              warnForUnmatchedText(textInstance, text3);
            }
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text3) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForUnmatchedText(textInstance, text3);
            }
          }
          function didNotHydrateContainerInstance(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
          function didNotFindHydratableContainerInstance(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableContainerTextInstance(parentContainer, text3) {
            {
              warnForInsertedHydratedText(parentContainer, text3);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type);
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text3) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text3);
            }
          }
          function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true)
              ;
          }
          var clientId = 0;
          function makeClientIdInDEV(warnOnAccessInDEV) {
            var id2 = "r:" + (clientId++).toString(36);
            return {
              toString: function() {
                warnOnAccessInDEV();
                return id2;
              },
              valueOf: function() {
                warnOnAccessInDEV();
                return id2;
              }
            };
          }
          function isOpaqueHydratingObject(value) {
            return value !== null && typeof value === "object" && value.$$typeof === REACT_OPAQUE_ID_TYPE;
          }
          function makeOpaqueHydratingObject(attemptToReadValue) {
            return {
              $$typeof: REACT_OPAQUE_ID_TYPE,
              toString: attemptToReadValue,
              valueOf: attemptToReadValue
            };
          }
          function preparePortalMount(portalInstance) {
            {
              listenToAllSupportedEvents(portalInstance);
            }
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            {
              {
                throw Error("getNodeFromInstance: Invalid argument.");
              }
            }
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack4 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack4);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has2 = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index2 = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index2 < 0) {
              {
                error2("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index2]) {
                error2("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index2];
            valueStack[index2] = null;
            {
              fiberStack[index2] = null;
            }
            index2--;
          }
          function push(cursor, value, fiber) {
            index2++;
            valueStack[index2] = cursor.current;
            {
              fiberStack[index2] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context2 = {};
              for (var key in contextTypes) {
                context2[key] = unmaskedContext[key];
              }
              {
                var name = getComponentName(type) || "Unknown";
                checkPropTypes(contextTypes, context2, "context", name);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context2);
              }
              return context2;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context2, didChange) {
            {
              if (!(contextStackCursor.current === emptyContextObject)) {
                {
                  throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              push(contextStackCursor, context2, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentName(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  {
                    throw Error((getComponentName(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                  }
                }
              }
              {
                var name = getComponentName(type) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return _assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                {
                  throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
                {
                  throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component2 = node.type;
                    if (isContextProvider(Component2)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              {
                {
                  throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          var LegacyRoot = 0;
          var BlockingRoot = 1;
          var ConcurrentRoot = 2;
          var rendererID = null;
          var injectedHook = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error2("React instrumentation encountered an error: %s.", err);
              }
            }
            return true;
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, priorityLevel) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  injectedHook.onCommitFiberRoot(rendererID, root2, priorityLevel, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
              }
            }
          }
          var fakeCallbackNode = {};
          var ImmediatePriority$1 = 99;
          var UserBlockingPriority$2 = 98;
          var NormalPriority$1 = 97;
          var LowPriority$1 = 96;
          var IdlePriority$1 = 95;
          var NoPriority$1 = 90;
          var shouldYield = Scheduler_shouldYield;
          var requestPaint = Scheduler_requestPaint !== void 0 ? Scheduler_requestPaint : function() {
          };
          var syncQueue = null;
          var immediateQueueCallbackNode = null;
          var isFlushingSyncQueue = false;
          var initialTimeMs$1 = Scheduler_now$1();
          var now = initialTimeMs$1 < 1e4 ? Scheduler_now$1 : function() {
            return Scheduler_now$1() - initialTimeMs$1;
          };
          function getCurrentPriorityLevel() {
            switch (Scheduler_getCurrentPriorityLevel()) {
              case Scheduler_ImmediatePriority:
                return ImmediatePriority$1;
              case Scheduler_UserBlockingPriority:
                return UserBlockingPriority$2;
              case Scheduler_NormalPriority:
                return NormalPriority$1;
              case Scheduler_LowPriority:
                return LowPriority$1;
              case Scheduler_IdlePriority:
                return IdlePriority$1;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function reactPriorityToSchedulerPriority(reactPriorityLevel) {
            switch (reactPriorityLevel) {
              case ImmediatePriority$1:
                return Scheduler_ImmediatePriority;
              case UserBlockingPriority$2:
                return Scheduler_UserBlockingPriority;
              case NormalPriority$1:
                return Scheduler_NormalPriority;
              case LowPriority$1:
                return Scheduler_LowPriority;
              case IdlePriority$1:
                return Scheduler_IdlePriority;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function runWithPriority$1(reactPriorityLevel, fn) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_runWithPriority(priorityLevel, fn);
          }
          function scheduleCallback(reactPriorityLevel, callback, options2) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_scheduleCallback(priorityLevel, callback, options2);
          }
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
              immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
            } else {
              syncQueue.push(callback);
            }
            return fakeCallbackNode;
          }
          function cancelCallback(callbackNode) {
            if (callbackNode !== fakeCallbackNode) {
              Scheduler_cancelCallback(callbackNode);
            }
          }
          function flushSyncCallbackQueue() {
            if (immediateQueueCallbackNode !== null) {
              var node = immediateQueueCallbackNode;
              immediateQueueCallbackNode = null;
              Scheduler_cancelCallback(node);
            }
            flushSyncCallbackQueueImpl();
          }
          function flushSyncCallbackQueueImpl() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i5 = 0;
              {
                try {
                  var _isSync2 = true;
                  var _queue = syncQueue;
                  runWithPriority$1(ImmediatePriority$1, function() {
                    for (; i5 < _queue.length; i5++) {
                      var callback = _queue[i5];
                      do {
                        callback = callback(_isSync2);
                      } while (callback !== null);
                    }
                  });
                  syncQueue = null;
                } catch (error3) {
                  if (syncQueue !== null) {
                    syncQueue = syncQueue.slice(i5 + 1);
                  }
                  Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                  throw error3;
                } finally {
                  isFlushingSyncQueue = false;
                }
              }
            }
          }
          var ReactVersion = "17.0.2";
          var NoMode = 0;
          var StrictMode2 = 1;
          var BlockingMode = 2;
          var ConcurrentMode = 4;
          var ProfileMode = 8;
          var DebugTracingMode = 16;
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = 0;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictMode2) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array = [];
              set2.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode2 && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode2 && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode2 && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn2("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn2("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn2("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = _assign({}, baseProps);
              var defaultProps = Component2.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var MAX_SIGNED_31_BIT_INT = 1073741823;
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastContextWithAllBitsObserved = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, nextValue) {
            var context2 = providerFiber.type._context;
            {
              push(valueCursor, context2._currentValue, providerFiber);
              context2._currentValue = nextValue;
              {
                if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                  error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context2._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            var context2 = providerFiber.type._context;
            {
              context2._currentValue = currentValue;
            }
          }
          function calculateChangedBits(context2, newValue, oldValue) {
            if (objectIs(oldValue, newValue)) {
              return 0;
            } else {
              var changedBits = typeof context2._calculateChangedBits === "function" ? context2._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
              {
                if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
                  error2("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
                }
              }
              return changedBits | 0;
            }
          }
          function scheduleWorkOnParentPath(parent, renderLanes2) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              } else {
                break;
              }
              node = node.return;
            }
          }
          function propagateContextChange(workInProgress2, context2, changedBits, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context2 && (dependency.observedBits & changedBits) !== 0) {
                    if (fiber.tag === ClassComponent) {
                      var update3 = createUpdate2(NoTimestamp, pickArbitraryLane(renderLanes2));
                      update3.tag = ForceUpdate;
                      enqueueUpdate(fiber, update3);
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleWorkOnParentPath(fiber.return, renderLanes2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
          function readContext(context2, observedBits) {
            {
              if (isDisallowedContextReadInDEV) {
                error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            if (lastContextWithAllBitsObserved === context2)
              ;
            else if (observedBits === false || observedBits === 0)
              ;
            else {
              var resolvedObservedBits;
              if (typeof observedBits !== "number" || observedBits === MAX_SIGNED_31_BIT_INT) {
                lastContextWithAllBitsObserved = context2;
                resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
              } else {
                resolvedObservedBits = observedBits;
              }
              var contextItem = {
                context: context2,
                observedBits: resolvedObservedBits,
                next: null
              };
              if (lastContextDependency === null) {
                if (!(currentlyRenderingFiber !== null)) {
                  {
                    throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                  }
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem,
                  responders: null
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return context2._currentValue;
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone2 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone2;
            }
          }
          function createUpdate2(eventTime, lane) {
            var update3 = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update3;
          }
          function enqueueUpdate(fiber, update3) {
            var updateQueue2 = fiber.updateQueue;
            if (updateQueue2 === null) {
              return;
            }
            var sharedQueue = updateQueue2.shared;
            var pending = sharedQueue.pending;
            if (pending === null) {
              update3.next = update3;
            } else {
              update3.next = pending.next;
              pending.next = update3;
            }
            sharedQueue.pending = update3;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update3 = firstBaseUpdate;
                  do {
                    var clone2 = {
                      eventTime: update3.eventTime,
                      lane: update3.lane,
                      tag: update3.tag,
                      payload: update3.payload,
                      callback: update3.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone2;
                    } else {
                      newLast.next = clone2;
                      newLast = clone2;
                    }
                    update3 = update3.next;
                  } while (update3 !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update3, prevState, nextProps, instance) {
            switch (update3.tag) {
              case ReplaceState: {
                var payload = update3.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictMode2) {
                      disableLogs();
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        reenableLogs();
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update3.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictMode2) {
                      disableLogs();
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        reenableLogs();
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return _assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update3 = firstBaseUpdate;
              do {
                var updateLane = update3.lane;
                var updateEventTime = update3.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone2 = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update3.tag,
                    payload: update3.payload,
                    callback: update3.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone2;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone2;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      lane: NoLane,
                      tag: update3.tag,
                      payload: update3.payload,
                      callback: update3.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update3, newState, props, instance);
                  var callback = update3.callback;
                  if (callback !== null) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update3];
                    } else {
                      effects.push(update3);
                    }
                  }
                }
                update3 = update3.next;
                if (update3 === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update3 = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context2) {
            if (!(typeof callback === "function")) {
              {
                throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
              }
            }
            callback.call(context2);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i5 = 0; i5 < effects.length; i5++) {
                var effect = effects[i5];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var isArray = Array.isArray;
          var emptyRefsObject = new React8.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentName(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                {
                  {
                    throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                  }
                }
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            {
              if (workInProgress2.mode & StrictMode2) {
                disableLogs();
                try {
                  getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  reenableLogs();
                }
              }
            }
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : _assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue2 = workInProgress2.updateQueue;
              updateQueue2.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get11(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update3 = createUpdate2(eventTime, lane);
              update3.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update3.callback = callback;
              }
              enqueueUpdate(fiber, update3);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get11(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update3 = createUpdate2(eventTime, lane);
              update3.tag = ReplaceState;
              update3.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update3.callback = callback;
              }
              enqueueUpdate(fiber, update3);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get11(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update3 = createUpdate2(eventTime, lane);
              update3.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update3.callback = callback;
              }
              enqueueUpdate(fiber, update3);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              {
                if (workInProgress2.mode & StrictMode2) {
                  disableLogs();
                  try {
                    instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    reenableLogs();
                  }
                }
              }
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (shouldUpdate === void 0) {
                  error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual2(oldProps, newProps) || !shallowEqual2(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentName(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error2("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context2 = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context2 = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context2 = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            {
              if (workInProgress2.mode & StrictMode2) {
                disableLogs();
                try {
                  new ctor(props, context2);
                } finally {
                  reenableLogs();
                }
              }
            }
            var instance = new ctor(props, context2);
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentName(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context2);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress2.type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentName(workInProgress2.type) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictMode2) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              workInProgress2.flags |= Update;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (!(typeof child._store === "object")) {
                {
                  throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              child._store.validated = true;
              var componentName = getComponentName(returnFiber.type) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          var isArray$1 = Array.isArray;
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictMode2 || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentName(returnFiber.type) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (!(ownerFiber.tag === ClassComponent)) {
                    {
                      throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                    }
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  {
                    throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref2 = function(value) {
                  var refs = inst.refs;
                  if (refs === emptyRefsObject) {
                    refs = inst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref2._stringRef = stringRef;
                return ref2;
              } else {
                if (!(typeof mixedRef === "string")) {
                  {
                    throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                  }
                }
                if (!element._owner) {
                  {
                    throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                  }
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            if (returnFiber.type !== "textarea") {
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentName(returnFiber.type) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = childToDelete;
                returnFiber.lastEffect = childToDelete;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
              }
              childToDelete.nextEffect = null;
              childToDelete.flags = Deletion;
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone2 = createWorkInProgress(fiber, pendingProps);
              clone2.index = 0;
              clone2.sibling = null;
              return clone2;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags = Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags = Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags = Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              if (current2 !== null) {
                if (current2.elementType === element.type || isCompatibleFamilyForHotReloading(current2, element)) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment3) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      if (newChild.type === REACT_FRAGMENT_TYPE) {
                        return updateFragment2(returnFiber, oldFiber, newChild.props.children, lanes, key);
                      }
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment2(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
                    }
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i5 = 0; i5 < newChildren.length; i5++) {
                  var child = newChildren[i5];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (!(typeof iteratorFn === "function")) {
                {
                  throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (!(newChildren != null)) {
                {
                  throw Error("An iterable object provided no iterator.");
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  switch (child.tag) {
                    case Fragment3: {
                      if (element.type === REACT_FRAGMENT_TYPE) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var existing = useFiber(child, element.props.children);
                        existing.return = returnFiber;
                        {
                          existing._debugSource = element._source;
                          existing._debugOwner = element._owner;
                        }
                        return existing;
                      }
                      break;
                    }
                    case Block3:
                    default: {
                      if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var _existing3 = useFiber(child, element.props);
                        _existing3.ref = coerceRef(returnFiber, child, element);
                        _existing3.return = returnFiber;
                        {
                          _existing3._debugSource = element._source;
                          _existing3._debugOwner = element._owner;
                        }
                        return _existing3;
                      }
                      break;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              var isObject5 = typeof newChild === "object" && newChild !== null;
              if (isObject5) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                }
              }
              if (typeof newChild === "string" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              if (isArray$1(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (isObject5) {
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
                switch (returnFiber.tag) {
                  case ClassComponent: {
                    {
                      var instance = returnFiber.stateNode;
                      if (instance.render._isMockFunction) {
                        break;
                      }
                    }
                  }
                  case Block3:
                  case FunctionComponent:
                  case ForwardRef2:
                  case SimpleMemoComponent: {
                    {
                      {
                        throw Error((getComponentName(returnFiber.type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
                      }
                    }
                  }
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (!(current2 === null || workInProgress2.child === current2.child)) {
              {
                throw Error("Resuming work not yet implemented.");
              }
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c6) {
            if (!(c6 !== NO_CONTEXT)) {
              {
                throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return c6;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context2 = requiredContext(contextStackCursor$1.current);
            return context2;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context2 = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context2, fiber.type);
            if (context2 === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            if (props.fallback === void 0) {
              return false;
            }
            if (props.unstable_avoidThisFallback !== true) {
              return true;
            }
            if (hasInvisibleParent) {
              return false;
            }
            return true;
          }
          function findFirstSuspended(row2) {
            var node = row2;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row2) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row2) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = 0;
          var HasEffect = 1;
          var Layout2 = 2;
          var Passive$1 = 4;
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChild(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            return true;
          }
          function deleteHydratableInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot:
                  didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                  break;
                case HostComponent:
                  didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                  break;
              }
            }
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            childToDelete.flags = Deletion;
            if (returnFiber.lastEffect !== null) {
              returnFiber.lastEffect.nextEffect = childToDelete;
              returnFiber.lastEffect = childToDelete;
            } else {
              returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableContainerInstance(parentContainer, type);
                      break;
                    case HostText:
                      var text3 = fiber.pendingProps;
                      didNotFindHydratableContainerTextInstance(parentContainer, text3);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                      break;
                    case HostText:
                      var _text = fiber.pendingProps;
                      didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                      break;
                    case SuspenseComponent:
                      didNotFindHydratableSuspenseInstance(parentType, parentProps);
                      break;
                  }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  return true;
                }
                return false;
              }
              case HostText: {
                var text3 = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text3);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                return false;
              }
              default:
                return false;
            }
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
            }
            hydrationParentFiber = fiber;
            nextHydratableInstance = getFirstHydratableChild(nextInstance);
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            {
              if (shouldUpdate) {
                var returnFiber = hydrationParentFiber;
                if (returnFiber !== null) {
                  switch (returnFiber.tag) {
                    case HostRoot: {
                      var parentContainer = returnFiber.stateNode.containerInfo;
                      didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                      break;
                    }
                    case HostComponent: {
                      var parentType = returnFiber.type;
                      var parentProps = returnFiber.memoizedProps;
                      var parentInstance = returnFiber.stateNode;
                      didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                      break;
                    }
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              {
                throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            var type = fiber.type;
            if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
              var nextInstance = nextHydratableInstance;
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
          }
          function getIsHydrating() {
            return isHydrating;
          }
          var workInProgressSources = [];
          var rendererSigil$1;
          {
            rendererSigil$1 = {};
          }
          function markSourceAsDirty(mutableSource) {
            workInProgressSources.push(mutableSource);
          }
          function resetWorkInProgressVersions() {
            for (var i5 = 0; i5 < workInProgressSources.length; i5++) {
              var mutableSource = workInProgressSources[i5];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function getWorkInProgressVersion(mutableSource) {
            {
              return mutableSource._workInProgressVersionPrimary;
            }
          }
          function setWorkInProgressVersion(mutableSource, version) {
            {
              mutableSource._workInProgressVersionPrimary = version;
            }
            workInProgressSources.push(mutableSource);
          }
          function warnAboutMultipleRenderersDEV(mutableSource) {
            {
              {
                if (mutableSource._currentPrimaryRenderer == null) {
                  mutableSource._currentPrimaryRenderer = rendererSigil$1;
                } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
                  error2("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
                }
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnAboutUseOpaqueIdentifier;
          {
            didWarnAboutUseOpaqueIdentifier = {};
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !Array.isArray(deps)) {
                error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentName(currentlyRenderingFiber$1.type);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i5 = 0; i5 <= hookTypesUpdateIndexDev; i5++) {
                    var oldHookName = hookTypesDev[i5];
                    var newHookName = i5 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row2 = i5 + 1 + ". " + oldHookName;
                    while (row2.length < secondColumnStart) {
                      row2 += " ";
                    }
                    row2 += newHookName + "\n";
                    table += row2;
                  }
                  error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i5 = 0; i5 < prevDeps.length && i5 < nextDeps.length; i5++) {
              if (objectIs(nextDeps[i5], prevDeps[i5])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component2(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
                  {
                    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                  }
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component2(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
            }
            didScheduleRenderPhaseUpdate = false;
            if (!!didRenderTooFewHooks) {
              {
                throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
              }
            }
            return children;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.flags &= ~(Passive | Update);
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (!(nextCurrentHook !== null)) {
                {
                  throw Error("Rendered more hooks than during the previous render.");
                }
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer3, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== void 0) {
              initialState = init(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: reducer3,
              lastRenderedState: initialState
            };
            var dispatch2 = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch2];
          }
          function updateReducer(reducer3, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (!(queue !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue.lastRenderedReducer = reducer3;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update3 = first;
              do {
                var updateLane = update3.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone2 = {
                    lane: updateLane,
                    action: update3.action,
                    eagerReducer: update3.eagerReducer,
                    eagerState: update3.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone2;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone2;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      lane: NoLane,
                      action: update3.action,
                      eagerReducer: update3.eagerReducer,
                      eagerState: update3.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update3.eagerReducer === reducer3) {
                    newState = update3.eagerState;
                  } else {
                    var action = update3.action;
                    newState = reducer3(newState, action);
                  }
                }
                update3 = update3.next;
              } while (update3 !== null && update3 !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var dispatch2 = queue.dispatch;
            return [hook.memoizedState, dispatch2];
          }
          function rerenderReducer(reducer3, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (!(queue !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue.lastRenderedReducer = reducer3;
            var dispatch2 = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update3 = firstRenderPhaseUpdate;
              do {
                var action = update3.action;
                newState = reducer3(newState, action);
                update3 = update3.next;
              } while (update3 !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch2];
          }
          function readFromUnsubcribedMutableSource(root2, source, getSnapshot) {
            {
              warnAboutMultipleRenderersDEV(source);
            }
            var getVersion2 = source._getVersion;
            var version = getVersion2(source._source);
            var isSafeToReadFromSource = false;
            var currentRenderVersion = getWorkInProgressVersion(source);
            if (currentRenderVersion !== null) {
              isSafeToReadFromSource = currentRenderVersion === version;
            } else {
              isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root2.mutableReadLanes);
              if (isSafeToReadFromSource) {
                setWorkInProgressVersion(source, version);
              }
            }
            if (isSafeToReadFromSource) {
              var snapshot2 = getSnapshot(source._source);
              {
                if (typeof snapshot2 === "function") {
                  error2("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                }
              }
              return snapshot2;
            } else {
              markSourceAsDirty(source);
              {
                {
                  throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
                }
              }
            }
          }
          function useMutableSource(hook, source, getSnapshot, subscribe4) {
            var root2 = getWorkInProgressRoot();
            if (!(root2 !== null)) {
              {
                throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
            }
            var getVersion2 = source._getVersion;
            var version = getVersion2(source._source);
            var dispatcher = ReactCurrentDispatcher$1.current;
            var _dispatcher$useState = dispatcher.useState(function() {
              return readFromUnsubcribedMutableSource(root2, source, getSnapshot);
            }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];
            var snapshot2 = currentSnapshot;
            var stateHook = workInProgressHook;
            var memoizedState = hook.memoizedState;
            var refs = memoizedState.refs;
            var prevGetSnapshot = refs.getSnapshot;
            var prevSource = memoizedState.source;
            var prevSubscribe = memoizedState.subscribe;
            var fiber = currentlyRenderingFiber$1;
            hook.memoizedState = {
              refs,
              source,
              subscribe: subscribe4
            };
            dispatcher.useEffect(function() {
              refs.getSnapshot = getSnapshot;
              refs.setSnapshot = setSnapshot;
              var maybeNewVersion = getVersion2(source._source);
              if (!objectIs(version, maybeNewVersion)) {
                var maybeNewSnapshot = getSnapshot(source._source);
                {
                  if (typeof maybeNewSnapshot === "function") {
                    error2("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                  }
                }
                if (!objectIs(snapshot2, maybeNewSnapshot)) {
                  setSnapshot(maybeNewSnapshot);
                  var lane = requestUpdateLane(fiber);
                  markRootMutableRead(root2, lane);
                }
                markRootEntangled(root2, root2.mutableReadLanes);
              }
            }, [getSnapshot, source, subscribe4]);
            dispatcher.useEffect(function() {
              var handleChange = function() {
                var latestGetSnapshot = refs.getSnapshot;
                var latestSetSnapshot = refs.setSnapshot;
                try {
                  latestSetSnapshot(latestGetSnapshot(source._source));
                  var lane = requestUpdateLane(fiber);
                  markRootMutableRead(root2, lane);
                } catch (error3) {
                  latestSetSnapshot(function() {
                    throw error3;
                  });
                }
              };
              var unsubscribe = subscribe4(source._source, handleChange);
              {
                if (typeof unsubscribe !== "function") {
                  error2("Mutable source subscribe function must return an unsubscribe function.");
                }
              }
              return unsubscribe;
            }, [source, subscribe4]);
            if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe4)) {
              var newQueue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: snapshot2
              };
              newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
              stateHook.queue = newQueue;
              stateHook.baseQueue = null;
              snapshot2 = readFromUnsubcribedMutableSource(root2, source, getSnapshot);
              stateHook.memoizedState = stateHook.baseState = snapshot2;
            }
            return snapshot2;
          }
          function mountMutableSource(source, getSnapshot, subscribe4) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = {
              refs: {
                getSnapshot,
                setSnapshot: null
              },
              source,
              subscribe: subscribe4
            };
            return useMutableSource(hook, source, getSnapshot, subscribe4);
          }
          function updateMutableSource(source, getSnapshot, subscribe4) {
            var hook = updateWorkInProgressHook();
            return useMutableSource(hook, source, getSnapshot, subscribe4);
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            var dispatch2 = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch2];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create3, destroy, deps) {
            var effect = {
              tag,
              create: create3,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            var ref2 = {
              current: initialValue
            };
            {
              Object.seal(ref2);
            }
            hook.memoizedState = ref2;
            return ref2;
          }
          function updateRef2(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create3, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create3, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create3, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  pushEffect(hookFlags, create3, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create3, destroy, nextDeps);
          }
          function mountEffect(create3, deps) {
            {
              if ("undefined" !== typeof jest) {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return mountEffectImpl(Update | Passive, Passive$1, create3, deps);
          }
          function updateEffect(create3, deps) {
            {
              if ("undefined" !== typeof jest) {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return updateEffectImpl(Update | Passive, Passive$1, create3, deps);
          }
          function mountLayoutEffect(create3, deps) {
            return mountEffectImpl(Update, Layout2, create3, deps);
          }
          function updateLayoutEffect(create3, deps) {
            return updateEffectImpl(Update, Layout2, create3, deps);
          }
          function imperativeHandleEffect(create3, ref2) {
            if (typeof ref2 === "function") {
              var refCallback = ref2;
              var _inst = create3();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref2 !== null && ref2 !== void 0) {
              var refObject = ref2;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create3();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref2, create3, deps) {
            {
              if (typeof create3 !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create3 !== null ? typeof create3 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
            return mountEffectImpl(Update, Layout2, imperativeHandleEffect.bind(null, create3, ref2), effectDeps);
          }
          function updateImperativeHandle(ref2, create3, deps) {
            {
              if (typeof create3 !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create3 !== null ? typeof create3 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
            return updateEffectImpl(Update, Layout2, imperativeHandleEffect.bind(null, create3, ref2), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
            mountEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function updateDeferredValue(value) {
            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
            updateEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function rerenderDeferredValue(value) {
            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
            updateEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function startTransition(setPending, callback) {
            var priorityLevel = getCurrentPriorityLevel();
            {
              runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function() {
                setPending(true);
              });
              runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
                var prevTransition = ReactCurrentBatchConfig$1.transition;
                ReactCurrentBatchConfig$1.transition = 1;
                try {
                  setPending(false);
                  callback();
                } finally {
                  ReactCurrentBatchConfig$1.transition = prevTransition;
                }
              });
            }
          }
          function mountTransition() {
            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1];
            var start2 = startTransition.bind(null, setPending);
            mountRef(start2);
            return [start2, isPending];
          }
          function updateTransition() {
            var _updateState2 = updateState(), isPending = _updateState2[0];
            var startRef = updateRef2();
            var start2 = startRef.current;
            return [start2, isPending];
          }
          function rerenderTransition() {
            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
            var startRef = updateRef2();
            var start2 = startRef.current;
            return [start2, isPending];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function warnOnOpaqueIdentifierAccessInDEV(fiber) {
            {
              var name = getComponentName(fiber.type) || "Unknown";
              if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
                error2("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                didWarnAboutUseOpaqueIdentifier[name] = true;
              }
            }
          }
          function mountOpaqueIdentifier() {
            var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
            if (getIsHydrating()) {
              var didUpgrade = false;
              var fiber = currentlyRenderingFiber$1;
              var readValue = function() {
                if (!didUpgrade) {
                  didUpgrade = true;
                  {
                    isUpdatingOpaqueValueInRenderPhase = true;
                    setId(makeId());
                    isUpdatingOpaqueValueInRenderPhase = false;
                    warnOnOpaqueIdentifierAccessInDEV(fiber);
                  }
                }
                {
                  {
                    throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                  }
                }
              };
              var id2 = makeOpaqueHydratingObject(readValue);
              var setId = mountState(id2)[1];
              if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
                currentlyRenderingFiber$1.flags |= Update | Passive;
                pushEffect(HasEffect | Passive$1, function() {
                  setId(makeId());
                }, void 0, null);
              }
              return id2;
            } else {
              var _id = makeId();
              mountState(_id);
              return _id;
            }
          }
          function updateOpaqueIdentifier() {
            var id2 = updateState()[0];
            return id2;
          }
          function rerenderOpaqueIdentifier() {
            var id2 = rerenderState()[0];
            return id2;
          }
          function dispatchAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update3 = {
              lane,
              action,
              eagerReducer: null,
              eagerState: null,
              next: null
            };
            var pending = queue.pending;
            if (pending === null) {
              update3.next = update3;
            } else {
              update3.next = pending.next;
              pending.next = update3;
            }
            queue.pending = update3;
            var alternate = fiber.alternate;
            if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
              didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            } else {
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update3.eagerReducer = lastRenderedReducer;
                    update3.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      return;
                    }
                  } catch (error3) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              {
                if ("undefined" !== typeof jest) {
                  warnIfNotScopedWithMatchingAct(fiber);
                  warnIfNotCurrentlyActingUpdatesInDev(fiber);
                }
              }
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useOpaqueIdentifier: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                mountHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef2();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return updateOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context2, observedBits) {
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef2();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return rerenderOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context2, observedBits) {
                warnInvalidContextAccess();
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context2, observedBits) {
                warnInvalidContextAccess();
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef2();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context2, observedBits) {
                warnInvalidContextAccess();
                return readContext(context2, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context2, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context2, observedBits);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref2, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref2, create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer3, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer3, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef2();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe4) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe4);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var profilerStartTime = -1;
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(Component2)
                  );
                }
              }
            }
            var render3 = Component2.render;
            var ref2 = workInProgress2.ref;
            var nextChildren;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref2, renderLanes2);
              if (workInProgress2.mode & StrictMode2) {
                disableLogs();
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref2, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component2, nextProps, updateLanes, renderLanes2) {
            if (current2 === null) {
              var type = Component2.type;
              if (isSimpleFunctionComponent(type) && Component2.compare === null && Component2.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, updateLanes, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component2.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentName(_type)
                );
              }
            }
            var currentChild = current2.child;
            if (!includesSomeLane(updateLanes, renderLanes2)) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component2.compare;
              compare = compare !== null ? compare : shallowEqual2;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, updateLanes, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    outerMemoType = init(payload);
                  } catch (x4) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      "prop",
                      getComponentName(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual2(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                if (!includesSomeLane(renderLanes2, updateLanes)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || nextProps.mode === "unstable-defer-without-hiding") {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                {
                  markSpawnedWork(OffscreenLane);
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes
                };
                workInProgress2.memoizedState = _nextState;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          var updateLegacyHiddenComponent = updateOffscreenComponent;
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref2 = workInProgress2.ref;
            if (current2 === null && ref2 !== null || current2 !== null && current2.ref !== ref2) {
              workInProgress2.flags |= Ref;
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(Component2)
                  );
                }
              }
            }
            var context2;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
              context2 = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context2, renderLanes2);
              if (workInProgress2.mode & StrictMode2) {
                disableLogs();
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context2, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentName(Component2)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
              constructClassInstance(workInProgress2, Component2, nextProps);
              mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component2, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress2.type) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component2, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictMode2) {
                  disableLogs();
                  try {
                    instance.render();
                  } finally {
                    reenableLogs();
                  }
                }
                setIsRendering(false);
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            var updateQueue2 = workInProgress2.updateQueue;
            if (!(current2 !== null && updateQueue2 !== null)) {
              {
                throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState !== null ? prevState.element : null;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var nextChildren = nextState.element;
            if (nextChildren === prevChildren) {
              resetHydrationState();
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var root2 = workInProgress2.stateNode;
            if (root2.hydrate && enterHydrationState(workInProgress2)) {
              {
                var mutableSourceEagerHydrationData = root2.mutableSourceEagerHydrationData;
                if (mutableSourceEagerHydrationData != null) {
                  for (var i5 = 0; i5 < mutableSourceEagerHydrationData.length; i5 += 2) {
                    var mutableSource = mutableSourceEagerHydrationData[i5];
                    var version = mutableSourceEagerHydrationData[i5 + 1];
                    setWorkInProgressVersion(mutableSource, version);
                  }
                }
              }
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
              resetHydrationState();
            }
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, updateLanes, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component2 = init(payload);
            workInProgress2.type = Component2;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
            var resolvedProps = resolveDefaultProps(Component2, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component2);
                  workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
                }
                child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
                }
                child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef2: {
                {
                  workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
                }
                child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        "prop",
                        getComponentName(Component2)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component2,
                  resolveDefaultProps(Component2.type, resolvedProps),
                  updateLanes,
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            {
              {
                throw Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". Lazy element type must resolve to a class or function." + hint);
              }
            }
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var context2;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
              context2 = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictMode2) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component2, props, context2, renderLanes2);
              setIsRendering(false);
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component2)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              var getDerivedStateFromProps = Component2.getDerivedStateFromProps;
              if (typeof getDerivedStateFromProps === "function") {
                applyDerivedStateFromProps(workInProgress2, Component2, getDerivedStateFromProps, props);
              }
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component2, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictMode2) {
                  disableLogs();
                  try {
                    value = renderWithHooks(null, workInProgress2, Component2, props, context2, renderLanes2);
                  } finally {
                    reenableLogs();
                  }
                }
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error2("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || workInProgress2._debugID || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error2("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2)
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                if (nextProps.fallback !== void 0 && nextProps.unstable_avoidThisFallback !== true) {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              if (nextProps.fallback !== void 0) {
                tryToClaimNextHydratableInstance(workInProgress2);
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else if (typeof nextProps.unstable_expectedLoadTime === "number") {
                var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment = workInProgress2.child;
                _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                workInProgress2.lanes = SomeRetryLane;
                {
                  markSpawnedWork(SomeRetryLane);
                }
                return _fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren, renderLanes2);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                if (showFallback) {
                  var _nextFallbackChildren2 = nextProps.fallback;
                  var _nextPrimaryChildren2 = nextProps.children;
                  var _fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes2);
                  var _primaryChildFragment3 = workInProgress2.child;
                  var prevOffscreenState = current2.child.memoizedState;
                  _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                  _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  return _fallbackChildFragment;
                } else {
                  var _nextPrimaryChildren3 = nextProps.children;
                  var _primaryChildFragment4 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren3, renderLanes2);
                  workInProgress2.memoizedState = null;
                  return _primaryChildFragment4;
                }
              } else {
                if (showFallback) {
                  var _nextFallbackChildren3 = nextProps.fallback;
                  var _nextPrimaryChildren4 = nextProps.children;
                  var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes2);
                  var _primaryChildFragment5 = workInProgress2.child;
                  var _prevOffscreenState = current2.child.memoizedState;
                  _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes2);
                  _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  return _fallbackChildFragment2;
                } else {
                  var _nextPrimaryChildren5 = nextProps.children;
                  var _primaryChildFragment6 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren5, renderLanes2);
                  workInProgress2.memoizedState = null;
                  return _primaryChildFragment6;
                }
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes2, null);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function createWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              currentFallbackChildFragment.nextEffect = null;
              currentFallbackChildFragment.flags = Deletion;
              workInProgress2.firstEffect = workInProgress2.lastEffect = currentFallbackChildFragment;
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & BlockingMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              var progressedLastEffect = primaryChildFragment.lastEffect;
              if (progressedLastEffect !== null) {
                workInProgress2.firstEffect = primaryChildFragment.firstEffect;
                workInProgress2.lastEffect = progressedLastEffect;
                progressedLastEffect.nextEffect = null;
              } else {
                workInProgress2.firstEffect = workInProgress2.lastEffect = null;
              }
            } else {
              primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function scheduleWorkOnFiber(fiber, renderLanes2) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleWorkOnParentPath(fiber.return, renderLanes2);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleWorkOnFiber(node, renderLanes2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleWorkOnFiber(node, renderLanes2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row2 = firstChild;
            var lastContentRow = null;
            while (row2 !== null) {
              var currentRow = row2.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row2;
              }
              row2 = row2.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index3) {
            {
              var isArray2 = Array.isArray(childSlot);
              var isIterable = !isArray2 && typeof getIteratorFn(childSlot) === "function";
              if (isArray2 || isIterable) {
                var type = isArray2 ? "array" : "iterable";
                error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index3, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (Array.isArray(children)) {
                  for (var i5 = 0; i5 < children.length; i5++) {
                    if (!validateSuspenseListNestedChild(children[i5], i5)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode,
                lastEffect: lastEffectBeforeRendering
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
              renderState.lastEffect = lastEffectBeforeRendering;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    tail,
                    lastContentRow,
                    tailMode,
                    workInProgress2.lastEffect
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row2 = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row2 !== null) {
                    var currentRow = row2.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row2;
                      break;
                    }
                    var nextRow = row2.sibling;
                    row2.sibling = _tail;
                    _tail = row2;
                    row2 = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    _tail,
                    null,
                    tailMode,
                    workInProgress2.lastEffect
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    null,
                    null,
                    void 0,
                    workInProgress2.lastEffect
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context2 = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, newValue);
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              var changedBits = calculateChangedBits(context2, newValue, oldValue);
              if (changedBits === 0) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context2, changedBits, renderLanes2);
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context2 = workInProgress2.type;
            {
              if (context2._context === void 0) {
                if (context2 !== context2.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context2 = context2._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render3 = newProps.children;
            {
              if (typeof render3 !== "function") {
                error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context2, newProps.unstable_observedBits);
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render3(newValue);
              setIsRendering(false);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              return null;
            } else {
              cloneChildFibers(current2, workInProgress2);
              return workInProgress2.child;
            }
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = current2;
                returnFiber.lastEffect = current2;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = current2;
              }
              current2.nextEffect = null;
              current2.flags = Deletion;
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            var updateLanes = workInProgress2.lanes;
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else if (!includesSomeLane(renderLanes2, updateLanes)) {
                didReceiveUpdate = false;
                switch (workInProgress2.tag) {
                  case HostRoot:
                    pushHostRootContext(workInProgress2);
                    resetHydrationState();
                    break;
                  case HostComponent:
                    pushHostContext(workInProgress2);
                    break;
                  case ClassComponent: {
                    var Component2 = workInProgress2.type;
                    if (isContextProvider(Component2)) {
                      pushContextProvider(workInProgress2);
                    }
                    break;
                  }
                  case HostPortal:
                    pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                    break;
                  case ContextProvider: {
                    var newValue = workInProgress2.memoizedProps.value;
                    pushProvider(workInProgress2, newValue);
                    break;
                  }
                  case Profiler:
                    {
                      var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                      if (hasChildWork) {
                        workInProgress2.flags |= Update;
                      }
                      var stateNode = workInProgress2.stateNode;
                      stateNode.effectDuration = 0;
                      stateNode.passiveEffectDuration = 0;
                    }
                    break;
                  case SuspenseComponent: {
                    var state = workInProgress2.memoizedState;
                    if (state !== null) {
                      var primaryChildFragment = workInProgress2.child;
                      var primaryChildLanes = primaryChildFragment.childLanes;
                      if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                        return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                      } else {
                        pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                        if (child !== null) {
                          return child.sibling;
                        } else {
                          return null;
                        }
                      }
                    } else {
                      pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    }
                    break;
                  }
                  case SuspenseListComponent: {
                    var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                    var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                    if (didSuspendBefore) {
                      if (_hasChildWork) {
                        return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                      }
                      workInProgress2.flags |= DidCapture;
                    }
                    var renderState = workInProgress2.memoizedState;
                    if (renderState !== null) {
                      renderState.rendering = null;
                      renderState.tail = null;
                      renderState.lastEffect = null;
                    }
                    pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                    if (_hasChildWork) {
                      break;
                    } else {
                      return null;
                    }
                  }
                  case OffscreenComponent:
                  case LegacyHiddenComponent: {
                    workInProgress2.lanes = NoLanes;
                    return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
                  }
                }
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else {
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, updateLanes, renderLanes2);
              }
              case FunctionComponent: {
                var _Component = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, _Component, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component2, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef2: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment3:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        "prop",
                        getComponentName(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, updateLanes, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, updateLanes, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component3 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component3, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case Block3: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
              case LegacyHiddenComponent: {
                return updateLegacyHiddenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden2) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef2:
              case Fragment3:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                return null;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var fiberRoot = workInProgress2.stateNode;
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else if (!fiberRoot.hydrate) {
                    workInProgress2.flags |= Snapshot;
                  }
                }
                updateHostContainer(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = false;
                if (current2 === null) {
                  if (workInProgress2.memoizedProps.fallback !== void 0) {
                    popHydrationState(workInProgress2);
                  }
                } else {
                  var prevState = current2.memoizedState;
                  prevDidTimeout = prevState !== null;
                }
                if (nextDidTimeout && !prevDidTimeout) {
                  if ((workInProgress2.mode & BlockingMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && workInProgress2.memoizedProps.unstable_avoidThisFallback !== true;
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
                {
                  if (nextDidTimeout || prevDidTimeout) {
                    workInProgress2.flags |= Update;
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row2 = workInProgress2.child;
                      while (row2 !== null) {
                        var suspended = findFirstSuspended(row2);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThennables = suspended.updateQueue;
                          if (newThennables !== null) {
                            workInProgress2.updateQueue = newThennables;
                            workInProgress2.flags |= Update;
                          }
                          if (renderState.lastEffect === null) {
                            workInProgress2.firstEffect = null;
                          }
                          workInProgress2.lastEffect = renderState.lastEffect;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row2 = row2.sibling;
                      }
                    }
                    if (renderState.tail !== null && now() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                      {
                        markSpawnedWork(SomeRetryLane);
                      }
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThennables = _suspended.updateQueue;
                      if (_newThennables !== null) {
                        workInProgress2.updateQueue = _newThennables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        var lastEffect = workInProgress2.lastEffect = renderState.lastEffect;
                        if (lastEffect !== null) {
                          lastEffect.nextEffect = null;
                        }
                        return null;
                      }
                    } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                      {
                        markSpawnedWork(SomeRetryLane);
                      }
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next2 = renderState.tail;
                  renderState.rendering = next2;
                  renderState.tail = next2.sibling;
                  renderState.lastEffect = workInProgress2.lastEffect;
                  renderState.renderingStartTime = now();
                  next2.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next2;
                }
                return null;
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case Block3:
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                if (current2 !== null) {
                  var _nextState = workInProgress2.memoizedState;
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  var nextIsHidden = _nextState !== null;
                  if (prevIsHidden !== nextIsHidden && newProps.mode !== "unstable-defer-without-hiding") {
                    workInProgress2.flags |= Update;
                  }
                }
                return null;
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function unwindWork(workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if (!((_flags & DidCapture) === NoFlags)) {
                  {
                    throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                  }
                }
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(interruptedWork) {
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                popProvider(interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          function createCapturedValue(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error3 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack4 = errorInfo.stack;
                var componentStack = stack4 !== null ? stack4 : "";
                if (error3 != null && error3._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error3);
                }
                var componentName = source ? getComponentName(source.type) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                var errorBoundaryName = getComponentName(boundary.type);
                if (errorBoundaryName) {
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                } else {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error3);
              }
            } catch (e4) {
              setTimeout(function() {
                throw e4;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update3 = createUpdate2(NoTimestamp, lane);
            update3.tag = CaptureUpdate;
            update3.payload = {
              element: null
            };
            var error3 = errorInfo.value;
            update3.callback = function() {
              onUncaughtError(error3);
              logCapturedError(fiber, errorInfo);
            };
            return update3;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update3 = createUpdate2(NoTimestamp, lane);
            update3.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update3.payload = function() {
                logCapturedError(fiber, errorInfo);
                return getDerivedStateFromError(error$1);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update3.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                  logCapturedError(fiber, errorInfo);
                }
                var error$12 = errorInfo.value;
                var stack4 = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack4 !== null ? stack4 : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown");
                    }
                  }
                }
              };
            } else {
              update3.callback = function() {
                markFailedErrorBoundaryForHotReloading(fiber);
              };
            }
            return update3;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              wakeable.then(ping, ping);
            }
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            sourceFiber.firstEffect = sourceFiber.lastEffect = null;
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              if ((sourceFiber.mode & BlockingMode) === NoMode) {
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                  sourceFiber.updateQueue = currentSource.updateQueue;
                  sourceFiber.memoizedState = currentSource.memoizedState;
                  sourceFiber.lanes = currentSource.lanes;
                } else {
                  sourceFiber.updateQueue = null;
                  sourceFiber.memoizedState = null;
                }
              }
              var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);
              var _workInProgress = returnFiber;
              do {
                if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                  var wakeables = _workInProgress.updateQueue;
                  if (wakeables === null) {
                    var updateQueue2 = /* @__PURE__ */ new Set();
                    updateQueue2.add(wakeable);
                    _workInProgress.updateQueue = updateQueue2;
                  } else {
                    wakeables.add(wakeable);
                  }
                  if ((_workInProgress.mode & BlockingMode) === NoMode) {
                    _workInProgress.flags |= DidCapture;
                    sourceFiber.flags |= ForceUpdateForLegacySuspense;
                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                    if (sourceFiber.tag === ClassComponent) {
                      var currentSourceFiber = sourceFiber.alternate;
                      if (currentSourceFiber === null) {
                        sourceFiber.tag = IncompleteClassComponent;
                      } else {
                        var update3 = createUpdate2(NoTimestamp, SyncLane);
                        update3.tag = ForceUpdate;
                        enqueueUpdate(sourceFiber, update3);
                      }
                    }
                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                    return;
                  }
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  _workInProgress.flags |= ShouldCapture;
                  _workInProgress.lanes = rootRenderLanes;
                  return;
                }
                _workInProgress = _workInProgress.return;
              } while (_workInProgress !== null);
              value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            renderDidError();
            value = createCapturedValue(value, sourceFiber);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var _update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update2 = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update2);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            {
              instance.componentWillUnmount();
            }
          };
          function safelyCallComponentWillUnmount(current2, instance) {
            {
              invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current2, instance);
              if (hasCaughtError()) {
                var unmountError = clearCaughtError();
                captureCommitPhaseError(current2, unmountError);
              }
            }
          }
          function safelyDetachRef(current2) {
            var ref2 = current2.ref;
            if (ref2 !== null) {
              if (typeof ref2 === "function") {
                {
                  invokeGuardedCallback(null, ref2, null, null);
                  if (hasCaughtError()) {
                    var refError = clearCaughtError();
                    captureCommitPhaseError(current2, refError);
                  }
                }
              } else {
                ref2.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, destroy) {
            {
              invokeGuardedCallback(null, destroy, null);
              if (hasCaughtError()) {
                var error3 = clearCaughtError();
                captureCommitPhaseError(current2, error3);
              }
            }
          }
          function commitBeforeMutationLifeCycles(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent:
              case Block3: {
                return;
              }
              case ClassComponent: {
                if (finishedWork.flags & Snapshot) {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    var snapshot2 = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot2 === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot2;
                  }
                }
                return;
              }
              case HostRoot: {
                {
                  if (finishedWork.flags & Snapshot) {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                }
                return;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitHookEffectListUnmount(tag, finishedWork) {
            var updateQueue2 = finishedWork.updateQueue;
            var lastEffect = updateQueue2 !== null ? updateQueue2.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    destroy();
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(tag, finishedWork) {
            var updateQueue2 = finishedWork.updateQueue;
            var lastEffect = updateQueue2 !== null ? updateQueue2.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var create3 = effect.create;
                  effect.destroy = create3();
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error2("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function schedulePassiveEffects(finishedWork) {
            var updateQueue2 = finishedWork.updateQueue;
            var lastEffect = updateQueue2 !== null ? updateQueue2.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                var _effect = effect, next2 = _effect.next, tag = _effect.tag;
                if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
                  enqueuePendingPassiveHookEffectMount(finishedWork, effect);
                }
                effect = next2;
              } while (effect !== firstEffect);
            }
          }
          function commitLifeCycles(finishedRoot, current2, finishedWork, committedLanes) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent:
              case Block3: {
                {
                  commitHookEffectListMount(Layout2 | HasEffect, finishedWork);
                }
                schedulePassiveEffects(finishedWork);
                return;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (current2 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    {
                      instance.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    {
                      instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
                var updateQueue2 = finishedWork.updateQueue;
                if (updateQueue2 !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue2, instance);
                }
                return;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                return;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props);
                }
                return;
              }
              case HostText: {
                return;
              }
              case HostPortal: {
                return;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  if (typeof onRender === "function") {
                    {
                      onRender(finishedWork.memoizedProps.id, current2 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2, finishedRoot.memoizedInteractions);
                    }
                  }
                }
                return;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                return;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case FundamentalComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden2) {
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  var instance = node.stateNode;
                  if (isHidden2) {
                    hideInstance(instance);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } else if (node.tag === HostText) {
                  var _instance3 = node.stateNode;
                  if (isHidden2) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref2 = finishedWork.ref;
            if (ref2 !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref2 === "function") {
                ref2(instanceToUse);
              } else {
                {
                  if (!ref2.hasOwnProperty("current")) {
                    error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type));
                  }
                }
                ref2.current = instanceToUse;
              }
            }
          }
          function commitDetachRef(current2) {
            var currentRef = current2.ref;
            if (currentRef !== null) {
              if (typeof currentRef === "function") {
                currentRef(null);
              } else {
                currentRef.current = null;
              }
            }
          }
          function commitUnmount(finishedRoot, current2, renderPriorityLevel) {
            onCommitUnmount(current2);
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block3: {
                var updateQueue2 = current2.updateQueue;
                if (updateQueue2 !== null) {
                  var lastEffect = updateQueue2.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                      if (destroy !== void 0) {
                        if ((tag & Passive$1) !== NoFlags$1) {
                          enqueuePendingPassiveHookEffectUnmount(current2, effect);
                        } else {
                          {
                            safelyCallDestroy(current2, destroy);
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
                return;
              }
              case ClassComponent: {
                safelyDetachRef(current2);
                var instance = current2.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(current2, instance);
                }
                return;
              }
              case HostComponent: {
                safelyDetachRef(current2);
                return;
              }
              case HostPortal: {
                {
                  unmountHostComponents(finishedRoot, current2);
                }
                return;
              }
              case FundamentalComponent: {
                return;
              }
              case DehydratedFragment: {
                return;
              }
              case ScopeComponent: {
                return;
              }
            }
          }
          function commitNestedUnmounts(finishedRoot, root2, renderPriorityLevel) {
            var node = root2;
            while (true) {
              commitUnmount(finishedRoot, node);
              if (node.child !== null && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === root2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === root2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function detachFiberMutation(fiber) {
            fiber.alternate = null;
            fiber.child = null;
            fiber.dependencies = null;
            fiber.firstEffect = null;
            fiber.lastEffect = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.return = null;
            fiber.updateQueue = null;
            {
              fiber._debugOwner = null;
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            {
              {
                throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            var parent;
            var isContainer;
            var parentStateNode = parentFiber.stateNode;
            switch (parentFiber.tag) {
              case HostComponent:
                parent = parentStateNode;
                isContainer = false;
                break;
              case HostRoot:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case HostPortal:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case FundamentalComponent:
              default: {
                {
                  throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            if (isContainer) {
              insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
            } else {
              insertOrAppendPlacementNode(finishedWork, before, parent);
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function unmountHostComponents(finishedRoot, current2, renderPriorityLevel) {
            var node = current2;
            var currentParentIsValid = false;
            var currentParent;
            var currentParentIsContainer;
            while (true) {
              if (!currentParentIsValid) {
                var parent = node.return;
                findParent:
                  while (true) {
                    if (!(parent !== null)) {
                      {
                        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    var parentStateNode = parent.stateNode;
                    switch (parent.tag) {
                      case HostComponent:
                        currentParent = parentStateNode;
                        currentParentIsContainer = false;
                        break findParent;
                      case HostRoot:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                      case HostPortal:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                    }
                    parent = parent.return;
                  }
                currentParentIsValid = true;
              }
              if (node.tag === HostComponent || node.tag === HostText) {
                commitNestedUnmounts(finishedRoot, node);
                if (currentParentIsContainer) {
                  removeChildFromContainer(currentParent, node.stateNode);
                } else {
                  removeChild(currentParent, node.stateNode);
                }
              } else if (node.tag === HostPortal) {
                if (node.child !== null) {
                  currentParent = node.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              } else {
                commitUnmount(finishedRoot, node);
                if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              }
              if (node === current2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === current2) {
                  return;
                }
                node = node.return;
                if (node.tag === HostPortal) {
                  currentParentIsValid = false;
                }
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function commitDeletion(finishedRoot, current2, renderPriorityLevel) {
            {
              unmountHostComponents(finishedRoot, current2);
            }
            var alternate = current2.alternate;
            detachFiberMutation(current2);
            if (alternate !== null) {
              detachFiberMutation(alternate);
            }
          }
          function commitWork(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block3: {
                {
                  commitHookEffectListUnmount(Layout2 | HasEffect, finishedWork);
                }
                return;
              }
              case ClassComponent: {
                return;
              }
              case HostComponent: {
                var instance = finishedWork.stateNode;
                if (instance != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    commitUpdate(instance, updatePayload, type, oldProps, newProps);
                  }
                }
                return;
              }
              case HostText: {
                if (!(finishedWork.stateNode !== null)) {
                  {
                    throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
              }
              case HostRoot: {
                {
                  var _root = finishedWork.stateNode;
                  if (_root.hydrate) {
                    _root.hydrate = false;
                    commitHydratedContainer(_root.containerInfo);
                  }
                }
                return;
              }
              case Profiler: {
                return;
              }
              case SuspenseComponent: {
                commitSuspenseComponent(finishedWork);
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case SuspenseListComponent: {
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case IncompleteClassComponent: {
                return;
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                var newState = finishedWork.memoizedState;
                var isHidden2 = newState !== null;
                hideOrUnhideAllChildren(finishedWork, isHidden2);
                return;
              }
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitSuspenseComponent(finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState !== null) {
              markCommitTimeOfFallback();
              {
                var primaryChildParent = finishedWork.child;
                hideOrUnhideAllChildren(primaryChildParent, true);
              }
            }
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  {
                    if (wakeable.__reactDoNotTraceInteractions !== true) {
                      retry = tracing.unstable_wrap(retry);
                    }
                  }
                  retryCache.add(wakeable);
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function isSuspenseBoundaryBeingHidden(current2, finishedWork) {
            if (current2 !== null) {
              var oldState = current2.memoizedState;
              if (oldState === null || oldState.dehydrated !== null) {
                var newState = finishedWork.memoizedState;
                return newState !== null && newState.dehydrated === null;
              }
            }
            return false;
          }
          function commitResetTextContent(current2) {
            resetTextContent(current2.stateNode);
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor$1 = Symbol.for;
            COMPONENT_TYPE = symbolFor$1("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor$1("selector.role");
            TEST_NAME_TYPE = symbolFor$1("selector.test_id");
            TEXT_TYPE = symbolFor$1("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
          var NoContext = 0;
          var BatchedContext = 1;
          var EventContext = 2;
          var DiscreteEventContext = 4;
          var LegacyUnbatchedContext = 8;
          var RenderContext = 16;
          var CommitContext = 32;
          var RetryAfterError = 64;
          var RootIncomplete = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootIncomplete;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var mostRecentlyUpdatedRoot = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var nextEffect = null;
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsRenderPriority = NoPriority$1;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveHookEffectsMount = [];
          var pendingPassiveHookEffectsUnmount = [];
          var rootsWithPendingDiscreteUpdates = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var spawnedWorkDuringRender = null;
          var currentEventTime = NoTimestamp;
          var currentEventWipLanes = NoLanes;
          var currentEventPendingLanes = NoLanes;
          var isFlushingPassiveEffects = false;
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return SyncLane;
            } else if ((mode & ConcurrentMode) === NoMode) {
              return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
            }
            if (currentEventWipLanes === NoLanes) {
              currentEventWipLanes = workInProgressRootIncludedLanes;
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (currentEventPendingLanes !== NoLanes) {
                currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
              }
              return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
            }
            var schedulerPriority = getCurrentPriorityLevel();
            var lane;
            if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
              lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
            } else {
              var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
              lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
            }
            return lane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return SyncLane;
            } else if ((mode & ConcurrentMode) === NoMode) {
              return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
            }
            if (currentEventWipLanes === NoLanes) {
              currentEventWipLanes = workInProgressRootIncludedLanes;
            }
            return findRetryLane(currentEventWipLanes);
          }
          function scheduleUpdateOnFiber(fiber, lane, eventTime) {
            checkForNestedUpdates();
            warnAboutRenderPhaseUpdatesInDEV(fiber);
            var root2 = markUpdateLaneFromFiberToRoot(fiber, lane);
            if (root2 === null) {
              warnAboutUpdateOnUnmountedFiberInDEV(fiber);
              return null;
            }
            markRootUpdated(root2, lane, eventTime);
            if (root2 === workInProgressRoot) {
              {
                workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            var priorityLevel = getCurrentPriorityLevel();
            if (lane === SyncLane) {
              if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                schedulePendingInteractions(root2, lane);
                performSyncWorkOnRoot(root2);
              } else {
                ensureRootIsScheduled(root2, eventTime);
                schedulePendingInteractions(root2, lane);
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            } else {
              if ((executionContext & DiscreteEventContext) !== NoContext && (priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
                if (rootsWithPendingDiscreteUpdates === null) {
                  rootsWithPendingDiscreteUpdates = /* @__PURE__ */ new Set([root2]);
                } else {
                  rootsWithPendingDiscreteUpdates.add(root2);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, lane);
            }
            mostRecentlyUpdatedRoot = root2;
          }
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root2 = node.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          function ensureRootIsScheduled(root2, currentTime) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            var newCallbackPriority = returnNextLanesPriority();
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback(existingCallbackNode);
                root2.callbackNode = null;
                root2.callbackPriority = NoLanePriority;
              }
              return;
            }
            if (existingCallbackNode !== null) {
              var existingCallbackPriority = root2.callbackPriority;
              if (existingCallbackPriority === newCallbackPriority) {
                return;
              }
              cancelCallback(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLanePriority) {
              newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else if (newCallbackPriority === SyncBatchedLanePriority) {
              newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root2));
            } else {
              var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
              newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2) {
            currentEventTime = NoTimestamp;
            currentEventWipLanes = NoLanes;
            currentEventPendingLanes = NoLanes;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var exitStatus = renderRootConcurrent(root2, lanes);
            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
              prepareFreshStack(root2, NoLanes);
            } else if (exitStatus !== RootIncomplete) {
              if (exitStatus === RootErrored) {
                executionContext |= RetryAfterError;
                if (root2.hydrate) {
                  root2.hydrate = false;
                  clearContainer(root2.containerInfo);
                }
                lanes = getLanesToRetrySynchronouslyOnError(root2);
                if (lanes !== NoLanes) {
                  exitStatus = renderRootSync(root2, lanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now());
                throw fatalError;
              }
              var finishedWork = root2.current.alternate;
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
            ensureRootIsScheduled(root2, now());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootIncomplete:
              case RootFatalErrored: {
                {
                  {
                    throw Error("Root did not complete. This is a bug in React.");
                  }
                }
              }
              case RootErrored: {
                commitRoot(root2);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2);
                break;
              }
              case RootCompleted: {
                commitRoot(root2);
                break;
              }
              default: {
                {
                  {
                    throw Error("Unknown root exit status.");
                  }
                }
              }
            }
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            flushPassiveEffects();
            var lanes;
            var exitStatus;
            if (root2 === workInProgressRoot && includesSomeLane(root2.expiredLanes, workInProgressRootRenderLanes)) {
              lanes = workInProgressRootRenderLanes;
              exitStatus = renderRootSync(root2, lanes);
              if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
                lanes = getNextLanes(root2, lanes);
                exitStatus = renderRootSync(root2, lanes);
              }
            } else {
              lanes = getNextLanes(root2, NoLanes);
              exitStatus = renderRootSync(root2, lanes);
            }
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              executionContext |= RetryAfterError;
              if (root2.hydrate) {
                root2.hydrate = false;
                clearContainer(root2.containerInfo);
              }
              lanes = getLanesToRetrySynchronouslyOnError(root2);
              if (lanes !== NoLanes) {
                exitStatus = renderRootSync(root2, lanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2);
            ensureRootIsScheduled(root2, now());
            return null;
          }
          function flushDiscreteUpdates() {
            if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
              {
                if ((executionContext & RenderContext) !== NoContext) {
                  error2("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
                }
              }
              return;
            }
            flushPendingDiscreteUpdates();
            flushPassiveEffects();
          }
          function flushPendingDiscreteUpdates() {
            if (rootsWithPendingDiscreteUpdates !== null) {
              var roots = rootsWithPendingDiscreteUpdates;
              rootsWithPendingDiscreteUpdates = null;
              roots.forEach(function(root2) {
                markDiscreteUpdatesExpired(root2);
                ensureRootIsScheduled(root2, now());
              });
            }
            flushSyncCallbackQueue();
          }
          function batchedUpdates$1(fn, a6) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn(a6);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function batchedEventUpdates$1(fn, a6) {
            var prevExecutionContext = executionContext;
            executionContext |= EventContext;
            try {
              return fn(a6);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function discreteUpdates$1(fn, a6, b6, c6, d4) {
            var prevExecutionContext = executionContext;
            executionContext |= DiscreteEventContext;
            {
              try {
                return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a6, b6, c6, d4));
              } finally {
                executionContext = prevExecutionContext;
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            }
          }
          function unbatchedUpdates(fn, a6) {
            var prevExecutionContext = executionContext;
            executionContext &= ~BatchedContext;
            executionContext |= LegacyUnbatchedContext;
            try {
              return fn(a6);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function flushSync3(fn, a6) {
            var prevExecutionContext = executionContext;
            if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
              {
                error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
              return fn(a6);
            }
            executionContext |= BatchedContext;
            {
              try {
                if (fn) {
                  return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a6));
                } else {
                  return void 0;
                }
              } finally {
                executionContext = prevExecutionContext;
                flushSyncCallbackQueue();
              }
            }
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                unwindInterruptedWork(interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            workInProgress = createWorkInProgress(root2.current, null);
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootIncomplete;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            {
              spawnedWorkDuringRender = null;
            }
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function pushInteractions(root2) {
            {
              var prevInteractions = tracing.__interactionsRef.current;
              tracing.__interactionsRef.current = root2.memoizedInteractions;
              return prevInteractions;
            }
          }
          function popInteractions(prevInteractions) {
            {
              tracing.__interactionsRef.current = prevInteractions;
            }
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError() {
            if (workInProgressRootExitStatus !== RootCompleted) {
              workInProgressRootExitStatus = RootErrored;
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootIncomplete;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              prepareFreshStack(root2, lanes);
              startWorkOnPendingInteractions(root2, lanes);
            }
            var prevInteractions = pushInteractions(root2);
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            {
              popInteractions(prevInteractions);
            }
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              {
                {
                  throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
              startWorkOnPendingInteractions(root2, lanes);
            }
            var prevInteractions = pushInteractions(root2);
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            {
              popInteractions(prevInteractions);
            }
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              return RootIncomplete;
            } else {
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next2;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next2 === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next2;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next2 = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next2 = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next2 = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next2 !== null) {
                  workInProgress = next2;
                  return;
                }
                resetChildLanes(completedWork);
                if (returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
                  if (returnFiber.firstEffect === null) {
                    returnFiber.firstEffect = completedWork.firstEffect;
                  }
                  if (completedWork.lastEffect !== null) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
                    }
                    returnFiber.lastEffect = completedWork.lastEffect;
                  }
                  var flags = completedWork.flags;
                  if (flags > PerformedWork) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = completedWork;
                    } else {
                      returnFiber.firstEffect = completedWork;
                    }
                    returnFiber.lastEffect = completedWork;
                  }
                }
              } else {
                var _next = unwindWork(completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.firstEffect = returnFiber.lastEffect = null;
                  returnFiber.flags |= Incomplete;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function resetChildLanes(completedWork) {
            if ((completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
              return;
            }
            var newChildLanes = NoLanes;
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                if (shouldBubbleActualDurations) {
                  actualDuration += child.actualDuration;
                }
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
              if (isTimedOutSuspense) {
                var primaryChildFragment = completedWork.child;
                if (primaryChildFragment !== null) {
                  treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                }
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                _child = _child.sibling;
              }
            }
            completedWork.childLanes = newChildLanes;
          }
          function commitRoot(root2) {
            var renderPriorityLevel = getCurrentPriorityLevel();
            runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root2, renderPriorityLevel));
            return null;
          }
          function commitRootImpl(root2, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            if (finishedWork === null) {
              return null;
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (!(finishedWork !== root2.current)) {
              {
                throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            root2.callbackNode = null;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (rootsWithPendingDiscreteUpdates !== null) {
              if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root2)) {
                rootsWithPendingDiscreteUpdates.delete(root2);
              }
            }
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            var firstEffect;
            if (finishedWork.flags > PerformedWork) {
              if (finishedWork.lastEffect !== null) {
                finishedWork.lastEffect.nextEffect = finishedWork;
                firstEffect = finishedWork.firstEffect;
              } else {
                firstEffect = finishedWork;
              }
            } else {
              firstEffect = finishedWork.firstEffect;
            }
            if (firstEffect !== null) {
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              var prevInteractions = pushInteractions(root2);
              ReactCurrentOwner$2.current = null;
              focusedInstanceHandle = prepareForCommit(root2.containerInfo);
              shouldFireAfterActiveInstanceBlur = false;
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error3 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, error3);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              focusedInstanceHandle = null;
              {
                recordCommitTime();
              }
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitMutationEffects, null, root2, renderPriorityLevel);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitLayoutEffects, null, root2, lanes);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error2);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              nextEffect = null;
              requestPaint();
              {
                popInteractions(prevInteractions);
              }
              executionContext = prevExecutionContext;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
              pendingPassiveEffectsRenderPriority = renderPriorityLevel;
            } else {
              nextEffect = firstEffect;
              while (nextEffect !== null) {
                var nextNextEffect = nextEffect.nextEffect;
                nextEffect.nextEffect = null;
                if (nextEffect.flags & Deletion) {
                  detachFiberAfterEffects(nextEffect);
                }
                nextEffect = nextNextEffect;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes !== NoLanes) {
              {
                if (spawnedWorkDuringRender !== null) {
                  var expirationTimes = spawnedWorkDuringRender;
                  spawnedWorkDuringRender = null;
                  for (var i5 = 0; i5 < expirationTimes.length; i5++) {
                    scheduleInteractions(root2, expirationTimes[i5], root2.memoizedInteractions);
                  }
                }
                schedulePendingInteractions(root2, remainingLanes);
              }
            } else {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                finishPendingInteractions(root2, lanes);
              }
            }
            if (remainingLanes === SyncLane) {
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now());
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var _error3 = firstUncaughtError;
              firstUncaughtError = null;
              throw _error3;
            }
            if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
              return null;
            }
            flushSyncCallbackQueue();
            return null;
          }
          function commitBeforeMutationEffects() {
            while (nextEffect !== null) {
              var current2 = nextEffect.alternate;
              if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
                if ((nextEffect.flags & Deletion) !== NoFlags) {
                  if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
                    shouldFireAfterActiveInstanceBlur = true;
                  }
                } else {
                  if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current2, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
                    shouldFireAfterActiveInstanceBlur = true;
                  }
                }
              }
              var flags = nextEffect.flags;
              if ((flags & Snapshot) !== NoFlags) {
                setCurrentFiber(nextEffect);
                commitBeforeMutationLifeCycles(current2, nextEffect);
                resetCurrentFiber();
              }
              if ((flags & Passive) !== NoFlags) {
                if (!rootDoesHavePassiveEffects) {
                  rootDoesHavePassiveEffects = true;
                  scheduleCallback(NormalPriority$1, function() {
                    flushPassiveEffects();
                    return null;
                  });
                }
              }
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitMutationEffects(root2, renderPriorityLevel) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var flags = nextEffect.flags;
              if (flags & ContentReset) {
                commitResetTextContent(nextEffect);
              }
              if (flags & Ref) {
                var current2 = nextEffect.alternate;
                if (current2 !== null) {
                  commitDetachRef(current2);
                }
              }
              var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
              switch (primaryFlags) {
                case Placement: {
                  commitPlacement(nextEffect);
                  nextEffect.flags &= ~Placement;
                  break;
                }
                case PlacementAndUpdate: {
                  commitPlacement(nextEffect);
                  nextEffect.flags &= ~Placement;
                  var _current = nextEffect.alternate;
                  commitWork(_current, nextEffect);
                  break;
                }
                case Hydrating: {
                  nextEffect.flags &= ~Hydrating;
                  break;
                }
                case HydratingAndUpdate: {
                  nextEffect.flags &= ~Hydrating;
                  var _current2 = nextEffect.alternate;
                  commitWork(_current2, nextEffect);
                  break;
                }
                case Update: {
                  var _current3 = nextEffect.alternate;
                  commitWork(_current3, nextEffect);
                  break;
                }
                case Deletion: {
                  commitDeletion(root2, nextEffect);
                  break;
                }
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitLayoutEffects(root2, committedLanes) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var flags = nextEffect.flags;
              if (flags & (Update | Callback)) {
                var current2 = nextEffect.alternate;
                commitLifeCycles(root2, current2, nextEffect);
              }
              {
                if (flags & Ref) {
                  commitAttachRef(nextEffect);
                }
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function flushPassiveEffects() {
            if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
              var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
              pendingPassiveEffectsRenderPriority = NoPriority$1;
              {
                return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
              }
            }
            return false;
          }
          function enqueuePendingPassiveHookEffectMount(fiber, effect) {
            pendingPassiveHookEffectsMount.push(effect, fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
            pendingPassiveHookEffectsUnmount.push(effect, fiber);
            {
              fiber.flags |= PassiveUnmountPendingDev;
              var alternate = fiber.alternate;
              if (alternate !== null) {
                alternate.flags |= PassiveUnmountPendingDev;
              }
            }
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          function invokePassiveEffectCreate(effect) {
            var create3 = effect.create;
            effect.destroy = create3();
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Cannot flush passive effects while already rendering.");
              }
            }
            {
              isFlushingPassiveEffects = true;
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root2);
            var unmountEffects = pendingPassiveHookEffectsUnmount;
            pendingPassiveHookEffectsUnmount = [];
            for (var i5 = 0; i5 < unmountEffects.length; i5 += 2) {
              var _effect = unmountEffects[i5];
              var fiber = unmountEffects[i5 + 1];
              var destroy = _effect.destroy;
              _effect.destroy = void 0;
              {
                fiber.flags &= ~PassiveUnmountPendingDev;
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.flags &= ~PassiveUnmountPendingDev;
                }
              }
              if (typeof destroy === "function") {
                {
                  setCurrentFiber(fiber);
                  {
                    invokeGuardedCallback(null, destroy, null);
                  }
                  if (hasCaughtError()) {
                    if (!(fiber !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error3 = clearCaughtError();
                    captureCommitPhaseError(fiber, error3);
                  }
                  resetCurrentFiber();
                }
              }
            }
            var mountEffects = pendingPassiveHookEffectsMount;
            pendingPassiveHookEffectsMount = [];
            for (var _i = 0; _i < mountEffects.length; _i += 2) {
              var _effect2 = mountEffects[_i];
              var _fiber = mountEffects[_i + 1];
              {
                setCurrentFiber(_fiber);
                {
                  invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
                }
                if (hasCaughtError()) {
                  if (!(_fiber !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var _error4 = clearCaughtError();
                  captureCommitPhaseError(_fiber, _error4);
                }
                resetCurrentFiber();
              }
            }
            var effect = root2.current.firstEffect;
            while (effect !== null) {
              var nextNextEffect = effect.nextEffect;
              effect.nextEffect = null;
              if (effect.flags & Deletion) {
                detachFiberAfterEffects(effect);
              }
              effect = nextNextEffect;
            }
            {
              popInteractions(prevInteractions);
              finishPendingInteractions(root2, lanes);
            }
            {
              isFlushingPassiveEffects = false;
            }
            executionContext = prevExecutionContext;
            flushSyncCallbackQueue();
            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error3) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error3;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
            var errorInfo = createCapturedValue(error3, sourceFiber);
            var update3 = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            enqueueUpdate(rootFiber, update3);
            var eventTime = requestEventTime();
            var root2 = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, SyncLane);
            }
          }
          function captureCommitPhaseError(sourceFiber, error3) {
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error3);
              return;
            }
            var fiber = sourceFiber.return;
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error3);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValue(error3, sourceFiber);
                  var update3 = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  enqueueUpdate(fiber, update3);
                  var eventTime = requestEventTime();
                  var root2 = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                    schedulePendingInteractions(root2, SyncLane);
                  } else {
                    if (typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                      try {
                        instance.componentDidCatch(error3, errorInfo);
                      } catch (errorToIgnore) {
                      }
                    }
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, pingedLanes);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, retryLane);
            }
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            {
              retryCache = boundaryFiber.stateNode;
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              {
                {
                  throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
                }
              }
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef2 && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block3) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var didWarnStateUpdateForUnmountedComponent = null;
          function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
            {
              var tag = fiber.tag;
              if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef2 && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block3) {
                return;
              }
              if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForUnmountedComponent !== null) {
                if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForUnmountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForUnmountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              if (isFlushingPassiveEffects)
                ;
              else {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? "the componentWillUnmount method" : "a useEffect cleanup function");
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  throw replayError;
                } else {
                  throw originalError;
                }
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef2:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentName(fiber.type) || "Unknown";
                      error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          var IsThisRendererActing = {
            current: false
          };
          function warnIfNotScopedWithMatchingAct(fiber) {
            {
              if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
            {
              if ((fiber.mode & StrictMode2) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                error2("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
              }
            }
          }
          function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
            {
              if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;
          var didWarnAboutUnmockedScheduler = false;
          function warnIfUnmockedScheduler(fiber) {
            {
              if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === void 0) {
                if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                  didWarnAboutUnmockedScheduler = true;
                  error2(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: 
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://reactjs.org/link/mock-scheduler`);
                }
              }
            }
          }
          function computeThreadID(root2, lane) {
            return lane * 1e3 + root2.interactionThreadID;
          }
          function markSpawnedWork(lane) {
            if (spawnedWorkDuringRender === null) {
              spawnedWorkDuringRender = [lane];
            } else {
              spawnedWorkDuringRender.push(lane);
            }
          }
          function scheduleInteractions(root2, lane, interactions) {
            if (interactions.size > 0) {
              var pendingInteractionMap = root2.pendingInteractionMap;
              var pendingInteractions = pendingInteractionMap.get(lane);
              if (pendingInteractions != null) {
                interactions.forEach(function(interaction) {
                  if (!pendingInteractions.has(interaction)) {
                    interaction.__count++;
                  }
                  pendingInteractions.add(interaction);
                });
              } else {
                pendingInteractionMap.set(lane, new Set(interactions));
                interactions.forEach(function(interaction) {
                  interaction.__count++;
                });
              }
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root2, lane);
                subscriber.onWorkScheduled(interactions, threadID);
              }
            }
          }
          function schedulePendingInteractions(root2, lane) {
            scheduleInteractions(root2, lane, tracing.__interactionsRef.current);
          }
          function startWorkOnPendingInteractions(root2, lanes) {
            var interactions = /* @__PURE__ */ new Set();
            root2.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
              if (includesSomeLane(lanes, scheduledLane)) {
                scheduledInteractions.forEach(function(interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root2.memoizedInteractions = interactions;
            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root2, lanes);
                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error3) {
                  scheduleCallback(ImmediatePriority$1, function() {
                    throw error3;
                  });
                }
              }
            }
          }
          function finishPendingInteractions(root2, committedLanes) {
            var remainingLanesAfterCommit = root2.pendingLanes;
            var subscriber;
            try {
              subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null && root2.memoizedInteractions.size > 0) {
                var threadID = computeThreadID(root2, committedLanes);
                subscriber.onWorkStopped(root2.memoizedInteractions, threadID);
              }
            } catch (error3) {
              scheduleCallback(ImmediatePriority$1, function() {
                throw error3;
              });
            } finally {
              var pendingInteractionMap = root2.pendingInteractionMap;
              pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
                if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
                  pendingInteractionMap.delete(lane);
                  scheduledInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      try {
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                      } catch (error3) {
                        scheduleCallback(ImmediatePriority$1, function() {
                          throw error3;
                        });
                      }
                    }
                  });
                }
              });
            }
          }
          function shouldForceFlushFallbacksInDEV() {
            return actingUpdatesScopeDepth > 0;
          }
          var actingUpdatesScopeDepth = 0;
          function detachFiberAfterEffects(fiber) {
            fiber.sibling = null;
            fiber.stateNode = null;
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef2: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update3) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update3.staleFamilies, updatedFamilies = update3.updatedFamilies;
              flushPassiveEffects();
              flushSync3(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync3(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef2:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types2 = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef2:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types2.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e4) {
              hasBadMapPolyfill = true;
            }
          }
          var debugCounter = 1;
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.nextEffect = null;
            this.firstEffect = null;
            this.lastEffect = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugID = debugCounter++;
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component2) {
            if (typeof Component2 === "function") {
              return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
            } else if (Component2 !== void 0 && Component2 !== null) {
              var $$typeof = Component2.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef2;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugID = current2._debugID;
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.nextEffect = null;
              workInProgress2.firstEffect = null;
              workInProgress2.lastEffect = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef2:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= Placement;
            workInProgress2.nextEffect = null;
            workInProgress2.firstEffect = null;
            workInProgress2.lastEffect = null;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode | BlockingMode | StrictMode2;
            } else if (tag === BlockingRoot) {
              mode = BlockingMode | StrictMode2;
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= DebugTracingMode;
                    break;
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictMode2;
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                    return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
                  case REACT_SCOPE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef2;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                        case REACT_BLOCK_TYPE:
                          fiberTag = Block3;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentName(owner.type) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    {
                      {
                        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
                      }
                    }
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment3, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error2('Profiler must specify an "id" as a prop');
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.type = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.type = REACT_SUSPENSE_TYPE;
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_SUSPENSE_LIST_TYPE;
            }
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_OFFSCREEN_TYPE;
            }
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
            var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_LEGACY_HIDDEN_TYPE;
            }
            fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            fiber.type = "DELETED";
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.nextEffect = source.nextEffect;
            target.firstEffect = source.firstEffect;
            target.lastEffect = source.lastEffect;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugID = source._debugID;
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate3) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.hydrate = hydrate3;
            this.callbackNode = null;
            this.callbackPriority = NoLanePriority;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.interactionThreadID = tracing.unstable_getThreadID();
              this.memoizedInteractions = /* @__PURE__ */ new Set();
              this.pendingInteractionMap = /* @__PURE__ */ new Map();
            }
            {
              switch (tag) {
                case BlockingRoot:
                  this._debugRootType = "createBlockingRoot()";
                  break;
                case ConcurrentRoot:
                  this._debugRootType = "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = "createLegacyRoot()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate3, hydrationCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate3);
            var uninitializedFiber = createHostRootFiber(tag);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion2 = mutableSource._getVersion;
            var version = getVersion2(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
          }
          function createPortal2(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get11(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component2 = fiber.type;
              if (isContextProvider(Component2)) {
                return processChildContext(fiber, Component2, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get11(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  {
                    {
                      throw Error("Unable to find node on an unmounted component.");
                    }
                  }
                } else {
                  {
                    {
                      throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
                    }
                  }
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictMode2) {
                var componentName = getComponentName(fiber.type) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictMode2) {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrate3, hydrationCallbacks) {
            return createFiberRoot(containerInfo, tag, hydrate3);
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            {
              if ("undefined" !== typeof jest) {
                warnIfUnmockedScheduler(current$1);
                warnIfNotScopedWithMatchingAct(current$1);
              }
            }
            var lane = requestUpdateLane(current$1);
            var context2 = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context2;
            } else {
              container.pendingContext = context2;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current.type) || "Unknown");
              }
            }
            var update3 = createUpdate2(eventTime, lane);
            update3.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update3.callback = callback;
            }
            enqueueUpdate(current$1, update3);
            scheduleUpdateOnFiber(current$1, lane, eventTime);
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptUserBlockingHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = InputDiscreteHydrationLane;
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = SelectiveHydrationLane;
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function runWithPriority$2(priority2, fn) {
            try {
              setCurrentUpdateLanePriority(priority2);
              return fn();
            } finally {
            }
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.tag === FundamentalComponent) {
              return hostFiber.stateNode.instance;
            }
            return hostFiber.stateNode;
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index3) {
              var key = path[index3];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              if (index3 + 1 === path.length) {
                if (Array.isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index3 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
              var oldKey = oldPath[index3];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              if (index3 + 1 === oldPath.length) {
                var newKey = newPath[index3];
                updated[newKey] = updated[oldKey];
                if (Array.isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index3 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn2("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i5 = 0; i5 < newPath.length - 1; i5++) {
                  if (oldPath[i5] !== newPath[i5]) {
                    warn2("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index3, value) {
              if (index3 >= path.length) {
                return value;
              }
              var key = path[index3];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index3 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id2) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id2 > 0) {
                currentHook2 = currentHook2.next;
                id2--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id2, path, value) {
              var hook = findHook(fiber, id2);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideHookStateDeletePath = function(fiber, id2, path) {
              var hook = findHook(fiber, id2);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideHookStateRenamePath = function(fiber, id2, oldPath, newPath) {
              var hook = findHook(fiber, id2);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            scheduleUpdate = function(fiber) {
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: getCurrentFiberForDevTools
            });
          }
          function ReactDOMRoot(container, options2) {
            this._internalRoot = createRootImpl(container, ConcurrentRoot, options2);
          }
          function ReactDOMBlockingRoot(container, tag, options2) {
            this._internalRoot = createRootImpl(container, tag, options2);
          }
          ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            {
              if (typeof arguments[1] === "function") {
                error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
              var container = root2.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root2.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root2, null, null);
          };
          ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root2 = this._internalRoot;
            var container = root2.containerInfo;
            updateContainer(null, root2, null, function() {
              unmarkContainerAsRoot(container);
            });
          };
          function createRootImpl(container, tag, options2) {
            var hydrate3 = options2 != null && options2.hydrate === true;
            var hydrationCallbacks = options2 != null && options2.hydrationOptions || null;
            var mutableSources = options2 != null && options2.hydrationOptions != null && options2.hydrationOptions.mutableSources || null;
            var root2 = createContainer(container, tag, hydrate3);
            markContainerAsRoot(root2.current, container);
            var containerNodeType = container.nodeType;
            {
              var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(rootContainerElement);
            }
            if (mutableSources) {
              for (var i5 = 0; i5 < mutableSources.length; i5++) {
                var mutableSource = mutableSources[i5];
                registerMutableSourceForHydration(root2, mutableSource);
              }
            }
            return root2;
          }
          function createLegacyRoot(container, options2) {
            return new ReactDOMBlockingRoot(container, LegacyRoot, options2);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          var warnedAboutHydrateAPI = false;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function shouldHydrateDueToLegacyHeuristic(container) {
            var rootElement = getReactRootElementInContainer(container);
            return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
          }
          function legacyCreateRootFromDOMContainer(container, forceHydrate) {
            var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
            if (!shouldHydrate) {
              var warned2 = false;
              var rootSibling;
              while (rootSibling = container.lastChild) {
                {
                  if (!warned2 && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                    warned2 = true;
                    error2("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
                  }
                }
                container.removeChild(rootSibling);
              }
            }
            {
              if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
                warnedAboutHydrateAPI = true;
                warn2("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.");
              }
            }
            return createLegacyRoot(container, shouldHydrate ? {
              hydrate: true
            } : void 0);
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var root2 = container._reactRootContainer;
            var fiberRoot;
            if (!root2) {
              root2 = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
              fiberRoot = root2._internalRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(fiberRoot);
                  originalCallback.call(instance);
                };
              }
              unbatchedUpdates(function() {
                updateContainer(children, fiberRoot, parentComponent, callback);
              });
            } else {
              fiberRoot = root2._internalRoot;
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(fiberRoot);
                  _originalCallback.call(instance);
                };
              }
              updateContainer(children, fiberRoot, parentComponent, callback);
            }
            return getPublicRootInstance(fiberRoot);
          }
          function findDOMNode2(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate2(element, container, callback) {
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render2(element, container, callback) {
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            if (!isValidContainer(containerNode)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            if (!(parentComponent != null && has(parentComponent))) {
              {
                throw Error("parentComponent must be a valid React Component");
              }
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode2(container) {
            if (!isValidContainer(container)) {
              {
                throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              unbatchedUpdates(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setAttemptHydrationAtPriority(runWithPriority$2);
          var didWarnAboutUnstableCreatePortal = false;
          {
            if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
          function createPortal$1(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            return createPortal2(children, container, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          function unstable_createPortal(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            {
              if (!didWarnAboutUnstableCreatePortal) {
                didWarnAboutUnstableCreatePortal = true;
                warn2('The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.');
              }
            }
            return createPortal$1(children, container, key);
          }
          var Internals = {
            Events: [
              getInstanceFromNode,
              getNodeFromInstance,
              getFiberCurrentPropsFromNode,
              enqueueStateRestore,
              restoreStateIfNeeded,
              flushPassiveEffects,
              IsThisRendererActing
            ]
          };
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM2 && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.findDOMNode = findDOMNode2;
          exports.flushSync = flushSync3;
          exports.hydrate = hydrate2;
          exports.render = render2;
          exports.unmountComponentAtNode = unmountComponentAtNode2;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_createPortal = unstable_createPortal;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/memize/index.js
  var require_memize = __commonJS({
    "node_modules/memize/index.js"(exports, module) {
      function memize2(fn, options) {
        var size = 0;
        var head;
        var tail;
        options = options || {};
        function memoized() {
          var node = head, len = arguments.length, args, i5;
          searchCache:
            while (node) {
              if (node.args.length !== arguments.length) {
                node = node.next;
                continue;
              }
              for (i5 = 0; i5 < len; i5++) {
                if (node.args[i5] !== arguments[i5]) {
                  node = node.next;
                  continue searchCache;
                }
              }
              if (node !== head) {
                if (node === tail) {
                  tail = node.prev;
                }
                node.prev.next = node.next;
                if (node.next) {
                  node.next.prev = node.prev;
                }
                node.next = head;
                node.prev = null;
                head.prev = node;
                head = node;
              }
              return node.val;
            }
          args = new Array(len);
          for (i5 = 0; i5 < len; i5++) {
            args[i5] = arguments[i5];
          }
          node = {
            args,
            val: fn.apply(null, args)
          };
          if (head) {
            head.prev = node;
            node.next = head;
          } else {
            tail = node;
          }
          if (size === options.maxSize) {
            tail = tail.prev;
            tail.next = null;
          } else {
            size++;
          }
          head = node;
          return node.val;
        }
        memoized.clear = function() {
          head = null;
          tail = null;
          size = 0;
        };
        if (false) {
          memoized.getCache = function() {
            return [head, tail, size];
          };
        }
        return memoized;
      }
      module.exports = memize2;
    }
  });

  // node_modules/sprintf-js/src/sprintf.js
  var require_sprintf = __commonJS({
    "node_modules/sprintf-js/src/sprintf.js"(exports) {
      !function() {
        "use strict";
        var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/
        };
        function sprintf2(key) {
          return sprintf_format(sprintf_parse(key), arguments);
        }
        function vsprintf(fmt, argv) {
          return sprintf2.apply(null, [fmt].concat(argv || []));
        }
        function sprintf_format(parse_tree, argv) {
          var cursor = 1, tree_length = parse_tree.length, arg, output3 = "", i5, k3, ph, pad, pad_character, pad_length, is_positive, sign;
          for (i5 = 0; i5 < tree_length; i5++) {
            if (typeof parse_tree[i5] === "string") {
              output3 += parse_tree[i5];
            } else if (typeof parse_tree[i5] === "object") {
              ph = parse_tree[i5];
              if (ph.keys) {
                arg = argv[cursor];
                for (k3 = 0; k3 < ph.keys.length; k3++) {
                  if (arg == void 0) {
                    throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k3], ph.keys[k3 - 1]));
                  }
                  arg = arg[ph.keys[k3]];
                }
              } else if (ph.param_no) {
                arg = argv[ph.param_no];
              } else {
                arg = argv[cursor++];
              }
              if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                arg = arg();
              }
              if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
                throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
              }
              if (re.number.test(ph.type)) {
                is_positive = arg >= 0;
              }
              switch (ph.type) {
                case "b":
                  arg = parseInt(arg, 10).toString(2);
                  break;
                case "c":
                  arg = String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                case "i":
                  arg = parseInt(arg, 10);
                  break;
                case "j":
                  arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                  break;
                case "e":
                  arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                  break;
                case "f":
                  arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                  break;
                case "g":
                  arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                  break;
                case "o":
                  arg = (parseInt(arg, 10) >>> 0).toString(8);
                  break;
                case "s":
                  arg = String(arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "t":
                  arg = String(!!arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "T":
                  arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "u":
                  arg = parseInt(arg, 10) >>> 0;
                  break;
                case "v":
                  arg = arg.valueOf();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "x":
                  arg = (parseInt(arg, 10) >>> 0).toString(16);
                  break;
                case "X":
                  arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                  break;
              }
              if (re.json.test(ph.type)) {
                output3 += arg;
              } else {
                if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                  sign = is_positive ? "+" : "-";
                  arg = arg.toString().replace(re.sign, "");
                } else {
                  sign = "";
                }
                pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
                pad_length = ph.width - (sign + arg).length;
                pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
                output3 += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
              }
            }
          }
          return output3;
        }
        var sprintf_cache = /* @__PURE__ */ Object.create(null);
        function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
          }
          var _fmt = fmt, match, parse_tree = [], arg_names = 0;
          while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
              parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
              parse_tree.push("%");
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
              if (match[2]) {
                arg_names |= 1;
                var field_list = [], replacement_field = match[2], field_match = [];
                if ((field_match = re.key.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                  while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                    } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                    } else {
                      throw new SyntaxError("[sprintf] failed to parse named argument key");
                    }
                  }
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
                match[2] = field_list;
              } else {
                arg_names |= 2;
              }
              if (arg_names === 3) {
                throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
              }
              parse_tree.push(
                {
                  placeholder: match[0],
                  param_no: match[1],
                  keys: match[2],
                  sign: match[3],
                  pad_char: match[4],
                  align: match[5],
                  width: match[6],
                  precision: match[7],
                  type: match[8]
                }
              );
            } else {
              throw new SyntaxError("[sprintf] unexpected placeholder");
            }
            _fmt = _fmt.substring(match[0].length);
          }
          return sprintf_cache[fmt] = parse_tree;
        }
        if (typeof exports !== "undefined") {
          exports["sprintf"] = sprintf2;
          exports["vsprintf"] = vsprintf;
        }
        if (typeof window !== "undefined") {
          window["sprintf"] = sprintf2;
          window["vsprintf"] = vsprintf;
          if (typeof define === "function" && define["amd"]) {
            define(function() {
              return {
                "sprintf": sprintf2,
                "vsprintf": vsprintf
              };
            });
          }
        }
      }();
    }
  });

  // node_modules/clipboard/dist/clipboard.js
  var require_clipboard = __commonJS({
    "node_modules/clipboard/dist/clipboard.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["ClipboardJS"] = factory();
        else
          root["ClipboardJS"] = factory();
      })(exports, function() {
        return function() {
          var __webpack_modules__ = {
            686: function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
              "use strict";
              __webpack_require__2.d(__webpack_exports__, {
                "default": function() {
                  return clipboard;
                }
              });
              var tiny_emitter = __webpack_require__2(279);
              var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
              var listen = __webpack_require__2(370);
              var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
              var src_select = __webpack_require__2(817);
              var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
              ;
              function command(type) {
                try {
                  return document.execCommand(type);
                } catch (err) {
                  return false;
                }
              }
              ;
              var ClipboardActionCut = function ClipboardActionCut2(target) {
                var selectedText = select_default()(target);
                command("cut");
                return selectedText;
              };
              var actions_cut = ClipboardActionCut;
              ;
              function createFakeElement(value) {
                var isRTL3 = document.documentElement.getAttribute("dir") === "rtl";
                var fakeElement = document.createElement("textarea");
                fakeElement.style.fontSize = "12pt";
                fakeElement.style.border = "0";
                fakeElement.style.padding = "0";
                fakeElement.style.margin = "0";
                fakeElement.style.position = "absolute";
                fakeElement.style[isRTL3 ? "right" : "left"] = "-9999px";
                var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                fakeElement.style.top = "".concat(yPosition, "px");
                fakeElement.setAttribute("readonly", "");
                fakeElement.value = value;
                return fakeElement;
              }
              ;
              var fakeCopyAction = function fakeCopyAction2(value, options) {
                var fakeElement = createFakeElement(value);
                options.container.appendChild(fakeElement);
                var selectedText = select_default()(fakeElement);
                command("copy");
                fakeElement.remove();
                return selectedText;
              };
              var ClipboardActionCopy = function ClipboardActionCopy2(target) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                  container: document.body
                };
                var selectedText = "";
                if (typeof target === "string") {
                  selectedText = fakeCopyAction(target, options);
                } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
                  selectedText = fakeCopyAction(target.value, options);
                } else {
                  selectedText = select_default()(target);
                  command("copy");
                }
                return selectedText;
              };
              var actions_copy = ClipboardActionCopy;
              ;
              function _typeof(obj) {
                "@babel/helpers - typeof";
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                  _typeof = function _typeof2(obj2) {
                    return typeof obj2;
                  };
                } else {
                  _typeof = function _typeof2(obj2) {
                    return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                  };
                }
                return _typeof(obj);
              }
              var ClipboardActionDefault = function ClipboardActionDefault2() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text3 = options.text;
                if (action !== "copy" && action !== "cut") {
                  throw new Error('Invalid "action" value, use either "copy" or "cut"');
                }
                if (target !== void 0) {
                  if (target && _typeof(target) === "object" && target.nodeType === 1) {
                    if (action === "copy" && target.hasAttribute("disabled")) {
                      throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                    }
                    if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                      throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                    }
                  } else {
                    throw new Error('Invalid "target" value, use a valid Element');
                  }
                }
                if (text3) {
                  return actions_copy(text3, {
                    container
                  });
                }
                if (target) {
                  return action === "cut" ? actions_cut(target) : actions_copy(target, {
                    container
                  });
                }
              };
              var actions_default = ClipboardActionDefault;
              ;
              function clipboard_typeof(obj) {
                "@babel/helpers - typeof";
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                  clipboard_typeof = function _typeof2(obj2) {
                    return typeof obj2;
                  };
                } else {
                  clipboard_typeof = function _typeof2(obj2) {
                    return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                  };
                }
                return clipboard_typeof(obj);
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _defineProperties(target, props) {
                for (var i5 = 0; i5 < props.length; i5++) {
                  var descriptor = props[i5];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                if (superClass)
                  _setPrototypeOf(subClass, superClass);
              }
              function _setPrototypeOf(o6, p5) {
                _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o7, p6) {
                  o7.__proto__ = p6;
                  return o7;
                };
                return _setPrototypeOf(o6, p5);
              }
              function _createSuper(Derived) {
                var hasNativeReflectConstruct = _isNativeReflectConstruct();
                return function _createSuperInternal() {
                  var Super = _getPrototypeOf(Derived), result;
                  if (hasNativeReflectConstruct) {
                    var NewTarget = _getPrototypeOf(this).constructor;
                    result = Reflect.construct(Super, arguments, NewTarget);
                  } else {
                    result = Super.apply(this, arguments);
                  }
                  return _possibleConstructorReturn(this, result);
                };
              }
              function _possibleConstructorReturn(self2, call3) {
                if (call3 && (clipboard_typeof(call3) === "object" || typeof call3 === "function")) {
                  return call3;
                }
                return _assertThisInitialized(self2);
              }
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                  return false;
                if (Reflect.construct.sham)
                  return false;
                if (typeof Proxy === "function")
                  return true;
                try {
                  Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                  }));
                  return true;
                } catch (e4) {
                  return false;
                }
              }
              function _getPrototypeOf(o6) {
                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o7) {
                  return o7.__proto__ || Object.getPrototypeOf(o7);
                };
                return _getPrototypeOf(o6);
              }
              function getAttributeValue(suffix, element) {
                var attribute = "data-clipboard-".concat(suffix);
                if (!element.hasAttribute(attribute)) {
                  return;
                }
                return element.getAttribute(attribute);
              }
              var Clipboard2 = /* @__PURE__ */ function(_Emitter) {
                _inherits(Clipboard3, _Emitter);
                var _super = _createSuper(Clipboard3);
                function Clipboard3(trigger, options) {
                  var _this;
                  _classCallCheck(this, Clipboard3);
                  _this = _super.call(this);
                  _this.resolveOptions(options);
                  _this.listenClick(trigger);
                  return _this;
                }
                _createClass(Clipboard3, [{
                  key: "resolveOptions",
                  value: function resolveOptions() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                    this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                    this.text = typeof options.text === "function" ? options.text : this.defaultText;
                    this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
                  }
                }, {
                  key: "listenClick",
                  value: function listenClick(trigger) {
                    var _this2 = this;
                    this.listener = listen_default()(trigger, "click", function(e4) {
                      return _this2.onClick(e4);
                    });
                  }
                }, {
                  key: "onClick",
                  value: function onClick(e4) {
                    var trigger = e4.delegateTarget || e4.currentTarget;
                    var action = this.action(trigger) || "copy";
                    var text3 = actions_default({
                      action,
                      container: this.container,
                      target: this.target(trigger),
                      text: this.text(trigger)
                    });
                    this.emit(text3 ? "success" : "error", {
                      action,
                      text: text3,
                      trigger,
                      clearSelection: function clearSelection() {
                        if (trigger) {
                          trigger.focus();
                        }
                        window.getSelection().removeAllRanges();
                      }
                    });
                  }
                }, {
                  key: "defaultAction",
                  value: function defaultAction(trigger) {
                    return getAttributeValue("action", trigger);
                  }
                }, {
                  key: "defaultTarget",
                  value: function defaultTarget(trigger) {
                    var selector4 = getAttributeValue("target", trigger);
                    if (selector4) {
                      return document.querySelector(selector4);
                    }
                  }
                }, {
                  key: "defaultText",
                  value: function defaultText(trigger) {
                    return getAttributeValue("text", trigger);
                  }
                }, {
                  key: "destroy",
                  value: function destroy() {
                    this.listener.destroy();
                  }
                }], [{
                  key: "copy",
                  value: function copy2(target) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                      container: document.body
                    };
                    return actions_copy(target, options);
                  }
                }, {
                  key: "cut",
                  value: function cut(target) {
                    return actions_cut(target);
                  }
                }, {
                  key: "isSupported",
                  value: function isSupported() {
                    var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                    var actions2 = typeof action === "string" ? [action] : action;
                    var support = !!document.queryCommandSupported;
                    actions2.forEach(function(action2) {
                      support = support && !!document.queryCommandSupported(action2);
                    });
                    return support;
                  }
                }]);
                return Clipboard3;
              }(tiny_emitter_default());
              var clipboard = Clipboard2;
            },
            828: function(module2) {
              var DOCUMENT_NODE_TYPE = 9;
              if (typeof Element !== "undefined" && !Element.prototype.matches) {
                var proto = Element.prototype;
                proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
              }
              function closest(element, selector4) {
                while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                  if (typeof element.matches === "function" && element.matches(selector4)) {
                    return element;
                  }
                  element = element.parentNode;
                }
              }
              module2.exports = closest;
            },
            438: function(module2, __unused_webpack_exports, __webpack_require__2) {
              var closest = __webpack_require__2(828);
              function _delegate(element, selector4, type, callback, useCapture) {
                var listenerFn = listener2.apply(this, arguments);
                element.addEventListener(type, listenerFn, useCapture);
                return {
                  destroy: function() {
                    element.removeEventListener(type, listenerFn, useCapture);
                  }
                };
              }
              function delegate(elements, selector4, type, callback, useCapture) {
                if (typeof elements.addEventListener === "function") {
                  return _delegate.apply(null, arguments);
                }
                if (typeof type === "function") {
                  return _delegate.bind(null, document).apply(null, arguments);
                }
                if (typeof elements === "string") {
                  elements = document.querySelectorAll(elements);
                }
                return Array.prototype.map.call(elements, function(element) {
                  return _delegate(element, selector4, type, callback, useCapture);
                });
              }
              function listener2(element, selector4, type, callback) {
                return function(e4) {
                  e4.delegateTarget = closest(e4.target, selector4);
                  if (e4.delegateTarget) {
                    callback.call(element, e4);
                  }
                };
              }
              module2.exports = delegate;
            },
            879: function(__unused_webpack_module, exports2) {
              exports2.node = function(value) {
                return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
              };
              exports2.nodeList = function(value) {
                var type = Object.prototype.toString.call(value);
                return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports2.node(value[0]));
              };
              exports2.string = function(value) {
                return typeof value === "string" || value instanceof String;
              };
              exports2.fn = function(value) {
                var type = Object.prototype.toString.call(value);
                return type === "[object Function]";
              };
            },
            370: function(module2, __unused_webpack_exports, __webpack_require__2) {
              var is2 = __webpack_require__2(879);
              var delegate = __webpack_require__2(438);
              function listen(target, type, callback) {
                if (!target && !type && !callback) {
                  throw new Error("Missing required arguments");
                }
                if (!is2.string(type)) {
                  throw new TypeError("Second argument must be a String");
                }
                if (!is2.fn(callback)) {
                  throw new TypeError("Third argument must be a Function");
                }
                if (is2.node(target)) {
                  return listenNode(target, type, callback);
                } else if (is2.nodeList(target)) {
                  return listenNodeList(target, type, callback);
                } else if (is2.string(target)) {
                  return listenSelector(target, type, callback);
                } else {
                  throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                }
              }
              function listenNode(node, type, callback) {
                node.addEventListener(type, callback);
                return {
                  destroy: function() {
                    node.removeEventListener(type, callback);
                  }
                };
              }
              function listenNodeList(nodeList, type, callback) {
                Array.prototype.forEach.call(nodeList, function(node) {
                  node.addEventListener(type, callback);
                });
                return {
                  destroy: function() {
                    Array.prototype.forEach.call(nodeList, function(node) {
                      node.removeEventListener(type, callback);
                    });
                  }
                };
              }
              function listenSelector(selector4, type, callback) {
                return delegate(document.body, selector4, type, callback);
              }
              module2.exports = listen;
            },
            817: function(module2) {
              function select2(element) {
                var selectedText;
                if (element.nodeName === "SELECT") {
                  element.focus();
                  selectedText = element.value;
                } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                  var isReadOnly = element.hasAttribute("readonly");
                  if (!isReadOnly) {
                    element.setAttribute("readonly", "");
                  }
                  element.select();
                  element.setSelectionRange(0, element.value.length);
                  if (!isReadOnly) {
                    element.removeAttribute("readonly");
                  }
                  selectedText = element.value;
                } else {
                  if (element.hasAttribute("contenteditable")) {
                    element.focus();
                  }
                  var selection2 = window.getSelection();
                  var range = document.createRange();
                  range.selectNodeContents(element);
                  selection2.removeAllRanges();
                  selection2.addRange(range);
                  selectedText = selection2.toString();
                }
                return selectedText;
              }
              module2.exports = select2;
            },
            279: function(module2) {
              function E3() {
              }
              E3.prototype = {
                on: function(name, callback, ctx2) {
                  var e4 = this.e || (this.e = {});
                  (e4[name] || (e4[name] = [])).push({
                    fn: callback,
                    ctx: ctx2
                  });
                  return this;
                },
                once: function(name, callback, ctx2) {
                  var self2 = this;
                  function listener2() {
                    self2.off(name, listener2);
                    callback.apply(ctx2, arguments);
                  }
                  ;
                  listener2._ = callback;
                  return this.on(name, listener2, ctx2);
                },
                emit: function(name) {
                  var data = [].slice.call(arguments, 1);
                  var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                  var i5 = 0;
                  var len = evtArr.length;
                  for (i5; i5 < len; i5++) {
                    evtArr[i5].fn.apply(evtArr[i5].ctx, data);
                  }
                  return this;
                },
                off: function(name, callback) {
                  var e4 = this.e || (this.e = {});
                  var evts = e4[name];
                  var liveEvents = [];
                  if (evts && callback) {
                    for (var i5 = 0, len = evts.length; i5 < len; i5++) {
                      if (evts[i5].fn !== callback && evts[i5].fn._ !== callback)
                        liveEvents.push(evts[i5]);
                    }
                  }
                  liveEvents.length ? e4[name] = liveEvents : delete e4[name];
                  return this;
                }
              };
              module2.exports = E3;
              module2.exports.TinyEmitter = E3;
            }
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            if (__webpack_module_cache__[moduleId]) {
              return __webpack_module_cache__[moduleId].exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              exports: {}
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          !function() {
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? function() {
                return module2["default"];
              } : function() {
                return module2;
              };
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop2) {
              return Object.prototype.hasOwnProperty.call(obj, prop2);
            };
          }();
          return __webpack_require__(686);
        }().default;
      });
    }
  });

  // node_modules/requestidlecallback/index.js
  var require_requestidlecallback = __commonJS({
    "node_modules/requestidlecallback/index.js"(exports, module) {
      (function(factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          window.idleCallbackShim = factory();
        }
      })(function() {
        "use strict";
        var scheduleStart, throttleDelay, lazytimer, lazyraf;
        var root = typeof window != "undefined" ? window : typeof global != void 0 ? global : this || {};
        var requestAnimationFrame2 = root.cancelRequestAnimationFrame && root.requestAnimationFrame || setTimeout;
        var cancelRequestAnimationFrame = root.cancelRequestAnimationFrame || clearTimeout;
        var tasks = [];
        var runAttempts = 0;
        var isRunning = false;
        var remainingTime = 7;
        var minThrottle = 35;
        var throttle2 = 125;
        var index2 = 0;
        var taskStart = 0;
        var tasklength = 0;
        var IdleDeadline = {
          get didTimeout() {
            return false;
          },
          timeRemaining: function() {
            var timeRemaining = remainingTime - (Date.now() - taskStart);
            return timeRemaining < 0 ? 0 : timeRemaining;
          }
        };
        var setInactive = debounce2(function() {
          remainingTime = 22;
          throttle2 = 66;
          minThrottle = 0;
        });
        function debounce2(fn) {
          var id2, timestamp;
          var wait = 99;
          var check2 = function() {
            var last = Date.now() - timestamp;
            if (last < wait) {
              id2 = setTimeout(check2, wait - last);
            } else {
              id2 = null;
              fn();
            }
          };
          return function() {
            timestamp = Date.now();
            if (!id2) {
              id2 = setTimeout(check2, wait);
            }
          };
        }
        function abortRunning() {
          if (isRunning) {
            if (lazyraf) {
              cancelRequestAnimationFrame(lazyraf);
            }
            if (lazytimer) {
              clearTimeout(lazytimer);
            }
            isRunning = false;
          }
        }
        function onInputorMutation() {
          if (throttle2 != 125) {
            remainingTime = 7;
            throttle2 = 125;
            minThrottle = 35;
            if (isRunning) {
              abortRunning();
              scheduleLazy();
            }
          }
          setInactive();
        }
        function scheduleAfterRaf() {
          lazyraf = null;
          lazytimer = setTimeout(runTasks, 0);
        }
        function scheduleRaf() {
          lazytimer = null;
          requestAnimationFrame2(scheduleAfterRaf);
        }
        function scheduleLazy() {
          if (isRunning) {
            return;
          }
          throttleDelay = throttle2 - (Date.now() - taskStart);
          scheduleStart = Date.now();
          isRunning = true;
          if (minThrottle && throttleDelay < minThrottle) {
            throttleDelay = minThrottle;
          }
          if (throttleDelay > 9) {
            lazytimer = setTimeout(scheduleRaf, throttleDelay);
          } else {
            throttleDelay = 0;
            scheduleRaf();
          }
        }
        function runTasks() {
          var task, i5, len;
          var timeThreshold = remainingTime > 9 ? 9 : 1;
          taskStart = Date.now();
          isRunning = false;
          lazytimer = null;
          if (runAttempts > 2 || taskStart - throttleDelay - 50 < scheduleStart) {
            for (i5 = 0, len = tasks.length; i5 < len && IdleDeadline.timeRemaining() > timeThreshold; i5++) {
              task = tasks.shift();
              tasklength++;
              if (task) {
                task(IdleDeadline);
              }
            }
          }
          if (tasks.length) {
            scheduleLazy();
          } else {
            runAttempts = 0;
          }
        }
        function requestIdleCallbackShim(task) {
          index2++;
          tasks.push(task);
          scheduleLazy();
          return index2;
        }
        function cancelIdleCallbackShim(id2) {
          var index3 = id2 - 1 - tasklength;
          if (tasks[index3]) {
            tasks[index3] = null;
          }
        }
        if (!root.requestIdleCallback || !root.cancelIdleCallback) {
          root.requestIdleCallback = requestIdleCallbackShim;
          root.cancelIdleCallback = cancelIdleCallbackShim;
          if (root.document && document.addEventListener) {
            root.addEventListener("scroll", onInputorMutation, true);
            root.addEventListener("resize", onInputorMutation);
            document.addEventListener("focus", onInputorMutation, true);
            document.addEventListener("mouseover", onInputorMutation, true);
            ["click", "keypress", "touchstart", "mousedown"].forEach(function(name) {
              document.addEventListener(name, onInputorMutation, { capture: true, passive: true });
            });
            if (root.MutationObserver) {
              new MutationObserver(onInputorMutation).observe(document.documentElement, { childList: true, subtree: true, attributes: true });
            }
          }
        } else {
          try {
            root.requestIdleCallback(function() {
            }, { timeout: 0 });
          } catch (e4) {
            (function(rIC) {
              var timeRemainingProto, timeRemaining;
              root.requestIdleCallback = function(fn, timeout) {
                if (timeout && typeof timeout.timeout == "number") {
                  return rIC(fn, timeout.timeout);
                }
                return rIC(fn);
              };
              if (root.IdleCallbackDeadline && (timeRemainingProto = IdleCallbackDeadline.prototype)) {
                timeRemaining = Object.getOwnPropertyDescriptor(timeRemainingProto, "timeRemaining");
                if (!timeRemaining || !timeRemaining.configurable || !timeRemaining.get) {
                  return;
                }
                Object.defineProperty(timeRemainingProto, "timeRemaining", {
                  value: function() {
                    return timeRemaining.get.call(this);
                  },
                  enumerable: true,
                  configurable: true
                });
              }
            })(root.requestIdleCallback);
          }
        }
        return {
          request: requestIdleCallbackShim,
          cancel: cancelIdleCallbackShim
        };
      });
    }
  });

  // node_modules/remove-accents/index.js
  var require_remove_accents = __commonJS({
    "node_modules/remove-accents/index.js"(exports, module) {
      var characterMap = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\u1EA4": "A",
        "\u1EAE": "A",
        "\u1EB2": "A",
        "\u1EB4": "A",
        "\u1EB6": "A",
        "\xC6": "AE",
        "\u1EA6": "A",
        "\u1EB0": "A",
        "\u0202": "A",
        "\xC7": "C",
        "\u1E08": "C",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\u1EBE": "E",
        "\u1E16": "E",
        "\u1EC0": "E",
        "\u1E14": "E",
        "\u1E1C": "E",
        "\u0206": "E",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\u1E2E": "I",
        "\u020A": "I",
        "\xD0": "D",
        "\xD1": "N",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\u1ED0": "O",
        "\u1E4C": "O",
        "\u1E52": "O",
        "\u020E": "O",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xDD": "Y",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\u1EA5": "a",
        "\u1EAF": "a",
        "\u1EB3": "a",
        "\u1EB5": "a",
        "\u1EB7": "a",
        "\xE6": "ae",
        "\u1EA7": "a",
        "\u1EB1": "a",
        "\u0203": "a",
        "\xE7": "c",
        "\u1E09": "c",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\u1EBF": "e",
        "\u1E17": "e",
        "\u1EC1": "e",
        "\u1E15": "e",
        "\u1E1D": "e",
        "\u0207": "e",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\u1E2F": "i",
        "\u020B": "i",
        "\xF0": "d",
        "\xF1": "n",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\u1ED1": "o",
        "\u1E4D": "o",
        "\u1E53": "o",
        "\u020F": "o",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xFD": "y",
        "\xFF": "y",
        "\u0100": "A",
        "\u0101": "a",
        "\u0102": "A",
        "\u0103": "a",
        "\u0104": "A",
        "\u0105": "a",
        "\u0106": "C",
        "\u0107": "c",
        "\u0108": "C",
        "\u0109": "c",
        "\u010A": "C",
        "\u010B": "c",
        "\u010C": "C",
        "\u010D": "c",
        "C\u0306": "C",
        "c\u0306": "c",
        "\u010E": "D",
        "\u010F": "d",
        "\u0110": "D",
        "\u0111": "d",
        "\u0112": "E",
        "\u0113": "e",
        "\u0114": "E",
        "\u0115": "e",
        "\u0116": "E",
        "\u0117": "e",
        "\u0118": "E",
        "\u0119": "e",
        "\u011A": "E",
        "\u011B": "e",
        "\u011C": "G",
        "\u01F4": "G",
        "\u011D": "g",
        "\u01F5": "g",
        "\u011E": "G",
        "\u011F": "g",
        "\u0120": "G",
        "\u0121": "g",
        "\u0122": "G",
        "\u0123": "g",
        "\u0124": "H",
        "\u0125": "h",
        "\u0126": "H",
        "\u0127": "h",
        "\u1E2A": "H",
        "\u1E2B": "h",
        "\u0128": "I",
        "\u0129": "i",
        "\u012A": "I",
        "\u012B": "i",
        "\u012C": "I",
        "\u012D": "i",
        "\u012E": "I",
        "\u012F": "i",
        "\u0130": "I",
        "\u0131": "i",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u1E30": "K",
        "\u1E31": "k",
        "K\u0306": "K",
        "k\u0306": "k",
        "\u0139": "L",
        "\u013A": "l",
        "\u013B": "L",
        "\u013C": "l",
        "\u013D": "L",
        "\u013E": "l",
        "\u013F": "L",
        "\u0140": "l",
        "\u0141": "l",
        "\u0142": "l",
        "\u1E3E": "M",
        "\u1E3F": "m",
        "M\u0306": "M",
        "m\u0306": "m",
        "\u0143": "N",
        "\u0144": "n",
        "\u0145": "N",
        "\u0146": "n",
        "\u0147": "N",
        "\u0148": "n",
        "\u0149": "n",
        "N\u0306": "N",
        "n\u0306": "n",
        "\u014C": "O",
        "\u014D": "o",
        "\u014E": "O",
        "\u014F": "o",
        "\u0150": "O",
        "\u0151": "o",
        "\u0152": "OE",
        "\u0153": "oe",
        "P\u0306": "P",
        "p\u0306": "p",
        "\u0154": "R",
        "\u0155": "r",
        "\u0156": "R",
        "\u0157": "r",
        "\u0158": "R",
        "\u0159": "r",
        "R\u0306": "R",
        "r\u0306": "r",
        "\u0212": "R",
        "\u0213": "r",
        "\u015A": "S",
        "\u015B": "s",
        "\u015C": "S",
        "\u015D": "s",
        "\u015E": "S",
        "\u0218": "S",
        "\u0219": "s",
        "\u015F": "s",
        "\u0160": "S",
        "\u0161": "s",
        "\u0162": "T",
        "\u0163": "t",
        "\u021B": "t",
        "\u021A": "T",
        "\u0164": "T",
        "\u0165": "t",
        "\u0166": "T",
        "\u0167": "t",
        "T\u0306": "T",
        "t\u0306": "t",
        "\u0168": "U",
        "\u0169": "u",
        "\u016A": "U",
        "\u016B": "u",
        "\u016C": "U",
        "\u016D": "u",
        "\u016E": "U",
        "\u016F": "u",
        "\u0170": "U",
        "\u0171": "u",
        "\u0172": "U",
        "\u0173": "u",
        "\u0216": "U",
        "\u0217": "u",
        "V\u0306": "V",
        "v\u0306": "v",
        "\u0174": "W",
        "\u0175": "w",
        "\u1E82": "W",
        "\u1E83": "w",
        "X\u0306": "X",
        "x\u0306": "x",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "Y\u0306": "Y",
        "y\u0306": "y",
        "\u0179": "Z",
        "\u017A": "z",
        "\u017B": "Z",
        "\u017C": "z",
        "\u017D": "Z",
        "\u017E": "z",
        "\u017F": "s",
        "\u0192": "f",
        "\u01A0": "O",
        "\u01A1": "o",
        "\u01AF": "U",
        "\u01B0": "u",
        "\u01CD": "A",
        "\u01CE": "a",
        "\u01CF": "I",
        "\u01D0": "i",
        "\u01D1": "O",
        "\u01D2": "o",
        "\u01D3": "U",
        "\u01D4": "u",
        "\u01D5": "U",
        "\u01D6": "u",
        "\u01D7": "U",
        "\u01D8": "u",
        "\u01D9": "U",
        "\u01DA": "u",
        "\u01DB": "U",
        "\u01DC": "u",
        "\u1EE8": "U",
        "\u1EE9": "u",
        "\u1E78": "U",
        "\u1E79": "u",
        "\u01FA": "A",
        "\u01FB": "a",
        "\u01FC": "AE",
        "\u01FD": "ae",
        "\u01FE": "O",
        "\u01FF": "o",
        "\xDE": "TH",
        "\xFE": "th",
        "\u1E54": "P",
        "\u1E55": "p",
        "\u1E64": "S",
        "\u1E65": "s",
        "X\u0301": "X",
        "x\u0301": "x",
        "\u0403": "\u0413",
        "\u0453": "\u0433",
        "\u040C": "\u041A",
        "\u045C": "\u043A",
        "A\u030B": "A",
        "a\u030B": "a",
        "E\u030B": "E",
        "e\u030B": "e",
        "I\u030B": "I",
        "i\u030B": "i",
        "\u01F8": "N",
        "\u01F9": "n",
        "\u1ED2": "O",
        "\u1ED3": "o",
        "\u1E50": "O",
        "\u1E51": "o",
        "\u1EEA": "U",
        "\u1EEB": "u",
        "\u1E80": "W",
        "\u1E81": "w",
        "\u1EF2": "Y",
        "\u1EF3": "y",
        "\u0200": "A",
        "\u0201": "a",
        "\u0204": "E",
        "\u0205": "e",
        "\u0208": "I",
        "\u0209": "i",
        "\u020C": "O",
        "\u020D": "o",
        "\u0210": "R",
        "\u0211": "r",
        "\u0214": "U",
        "\u0215": "u",
        "B\u030C": "B",
        "b\u030C": "b",
        "\u010C\u0323": "C",
        "\u010D\u0323": "c",
        "\xCA\u030C": "E",
        "\xEA\u030C": "e",
        "F\u030C": "F",
        "f\u030C": "f",
        "\u01E6": "G",
        "\u01E7": "g",
        "\u021E": "H",
        "\u021F": "h",
        "J\u030C": "J",
        "\u01F0": "j",
        "\u01E8": "K",
        "\u01E9": "k",
        "M\u030C": "M",
        "m\u030C": "m",
        "P\u030C": "P",
        "p\u030C": "p",
        "Q\u030C": "Q",
        "q\u030C": "q",
        "\u0158\u0329": "R",
        "\u0159\u0329": "r",
        "\u1E66": "S",
        "\u1E67": "s",
        "V\u030C": "V",
        "v\u030C": "v",
        "W\u030C": "W",
        "w\u030C": "w",
        "X\u030C": "X",
        "x\u030C": "x",
        "Y\u030C": "Y",
        "y\u030C": "y",
        "A\u0327": "A",
        "a\u0327": "a",
        "B\u0327": "B",
        "b\u0327": "b",
        "\u1E10": "D",
        "\u1E11": "d",
        "\u0228": "E",
        "\u0229": "e",
        "\u0190\u0327": "E",
        "\u025B\u0327": "e",
        "\u1E28": "H",
        "\u1E29": "h",
        "I\u0327": "I",
        "i\u0327": "i",
        "\u0197\u0327": "I",
        "\u0268\u0327": "i",
        "M\u0327": "M",
        "m\u0327": "m",
        "O\u0327": "O",
        "o\u0327": "o",
        "Q\u0327": "Q",
        "q\u0327": "q",
        "U\u0327": "U",
        "u\u0327": "u",
        "X\u0327": "X",
        "x\u0327": "x",
        "Z\u0327": "Z",
        "z\u0327": "z"
      };
      var chars = Object.keys(characterMap).join("|");
      var allAccents = new RegExp(chars, "g");
      var firstAccent = new RegExp(chars, "");
      function matcher3(match) {
        return characterMap[match];
      }
      var removeAccents3 = function(string2) {
        return string2.replace(allAccents, matcher3);
      };
      var hasAccents = function(string2) {
        return !!string2.match(firstAccent);
      };
      module.exports = removeAccents3;
      module.exports.has = hasAccents;
      module.exports.remove = removeAccents3;
    }
  });

  // node_modules/showdown/dist/showdown.js
  var require_showdown = __commonJS({
    "node_modules/showdown/dist/showdown.js"(exports, module) {
      (function() {
        function getDefaultOpts(simple) {
          "use strict";
          var defaultOptions2 = {
            omitExtraWLInCodeBlocks: {
              defaultValue: false,
              describe: "Omit the default extra whiteline added to code blocks",
              type: "boolean"
            },
            noHeaderId: {
              defaultValue: false,
              describe: "Turn on/off generated header id",
              type: "boolean"
            },
            prefixHeaderId: {
              defaultValue: false,
              describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
              type: "string"
            },
            rawPrefixHeaderId: {
              defaultValue: false,
              describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
              type: "boolean"
            },
            ghCompatibleHeaderId: {
              defaultValue: false,
              describe: "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
              type: "boolean"
            },
            rawHeaderId: {
              defaultValue: false,
              describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
              type: "boolean"
            },
            headerLevelStart: {
              defaultValue: false,
              describe: "The header blocks level start",
              type: "integer"
            },
            parseImgDimensions: {
              defaultValue: false,
              describe: "Turn on/off image dimension parsing",
              type: "boolean"
            },
            simplifiedAutoLink: {
              defaultValue: false,
              describe: "Turn on/off GFM autolink style",
              type: "boolean"
            },
            excludeTrailingPunctuationFromURLs: {
              defaultValue: false,
              describe: "Excludes trailing punctuation from links generated with autoLinking",
              type: "boolean"
            },
            literalMidWordUnderscores: {
              defaultValue: false,
              describe: "Parse midword underscores as literal underscores",
              type: "boolean"
            },
            literalMidWordAsterisks: {
              defaultValue: false,
              describe: "Parse midword asterisks as literal asterisks",
              type: "boolean"
            },
            strikethrough: {
              defaultValue: false,
              describe: "Turn on/off strikethrough support",
              type: "boolean"
            },
            tables: {
              defaultValue: false,
              describe: "Turn on/off tables support",
              type: "boolean"
            },
            tablesHeaderId: {
              defaultValue: false,
              describe: "Add an id to table headers",
              type: "boolean"
            },
            ghCodeBlocks: {
              defaultValue: true,
              describe: "Turn on/off GFM fenced code blocks support",
              type: "boolean"
            },
            tasklists: {
              defaultValue: false,
              describe: "Turn on/off GFM tasklist support",
              type: "boolean"
            },
            smoothLivePreview: {
              defaultValue: false,
              describe: "Prevents weird effects in live previews due to incomplete input",
              type: "boolean"
            },
            smartIndentationFix: {
              defaultValue: false,
              description: "Tries to smartly fix indentation in es6 strings",
              type: "boolean"
            },
            disableForced4SpacesIndentedSublists: {
              defaultValue: false,
              description: "Disables the requirement of indenting nested sublists by 4 spaces",
              type: "boolean"
            },
            simpleLineBreaks: {
              defaultValue: false,
              description: "Parses simple line breaks as <br> (GFM Style)",
              type: "boolean"
            },
            requireSpaceBeforeHeadingText: {
              defaultValue: false,
              description: "Makes adding a space between `#` and the header text mandatory (GFM Style)",
              type: "boolean"
            },
            ghMentions: {
              defaultValue: false,
              description: "Enables github @mentions",
              type: "boolean"
            },
            ghMentionsLink: {
              defaultValue: "https://github.com/{u}",
              description: "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
              type: "string"
            },
            encodeEmails: {
              defaultValue: true,
              description: "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
              type: "boolean"
            },
            openLinksInNewWindow: {
              defaultValue: false,
              description: "Open all links in new windows",
              type: "boolean"
            },
            backslashEscapesHTMLTags: {
              defaultValue: false,
              description: "Support for HTML Tag escaping. ex: <div>foo</div>",
              type: "boolean"
            },
            emoji: {
              defaultValue: false,
              description: "Enable emoji support. Ex: `this is a :smile: emoji`",
              type: "boolean"
            },
            underline: {
              defaultValue: false,
              description: "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
              type: "boolean"
            },
            completeHTMLDocument: {
              defaultValue: false,
              description: "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
              type: "boolean"
            },
            metadata: {
              defaultValue: false,
              description: "Enable support for document metadata (defined at the top of the document between `\xAB\xAB\xAB` and `\xBB\xBB\xBB` or between `---` and `---`).",
              type: "boolean"
            },
            splitAdjacentBlockquotes: {
              defaultValue: false,
              description: "Split adjacent blockquote blocks",
              type: "boolean"
            }
          };
          if (simple === false) {
            return JSON.parse(JSON.stringify(defaultOptions2));
          }
          var ret = {};
          for (var opt in defaultOptions2) {
            if (defaultOptions2.hasOwnProperty(opt)) {
              ret[opt] = defaultOptions2[opt].defaultValue;
            }
          }
          return ret;
        }
        function allOptionsOn() {
          "use strict";
          var options = getDefaultOpts(true), ret = {};
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              ret[opt] = true;
            }
          }
          return ret;
        }
        var showdown2 = {}, parsers = {}, extensions = {}, globalOptions = getDefaultOpts(true), setFlavor = "vanilla", flavor = {
          github: {
            omitExtraWLInCodeBlocks: true,
            simplifiedAutoLink: true,
            excludeTrailingPunctuationFromURLs: true,
            literalMidWordUnderscores: true,
            strikethrough: true,
            tables: true,
            tablesHeaderId: true,
            ghCodeBlocks: true,
            tasklists: true,
            disableForced4SpacesIndentedSublists: true,
            simpleLineBreaks: true,
            requireSpaceBeforeHeadingText: true,
            ghCompatibleHeaderId: true,
            ghMentions: true,
            backslashEscapesHTMLTags: true,
            emoji: true,
            splitAdjacentBlockquotes: true
          },
          original: {
            noHeaderId: true,
            ghCodeBlocks: false
          },
          ghost: {
            omitExtraWLInCodeBlocks: true,
            parseImgDimensions: true,
            simplifiedAutoLink: true,
            excludeTrailingPunctuationFromURLs: true,
            literalMidWordUnderscores: true,
            strikethrough: true,
            tables: true,
            tablesHeaderId: true,
            ghCodeBlocks: true,
            tasklists: true,
            smoothLivePreview: true,
            simpleLineBreaks: true,
            requireSpaceBeforeHeadingText: true,
            ghMentions: false,
            encodeEmails: true
          },
          vanilla: getDefaultOpts(true),
          allOn: allOptionsOn()
        };
        showdown2.helper = {};
        showdown2.extensions = {};
        showdown2.setOption = function(key, value) {
          "use strict";
          globalOptions[key] = value;
          return this;
        };
        showdown2.getOption = function(key) {
          "use strict";
          return globalOptions[key];
        };
        showdown2.getOptions = function() {
          "use strict";
          return globalOptions;
        };
        showdown2.resetOptions = function() {
          "use strict";
          globalOptions = getDefaultOpts(true);
        };
        showdown2.setFlavor = function(name) {
          "use strict";
          if (!flavor.hasOwnProperty(name)) {
            throw Error(name + " flavor was not found");
          }
          showdown2.resetOptions();
          var preset = flavor[name];
          setFlavor = name;
          for (var option in preset) {
            if (preset.hasOwnProperty(option)) {
              globalOptions[option] = preset[option];
            }
          }
        };
        showdown2.getFlavor = function() {
          "use strict";
          return setFlavor;
        };
        showdown2.getFlavorOptions = function(name) {
          "use strict";
          if (flavor.hasOwnProperty(name)) {
            return flavor[name];
          }
        };
        showdown2.getDefaultOptions = function(simple) {
          "use strict";
          return getDefaultOpts(simple);
        };
        showdown2.subParser = function(name, func) {
          "use strict";
          if (showdown2.helper.isString(name)) {
            if (typeof func !== "undefined") {
              parsers[name] = func;
            } else {
              if (parsers.hasOwnProperty(name)) {
                return parsers[name];
              } else {
                throw Error("SubParser named " + name + " not registered!");
              }
            }
          }
        };
        showdown2.extension = function(name, ext) {
          "use strict";
          if (!showdown2.helper.isString(name)) {
            throw Error("Extension 'name' must be a string");
          }
          name = showdown2.helper.stdExtName(name);
          if (showdown2.helper.isUndefined(ext)) {
            if (!extensions.hasOwnProperty(name)) {
              throw Error("Extension named " + name + " is not registered!");
            }
            return extensions[name];
          } else {
            if (typeof ext === "function") {
              ext = ext();
            }
            if (!showdown2.helper.isArray(ext)) {
              ext = [ext];
            }
            var validExtension = validate2(ext, name);
            if (validExtension.valid) {
              extensions[name] = ext;
            } else {
              throw Error(validExtension.error);
            }
          }
        };
        showdown2.getAllExtensions = function() {
          "use strict";
          return extensions;
        };
        showdown2.removeExtension = function(name) {
          "use strict";
          delete extensions[name];
        };
        showdown2.resetExtensions = function() {
          "use strict";
          extensions = {};
        };
        function validate2(extension, name) {
          "use strict";
          var errMsg = name ? "Error in " + name + " extension->" : "Error in unnamed extension", ret = {
            valid: true,
            error: ""
          };
          if (!showdown2.helper.isArray(extension)) {
            extension = [extension];
          }
          for (var i5 = 0; i5 < extension.length; ++i5) {
            var baseMsg = errMsg + " sub-extension " + i5 + ": ", ext = extension[i5];
            if (typeof ext !== "object") {
              ret.valid = false;
              ret.error = baseMsg + "must be an object, but " + typeof ext + " given";
              return ret;
            }
            if (!showdown2.helper.isString(ext.type)) {
              ret.valid = false;
              ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + " given";
              return ret;
            }
            var type = ext.type = ext.type.toLowerCase();
            if (type === "language") {
              type = ext.type = "lang";
            }
            if (type === "html") {
              type = ext.type = "output";
            }
            if (type !== "lang" && type !== "output" && type !== "listener") {
              ret.valid = false;
              ret.error = baseMsg + "type " + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
              return ret;
            }
            if (type === "listener") {
              if (showdown2.helper.isUndefined(ext.listeners)) {
                ret.valid = false;
                ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
                return ret;
              }
            } else {
              if (showdown2.helper.isUndefined(ext.filter) && showdown2.helper.isUndefined(ext.regex)) {
                ret.valid = false;
                ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
                return ret;
              }
            }
            if (ext.listeners) {
              if (typeof ext.listeners !== "object") {
                ret.valid = false;
                ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + " given";
                return ret;
              }
              for (var ln in ext.listeners) {
                if (ext.listeners.hasOwnProperty(ln)) {
                  if (typeof ext.listeners[ln] !== "function") {
                    ret.valid = false;
                    ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln + " must be a function but " + typeof ext.listeners[ln] + " given";
                    return ret;
                  }
                }
              }
            }
            if (ext.filter) {
              if (typeof ext.filter !== "function") {
                ret.valid = false;
                ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + " given";
                return ret;
              }
            } else if (ext.regex) {
              if (showdown2.helper.isString(ext.regex)) {
                ext.regex = new RegExp(ext.regex, "g");
              }
              if (!(ext.regex instanceof RegExp)) {
                ret.valid = false;
                ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + " given";
                return ret;
              }
              if (showdown2.helper.isUndefined(ext.replace)) {
                ret.valid = false;
                ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
                return ret;
              }
            }
          }
          return ret;
        }
        showdown2.validateExtension = function(ext) {
          "use strict";
          var validateExtension = validate2(ext, null);
          if (!validateExtension.valid) {
            console.warn(validateExtension.error);
            return false;
          }
          return true;
        };
        if (!showdown2.hasOwnProperty("helper")) {
          showdown2.helper = {};
        }
        showdown2.helper.isString = function(a6) {
          "use strict";
          return typeof a6 === "string" || a6 instanceof String;
        };
        showdown2.helper.isFunction = function(a6) {
          "use strict";
          var getType = {};
          return a6 && getType.toString.call(a6) === "[object Function]";
        };
        showdown2.helper.isArray = function(a6) {
          "use strict";
          return Array.isArray(a6);
        };
        showdown2.helper.isUndefined = function(value) {
          "use strict";
          return typeof value === "undefined";
        };
        showdown2.helper.forEach = function(obj, callback) {
          "use strict";
          if (showdown2.helper.isUndefined(obj)) {
            throw new Error("obj param is required");
          }
          if (showdown2.helper.isUndefined(callback)) {
            throw new Error("callback param is required");
          }
          if (!showdown2.helper.isFunction(callback)) {
            throw new Error("callback param must be a function/closure");
          }
          if (typeof obj.forEach === "function") {
            obj.forEach(callback);
          } else if (showdown2.helper.isArray(obj)) {
            for (var i5 = 0; i5 < obj.length; i5++) {
              callback(obj[i5], i5, obj);
            }
          } else if (typeof obj === "object") {
            for (var prop2 in obj) {
              if (obj.hasOwnProperty(prop2)) {
                callback(obj[prop2], prop2, obj);
              }
            }
          } else {
            throw new Error("obj does not seem to be an array or an iterable object");
          }
        };
        showdown2.helper.stdExtName = function(s5) {
          "use strict";
          return s5.replace(/[_?*+\/\\.^-]/g, "").replace(/\s/g, "").toLowerCase();
        };
        function escapeCharactersCallback(wholeMatch, m1) {
          "use strict";
          var charCodeToEscape = m1.charCodeAt(0);
          return "\xA8E" + charCodeToEscape + "E";
        }
        showdown2.helper.escapeCharactersCallback = escapeCharactersCallback;
        showdown2.helper.escapeCharacters = function(text3, charsToEscape, afterBackslash) {
          "use strict";
          var regexString = "([" + charsToEscape.replace(/([\[\]\\])/g, "\\$1") + "])";
          if (afterBackslash) {
            regexString = "\\\\" + regexString;
          }
          var regex = new RegExp(regexString, "g");
          text3 = text3.replace(regex, escapeCharactersCallback);
          return text3;
        };
        showdown2.helper.unescapeHTMLEntities = function(txt) {
          "use strict";
          return txt.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
        };
        var rgxFindMatchPos = function(str, left, right, flags) {
          "use strict";
          var f5 = flags || "", g5 = f5.indexOf("g") > -1, x4 = new RegExp(left + "|" + right, "g" + f5.replace(/g/g, "")), l5 = new RegExp(left, f5.replace(/g/g, "")), pos = [], t5, s5, m4, start2, end;
          do {
            t5 = 0;
            while (m4 = x4.exec(str)) {
              if (l5.test(m4[0])) {
                if (!t5++) {
                  s5 = x4.lastIndex;
                  start2 = s5 - m4[0].length;
                }
              } else if (t5) {
                if (!--t5) {
                  end = m4.index + m4[0].length;
                  var obj = {
                    left: { start: start2, end: s5 },
                    match: { start: s5, end: m4.index },
                    right: { start: m4.index, end },
                    wholeMatch: { start: start2, end }
                  };
                  pos.push(obj);
                  if (!g5) {
                    return pos;
                  }
                }
              }
            }
          } while (t5 && (x4.lastIndex = s5));
          return pos;
        };
        showdown2.helper.matchRecursiveRegExp = function(str, left, right, flags) {
          "use strict";
          var matchPos = rgxFindMatchPos(str, left, right, flags), results = [];
          for (var i5 = 0; i5 < matchPos.length; ++i5) {
            results.push([
              str.slice(matchPos[i5].wholeMatch.start, matchPos[i5].wholeMatch.end),
              str.slice(matchPos[i5].match.start, matchPos[i5].match.end),
              str.slice(matchPos[i5].left.start, matchPos[i5].left.end),
              str.slice(matchPos[i5].right.start, matchPos[i5].right.end)
            ]);
          }
          return results;
        };
        showdown2.helper.replaceRecursiveRegExp = function(str, replacement, left, right, flags) {
          "use strict";
          if (!showdown2.helper.isFunction(replacement)) {
            var repStr = replacement;
            replacement = function() {
              return repStr;
            };
          }
          var matchPos = rgxFindMatchPos(str, left, right, flags), finalStr = str, lng = matchPos.length;
          if (lng > 0) {
            var bits = [];
            if (matchPos[0].wholeMatch.start !== 0) {
              bits.push(str.slice(0, matchPos[0].wholeMatch.start));
            }
            for (var i5 = 0; i5 < lng; ++i5) {
              bits.push(
                replacement(
                  str.slice(matchPos[i5].wholeMatch.start, matchPos[i5].wholeMatch.end),
                  str.slice(matchPos[i5].match.start, matchPos[i5].match.end),
                  str.slice(matchPos[i5].left.start, matchPos[i5].left.end),
                  str.slice(matchPos[i5].right.start, matchPos[i5].right.end)
                )
              );
              if (i5 < lng - 1) {
                bits.push(str.slice(matchPos[i5].wholeMatch.end, matchPos[i5 + 1].wholeMatch.start));
              }
            }
            if (matchPos[lng - 1].wholeMatch.end < str.length) {
              bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
            }
            finalStr = bits.join("");
          }
          return finalStr;
        };
        showdown2.helper.regexIndexOf = function(str, regex, fromIndex) {
          "use strict";
          if (!showdown2.helper.isString(str)) {
            throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
          }
          if (regex instanceof RegExp === false) {
            throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
          }
          var indexOf = str.substring(fromIndex || 0).search(regex);
          return indexOf >= 0 ? indexOf + (fromIndex || 0) : indexOf;
        };
        showdown2.helper.splitAtIndex = function(str, index2) {
          "use strict";
          if (!showdown2.helper.isString(str)) {
            throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
          }
          return [str.substring(0, index2), str.substring(index2)];
        };
        showdown2.helper.encodeEmailAddress = function(mail) {
          "use strict";
          var encode = [
            function(ch) {
              return "&#" + ch.charCodeAt(0) + ";";
            },
            function(ch) {
              return "&#x" + ch.charCodeAt(0).toString(16) + ";";
            },
            function(ch) {
              return ch;
            }
          ];
          mail = mail.replace(/./g, function(ch) {
            if (ch === "@") {
              ch = encode[Math.floor(Math.random() * 2)](ch);
            } else {
              var r5 = Math.random();
              ch = r5 > 0.9 ? encode[2](ch) : r5 > 0.45 ? encode[1](ch) : encode[0](ch);
            }
            return ch;
          });
          return mail;
        };
        showdown2.helper.padEnd = function padEnd(str, targetLength, padString) {
          "use strict";
          targetLength = targetLength >> 0;
          padString = String(padString || " ");
          if (str.length > targetLength) {
            return String(str);
          } else {
            targetLength = targetLength - str.length;
            if (targetLength > padString.length) {
              padString += padString.repeat(targetLength / padString.length);
            }
            return String(str) + padString.slice(0, targetLength);
          }
        };
        if (typeof console === "undefined") {
          console = {
            warn: function(msg) {
              "use strict";
              alert(msg);
            },
            log: function(msg) {
              "use strict";
              alert(msg);
            },
            error: function(msg) {
              "use strict";
              throw msg;
            }
          };
        }
        showdown2.helper.regexes = {
          asteriskDashAndColon: /([*_:~])/g
        };
        showdown2.helper.emojis = {
          "+1": "\u{1F44D}",
          "-1": "\u{1F44E}",
          "100": "\u{1F4AF}",
          "1234": "\u{1F522}",
          "1st_place_medal": "\u{1F947}",
          "2nd_place_medal": "\u{1F948}",
          "3rd_place_medal": "\u{1F949}",
          "8ball": "\u{1F3B1}",
          "a": "\u{1F170}\uFE0F",
          "ab": "\u{1F18E}",
          "abc": "\u{1F524}",
          "abcd": "\u{1F521}",
          "accept": "\u{1F251}",
          "aerial_tramway": "\u{1F6A1}",
          "airplane": "\u2708\uFE0F",
          "alarm_clock": "\u23F0",
          "alembic": "\u2697\uFE0F",
          "alien": "\u{1F47D}",
          "ambulance": "\u{1F691}",
          "amphora": "\u{1F3FA}",
          "anchor": "\u2693\uFE0F",
          "angel": "\u{1F47C}",
          "anger": "\u{1F4A2}",
          "angry": "\u{1F620}",
          "anguished": "\u{1F627}",
          "ant": "\u{1F41C}",
          "apple": "\u{1F34E}",
          "aquarius": "\u2652\uFE0F",
          "aries": "\u2648\uFE0F",
          "arrow_backward": "\u25C0\uFE0F",
          "arrow_double_down": "\u23EC",
          "arrow_double_up": "\u23EB",
          "arrow_down": "\u2B07\uFE0F",
          "arrow_down_small": "\u{1F53D}",
          "arrow_forward": "\u25B6\uFE0F",
          "arrow_heading_down": "\u2935\uFE0F",
          "arrow_heading_up": "\u2934\uFE0F",
          "arrow_left": "\u2B05\uFE0F",
          "arrow_lower_left": "\u2199\uFE0F",
          "arrow_lower_right": "\u2198\uFE0F",
          "arrow_right": "\u27A1\uFE0F",
          "arrow_right_hook": "\u21AA\uFE0F",
          "arrow_up": "\u2B06\uFE0F",
          "arrow_up_down": "\u2195\uFE0F",
          "arrow_up_small": "\u{1F53C}",
          "arrow_upper_left": "\u2196\uFE0F",
          "arrow_upper_right": "\u2197\uFE0F",
          "arrows_clockwise": "\u{1F503}",
          "arrows_counterclockwise": "\u{1F504}",
          "art": "\u{1F3A8}",
          "articulated_lorry": "\u{1F69B}",
          "artificial_satellite": "\u{1F6F0}",
          "astonished": "\u{1F632}",
          "athletic_shoe": "\u{1F45F}",
          "atm": "\u{1F3E7}",
          "atom_symbol": "\u269B\uFE0F",
          "avocado": "\u{1F951}",
          "b": "\u{1F171}\uFE0F",
          "baby": "\u{1F476}",
          "baby_bottle": "\u{1F37C}",
          "baby_chick": "\u{1F424}",
          "baby_symbol": "\u{1F6BC}",
          "back": "\u{1F519}",
          "bacon": "\u{1F953}",
          "badminton": "\u{1F3F8}",
          "baggage_claim": "\u{1F6C4}",
          "baguette_bread": "\u{1F956}",
          "balance_scale": "\u2696\uFE0F",
          "balloon": "\u{1F388}",
          "ballot_box": "\u{1F5F3}",
          "ballot_box_with_check": "\u2611\uFE0F",
          "bamboo": "\u{1F38D}",
          "banana": "\u{1F34C}",
          "bangbang": "\u203C\uFE0F",
          "bank": "\u{1F3E6}",
          "bar_chart": "\u{1F4CA}",
          "barber": "\u{1F488}",
          "baseball": "\u26BE\uFE0F",
          "basketball": "\u{1F3C0}",
          "basketball_man": "\u26F9\uFE0F",
          "basketball_woman": "\u26F9\uFE0F&zwj;\u2640\uFE0F",
          "bat": "\u{1F987}",
          "bath": "\u{1F6C0}",
          "bathtub": "\u{1F6C1}",
          "battery": "\u{1F50B}",
          "beach_umbrella": "\u{1F3D6}",
          "bear": "\u{1F43B}",
          "bed": "\u{1F6CF}",
          "bee": "\u{1F41D}",
          "beer": "\u{1F37A}",
          "beers": "\u{1F37B}",
          "beetle": "\u{1F41E}",
          "beginner": "\u{1F530}",
          "bell": "\u{1F514}",
          "bellhop_bell": "\u{1F6CE}",
          "bento": "\u{1F371}",
          "biking_man": "\u{1F6B4}",
          "bike": "\u{1F6B2}",
          "biking_woman": "\u{1F6B4}&zwj;\u2640\uFE0F",
          "bikini": "\u{1F459}",
          "biohazard": "\u2623\uFE0F",
          "bird": "\u{1F426}",
          "birthday": "\u{1F382}",
          "black_circle": "\u26AB\uFE0F",
          "black_flag": "\u{1F3F4}",
          "black_heart": "\u{1F5A4}",
          "black_joker": "\u{1F0CF}",
          "black_large_square": "\u2B1B\uFE0F",
          "black_medium_small_square": "\u25FE\uFE0F",
          "black_medium_square": "\u25FC\uFE0F",
          "black_nib": "\u2712\uFE0F",
          "black_small_square": "\u25AA\uFE0F",
          "black_square_button": "\u{1F532}",
          "blonde_man": "\u{1F471}",
          "blonde_woman": "\u{1F471}&zwj;\u2640\uFE0F",
          "blossom": "\u{1F33C}",
          "blowfish": "\u{1F421}",
          "blue_book": "\u{1F4D8}",
          "blue_car": "\u{1F699}",
          "blue_heart": "\u{1F499}",
          "blush": "\u{1F60A}",
          "boar": "\u{1F417}",
          "boat": "\u26F5\uFE0F",
          "bomb": "\u{1F4A3}",
          "book": "\u{1F4D6}",
          "bookmark": "\u{1F516}",
          "bookmark_tabs": "\u{1F4D1}",
          "books": "\u{1F4DA}",
          "boom": "\u{1F4A5}",
          "boot": "\u{1F462}",
          "bouquet": "\u{1F490}",
          "bowing_man": "\u{1F647}",
          "bow_and_arrow": "\u{1F3F9}",
          "bowing_woman": "\u{1F647}&zwj;\u2640\uFE0F",
          "bowling": "\u{1F3B3}",
          "boxing_glove": "\u{1F94A}",
          "boy": "\u{1F466}",
          "bread": "\u{1F35E}",
          "bride_with_veil": "\u{1F470}",
          "bridge_at_night": "\u{1F309}",
          "briefcase": "\u{1F4BC}",
          "broken_heart": "\u{1F494}",
          "bug": "\u{1F41B}",
          "building_construction": "\u{1F3D7}",
          "bulb": "\u{1F4A1}",
          "bullettrain_front": "\u{1F685}",
          "bullettrain_side": "\u{1F684}",
          "burrito": "\u{1F32F}",
          "bus": "\u{1F68C}",
          "business_suit_levitating": "\u{1F574}",
          "busstop": "\u{1F68F}",
          "bust_in_silhouette": "\u{1F464}",
          "busts_in_silhouette": "\u{1F465}",
          "butterfly": "\u{1F98B}",
          "cactus": "\u{1F335}",
          "cake": "\u{1F370}",
          "calendar": "\u{1F4C6}",
          "call_me_hand": "\u{1F919}",
          "calling": "\u{1F4F2}",
          "camel": "\u{1F42B}",
          "camera": "\u{1F4F7}",
          "camera_flash": "\u{1F4F8}",
          "camping": "\u{1F3D5}",
          "cancer": "\u264B\uFE0F",
          "candle": "\u{1F56F}",
          "candy": "\u{1F36C}",
          "canoe": "\u{1F6F6}",
          "capital_abcd": "\u{1F520}",
          "capricorn": "\u2651\uFE0F",
          "car": "\u{1F697}",
          "card_file_box": "\u{1F5C3}",
          "card_index": "\u{1F4C7}",
          "card_index_dividers": "\u{1F5C2}",
          "carousel_horse": "\u{1F3A0}",
          "carrot": "\u{1F955}",
          "cat": "\u{1F431}",
          "cat2": "\u{1F408}",
          "cd": "\u{1F4BF}",
          "chains": "\u26D3",
          "champagne": "\u{1F37E}",
          "chart": "\u{1F4B9}",
          "chart_with_downwards_trend": "\u{1F4C9}",
          "chart_with_upwards_trend": "\u{1F4C8}",
          "checkered_flag": "\u{1F3C1}",
          "cheese": "\u{1F9C0}",
          "cherries": "\u{1F352}",
          "cherry_blossom": "\u{1F338}",
          "chestnut": "\u{1F330}",
          "chicken": "\u{1F414}",
          "children_crossing": "\u{1F6B8}",
          "chipmunk": "\u{1F43F}",
          "chocolate_bar": "\u{1F36B}",
          "christmas_tree": "\u{1F384}",
          "church": "\u26EA\uFE0F",
          "cinema": "\u{1F3A6}",
          "circus_tent": "\u{1F3AA}",
          "city_sunrise": "\u{1F307}",
          "city_sunset": "\u{1F306}",
          "cityscape": "\u{1F3D9}",
          "cl": "\u{1F191}",
          "clamp": "\u{1F5DC}",
          "clap": "\u{1F44F}",
          "clapper": "\u{1F3AC}",
          "classical_building": "\u{1F3DB}",
          "clinking_glasses": "\u{1F942}",
          "clipboard": "\u{1F4CB}",
          "clock1": "\u{1F550}",
          "clock10": "\u{1F559}",
          "clock1030": "\u{1F565}",
          "clock11": "\u{1F55A}",
          "clock1130": "\u{1F566}",
          "clock12": "\u{1F55B}",
          "clock1230": "\u{1F567}",
          "clock130": "\u{1F55C}",
          "clock2": "\u{1F551}",
          "clock230": "\u{1F55D}",
          "clock3": "\u{1F552}",
          "clock330": "\u{1F55E}",
          "clock4": "\u{1F553}",
          "clock430": "\u{1F55F}",
          "clock5": "\u{1F554}",
          "clock530": "\u{1F560}",
          "clock6": "\u{1F555}",
          "clock630": "\u{1F561}",
          "clock7": "\u{1F556}",
          "clock730": "\u{1F562}",
          "clock8": "\u{1F557}",
          "clock830": "\u{1F563}",
          "clock9": "\u{1F558}",
          "clock930": "\u{1F564}",
          "closed_book": "\u{1F4D5}",
          "closed_lock_with_key": "\u{1F510}",
          "closed_umbrella": "\u{1F302}",
          "cloud": "\u2601\uFE0F",
          "cloud_with_lightning": "\u{1F329}",
          "cloud_with_lightning_and_rain": "\u26C8",
          "cloud_with_rain": "\u{1F327}",
          "cloud_with_snow": "\u{1F328}",
          "clown_face": "\u{1F921}",
          "clubs": "\u2663\uFE0F",
          "cocktail": "\u{1F378}",
          "coffee": "\u2615\uFE0F",
          "coffin": "\u26B0\uFE0F",
          "cold_sweat": "\u{1F630}",
          "comet": "\u2604\uFE0F",
          "computer": "\u{1F4BB}",
          "computer_mouse": "\u{1F5B1}",
          "confetti_ball": "\u{1F38A}",
          "confounded": "\u{1F616}",
          "confused": "\u{1F615}",
          "congratulations": "\u3297\uFE0F",
          "construction": "\u{1F6A7}",
          "construction_worker_man": "\u{1F477}",
          "construction_worker_woman": "\u{1F477}&zwj;\u2640\uFE0F",
          "control_knobs": "\u{1F39B}",
          "convenience_store": "\u{1F3EA}",
          "cookie": "\u{1F36A}",
          "cool": "\u{1F192}",
          "policeman": "\u{1F46E}",
          "copyright": "\xA9\uFE0F",
          "corn": "\u{1F33D}",
          "couch_and_lamp": "\u{1F6CB}",
          "couple": "\u{1F46B}",
          "couple_with_heart_woman_man": "\u{1F491}",
          "couple_with_heart_man_man": "\u{1F468}&zwj;\u2764\uFE0F&zwj;\u{1F468}",
          "couple_with_heart_woman_woman": "\u{1F469}&zwj;\u2764\uFE0F&zwj;\u{1F469}",
          "couplekiss_man_man": "\u{1F468}&zwj;\u2764\uFE0F&zwj;\u{1F48B}&zwj;\u{1F468}",
          "couplekiss_man_woman": "\u{1F48F}",
          "couplekiss_woman_woman": "\u{1F469}&zwj;\u2764\uFE0F&zwj;\u{1F48B}&zwj;\u{1F469}",
          "cow": "\u{1F42E}",
          "cow2": "\u{1F404}",
          "cowboy_hat_face": "\u{1F920}",
          "crab": "\u{1F980}",
          "crayon": "\u{1F58D}",
          "credit_card": "\u{1F4B3}",
          "crescent_moon": "\u{1F319}",
          "cricket": "\u{1F3CF}",
          "crocodile": "\u{1F40A}",
          "croissant": "\u{1F950}",
          "crossed_fingers": "\u{1F91E}",
          "crossed_flags": "\u{1F38C}",
          "crossed_swords": "\u2694\uFE0F",
          "crown": "\u{1F451}",
          "cry": "\u{1F622}",
          "crying_cat_face": "\u{1F63F}",
          "crystal_ball": "\u{1F52E}",
          "cucumber": "\u{1F952}",
          "cupid": "\u{1F498}",
          "curly_loop": "\u27B0",
          "currency_exchange": "\u{1F4B1}",
          "curry": "\u{1F35B}",
          "custard": "\u{1F36E}",
          "customs": "\u{1F6C3}",
          "cyclone": "\u{1F300}",
          "dagger": "\u{1F5E1}",
          "dancer": "\u{1F483}",
          "dancing_women": "\u{1F46F}",
          "dancing_men": "\u{1F46F}&zwj;\u2642\uFE0F",
          "dango": "\u{1F361}",
          "dark_sunglasses": "\u{1F576}",
          "dart": "\u{1F3AF}",
          "dash": "\u{1F4A8}",
          "date": "\u{1F4C5}",
          "deciduous_tree": "\u{1F333}",
          "deer": "\u{1F98C}",
          "department_store": "\u{1F3EC}",
          "derelict_house": "\u{1F3DA}",
          "desert": "\u{1F3DC}",
          "desert_island": "\u{1F3DD}",
          "desktop_computer": "\u{1F5A5}",
          "male_detective": "\u{1F575}\uFE0F",
          "diamond_shape_with_a_dot_inside": "\u{1F4A0}",
          "diamonds": "\u2666\uFE0F",
          "disappointed": "\u{1F61E}",
          "disappointed_relieved": "\u{1F625}",
          "dizzy": "\u{1F4AB}",
          "dizzy_face": "\u{1F635}",
          "do_not_litter": "\u{1F6AF}",
          "dog": "\u{1F436}",
          "dog2": "\u{1F415}",
          "dollar": "\u{1F4B5}",
          "dolls": "\u{1F38E}",
          "dolphin": "\u{1F42C}",
          "door": "\u{1F6AA}",
          "doughnut": "\u{1F369}",
          "dove": "\u{1F54A}",
          "dragon": "\u{1F409}",
          "dragon_face": "\u{1F432}",
          "dress": "\u{1F457}",
          "dromedary_camel": "\u{1F42A}",
          "drooling_face": "\u{1F924}",
          "droplet": "\u{1F4A7}",
          "drum": "\u{1F941}",
          "duck": "\u{1F986}",
          "dvd": "\u{1F4C0}",
          "e-mail": "\u{1F4E7}",
          "eagle": "\u{1F985}",
          "ear": "\u{1F442}",
          "ear_of_rice": "\u{1F33E}",
          "earth_africa": "\u{1F30D}",
          "earth_americas": "\u{1F30E}",
          "earth_asia": "\u{1F30F}",
          "egg": "\u{1F95A}",
          "eggplant": "\u{1F346}",
          "eight_pointed_black_star": "\u2734\uFE0F",
          "eight_spoked_asterisk": "\u2733\uFE0F",
          "electric_plug": "\u{1F50C}",
          "elephant": "\u{1F418}",
          "email": "\u2709\uFE0F",
          "end": "\u{1F51A}",
          "envelope_with_arrow": "\u{1F4E9}",
          "euro": "\u{1F4B6}",
          "european_castle": "\u{1F3F0}",
          "european_post_office": "\u{1F3E4}",
          "evergreen_tree": "\u{1F332}",
          "exclamation": "\u2757\uFE0F",
          "expressionless": "\u{1F611}",
          "eye": "\u{1F441}",
          "eye_speech_bubble": "\u{1F441}&zwj;\u{1F5E8}",
          "eyeglasses": "\u{1F453}",
          "eyes": "\u{1F440}",
          "face_with_head_bandage": "\u{1F915}",
          "face_with_thermometer": "\u{1F912}",
          "fist_oncoming": "\u{1F44A}",
          "factory": "\u{1F3ED}",
          "fallen_leaf": "\u{1F342}",
          "family_man_woman_boy": "\u{1F46A}",
          "family_man_boy": "\u{1F468}&zwj;\u{1F466}",
          "family_man_boy_boy": "\u{1F468}&zwj;\u{1F466}&zwj;\u{1F466}",
          "family_man_girl": "\u{1F468}&zwj;\u{1F467}",
          "family_man_girl_boy": "\u{1F468}&zwj;\u{1F467}&zwj;\u{1F466}",
          "family_man_girl_girl": "\u{1F468}&zwj;\u{1F467}&zwj;\u{1F467}",
          "family_man_man_boy": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F466}",
          "family_man_man_boy_boy": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F466}&zwj;\u{1F466}",
          "family_man_man_girl": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F467}",
          "family_man_man_girl_boy": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F467}&zwj;\u{1F466}",
          "family_man_man_girl_girl": "\u{1F468}&zwj;\u{1F468}&zwj;\u{1F467}&zwj;\u{1F467}",
          "family_man_woman_boy_boy": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F466}&zwj;\u{1F466}",
          "family_man_woman_girl": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F467}",
          "family_man_woman_girl_boy": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F466}",
          "family_man_woman_girl_girl": "\u{1F468}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F467}",
          "family_woman_boy": "\u{1F469}&zwj;\u{1F466}",
          "family_woman_boy_boy": "\u{1F469}&zwj;\u{1F466}&zwj;\u{1F466}",
          "family_woman_girl": "\u{1F469}&zwj;\u{1F467}",
          "family_woman_girl_boy": "\u{1F469}&zwj;\u{1F467}&zwj;\u{1F466}",
          "family_woman_girl_girl": "\u{1F469}&zwj;\u{1F467}&zwj;\u{1F467}",
          "family_woman_woman_boy": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F466}",
          "family_woman_woman_boy_boy": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F466}&zwj;\u{1F466}",
          "family_woman_woman_girl": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F467}",
          "family_woman_woman_girl_boy": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F466}",
          "family_woman_woman_girl_girl": "\u{1F469}&zwj;\u{1F469}&zwj;\u{1F467}&zwj;\u{1F467}",
          "fast_forward": "\u23E9",
          "fax": "\u{1F4E0}",
          "fearful": "\u{1F628}",
          "feet": "\u{1F43E}",
          "female_detective": "\u{1F575}\uFE0F&zwj;\u2640\uFE0F",
          "ferris_wheel": "\u{1F3A1}",
          "ferry": "\u26F4",
          "field_hockey": "\u{1F3D1}",
          "file_cabinet": "\u{1F5C4}",
          "file_folder": "\u{1F4C1}",
          "film_projector": "\u{1F4FD}",
          "film_strip": "\u{1F39E}",
          "fire": "\u{1F525}",
          "fire_engine": "\u{1F692}",
          "fireworks": "\u{1F386}",
          "first_quarter_moon": "\u{1F313}",
          "first_quarter_moon_with_face": "\u{1F31B}",
          "fish": "\u{1F41F}",
          "fish_cake": "\u{1F365}",
          "fishing_pole_and_fish": "\u{1F3A3}",
          "fist_raised": "\u270A",
          "fist_left": "\u{1F91B}",
          "fist_right": "\u{1F91C}",
          "flags": "\u{1F38F}",
          "flashlight": "\u{1F526}",
          "fleur_de_lis": "\u269C\uFE0F",
          "flight_arrival": "\u{1F6EC}",
          "flight_departure": "\u{1F6EB}",
          "floppy_disk": "\u{1F4BE}",
          "flower_playing_cards": "\u{1F3B4}",
          "flushed": "\u{1F633}",
          "fog": "\u{1F32B}",
          "foggy": "\u{1F301}",
          "football": "\u{1F3C8}",
          "footprints": "\u{1F463}",
          "fork_and_knife": "\u{1F374}",
          "fountain": "\u26F2\uFE0F",
          "fountain_pen": "\u{1F58B}",
          "four_leaf_clover": "\u{1F340}",
          "fox_face": "\u{1F98A}",
          "framed_picture": "\u{1F5BC}",
          "free": "\u{1F193}",
          "fried_egg": "\u{1F373}",
          "fried_shrimp": "\u{1F364}",
          "fries": "\u{1F35F}",
          "frog": "\u{1F438}",
          "frowning": "\u{1F626}",
          "frowning_face": "\u2639\uFE0F",
          "frowning_man": "\u{1F64D}&zwj;\u2642\uFE0F",
          "frowning_woman": "\u{1F64D}",
          "middle_finger": "\u{1F595}",
          "fuelpump": "\u26FD\uFE0F",
          "full_moon": "\u{1F315}",
          "full_moon_with_face": "\u{1F31D}",
          "funeral_urn": "\u26B1\uFE0F",
          "game_die": "\u{1F3B2}",
          "gear": "\u2699\uFE0F",
          "gem": "\u{1F48E}",
          "gemini": "\u264A\uFE0F",
          "ghost": "\u{1F47B}",
          "gift": "\u{1F381}",
          "gift_heart": "\u{1F49D}",
          "girl": "\u{1F467}",
          "globe_with_meridians": "\u{1F310}",
          "goal_net": "\u{1F945}",
          "goat": "\u{1F410}",
          "golf": "\u26F3\uFE0F",
          "golfing_man": "\u{1F3CC}\uFE0F",
          "golfing_woman": "\u{1F3CC}\uFE0F&zwj;\u2640\uFE0F",
          "gorilla": "\u{1F98D}",
          "grapes": "\u{1F347}",
          "green_apple": "\u{1F34F}",
          "green_book": "\u{1F4D7}",
          "green_heart": "\u{1F49A}",
          "green_salad": "\u{1F957}",
          "grey_exclamation": "\u2755",
          "grey_question": "\u2754",
          "grimacing": "\u{1F62C}",
          "grin": "\u{1F601}",
          "grinning": "\u{1F600}",
          "guardsman": "\u{1F482}",
          "guardswoman": "\u{1F482}&zwj;\u2640\uFE0F",
          "guitar": "\u{1F3B8}",
          "gun": "\u{1F52B}",
          "haircut_woman": "\u{1F487}",
          "haircut_man": "\u{1F487}&zwj;\u2642\uFE0F",
          "hamburger": "\u{1F354}",
          "hammer": "\u{1F528}",
          "hammer_and_pick": "\u2692",
          "hammer_and_wrench": "\u{1F6E0}",
          "hamster": "\u{1F439}",
          "hand": "\u270B",
          "handbag": "\u{1F45C}",
          "handshake": "\u{1F91D}",
          "hankey": "\u{1F4A9}",
          "hatched_chick": "\u{1F425}",
          "hatching_chick": "\u{1F423}",
          "headphones": "\u{1F3A7}",
          "hear_no_evil": "\u{1F649}",
          "heart": "\u2764\uFE0F",
          "heart_decoration": "\u{1F49F}",
          "heart_eyes": "\u{1F60D}",
          "heart_eyes_cat": "\u{1F63B}",
          "heartbeat": "\u{1F493}",
          "heartpulse": "\u{1F497}",
          "hearts": "\u2665\uFE0F",
          "heavy_check_mark": "\u2714\uFE0F",
          "heavy_division_sign": "\u2797",
          "heavy_dollar_sign": "\u{1F4B2}",
          "heavy_heart_exclamation": "\u2763\uFE0F",
          "heavy_minus_sign": "\u2796",
          "heavy_multiplication_x": "\u2716\uFE0F",
          "heavy_plus_sign": "\u2795",
          "helicopter": "\u{1F681}",
          "herb": "\u{1F33F}",
          "hibiscus": "\u{1F33A}",
          "high_brightness": "\u{1F506}",
          "high_heel": "\u{1F460}",
          "hocho": "\u{1F52A}",
          "hole": "\u{1F573}",
          "honey_pot": "\u{1F36F}",
          "horse": "\u{1F434}",
          "horse_racing": "\u{1F3C7}",
          "hospital": "\u{1F3E5}",
          "hot_pepper": "\u{1F336}",
          "hotdog": "\u{1F32D}",
          "hotel": "\u{1F3E8}",
          "hotsprings": "\u2668\uFE0F",
          "hourglass": "\u231B\uFE0F",
          "hourglass_flowing_sand": "\u23F3",
          "house": "\u{1F3E0}",
          "house_with_garden": "\u{1F3E1}",
          "houses": "\u{1F3D8}",
          "hugs": "\u{1F917}",
          "hushed": "\u{1F62F}",
          "ice_cream": "\u{1F368}",
          "ice_hockey": "\u{1F3D2}",
          "ice_skate": "\u26F8",
          "icecream": "\u{1F366}",
          "id": "\u{1F194}",
          "ideograph_advantage": "\u{1F250}",
          "imp": "\u{1F47F}",
          "inbox_tray": "\u{1F4E5}",
          "incoming_envelope": "\u{1F4E8}",
          "tipping_hand_woman": "\u{1F481}",
          "information_source": "\u2139\uFE0F",
          "innocent": "\u{1F607}",
          "interrobang": "\u2049\uFE0F",
          "iphone": "\u{1F4F1}",
          "izakaya_lantern": "\u{1F3EE}",
          "jack_o_lantern": "\u{1F383}",
          "japan": "\u{1F5FE}",
          "japanese_castle": "\u{1F3EF}",
          "japanese_goblin": "\u{1F47A}",
          "japanese_ogre": "\u{1F479}",
          "jeans": "\u{1F456}",
          "joy": "\u{1F602}",
          "joy_cat": "\u{1F639}",
          "joystick": "\u{1F579}",
          "kaaba": "\u{1F54B}",
          "key": "\u{1F511}",
          "keyboard": "\u2328\uFE0F",
          "keycap_ten": "\u{1F51F}",
          "kick_scooter": "\u{1F6F4}",
          "kimono": "\u{1F458}",
          "kiss": "\u{1F48B}",
          "kissing": "\u{1F617}",
          "kissing_cat": "\u{1F63D}",
          "kissing_closed_eyes": "\u{1F61A}",
          "kissing_heart": "\u{1F618}",
          "kissing_smiling_eyes": "\u{1F619}",
          "kiwi_fruit": "\u{1F95D}",
          "koala": "\u{1F428}",
          "koko": "\u{1F201}",
          "label": "\u{1F3F7}",
          "large_blue_circle": "\u{1F535}",
          "large_blue_diamond": "\u{1F537}",
          "large_orange_diamond": "\u{1F536}",
          "last_quarter_moon": "\u{1F317}",
          "last_quarter_moon_with_face": "\u{1F31C}",
          "latin_cross": "\u271D\uFE0F",
          "laughing": "\u{1F606}",
          "leaves": "\u{1F343}",
          "ledger": "\u{1F4D2}",
          "left_luggage": "\u{1F6C5}",
          "left_right_arrow": "\u2194\uFE0F",
          "leftwards_arrow_with_hook": "\u21A9\uFE0F",
          "lemon": "\u{1F34B}",
          "leo": "\u264C\uFE0F",
          "leopard": "\u{1F406}",
          "level_slider": "\u{1F39A}",
          "libra": "\u264E\uFE0F",
          "light_rail": "\u{1F688}",
          "link": "\u{1F517}",
          "lion": "\u{1F981}",
          "lips": "\u{1F444}",
          "lipstick": "\u{1F484}",
          "lizard": "\u{1F98E}",
          "lock": "\u{1F512}",
          "lock_with_ink_pen": "\u{1F50F}",
          "lollipop": "\u{1F36D}",
          "loop": "\u27BF",
          "loud_sound": "\u{1F50A}",
          "loudspeaker": "\u{1F4E2}",
          "love_hotel": "\u{1F3E9}",
          "love_letter": "\u{1F48C}",
          "low_brightness": "\u{1F505}",
          "lying_face": "\u{1F925}",
          "m": "\u24C2\uFE0F",
          "mag": "\u{1F50D}",
          "mag_right": "\u{1F50E}",
          "mahjong": "\u{1F004}\uFE0F",
          "mailbox": "\u{1F4EB}",
          "mailbox_closed": "\u{1F4EA}",
          "mailbox_with_mail": "\u{1F4EC}",
          "mailbox_with_no_mail": "\u{1F4ED}",
          "man": "\u{1F468}",
          "man_artist": "\u{1F468}&zwj;\u{1F3A8}",
          "man_astronaut": "\u{1F468}&zwj;\u{1F680}",
          "man_cartwheeling": "\u{1F938}&zwj;\u2642\uFE0F",
          "man_cook": "\u{1F468}&zwj;\u{1F373}",
          "man_dancing": "\u{1F57A}",
          "man_facepalming": "\u{1F926}&zwj;\u2642\uFE0F",
          "man_factory_worker": "\u{1F468}&zwj;\u{1F3ED}",
          "man_farmer": "\u{1F468}&zwj;\u{1F33E}",
          "man_firefighter": "\u{1F468}&zwj;\u{1F692}",
          "man_health_worker": "\u{1F468}&zwj;\u2695\uFE0F",
          "man_in_tuxedo": "\u{1F935}",
          "man_judge": "\u{1F468}&zwj;\u2696\uFE0F",
          "man_juggling": "\u{1F939}&zwj;\u2642\uFE0F",
          "man_mechanic": "\u{1F468}&zwj;\u{1F527}",
          "man_office_worker": "\u{1F468}&zwj;\u{1F4BC}",
          "man_pilot": "\u{1F468}&zwj;\u2708\uFE0F",
          "man_playing_handball": "\u{1F93E}&zwj;\u2642\uFE0F",
          "man_playing_water_polo": "\u{1F93D}&zwj;\u2642\uFE0F",
          "man_scientist": "\u{1F468}&zwj;\u{1F52C}",
          "man_shrugging": "\u{1F937}&zwj;\u2642\uFE0F",
          "man_singer": "\u{1F468}&zwj;\u{1F3A4}",
          "man_student": "\u{1F468}&zwj;\u{1F393}",
          "man_teacher": "\u{1F468}&zwj;\u{1F3EB}",
          "man_technologist": "\u{1F468}&zwj;\u{1F4BB}",
          "man_with_gua_pi_mao": "\u{1F472}",
          "man_with_turban": "\u{1F473}",
          "tangerine": "\u{1F34A}",
          "mans_shoe": "\u{1F45E}",
          "mantelpiece_clock": "\u{1F570}",
          "maple_leaf": "\u{1F341}",
          "martial_arts_uniform": "\u{1F94B}",
          "mask": "\u{1F637}",
          "massage_woman": "\u{1F486}",
          "massage_man": "\u{1F486}&zwj;\u2642\uFE0F",
          "meat_on_bone": "\u{1F356}",
          "medal_military": "\u{1F396}",
          "medal_sports": "\u{1F3C5}",
          "mega": "\u{1F4E3}",
          "melon": "\u{1F348}",
          "memo": "\u{1F4DD}",
          "men_wrestling": "\u{1F93C}&zwj;\u2642\uFE0F",
          "menorah": "\u{1F54E}",
          "mens": "\u{1F6B9}",
          "metal": "\u{1F918}",
          "metro": "\u{1F687}",
          "microphone": "\u{1F3A4}",
          "microscope": "\u{1F52C}",
          "milk_glass": "\u{1F95B}",
          "milky_way": "\u{1F30C}",
          "minibus": "\u{1F690}",
          "minidisc": "\u{1F4BD}",
          "mobile_phone_off": "\u{1F4F4}",
          "money_mouth_face": "\u{1F911}",
          "money_with_wings": "\u{1F4B8}",
          "moneybag": "\u{1F4B0}",
          "monkey": "\u{1F412}",
          "monkey_face": "\u{1F435}",
          "monorail": "\u{1F69D}",
          "moon": "\u{1F314}",
          "mortar_board": "\u{1F393}",
          "mosque": "\u{1F54C}",
          "motor_boat": "\u{1F6E5}",
          "motor_scooter": "\u{1F6F5}",
          "motorcycle": "\u{1F3CD}",
          "motorway": "\u{1F6E3}",
          "mount_fuji": "\u{1F5FB}",
          "mountain": "\u26F0",
          "mountain_biking_man": "\u{1F6B5}",
          "mountain_biking_woman": "\u{1F6B5}&zwj;\u2640\uFE0F",
          "mountain_cableway": "\u{1F6A0}",
          "mountain_railway": "\u{1F69E}",
          "mountain_snow": "\u{1F3D4}",
          "mouse": "\u{1F42D}",
          "mouse2": "\u{1F401}",
          "movie_camera": "\u{1F3A5}",
          "moyai": "\u{1F5FF}",
          "mrs_claus": "\u{1F936}",
          "muscle": "\u{1F4AA}",
          "mushroom": "\u{1F344}",
          "musical_keyboard": "\u{1F3B9}",
          "musical_note": "\u{1F3B5}",
          "musical_score": "\u{1F3BC}",
          "mute": "\u{1F507}",
          "nail_care": "\u{1F485}",
          "name_badge": "\u{1F4DB}",
          "national_park": "\u{1F3DE}",
          "nauseated_face": "\u{1F922}",
          "necktie": "\u{1F454}",
          "negative_squared_cross_mark": "\u274E",
          "nerd_face": "\u{1F913}",
          "neutral_face": "\u{1F610}",
          "new": "\u{1F195}",
          "new_moon": "\u{1F311}",
          "new_moon_with_face": "\u{1F31A}",
          "newspaper": "\u{1F4F0}",
          "newspaper_roll": "\u{1F5DE}",
          "next_track_button": "\u23ED",
          "ng": "\u{1F196}",
          "no_good_man": "\u{1F645}&zwj;\u2642\uFE0F",
          "no_good_woman": "\u{1F645}",
          "night_with_stars": "\u{1F303}",
          "no_bell": "\u{1F515}",
          "no_bicycles": "\u{1F6B3}",
          "no_entry": "\u26D4\uFE0F",
          "no_entry_sign": "\u{1F6AB}",
          "no_mobile_phones": "\u{1F4F5}",
          "no_mouth": "\u{1F636}",
          "no_pedestrians": "\u{1F6B7}",
          "no_smoking": "\u{1F6AD}",
          "non-potable_water": "\u{1F6B1}",
          "nose": "\u{1F443}",
          "notebook": "\u{1F4D3}",
          "notebook_with_decorative_cover": "\u{1F4D4}",
          "notes": "\u{1F3B6}",
          "nut_and_bolt": "\u{1F529}",
          "o": "\u2B55\uFE0F",
          "o2": "\u{1F17E}\uFE0F",
          "ocean": "\u{1F30A}",
          "octopus": "\u{1F419}",
          "oden": "\u{1F362}",
          "office": "\u{1F3E2}",
          "oil_drum": "\u{1F6E2}",
          "ok": "\u{1F197}",
          "ok_hand": "\u{1F44C}",
          "ok_man": "\u{1F646}&zwj;\u2642\uFE0F",
          "ok_woman": "\u{1F646}",
          "old_key": "\u{1F5DD}",
          "older_man": "\u{1F474}",
          "older_woman": "\u{1F475}",
          "om": "\u{1F549}",
          "on": "\u{1F51B}",
          "oncoming_automobile": "\u{1F698}",
          "oncoming_bus": "\u{1F68D}",
          "oncoming_police_car": "\u{1F694}",
          "oncoming_taxi": "\u{1F696}",
          "open_file_folder": "\u{1F4C2}",
          "open_hands": "\u{1F450}",
          "open_mouth": "\u{1F62E}",
          "open_umbrella": "\u2602\uFE0F",
          "ophiuchus": "\u26CE",
          "orange_book": "\u{1F4D9}",
          "orthodox_cross": "\u2626\uFE0F",
          "outbox_tray": "\u{1F4E4}",
          "owl": "\u{1F989}",
          "ox": "\u{1F402}",
          "package": "\u{1F4E6}",
          "page_facing_up": "\u{1F4C4}",
          "page_with_curl": "\u{1F4C3}",
          "pager": "\u{1F4DF}",
          "paintbrush": "\u{1F58C}",
          "palm_tree": "\u{1F334}",
          "pancakes": "\u{1F95E}",
          "panda_face": "\u{1F43C}",
          "paperclip": "\u{1F4CE}",
          "paperclips": "\u{1F587}",
          "parasol_on_ground": "\u26F1",
          "parking": "\u{1F17F}\uFE0F",
          "part_alternation_mark": "\u303D\uFE0F",
          "partly_sunny": "\u26C5\uFE0F",
          "passenger_ship": "\u{1F6F3}",
          "passport_control": "\u{1F6C2}",
          "pause_button": "\u23F8",
          "peace_symbol": "\u262E\uFE0F",
          "peach": "\u{1F351}",
          "peanuts": "\u{1F95C}",
          "pear": "\u{1F350}",
          "pen": "\u{1F58A}",
          "pencil2": "\u270F\uFE0F",
          "penguin": "\u{1F427}",
          "pensive": "\u{1F614}",
          "performing_arts": "\u{1F3AD}",
          "persevere": "\u{1F623}",
          "person_fencing": "\u{1F93A}",
          "pouting_woman": "\u{1F64E}",
          "phone": "\u260E\uFE0F",
          "pick": "\u26CF",
          "pig": "\u{1F437}",
          "pig2": "\u{1F416}",
          "pig_nose": "\u{1F43D}",
          "pill": "\u{1F48A}",
          "pineapple": "\u{1F34D}",
          "ping_pong": "\u{1F3D3}",
          "pisces": "\u2653\uFE0F",
          "pizza": "\u{1F355}",
          "place_of_worship": "\u{1F6D0}",
          "plate_with_cutlery": "\u{1F37D}",
          "play_or_pause_button": "\u23EF",
          "point_down": "\u{1F447}",
          "point_left": "\u{1F448}",
          "point_right": "\u{1F449}",
          "point_up": "\u261D\uFE0F",
          "point_up_2": "\u{1F446}",
          "police_car": "\u{1F693}",
          "policewoman": "\u{1F46E}&zwj;\u2640\uFE0F",
          "poodle": "\u{1F429}",
          "popcorn": "\u{1F37F}",
          "post_office": "\u{1F3E3}",
          "postal_horn": "\u{1F4EF}",
          "postbox": "\u{1F4EE}",
          "potable_water": "\u{1F6B0}",
          "potato": "\u{1F954}",
          "pouch": "\u{1F45D}",
          "poultry_leg": "\u{1F357}",
          "pound": "\u{1F4B7}",
          "rage": "\u{1F621}",
          "pouting_cat": "\u{1F63E}",
          "pouting_man": "\u{1F64E}&zwj;\u2642\uFE0F",
          "pray": "\u{1F64F}",
          "prayer_beads": "\u{1F4FF}",
          "pregnant_woman": "\u{1F930}",
          "previous_track_button": "\u23EE",
          "prince": "\u{1F934}",
          "princess": "\u{1F478}",
          "printer": "\u{1F5A8}",
          "purple_heart": "\u{1F49C}",
          "purse": "\u{1F45B}",
          "pushpin": "\u{1F4CC}",
          "put_litter_in_its_place": "\u{1F6AE}",
          "question": "\u2753",
          "rabbit": "\u{1F430}",
          "rabbit2": "\u{1F407}",
          "racehorse": "\u{1F40E}",
          "racing_car": "\u{1F3CE}",
          "radio": "\u{1F4FB}",
          "radio_button": "\u{1F518}",
          "radioactive": "\u2622\uFE0F",
          "railway_car": "\u{1F683}",
          "railway_track": "\u{1F6E4}",
          "rainbow": "\u{1F308}",
          "rainbow_flag": "\u{1F3F3}\uFE0F&zwj;\u{1F308}",
          "raised_back_of_hand": "\u{1F91A}",
          "raised_hand_with_fingers_splayed": "\u{1F590}",
          "raised_hands": "\u{1F64C}",
          "raising_hand_woman": "\u{1F64B}",
          "raising_hand_man": "\u{1F64B}&zwj;\u2642\uFE0F",
          "ram": "\u{1F40F}",
          "ramen": "\u{1F35C}",
          "rat": "\u{1F400}",
          "record_button": "\u23FA",
          "recycle": "\u267B\uFE0F",
          "red_circle": "\u{1F534}",
          "registered": "\xAE\uFE0F",
          "relaxed": "\u263A\uFE0F",
          "relieved": "\u{1F60C}",
          "reminder_ribbon": "\u{1F397}",
          "repeat": "\u{1F501}",
          "repeat_one": "\u{1F502}",
          "rescue_worker_helmet": "\u26D1",
          "restroom": "\u{1F6BB}",
          "revolving_hearts": "\u{1F49E}",
          "rewind": "\u23EA",
          "rhinoceros": "\u{1F98F}",
          "ribbon": "\u{1F380}",
          "rice": "\u{1F35A}",
          "rice_ball": "\u{1F359}",
          "rice_cracker": "\u{1F358}",
          "rice_scene": "\u{1F391}",
          "right_anger_bubble": "\u{1F5EF}",
          "ring": "\u{1F48D}",
          "robot": "\u{1F916}",
          "rocket": "\u{1F680}",
          "rofl": "\u{1F923}",
          "roll_eyes": "\u{1F644}",
          "roller_coaster": "\u{1F3A2}",
          "rooster": "\u{1F413}",
          "rose": "\u{1F339}",
          "rosette": "\u{1F3F5}",
          "rotating_light": "\u{1F6A8}",
          "round_pushpin": "\u{1F4CD}",
          "rowing_man": "\u{1F6A3}",
          "rowing_woman": "\u{1F6A3}&zwj;\u2640\uFE0F",
          "rugby_football": "\u{1F3C9}",
          "running_man": "\u{1F3C3}",
          "running_shirt_with_sash": "\u{1F3BD}",
          "running_woman": "\u{1F3C3}&zwj;\u2640\uFE0F",
          "sa": "\u{1F202}\uFE0F",
          "sagittarius": "\u2650\uFE0F",
          "sake": "\u{1F376}",
          "sandal": "\u{1F461}",
          "santa": "\u{1F385}",
          "satellite": "\u{1F4E1}",
          "saxophone": "\u{1F3B7}",
          "school": "\u{1F3EB}",
          "school_satchel": "\u{1F392}",
          "scissors": "\u2702\uFE0F",
          "scorpion": "\u{1F982}",
          "scorpius": "\u264F\uFE0F",
          "scream": "\u{1F631}",
          "scream_cat": "\u{1F640}",
          "scroll": "\u{1F4DC}",
          "seat": "\u{1F4BA}",
          "secret": "\u3299\uFE0F",
          "see_no_evil": "\u{1F648}",
          "seedling": "\u{1F331}",
          "selfie": "\u{1F933}",
          "shallow_pan_of_food": "\u{1F958}",
          "shamrock": "\u2618\uFE0F",
          "shark": "\u{1F988}",
          "shaved_ice": "\u{1F367}",
          "sheep": "\u{1F411}",
          "shell": "\u{1F41A}",
          "shield": "\u{1F6E1}",
          "shinto_shrine": "\u26E9",
          "ship": "\u{1F6A2}",
          "shirt": "\u{1F455}",
          "shopping": "\u{1F6CD}",
          "shopping_cart": "\u{1F6D2}",
          "shower": "\u{1F6BF}",
          "shrimp": "\u{1F990}",
          "signal_strength": "\u{1F4F6}",
          "six_pointed_star": "\u{1F52F}",
          "ski": "\u{1F3BF}",
          "skier": "\u26F7",
          "skull": "\u{1F480}",
          "skull_and_crossbones": "\u2620\uFE0F",
          "sleeping": "\u{1F634}",
          "sleeping_bed": "\u{1F6CC}",
          "sleepy": "\u{1F62A}",
          "slightly_frowning_face": "\u{1F641}",
          "slightly_smiling_face": "\u{1F642}",
          "slot_machine": "\u{1F3B0}",
          "small_airplane": "\u{1F6E9}",
          "small_blue_diamond": "\u{1F539}",
          "small_orange_diamond": "\u{1F538}",
          "small_red_triangle": "\u{1F53A}",
          "small_red_triangle_down": "\u{1F53B}",
          "smile": "\u{1F604}",
          "smile_cat": "\u{1F638}",
          "smiley": "\u{1F603}",
          "smiley_cat": "\u{1F63A}",
          "smiling_imp": "\u{1F608}",
          "smirk": "\u{1F60F}",
          "smirk_cat": "\u{1F63C}",
          "smoking": "\u{1F6AC}",
          "snail": "\u{1F40C}",
          "snake": "\u{1F40D}",
          "sneezing_face": "\u{1F927}",
          "snowboarder": "\u{1F3C2}",
          "snowflake": "\u2744\uFE0F",
          "snowman": "\u26C4\uFE0F",
          "snowman_with_snow": "\u2603\uFE0F",
          "sob": "\u{1F62D}",
          "soccer": "\u26BD\uFE0F",
          "soon": "\u{1F51C}",
          "sos": "\u{1F198}",
          "sound": "\u{1F509}",
          "space_invader": "\u{1F47E}",
          "spades": "\u2660\uFE0F",
          "spaghetti": "\u{1F35D}",
          "sparkle": "\u2747\uFE0F",
          "sparkler": "\u{1F387}",
          "sparkles": "\u2728",
          "sparkling_heart": "\u{1F496}",
          "speak_no_evil": "\u{1F64A}",
          "speaker": "\u{1F508}",
          "speaking_head": "\u{1F5E3}",
          "speech_balloon": "\u{1F4AC}",
          "speedboat": "\u{1F6A4}",
          "spider": "\u{1F577}",
          "spider_web": "\u{1F578}",
          "spiral_calendar": "\u{1F5D3}",
          "spiral_notepad": "\u{1F5D2}",
          "spoon": "\u{1F944}",
          "squid": "\u{1F991}",
          "stadium": "\u{1F3DF}",
          "star": "\u2B50\uFE0F",
          "star2": "\u{1F31F}",
          "star_and_crescent": "\u262A\uFE0F",
          "star_of_david": "\u2721\uFE0F",
          "stars": "\u{1F320}",
          "station": "\u{1F689}",
          "statue_of_liberty": "\u{1F5FD}",
          "steam_locomotive": "\u{1F682}",
          "stew": "\u{1F372}",
          "stop_button": "\u23F9",
          "stop_sign": "\u{1F6D1}",
          "stopwatch": "\u23F1",
          "straight_ruler": "\u{1F4CF}",
          "strawberry": "\u{1F353}",
          "stuck_out_tongue": "\u{1F61B}",
          "stuck_out_tongue_closed_eyes": "\u{1F61D}",
          "stuck_out_tongue_winking_eye": "\u{1F61C}",
          "studio_microphone": "\u{1F399}",
          "stuffed_flatbread": "\u{1F959}",
          "sun_behind_large_cloud": "\u{1F325}",
          "sun_behind_rain_cloud": "\u{1F326}",
          "sun_behind_small_cloud": "\u{1F324}",
          "sun_with_face": "\u{1F31E}",
          "sunflower": "\u{1F33B}",
          "sunglasses": "\u{1F60E}",
          "sunny": "\u2600\uFE0F",
          "sunrise": "\u{1F305}",
          "sunrise_over_mountains": "\u{1F304}",
          "surfing_man": "\u{1F3C4}",
          "surfing_woman": "\u{1F3C4}&zwj;\u2640\uFE0F",
          "sushi": "\u{1F363}",
          "suspension_railway": "\u{1F69F}",
          "sweat": "\u{1F613}",
          "sweat_drops": "\u{1F4A6}",
          "sweat_smile": "\u{1F605}",
          "sweet_potato": "\u{1F360}",
          "swimming_man": "\u{1F3CA}",
          "swimming_woman": "\u{1F3CA}&zwj;\u2640\uFE0F",
          "symbols": "\u{1F523}",
          "synagogue": "\u{1F54D}",
          "syringe": "\u{1F489}",
          "taco": "\u{1F32E}",
          "tada": "\u{1F389}",
          "tanabata_tree": "\u{1F38B}",
          "taurus": "\u2649\uFE0F",
          "taxi": "\u{1F695}",
          "tea": "\u{1F375}",
          "telephone_receiver": "\u{1F4DE}",
          "telescope": "\u{1F52D}",
          "tennis": "\u{1F3BE}",
          "tent": "\u26FA\uFE0F",
          "thermometer": "\u{1F321}",
          "thinking": "\u{1F914}",
          "thought_balloon": "\u{1F4AD}",
          "ticket": "\u{1F3AB}",
          "tickets": "\u{1F39F}",
          "tiger": "\u{1F42F}",
          "tiger2": "\u{1F405}",
          "timer_clock": "\u23F2",
          "tipping_hand_man": "\u{1F481}&zwj;\u2642\uFE0F",
          "tired_face": "\u{1F62B}",
          "tm": "\u2122\uFE0F",
          "toilet": "\u{1F6BD}",
          "tokyo_tower": "\u{1F5FC}",
          "tomato": "\u{1F345}",
          "tongue": "\u{1F445}",
          "top": "\u{1F51D}",
          "tophat": "\u{1F3A9}",
          "tornado": "\u{1F32A}",
          "trackball": "\u{1F5B2}",
          "tractor": "\u{1F69C}",
          "traffic_light": "\u{1F6A5}",
          "train": "\u{1F68B}",
          "train2": "\u{1F686}",
          "tram": "\u{1F68A}",
          "triangular_flag_on_post": "\u{1F6A9}",
          "triangular_ruler": "\u{1F4D0}",
          "trident": "\u{1F531}",
          "triumph": "\u{1F624}",
          "trolleybus": "\u{1F68E}",
          "trophy": "\u{1F3C6}",
          "tropical_drink": "\u{1F379}",
          "tropical_fish": "\u{1F420}",
          "truck": "\u{1F69A}",
          "trumpet": "\u{1F3BA}",
          "tulip": "\u{1F337}",
          "tumbler_glass": "\u{1F943}",
          "turkey": "\u{1F983}",
          "turtle": "\u{1F422}",
          "tv": "\u{1F4FA}",
          "twisted_rightwards_arrows": "\u{1F500}",
          "two_hearts": "\u{1F495}",
          "two_men_holding_hands": "\u{1F46C}",
          "two_women_holding_hands": "\u{1F46D}",
          "u5272": "\u{1F239}",
          "u5408": "\u{1F234}",
          "u55b6": "\u{1F23A}",
          "u6307": "\u{1F22F}\uFE0F",
          "u6708": "\u{1F237}\uFE0F",
          "u6709": "\u{1F236}",
          "u6e80": "\u{1F235}",
          "u7121": "\u{1F21A}\uFE0F",
          "u7533": "\u{1F238}",
          "u7981": "\u{1F232}",
          "u7a7a": "\u{1F233}",
          "umbrella": "\u2614\uFE0F",
          "unamused": "\u{1F612}",
          "underage": "\u{1F51E}",
          "unicorn": "\u{1F984}",
          "unlock": "\u{1F513}",
          "up": "\u{1F199}",
          "upside_down_face": "\u{1F643}",
          "v": "\u270C\uFE0F",
          "vertical_traffic_light": "\u{1F6A6}",
          "vhs": "\u{1F4FC}",
          "vibration_mode": "\u{1F4F3}",
          "video_camera": "\u{1F4F9}",
          "video_game": "\u{1F3AE}",
          "violin": "\u{1F3BB}",
          "virgo": "\u264D\uFE0F",
          "volcano": "\u{1F30B}",
          "volleyball": "\u{1F3D0}",
          "vs": "\u{1F19A}",
          "vulcan_salute": "\u{1F596}",
          "walking_man": "\u{1F6B6}",
          "walking_woman": "\u{1F6B6}&zwj;\u2640\uFE0F",
          "waning_crescent_moon": "\u{1F318}",
          "waning_gibbous_moon": "\u{1F316}",
          "warning": "\u26A0\uFE0F",
          "wastebasket": "\u{1F5D1}",
          "watch": "\u231A\uFE0F",
          "water_buffalo": "\u{1F403}",
          "watermelon": "\u{1F349}",
          "wave": "\u{1F44B}",
          "wavy_dash": "\u3030\uFE0F",
          "waxing_crescent_moon": "\u{1F312}",
          "wc": "\u{1F6BE}",
          "weary": "\u{1F629}",
          "wedding": "\u{1F492}",
          "weight_lifting_man": "\u{1F3CB}\uFE0F",
          "weight_lifting_woman": "\u{1F3CB}\uFE0F&zwj;\u2640\uFE0F",
          "whale": "\u{1F433}",
          "whale2": "\u{1F40B}",
          "wheel_of_dharma": "\u2638\uFE0F",
          "wheelchair": "\u267F\uFE0F",
          "white_check_mark": "\u2705",
          "white_circle": "\u26AA\uFE0F",
          "white_flag": "\u{1F3F3}\uFE0F",
          "white_flower": "\u{1F4AE}",
          "white_large_square": "\u2B1C\uFE0F",
          "white_medium_small_square": "\u25FD\uFE0F",
          "white_medium_square": "\u25FB\uFE0F",
          "white_small_square": "\u25AB\uFE0F",
          "white_square_button": "\u{1F533}",
          "wilted_flower": "\u{1F940}",
          "wind_chime": "\u{1F390}",
          "wind_face": "\u{1F32C}",
          "wine_glass": "\u{1F377}",
          "wink": "\u{1F609}",
          "wolf": "\u{1F43A}",
          "woman": "\u{1F469}",
          "woman_artist": "\u{1F469}&zwj;\u{1F3A8}",
          "woman_astronaut": "\u{1F469}&zwj;\u{1F680}",
          "woman_cartwheeling": "\u{1F938}&zwj;\u2640\uFE0F",
          "woman_cook": "\u{1F469}&zwj;\u{1F373}",
          "woman_facepalming": "\u{1F926}&zwj;\u2640\uFE0F",
          "woman_factory_worker": "\u{1F469}&zwj;\u{1F3ED}",
          "woman_farmer": "\u{1F469}&zwj;\u{1F33E}",
          "woman_firefighter": "\u{1F469}&zwj;\u{1F692}",
          "woman_health_worker": "\u{1F469}&zwj;\u2695\uFE0F",
          "woman_judge": "\u{1F469}&zwj;\u2696\uFE0F",
          "woman_juggling": "\u{1F939}&zwj;\u2640\uFE0F",
          "woman_mechanic": "\u{1F469}&zwj;\u{1F527}",
          "woman_office_worker": "\u{1F469}&zwj;\u{1F4BC}",
          "woman_pilot": "\u{1F469}&zwj;\u2708\uFE0F",
          "woman_playing_handball": "\u{1F93E}&zwj;\u2640\uFE0F",
          "woman_playing_water_polo": "\u{1F93D}&zwj;\u2640\uFE0F",
          "woman_scientist": "\u{1F469}&zwj;\u{1F52C}",
          "woman_shrugging": "\u{1F937}&zwj;\u2640\uFE0F",
          "woman_singer": "\u{1F469}&zwj;\u{1F3A4}",
          "woman_student": "\u{1F469}&zwj;\u{1F393}",
          "woman_teacher": "\u{1F469}&zwj;\u{1F3EB}",
          "woman_technologist": "\u{1F469}&zwj;\u{1F4BB}",
          "woman_with_turban": "\u{1F473}&zwj;\u2640\uFE0F",
          "womans_clothes": "\u{1F45A}",
          "womans_hat": "\u{1F452}",
          "women_wrestling": "\u{1F93C}&zwj;\u2640\uFE0F",
          "womens": "\u{1F6BA}",
          "world_map": "\u{1F5FA}",
          "worried": "\u{1F61F}",
          "wrench": "\u{1F527}",
          "writing_hand": "\u270D\uFE0F",
          "x": "\u274C",
          "yellow_heart": "\u{1F49B}",
          "yen": "\u{1F4B4}",
          "yin_yang": "\u262F\uFE0F",
          "yum": "\u{1F60B}",
          "zap": "\u26A1\uFE0F",
          "zipper_mouth_face": "\u{1F910}",
          "zzz": "\u{1F4A4}",
          "octocat": '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
          "showdown": `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`
        };
        showdown2.Converter = function(converterOptions) {
          "use strict";
          var options = {}, langExtensions = [], outputModifiers = [], listeners = {}, setConvFlavor = setFlavor, metadata = {
            parsed: {},
            raw: "",
            format: ""
          };
          _constructor();
          function _constructor() {
            converterOptions = converterOptions || {};
            for (var gOpt in globalOptions) {
              if (globalOptions.hasOwnProperty(gOpt)) {
                options[gOpt] = globalOptions[gOpt];
              }
            }
            if (typeof converterOptions === "object") {
              for (var opt in converterOptions) {
                if (converterOptions.hasOwnProperty(opt)) {
                  options[opt] = converterOptions[opt];
                }
              }
            } else {
              throw Error("Converter expects the passed parameter to be an object, but " + typeof converterOptions + " was passed instead.");
            }
            if (options.extensions) {
              showdown2.helper.forEach(options.extensions, _parseExtension);
            }
          }
          function _parseExtension(ext, name) {
            name = name || null;
            if (showdown2.helper.isString(ext)) {
              ext = showdown2.helper.stdExtName(ext);
              name = ext;
              if (showdown2.extensions[ext]) {
                console.warn("DEPRECATION WARNING: " + ext + " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!");
                legacyExtensionLoading(showdown2.extensions[ext], ext);
                return;
              } else if (!showdown2.helper.isUndefined(extensions[ext])) {
                ext = extensions[ext];
              } else {
                throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
              }
            }
            if (typeof ext === "function") {
              ext = ext();
            }
            if (!showdown2.helper.isArray(ext)) {
              ext = [ext];
            }
            var validExt = validate2(ext, name);
            if (!validExt.valid) {
              throw Error(validExt.error);
            }
            for (var i5 = 0; i5 < ext.length; ++i5) {
              switch (ext[i5].type) {
                case "lang":
                  langExtensions.push(ext[i5]);
                  break;
                case "output":
                  outputModifiers.push(ext[i5]);
                  break;
              }
              if (ext[i5].hasOwnProperty("listeners")) {
                for (var ln in ext[i5].listeners) {
                  if (ext[i5].listeners.hasOwnProperty(ln)) {
                    listen(ln, ext[i5].listeners[ln]);
                  }
                }
              }
            }
          }
          function legacyExtensionLoading(ext, name) {
            if (typeof ext === "function") {
              ext = ext(new showdown2.Converter());
            }
            if (!showdown2.helper.isArray(ext)) {
              ext = [ext];
            }
            var valid = validate2(ext, name);
            if (!valid.valid) {
              throw Error(valid.error);
            }
            for (var i5 = 0; i5 < ext.length; ++i5) {
              switch (ext[i5].type) {
                case "lang":
                  langExtensions.push(ext[i5]);
                  break;
                case "output":
                  outputModifiers.push(ext[i5]);
                  break;
                default:
                  throw Error("Extension loader error: Type unrecognized!!!");
              }
            }
          }
          function listen(name, callback) {
            if (!showdown2.helper.isString(name)) {
              throw Error("Invalid argument in converter.listen() method: name must be a string, but " + typeof name + " given");
            }
            if (typeof callback !== "function") {
              throw Error("Invalid argument in converter.listen() method: callback must be a function, but " + typeof callback + " given");
            }
            if (!listeners.hasOwnProperty(name)) {
              listeners[name] = [];
            }
            listeners[name].push(callback);
          }
          function rTrimInputText(text3) {
            var rsp = text3.match(/^\s*/)[0].length, rgx = new RegExp("^\\s{0," + rsp + "}", "gm");
            return text3.replace(rgx, "");
          }
          this._dispatch = function dispatch2(evtName, text3, options2, globals2) {
            if (listeners.hasOwnProperty(evtName)) {
              for (var ei = 0; ei < listeners[evtName].length; ++ei) {
                var nText = listeners[evtName][ei](evtName, text3, this, options2, globals2);
                if (nText && typeof nText !== "undefined") {
                  text3 = nText;
                }
              }
            }
            return text3;
          };
          this.listen = function(name, callback) {
            listen(name, callback);
            return this;
          };
          this.makeHtml = function(text3) {
            if (!text3) {
              return text3;
            }
            var globals2 = {
              gHtmlBlocks: [],
              gHtmlMdBlocks: [],
              gHtmlSpans: [],
              gUrls: {},
              gTitles: {},
              gDimensions: {},
              gListLevel: 0,
              hashLinkCounts: {},
              langExtensions,
              outputModifiers,
              converter: this,
              ghCodeBlocks: [],
              metadata: {
                parsed: {},
                raw: "",
                format: ""
              }
            };
            text3 = text3.replace(//g, "\xA8T");
            text3 = text3.replace(/\$/g, "\xA8D");
            text3 = text3.replace(/\r\n/g, "\n");
            text3 = text3.replace(/\r/g, "\n");
            text3 = text3.replace(/\u00A0/g, "&nbsp;");
            if (options.smartIndentationFix) {
              text3 = rTrimInputText(text3);
            }
            text3 = "\n\n" + text3 + "\n\n";
            text3 = showdown2.subParser("detab")(text3, options, globals2);
            text3 = text3.replace(/^[ \t]+$/mg, "");
            showdown2.helper.forEach(langExtensions, function(ext) {
              text3 = showdown2.subParser("runExtension")(ext, text3, options, globals2);
            });
            text3 = showdown2.subParser("metadata")(text3, options, globals2);
            text3 = showdown2.subParser("hashPreCodeTags")(text3, options, globals2);
            text3 = showdown2.subParser("githubCodeBlocks")(text3, options, globals2);
            text3 = showdown2.subParser("hashHTMLBlocks")(text3, options, globals2);
            text3 = showdown2.subParser("hashCodeTags")(text3, options, globals2);
            text3 = showdown2.subParser("stripLinkDefinitions")(text3, options, globals2);
            text3 = showdown2.subParser("blockGamut")(text3, options, globals2);
            text3 = showdown2.subParser("unhashHTMLSpans")(text3, options, globals2);
            text3 = showdown2.subParser("unescapeSpecialChars")(text3, options, globals2);
            text3 = text3.replace(/D/g, "$$");
            text3 = text3.replace(/T/g, "\xA8");
            text3 = showdown2.subParser("completeHTMLDocument")(text3, options, globals2);
            showdown2.helper.forEach(outputModifiers, function(ext) {
              text3 = showdown2.subParser("runExtension")(ext, text3, options, globals2);
            });
            metadata = globals2.metadata;
            return text3;
          };
          this.makeMarkdown = this.makeMd = function(src, HTMLParser) {
            src = src.replace(/\r\n/g, "\n");
            src = src.replace(/\r/g, "\n");
            src = src.replace(/>[ \t]+</, ">\xA8NBSP;<");
            if (!HTMLParser) {
              if (window && window.document) {
                HTMLParser = window.document;
              } else {
                throw new Error("HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM");
              }
            }
            var doc = HTMLParser.createElement("div");
            doc.innerHTML = src;
            var globals2 = {
              preList: substitutePreCodeTags(doc)
            };
            clean(doc);
            var nodes = doc.childNodes, mdDoc = "";
            for (var i5 = 0; i5 < nodes.length; i5++) {
              mdDoc += showdown2.subParser("makeMarkdown.node")(nodes[i5], globals2);
            }
            function clean(node) {
              for (var n5 = 0; n5 < node.childNodes.length; ++n5) {
                var child = node.childNodes[n5];
                if (child.nodeType === 3) {
                  if (!/\S/.test(child.nodeValue)) {
                    node.removeChild(child);
                    --n5;
                  } else {
                    child.nodeValue = child.nodeValue.split("\n").join(" ");
                    child.nodeValue = child.nodeValue.replace(/(\s)+/g, "$1");
                  }
                } else if (child.nodeType === 1) {
                  clean(child);
                }
              }
            }
            function substitutePreCodeTags(doc2) {
              var pres = doc2.querySelectorAll("pre"), presPH = [];
              for (var i6 = 0; i6 < pres.length; ++i6) {
                if (pres[i6].childElementCount === 1 && pres[i6].firstChild.tagName.toLowerCase() === "code") {
                  var content = pres[i6].firstChild.innerHTML.trim(), language = pres[i6].firstChild.getAttribute("data-language") || "";
                  if (language === "") {
                    var classes = pres[i6].firstChild.className.split(" ");
                    for (var c6 = 0; c6 < classes.length; ++c6) {
                      var matches2 = classes[c6].match(/^language-(.+)$/);
                      if (matches2 !== null) {
                        language = matches2[1];
                        break;
                      }
                    }
                  }
                  content = showdown2.helper.unescapeHTMLEntities(content);
                  presPH.push(content);
                  pres[i6].outerHTML = '<precode language="' + language + '" precodenum="' + i6.toString() + '"></precode>';
                } else {
                  presPH.push(pres[i6].innerHTML);
                  pres[i6].innerHTML = "";
                  pres[i6].setAttribute("prenum", i6.toString());
                }
              }
              return presPH;
            }
            return mdDoc;
          };
          this.setOption = function(key, value) {
            options[key] = value;
          };
          this.getOption = function(key) {
            return options[key];
          };
          this.getOptions = function() {
            return options;
          };
          this.addExtension = function(extension, name) {
            name = name || null;
            _parseExtension(extension, name);
          };
          this.useExtension = function(extensionName) {
            _parseExtension(extensionName);
          };
          this.setFlavor = function(name) {
            if (!flavor.hasOwnProperty(name)) {
              throw Error(name + " flavor was not found");
            }
            var preset = flavor[name];
            setConvFlavor = name;
            for (var option in preset) {
              if (preset.hasOwnProperty(option)) {
                options[option] = preset[option];
              }
            }
          };
          this.getFlavor = function() {
            return setConvFlavor;
          };
          this.removeExtension = function(extension) {
            if (!showdown2.helper.isArray(extension)) {
              extension = [extension];
            }
            for (var a6 = 0; a6 < extension.length; ++a6) {
              var ext = extension[a6];
              for (var i5 = 0; i5 < langExtensions.length; ++i5) {
                if (langExtensions[i5] === ext) {
                  langExtensions[i5].splice(i5, 1);
                }
              }
              for (var ii = 0; ii < outputModifiers.length; ++i5) {
                if (outputModifiers[ii] === ext) {
                  outputModifiers[ii].splice(i5, 1);
                }
              }
            }
          };
          this.getAllExtensions = function() {
            return {
              language: langExtensions,
              output: outputModifiers
            };
          };
          this.getMetadata = function(raw) {
            if (raw) {
              return metadata.raw;
            } else {
              return metadata.parsed;
            }
          };
          this.getMetadataFormat = function() {
            return metadata.format;
          };
          this._setMetadataPair = function(key, value) {
            metadata.parsed[key] = value;
          };
          this._setMetadataFormat = function(format) {
            metadata.format = format;
          };
          this._setMetadataRaw = function(raw) {
            metadata.raw = raw;
          };
        };
        showdown2.subParser("anchors", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("anchors.before", text3, options, globals2);
          var writeAnchorTag = function(wholeMatch, linkText, linkId, url, m5, m6, title) {
            if (showdown2.helper.isUndefined(title)) {
              title = "";
            }
            linkId = linkId.toLowerCase();
            if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
              url = "";
            } else if (!url) {
              if (!linkId) {
                linkId = linkText.toLowerCase().replace(/ ?\n/g, " ");
              }
              url = "#" + linkId;
              if (!showdown2.helper.isUndefined(globals2.gUrls[linkId])) {
                url = globals2.gUrls[linkId];
                if (!showdown2.helper.isUndefined(globals2.gTitles[linkId])) {
                  title = globals2.gTitles[linkId];
                }
              } else {
                return wholeMatch;
              }
            }
            url = url.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            var result = '<a href="' + url + '"';
            if (title !== "" && title !== null) {
              title = title.replace(/"/g, "&quot;");
              title = title.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
              result += ' title="' + title + '"';
            }
            if (options.openLinksInNewWindow && !/^#/.test(url)) {
              result += ' rel="noopener noreferrer" target="\xA8E95Eblank"';
            }
            result += ">" + linkText + "</a>";
            return result;
          };
          text3 = text3.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);
          text3 = text3.replace(
            /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
            writeAnchorTag
          );
          text3 = text3.replace(
            /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
            writeAnchorTag
          );
          text3 = text3.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);
          if (options.ghMentions) {
            text3 = text3.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function(wm, st, escape, mentions, username) {
              if (escape === "\\") {
                return st + mentions;
              }
              if (!showdown2.helper.isString(options.ghMentionsLink)) {
                throw new Error("ghMentionsLink option must be a string");
              }
              var lnk = options.ghMentionsLink.replace(/\{u}/g, username), target = "";
              if (options.openLinksInNewWindow) {
                target = ' rel="noopener noreferrer" target="\xA8E95Eblank"';
              }
              return st + '<a href="' + lnk + '"' + target + ">" + mentions + "</a>";
            });
          }
          text3 = globals2.converter._dispatch("anchors.after", text3, options, globals2);
          return text3;
        });
        var simpleURLRegex = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi, simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi, delimUrlRegex = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi, simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi, delimMailRegex = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi, replaceLink = function(options) {
          "use strict";
          return function(wm, leadingMagicChars, link, m22, m32, trailingPunctuation, trailingMagicChars) {
            link = link.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            var lnkTxt = link, append2 = "", target = "", lmc = leadingMagicChars || "", tmc = trailingMagicChars || "";
            if (/^www\./i.test(link)) {
              link = link.replace(/^www\./i, "http://www.");
            }
            if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
              append2 = trailingPunctuation;
            }
            if (options.openLinksInNewWindow) {
              target = ' rel="noopener noreferrer" target="\xA8E95Eblank"';
            }
            return lmc + '<a href="' + link + '"' + target + ">" + lnkTxt + "</a>" + append2 + tmc;
          };
        }, replaceMail = function(options, globals2) {
          "use strict";
          return function(wholeMatch, b6, mail) {
            var href = "mailto:";
            b6 = b6 || "";
            mail = showdown2.subParser("unescapeSpecialChars")(mail, options, globals2);
            if (options.encodeEmails) {
              href = showdown2.helper.encodeEmailAddress(href + mail);
              mail = showdown2.helper.encodeEmailAddress(mail);
            } else {
              href = href + mail;
            }
            return b6 + '<a href="' + href + '">' + mail + "</a>";
          };
        };
        showdown2.subParser("autoLinks", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("autoLinks.before", text3, options, globals2);
          text3 = text3.replace(delimUrlRegex, replaceLink(options));
          text3 = text3.replace(delimMailRegex, replaceMail(options, globals2));
          text3 = globals2.converter._dispatch("autoLinks.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("simplifiedAutoLinks", function(text3, options, globals2) {
          "use strict";
          if (!options.simplifiedAutoLink) {
            return text3;
          }
          text3 = globals2.converter._dispatch("simplifiedAutoLinks.before", text3, options, globals2);
          if (options.excludeTrailingPunctuationFromURLs) {
            text3 = text3.replace(simpleURLRegex2, replaceLink(options));
          } else {
            text3 = text3.replace(simpleURLRegex, replaceLink(options));
          }
          text3 = text3.replace(simpleMailRegex, replaceMail(options, globals2));
          text3 = globals2.converter._dispatch("simplifiedAutoLinks.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("blockGamut", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("blockGamut.before", text3, options, globals2);
          text3 = showdown2.subParser("blockQuotes")(text3, options, globals2);
          text3 = showdown2.subParser("headers")(text3, options, globals2);
          text3 = showdown2.subParser("horizontalRule")(text3, options, globals2);
          text3 = showdown2.subParser("lists")(text3, options, globals2);
          text3 = showdown2.subParser("codeBlocks")(text3, options, globals2);
          text3 = showdown2.subParser("tables")(text3, options, globals2);
          text3 = showdown2.subParser("hashHTMLBlocks")(text3, options, globals2);
          text3 = showdown2.subParser("paragraphs")(text3, options, globals2);
          text3 = globals2.converter._dispatch("blockGamut.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("blockQuotes", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("blockQuotes.before", text3, options, globals2);
          text3 = text3 + "\n\n";
          var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
          if (options.splitAdjacentBlockquotes) {
            rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
          }
          text3 = text3.replace(rgx, function(bq) {
            bq = bq.replace(/^[ \t]*>[ \t]?/gm, "");
            bq = bq.replace(/0/g, "");
            bq = bq.replace(/^[ \t]+$/gm, "");
            bq = showdown2.subParser("githubCodeBlocks")(bq, options, globals2);
            bq = showdown2.subParser("blockGamut")(bq, options, globals2);
            bq = bq.replace(/(^|\n)/g, "$1  ");
            bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(wholeMatch, m1) {
              var pre = m1;
              pre = pre.replace(/^  /mg, "\xA80");
              pre = pre.replace(/0/g, "");
              return pre;
            });
            return showdown2.subParser("hashBlock")("<blockquote>\n" + bq + "\n</blockquote>", options, globals2);
          });
          text3 = globals2.converter._dispatch("blockQuotes.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("codeBlocks", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("codeBlocks.before", text3, options, globals2);
          text3 += "\xA80";
          var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
          text3 = text3.replace(pattern, function(wholeMatch, m1, m22) {
            var codeblock = m1, nextChar = m22, end = "\n";
            codeblock = showdown2.subParser("outdent")(codeblock, options, globals2);
            codeblock = showdown2.subParser("encodeCode")(codeblock, options, globals2);
            codeblock = showdown2.subParser("detab")(codeblock, options, globals2);
            codeblock = codeblock.replace(/^\n+/g, "");
            codeblock = codeblock.replace(/\n+$/g, "");
            if (options.omitExtraWLInCodeBlocks) {
              end = "";
            }
            codeblock = "<pre><code>" + codeblock + end + "</code></pre>";
            return showdown2.subParser("hashBlock")(codeblock, options, globals2) + nextChar;
          });
          text3 = text3.replace(/0/, "");
          text3 = globals2.converter._dispatch("codeBlocks.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("codeSpans", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("codeSpans.before", text3, options, globals2);
          if (typeof text3 === "undefined") {
            text3 = "";
          }
          text3 = text3.replace(
            /(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
            function(wholeMatch, m1, m22, m32) {
              var c6 = m32;
              c6 = c6.replace(/^([ \t]*)/g, "");
              c6 = c6.replace(/[ \t]*$/g, "");
              c6 = showdown2.subParser("encodeCode")(c6, options, globals2);
              c6 = m1 + "<code>" + c6 + "</code>";
              c6 = showdown2.subParser("hashHTMLSpans")(c6, options, globals2);
              return c6;
            }
          );
          text3 = globals2.converter._dispatch("codeSpans.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("completeHTMLDocument", function(text3, options, globals2) {
          "use strict";
          if (!options.completeHTMLDocument) {
            return text3;
          }
          text3 = globals2.converter._dispatch("completeHTMLDocument.before", text3, options, globals2);
          var doctype = "html", doctypeParsed = "<!DOCTYPE HTML>\n", title = "", charset = '<meta charset="utf-8">\n', lang = "", metadata = "";
          if (typeof globals2.metadata.parsed.doctype !== "undefined") {
            doctypeParsed = "<!DOCTYPE " + globals2.metadata.parsed.doctype + ">\n";
            doctype = globals2.metadata.parsed.doctype.toString().toLowerCase();
            if (doctype === "html" || doctype === "html5") {
              charset = '<meta charset="utf-8">';
            }
          }
          for (var meta in globals2.metadata.parsed) {
            if (globals2.metadata.parsed.hasOwnProperty(meta)) {
              switch (meta.toLowerCase()) {
                case "doctype":
                  break;
                case "title":
                  title = "<title>" + globals2.metadata.parsed.title + "</title>\n";
                  break;
                case "charset":
                  if (doctype === "html" || doctype === "html5") {
                    charset = '<meta charset="' + globals2.metadata.parsed.charset + '">\n';
                  } else {
                    charset = '<meta name="charset" content="' + globals2.metadata.parsed.charset + '">\n';
                  }
                  break;
                case "language":
                case "lang":
                  lang = ' lang="' + globals2.metadata.parsed[meta] + '"';
                  metadata += '<meta name="' + meta + '" content="' + globals2.metadata.parsed[meta] + '">\n';
                  break;
                default:
                  metadata += '<meta name="' + meta + '" content="' + globals2.metadata.parsed[meta] + '">\n';
              }
            }
          }
          text3 = doctypeParsed + "<html" + lang + ">\n<head>\n" + title + charset + metadata + "</head>\n<body>\n" + text3.trim() + "\n</body>\n</html>";
          text3 = globals2.converter._dispatch("completeHTMLDocument.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("detab", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("detab.before", text3, options, globals2);
          text3 = text3.replace(/\t(?=\t)/g, "    ");
          text3 = text3.replace(/\t/g, "\xA8A\xA8B");
          text3 = text3.replace(/B(.+?)A/g, function(wholeMatch, m1) {
            var leadingText = m1, numSpaces = 4 - leadingText.length % 4;
            for (var i5 = 0; i5 < numSpaces; i5++) {
              leadingText += " ";
            }
            return leadingText;
          });
          text3 = text3.replace(/A/g, "    ");
          text3 = text3.replace(/B/g, "");
          text3 = globals2.converter._dispatch("detab.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("ellipsis", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("ellipsis.before", text3, options, globals2);
          text3 = text3.replace(/\.\.\./g, "\u2026");
          text3 = globals2.converter._dispatch("ellipsis.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("emoji", function(text3, options, globals2) {
          "use strict";
          if (!options.emoji) {
            return text3;
          }
          text3 = globals2.converter._dispatch("emoji.before", text3, options, globals2);
          var emojiRgx = /:([\S]+?):/g;
          text3 = text3.replace(emojiRgx, function(wm, emojiCode) {
            if (showdown2.helper.emojis.hasOwnProperty(emojiCode)) {
              return showdown2.helper.emojis[emojiCode];
            }
            return wm;
          });
          text3 = globals2.converter._dispatch("emoji.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("encodeAmpsAndAngles", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("encodeAmpsAndAngles.before", text3, options, globals2);
          text3 = text3.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;");
          text3 = text3.replace(/<(?![a-z\/?$!])/gi, "&lt;");
          text3 = text3.replace(/</g, "&lt;");
          text3 = text3.replace(/>/g, "&gt;");
          text3 = globals2.converter._dispatch("encodeAmpsAndAngles.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("encodeBackslashEscapes", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("encodeBackslashEscapes.before", text3, options, globals2);
          text3 = text3.replace(/\\(\\)/g, showdown2.helper.escapeCharactersCallback);
          text3 = text3.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown2.helper.escapeCharactersCallback);
          text3 = globals2.converter._dispatch("encodeBackslashEscapes.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("encodeCode", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("encodeCode.before", text3, options, globals2);
          text3 = text3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([*_{}\[\]\\=~-])/g, showdown2.helper.escapeCharactersCallback);
          text3 = globals2.converter._dispatch("encodeCode.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("escapeSpecialCharsWithinTagAttributes", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("escapeSpecialCharsWithinTagAttributes.before", text3, options, globals2);
          var tags = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi, comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
          text3 = text3.replace(tags, function(wholeMatch) {
            return wholeMatch.replace(/(.)<\/?code>(?=.)/g, "$1`").replace(/([\\`*_~=|])/g, showdown2.helper.escapeCharactersCallback);
          });
          text3 = text3.replace(comments, function(wholeMatch) {
            return wholeMatch.replace(/([\\`*_~=|])/g, showdown2.helper.escapeCharactersCallback);
          });
          text3 = globals2.converter._dispatch("escapeSpecialCharsWithinTagAttributes.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("githubCodeBlocks", function(text3, options, globals2) {
          "use strict";
          if (!options.ghCodeBlocks) {
            return text3;
          }
          text3 = globals2.converter._dispatch("githubCodeBlocks.before", text3, options, globals2);
          text3 += "\xA80";
          text3 = text3.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function(wholeMatch, delim, language, codeblock) {
            var end = options.omitExtraWLInCodeBlocks ? "" : "\n";
            codeblock = showdown2.subParser("encodeCode")(codeblock, options, globals2);
            codeblock = showdown2.subParser("detab")(codeblock, options, globals2);
            codeblock = codeblock.replace(/^\n+/g, "");
            codeblock = codeblock.replace(/\n+$/g, "");
            codeblock = "<pre><code" + (language ? ' class="' + language + " language-" + language + '"' : "") + ">" + codeblock + end + "</code></pre>";
            codeblock = showdown2.subParser("hashBlock")(codeblock, options, globals2);
            return "\n\n\xA8G" + (globals2.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
          });
          text3 = text3.replace(/0/, "");
          return globals2.converter._dispatch("githubCodeBlocks.after", text3, options, globals2);
        });
        showdown2.subParser("hashBlock", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("hashBlock.before", text3, options, globals2);
          text3 = text3.replace(/(^\n+|\n+$)/g, "");
          text3 = "\n\n\xA8K" + (globals2.gHtmlBlocks.push(text3) - 1) + "K\n\n";
          text3 = globals2.converter._dispatch("hashBlock.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("hashCodeTags", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("hashCodeTags.before", text3, options, globals2);
          var repFunc = function(wholeMatch, match, left, right) {
            var codeblock = left + showdown2.subParser("encodeCode")(match, options, globals2) + right;
            return "\xA8C" + (globals2.gHtmlSpans.push(codeblock) - 1) + "C";
          };
          text3 = showdown2.helper.replaceRecursiveRegExp(text3, repFunc, "<code\\b[^>]*>", "</code>", "gim");
          text3 = globals2.converter._dispatch("hashCodeTags.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("hashElement", function(text3, options, globals2) {
          "use strict";
          return function(wholeMatch, m1) {
            var blockText = m1;
            blockText = blockText.replace(/\n\n/g, "\n");
            blockText = blockText.replace(/^\n/, "");
            blockText = blockText.replace(/\n+$/g, "");
            blockText = "\n\n\xA8K" + (globals2.gHtmlBlocks.push(blockText) - 1) + "K\n\n";
            return blockText;
          };
        });
        showdown2.subParser("hashHTMLBlocks", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("hashHTMLBlocks.before", text3, options, globals2);
          var blockTags = [
            "pre",
            "div",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "blockquote",
            "table",
            "dl",
            "ol",
            "ul",
            "script",
            "noscript",
            "form",
            "fieldset",
            "iframe",
            "math",
            "style",
            "section",
            "header",
            "footer",
            "nav",
            "article",
            "aside",
            "address",
            "audio",
            "canvas",
            "figure",
            "hgroup",
            "output",
            "video",
            "p"
          ], repFunc = function(wholeMatch, match, left, right) {
            var txt = wholeMatch;
            if (left.search(/\bmarkdown\b/) !== -1) {
              txt = left + globals2.converter.makeHtml(match) + right;
            }
            return "\n\n\xA8K" + (globals2.gHtmlBlocks.push(txt) - 1) + "K\n\n";
          };
          if (options.backslashEscapesHTMLTags) {
            text3 = text3.replace(/\\<(\/?[^>]+?)>/g, function(wm, inside) {
              return "&lt;" + inside + "&gt;";
            });
          }
          for (var i5 = 0; i5 < blockTags.length; ++i5) {
            var opTagPos, rgx1 = new RegExp("^ {0,3}(<" + blockTags[i5] + "\\b[^>]*>)", "im"), patLeft = "<" + blockTags[i5] + "\\b[^>]*>", patRight = "</" + blockTags[i5] + ">";
            while ((opTagPos = showdown2.helper.regexIndexOf(text3, rgx1)) !== -1) {
              var subTexts = showdown2.helper.splitAtIndex(text3, opTagPos), newSubText1 = showdown2.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, "im");
              if (newSubText1 === subTexts[1]) {
                break;
              }
              text3 = subTexts[0].concat(newSubText1);
            }
          }
          text3 = text3.replace(
            /(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
            showdown2.subParser("hashElement")(text3, options, globals2)
          );
          text3 = showdown2.helper.replaceRecursiveRegExp(text3, function(txt) {
            return "\n\n\xA8K" + (globals2.gHtmlBlocks.push(txt) - 1) + "K\n\n";
          }, "^ {0,3}<!--", "-->", "gm");
          text3 = text3.replace(
            /(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
            showdown2.subParser("hashElement")(text3, options, globals2)
          );
          text3 = globals2.converter._dispatch("hashHTMLBlocks.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("hashHTMLSpans", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("hashHTMLSpans.before", text3, options, globals2);
          function hashHTMLSpan(html2) {
            return "\xA8C" + (globals2.gHtmlSpans.push(html2) - 1) + "C";
          }
          text3 = text3.replace(/<[^>]+?\/>/gi, function(wm) {
            return hashHTMLSpan(wm);
          });
          text3 = text3.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function(wm) {
            return hashHTMLSpan(wm);
          });
          text3 = text3.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function(wm) {
            return hashHTMLSpan(wm);
          });
          text3 = text3.replace(/<[^>]+?>/gi, function(wm) {
            return hashHTMLSpan(wm);
          });
          text3 = globals2.converter._dispatch("hashHTMLSpans.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("unhashHTMLSpans", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("unhashHTMLSpans.before", text3, options, globals2);
          for (var i5 = 0; i5 < globals2.gHtmlSpans.length; ++i5) {
            var repText = globals2.gHtmlSpans[i5], limit = 0;
            while (/C(\d+)C/.test(repText)) {
              var num = RegExp.$1;
              repText = repText.replace("\xA8C" + num + "C", globals2.gHtmlSpans[num]);
              if (limit === 10) {
                console.error("maximum nesting of 10 spans reached!!!");
                break;
              }
              ++limit;
            }
            text3 = text3.replace("\xA8C" + i5 + "C", repText);
          }
          text3 = globals2.converter._dispatch("unhashHTMLSpans.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("hashPreCodeTags", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("hashPreCodeTags.before", text3, options, globals2);
          var repFunc = function(wholeMatch, match, left, right) {
            var codeblock = left + showdown2.subParser("encodeCode")(match, options, globals2) + right;
            return "\n\n\xA8G" + (globals2.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + "G\n\n";
          };
          text3 = showdown2.helper.replaceRecursiveRegExp(text3, repFunc, "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>", "^ {0,3}</code>\\s*</pre>", "gim");
          text3 = globals2.converter._dispatch("hashPreCodeTags.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("headers", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("headers.before", text3, options, globals2);
          var headerLevelStart = isNaN(parseInt(options.headerLevelStart)) ? 1 : parseInt(options.headerLevelStart), setextRegexH1 = options.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm, setextRegexH2 = options.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
          text3 = text3.replace(setextRegexH1, function(wholeMatch, m1) {
            var spanGamut = showdown2.subParser("spanGamut")(m1, options, globals2), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
            return showdown2.subParser("hashBlock")(hashBlock, options, globals2);
          });
          text3 = text3.replace(setextRegexH2, function(matchFound, m1) {
            var spanGamut = showdown2.subParser("spanGamut")(m1, options, globals2), hID = options.noHeaderId ? "" : ' id="' + headerId(m1) + '"', hLevel = headerLevelStart + 1, hashBlock = "<h" + hLevel + hID + ">" + spanGamut + "</h" + hLevel + ">";
            return showdown2.subParser("hashBlock")(hashBlock, options, globals2);
          });
          var atxStyle = options.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
          text3 = text3.replace(atxStyle, function(wholeMatch, m1, m22) {
            var hText = m22;
            if (options.customizedHeaderId) {
              hText = m22.replace(/\s?\{([^{]+?)}\s*$/, "");
            }
            var span = showdown2.subParser("spanGamut")(hText, options, globals2), hID = options.noHeaderId ? "" : ' id="' + headerId(m22) + '"', hLevel = headerLevelStart - 1 + m1.length, header = "<h" + hLevel + hID + ">" + span + "</h" + hLevel + ">";
            return showdown2.subParser("hashBlock")(header, options, globals2);
          });
          function headerId(m4) {
            var title, prefix2;
            if (options.customizedHeaderId) {
              var match = m4.match(/\{([^{]+?)}\s*$/);
              if (match && match[1]) {
                m4 = match[1];
              }
            }
            title = m4;
            if (showdown2.helper.isString(options.prefixHeaderId)) {
              prefix2 = options.prefixHeaderId;
            } else if (options.prefixHeaderId === true) {
              prefix2 = "section-";
            } else {
              prefix2 = "";
            }
            if (!options.rawPrefixHeaderId) {
              title = prefix2 + title;
            }
            if (options.ghCompatibleHeaderId) {
              title = title.replace(/ /g, "-").replace(/&amp;/g, "").replace(/T/g, "").replace(/D/g, "").replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, "").toLowerCase();
            } else if (options.rawHeaderId) {
              title = title.replace(/ /g, "-").replace(/&amp;/g, "&").replace(/T/g, "\xA8").replace(/D/g, "$").replace(/["']/g, "-").toLowerCase();
            } else {
              title = title.replace(/[^\w]/g, "").toLowerCase();
            }
            if (options.rawPrefixHeaderId) {
              title = prefix2 + title;
            }
            if (globals2.hashLinkCounts[title]) {
              title = title + "-" + globals2.hashLinkCounts[title]++;
            } else {
              globals2.hashLinkCounts[title] = 1;
            }
            return title;
          }
          text3 = globals2.converter._dispatch("headers.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("horizontalRule", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("horizontalRule.before", text3, options, globals2);
          var key = showdown2.subParser("hashBlock")("<hr />", options, globals2);
          text3 = text3.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
          text3 = text3.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
          text3 = text3.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);
          text3 = globals2.converter._dispatch("horizontalRule.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("images", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("images.before", text3, options, globals2);
          var inlineRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, crazyRegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g, base64RegExp = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, referenceRegExp = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g, refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;
          function writeImageTagBase64(wholeMatch, altText, linkId, url, width3, height, m5, title) {
            url = url.replace(/\s/g, "");
            return writeImageTag(wholeMatch, altText, linkId, url, width3, height, m5, title);
          }
          function writeImageTag(wholeMatch, altText, linkId, url, width3, height, m5, title) {
            var gUrls = globals2.gUrls, gTitles = globals2.gTitles, gDims = globals2.gDimensions;
            linkId = linkId.toLowerCase();
            if (!title) {
              title = "";
            }
            if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
              url = "";
            } else if (url === "" || url === null) {
              if (linkId === "" || linkId === null) {
                linkId = altText.toLowerCase().replace(/ ?\n/g, " ");
              }
              url = "#" + linkId;
              if (!showdown2.helper.isUndefined(gUrls[linkId])) {
                url = gUrls[linkId];
                if (!showdown2.helper.isUndefined(gTitles[linkId])) {
                  title = gTitles[linkId];
                }
                if (!showdown2.helper.isUndefined(gDims[linkId])) {
                  width3 = gDims[linkId].width;
                  height = gDims[linkId].height;
                }
              } else {
                return wholeMatch;
              }
            }
            altText = altText.replace(/"/g, "&quot;").replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            url = url.replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
            var result = '<img src="' + url + '" alt="' + altText + '"';
            if (title && showdown2.helper.isString(title)) {
              title = title.replace(/"/g, "&quot;").replace(showdown2.helper.regexes.asteriskDashAndColon, showdown2.helper.escapeCharactersCallback);
              result += ' title="' + title + '"';
            }
            if (width3 && height) {
              width3 = width3 === "*" ? "auto" : width3;
              height = height === "*" ? "auto" : height;
              result += ' width="' + width3 + '"';
              result += ' height="' + height + '"';
            }
            result += " />";
            return result;
          }
          text3 = text3.replace(referenceRegExp, writeImageTag);
          text3 = text3.replace(base64RegExp, writeImageTagBase64);
          text3 = text3.replace(crazyRegExp, writeImageTag);
          text3 = text3.replace(inlineRegExp, writeImageTag);
          text3 = text3.replace(refShortcutRegExp, writeImageTag);
          text3 = globals2.converter._dispatch("images.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("italicsAndBold", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("italicsAndBold.before", text3, options, globals2);
          function parseInside(txt, left, right) {
            return left + txt + right;
          }
          if (options.literalMidWordUnderscores) {
            text3 = text3.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
              return parseInside(txt, "<strong><em>", "</em></strong>");
            });
            text3 = text3.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
              return parseInside(txt, "<strong>", "</strong>");
            });
            text3 = text3.replace(/\b_(\S[\s\S]*?)_\b/g, function(wm, txt) {
              return parseInside(txt, "<em>", "</em>");
            });
          } else {
            text3 = text3.replace(/___(\S[\s\S]*?)___/g, function(wm, m4) {
              return /\S$/.test(m4) ? parseInside(m4, "<strong><em>", "</em></strong>") : wm;
            });
            text3 = text3.replace(/__(\S[\s\S]*?)__/g, function(wm, m4) {
              return /\S$/.test(m4) ? parseInside(m4, "<strong>", "</strong>") : wm;
            });
            text3 = text3.replace(/_([^\s_][\s\S]*?)_/g, function(wm, m4) {
              return /\S$/.test(m4) ? parseInside(m4, "<em>", "</em>") : wm;
            });
          }
          if (options.literalMidWordAsterisks) {
            text3 = text3.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function(wm, lead, txt) {
              return parseInside(txt, lead + "<strong><em>", "</em></strong>");
            });
            text3 = text3.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function(wm, lead, txt) {
              return parseInside(txt, lead + "<strong>", "</strong>");
            });
            text3 = text3.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function(wm, lead, txt) {
              return parseInside(txt, lead + "<em>", "</em>");
            });
          } else {
            text3 = text3.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function(wm, m4) {
              return /\S$/.test(m4) ? parseInside(m4, "<strong><em>", "</em></strong>") : wm;
            });
            text3 = text3.replace(/\*\*(\S[\s\S]*?)\*\*/g, function(wm, m4) {
              return /\S$/.test(m4) ? parseInside(m4, "<strong>", "</strong>") : wm;
            });
            text3 = text3.replace(/\*([^\s*][\s\S]*?)\*/g, function(wm, m4) {
              return /\S$/.test(m4) ? parseInside(m4, "<em>", "</em>") : wm;
            });
          }
          text3 = globals2.converter._dispatch("italicsAndBold.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("lists", function(text3, options, globals2) {
          "use strict";
          function processListItems(listStr, trimTrailing) {
            globals2.gListLevel++;
            listStr = listStr.replace(/\n{2,}$/, "\n");
            listStr += "\xA80";
            var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm, isParagraphed = /\n[ \t]*\n(?!0)/.test(listStr);
            if (options.disableForced4SpacesIndentedSublists) {
              rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm;
            }
            listStr = listStr.replace(rgx, function(wholeMatch, m1, m22, m32, m4, taskbtn, checked) {
              checked = checked && checked.trim() !== "";
              var item2 = showdown2.subParser("outdent")(m4, options, globals2), bulletStyle = "";
              if (taskbtn && options.tasklists) {
                bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
                item2 = item2.replace(/^[ \t]*\[(x|X| )?]/m, function() {
                  var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
                  if (checked) {
                    otp += " checked";
                  }
                  otp += ">";
                  return otp;
                });
              }
              item2 = item2.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function(wm2) {
                return "\xA8A" + wm2;
              });
              if (m1 || item2.search(/\n{2,}/) > -1) {
                item2 = showdown2.subParser("githubCodeBlocks")(item2, options, globals2);
                item2 = showdown2.subParser("blockGamut")(item2, options, globals2);
              } else {
                item2 = showdown2.subParser("lists")(item2, options, globals2);
                item2 = item2.replace(/\n$/, "");
                item2 = showdown2.subParser("hashHTMLBlocks")(item2, options, globals2);
                item2 = item2.replace(/\n\n+/g, "\n\n");
                if (isParagraphed) {
                  item2 = showdown2.subParser("paragraphs")(item2, options, globals2);
                } else {
                  item2 = showdown2.subParser("spanGamut")(item2, options, globals2);
                }
              }
              item2 = item2.replace("\xA8A", "");
              item2 = "<li" + bulletStyle + ">" + item2 + "</li>\n";
              return item2;
            });
            listStr = listStr.replace(/0/g, "");
            globals2.gListLevel--;
            if (trimTrailing) {
              listStr = listStr.replace(/\s+$/, "");
            }
            return listStr;
          }
          function styleStartNumber(list, listType) {
            if (listType === "ol") {
              var res = list.match(/^ *(\d+)\./);
              if (res && res[1] !== "1") {
                return ' start="' + res[1] + '"';
              }
            }
            return "";
          }
          function parseConsecutiveLists(list, listType, trimTrailing) {
            var olRgx = options.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm, ulRgx = options.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm, counterRxg = listType === "ul" ? olRgx : ulRgx, result = "";
            if (list.search(counterRxg) !== -1) {
              (function parseCL(txt) {
                var pos = txt.search(counterRxg), style2 = styleStartNumber(list, listType);
                if (pos !== -1) {
                  result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt.slice(0, pos), !!trimTrailing) + "</" + listType + ">\n";
                  listType = listType === "ul" ? "ol" : "ul";
                  counterRxg = listType === "ul" ? olRgx : ulRgx;
                  parseCL(txt.slice(pos));
                } else {
                  result += "\n\n<" + listType + style2 + ">\n" + processListItems(txt, !!trimTrailing) + "</" + listType + ">\n";
                }
              })(list);
            } else {
              var style = styleStartNumber(list, listType);
              result = "\n\n<" + listType + style + ">\n" + processListItems(list, !!trimTrailing) + "</" + listType + ">\n";
            }
            return result;
          }
          text3 = globals2.converter._dispatch("lists.before", text3, options, globals2);
          text3 += "\xA80";
          if (globals2.gListLevel) {
            text3 = text3.replace(
              /^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
              function(wholeMatch, list, m22) {
                var listType = m22.search(/[*+-]/g) > -1 ? "ul" : "ol";
                return parseConsecutiveLists(list, listType, true);
              }
            );
          } else {
            text3 = text3.replace(
              /(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
              function(wholeMatch, m1, list, m32) {
                var listType = m32.search(/[*+-]/g) > -1 ? "ul" : "ol";
                return parseConsecutiveLists(list, listType, false);
              }
            );
          }
          text3 = text3.replace(/0/, "");
          text3 = globals2.converter._dispatch("lists.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("metadata", function(text3, options, globals2) {
          "use strict";
          if (!options.metadata) {
            return text3;
          }
          text3 = globals2.converter._dispatch("metadata.before", text3, options, globals2);
          function parseMetadataContents(content) {
            globals2.metadata.raw = content;
            content = content.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
            content = content.replace(/\n {4}/g, " ");
            content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function(wm, key, value) {
              globals2.metadata.parsed[key] = value;
              return "";
            });
          }
          text3 = text3.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function(wholematch, format, content) {
            parseMetadataContents(content);
            return "\xA8M";
          });
          text3 = text3.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function(wholematch, format, content) {
            if (format) {
              globals2.metadata.format = format;
            }
            parseMetadataContents(content);
            return "\xA8M";
          });
          text3 = text3.replace(/M/g, "");
          text3 = globals2.converter._dispatch("metadata.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("outdent", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("outdent.before", text3, options, globals2);
          text3 = text3.replace(/^(\t|[ ]{1,4})/gm, "\xA80");
          text3 = text3.replace(/0/g, "");
          text3 = globals2.converter._dispatch("outdent.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("paragraphs", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("paragraphs.before", text3, options, globals2);
          text3 = text3.replace(/^\n+/g, "");
          text3 = text3.replace(/\n+$/g, "");
          var grafs = text3.split(/\n{2,}/g), grafsOut = [], end = grafs.length;
          for (var i5 = 0; i5 < end; i5++) {
            var str = grafs[i5];
            if (str.search(/(K|G)(\d+)\1/g) >= 0) {
              grafsOut.push(str);
            } else if (str.search(/\S/) >= 0) {
              str = showdown2.subParser("spanGamut")(str, options, globals2);
              str = str.replace(/^([ \t]*)/g, "<p>");
              str += "</p>";
              grafsOut.push(str);
            }
          }
          end = grafsOut.length;
          for (i5 = 0; i5 < end; i5++) {
            var blockText = "", grafsOutIt = grafsOut[i5], codeFlag = false;
            while (/(K|G)(\d+)\1/.test(grafsOutIt)) {
              var delim = RegExp.$1, num = RegExp.$2;
              if (delim === "K") {
                blockText = globals2.gHtmlBlocks[num];
              } else {
                if (codeFlag) {
                  blockText = showdown2.subParser("encodeCode")(globals2.ghCodeBlocks[num].text, options, globals2);
                } else {
                  blockText = globals2.ghCodeBlocks[num].codeblock;
                }
              }
              blockText = blockText.replace(/\$/g, "$$$$");
              grafsOutIt = grafsOutIt.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, blockText);
              if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
                codeFlag = true;
              }
            }
            grafsOut[i5] = grafsOutIt;
          }
          text3 = grafsOut.join("\n");
          text3 = text3.replace(/^\n+/g, "");
          text3 = text3.replace(/\n+$/g, "");
          return globals2.converter._dispatch("paragraphs.after", text3, options, globals2);
        });
        showdown2.subParser("runExtension", function(ext, text3, options, globals2) {
          "use strict";
          if (ext.filter) {
            text3 = ext.filter(text3, globals2.converter, options);
          } else if (ext.regex) {
            var re = ext.regex;
            if (!(re instanceof RegExp)) {
              re = new RegExp(re, "g");
            }
            text3 = text3.replace(re, ext.replace);
          }
          return text3;
        });
        showdown2.subParser("spanGamut", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("spanGamut.before", text3, options, globals2);
          text3 = showdown2.subParser("codeSpans")(text3, options, globals2);
          text3 = showdown2.subParser("escapeSpecialCharsWithinTagAttributes")(text3, options, globals2);
          text3 = showdown2.subParser("encodeBackslashEscapes")(text3, options, globals2);
          text3 = showdown2.subParser("images")(text3, options, globals2);
          text3 = showdown2.subParser("anchors")(text3, options, globals2);
          text3 = showdown2.subParser("autoLinks")(text3, options, globals2);
          text3 = showdown2.subParser("simplifiedAutoLinks")(text3, options, globals2);
          text3 = showdown2.subParser("emoji")(text3, options, globals2);
          text3 = showdown2.subParser("underline")(text3, options, globals2);
          text3 = showdown2.subParser("italicsAndBold")(text3, options, globals2);
          text3 = showdown2.subParser("strikethrough")(text3, options, globals2);
          text3 = showdown2.subParser("ellipsis")(text3, options, globals2);
          text3 = showdown2.subParser("hashHTMLSpans")(text3, options, globals2);
          text3 = showdown2.subParser("encodeAmpsAndAngles")(text3, options, globals2);
          if (options.simpleLineBreaks) {
            if (!/\n\nK/.test(text3)) {
              text3 = text3.replace(/\n+/g, "<br />\n");
            }
          } else {
            text3 = text3.replace(/  +\n/g, "<br />\n");
          }
          text3 = globals2.converter._dispatch("spanGamut.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("strikethrough", function(text3, options, globals2) {
          "use strict";
          function parseInside(txt) {
            if (options.simplifiedAutoLink) {
              txt = showdown2.subParser("simplifiedAutoLinks")(txt, options, globals2);
            }
            return "<del>" + txt + "</del>";
          }
          if (options.strikethrough) {
            text3 = globals2.converter._dispatch("strikethrough.before", text3, options, globals2);
            text3 = text3.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function(wm, txt) {
              return parseInside(txt);
            });
            text3 = globals2.converter._dispatch("strikethrough.after", text3, options, globals2);
          }
          return text3;
        });
        showdown2.subParser("stripLinkDefinitions", function(text3, options, globals2) {
          "use strict";
          var regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm, base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;
          text3 += "\xA80";
          var replaceFunc = function(wholeMatch, linkId, url, width3, height, blankLines, title) {
            linkId = linkId.toLowerCase();
            if (url.match(/^data:.+?\/.+?;base64,/)) {
              globals2.gUrls[linkId] = url.replace(/\s/g, "");
            } else {
              globals2.gUrls[linkId] = showdown2.subParser("encodeAmpsAndAngles")(url, options, globals2);
            }
            if (blankLines) {
              return blankLines + title;
            } else {
              if (title) {
                globals2.gTitles[linkId] = title.replace(/"|'/g, "&quot;");
              }
              if (options.parseImgDimensions && width3 && height) {
                globals2.gDimensions[linkId] = {
                  width: width3,
                  height
                };
              }
            }
            return "";
          };
          text3 = text3.replace(base64Regex, replaceFunc);
          text3 = text3.replace(regex, replaceFunc);
          text3 = text3.replace(/0/, "");
          return text3;
        });
        showdown2.subParser("tables", function(text3, options, globals2) {
          "use strict";
          if (!options.tables) {
            return text3;
          }
          var tableRgx = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm, singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;
          function parseStyles(sLine) {
            if (/^:[ \t]*--*$/.test(sLine)) {
              return ' style="text-align:left;"';
            } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
              return ' style="text-align:right;"';
            } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
              return ' style="text-align:center;"';
            } else {
              return "";
            }
          }
          function parseHeaders(header, style) {
            var id2 = "";
            header = header.trim();
            if (options.tablesHeaderId || options.tableHeaderId) {
              id2 = ' id="' + header.replace(/ /g, "_").toLowerCase() + '"';
            }
            header = showdown2.subParser("spanGamut")(header, options, globals2);
            return "<th" + id2 + style + ">" + header + "</th>\n";
          }
          function parseCells(cell, style) {
            var subText = showdown2.subParser("spanGamut")(cell, options, globals2);
            return "<td" + style + ">" + subText + "</td>\n";
          }
          function buildTable(headers, cells) {
            var tb = "<table>\n<thead>\n<tr>\n", tblLgn = headers.length;
            for (var i5 = 0; i5 < tblLgn; ++i5) {
              tb += headers[i5];
            }
            tb += "</tr>\n</thead>\n<tbody>\n";
            for (i5 = 0; i5 < cells.length; ++i5) {
              tb += "<tr>\n";
              for (var ii = 0; ii < tblLgn; ++ii) {
                tb += cells[i5][ii];
              }
              tb += "</tr>\n";
            }
            tb += "</tbody>\n</table>\n";
            return tb;
          }
          function parseTable(rawTable) {
            var i5, tableLines = rawTable.split("\n");
            for (i5 = 0; i5 < tableLines.length; ++i5) {
              if (/^ {0,3}\|/.test(tableLines[i5])) {
                tableLines[i5] = tableLines[i5].replace(/^ {0,3}\|/, "");
              }
              if (/\|[ \t]*$/.test(tableLines[i5])) {
                tableLines[i5] = tableLines[i5].replace(/\|[ \t]*$/, "");
              }
              tableLines[i5] = showdown2.subParser("codeSpans")(tableLines[i5], options, globals2);
            }
            var rawHeaders = tableLines[0].split("|").map(function(s5) {
              return s5.trim();
            }), rawStyles = tableLines[1].split("|").map(function(s5) {
              return s5.trim();
            }), rawCells = [], headers = [], styles = [], cells = [];
            tableLines.shift();
            tableLines.shift();
            for (i5 = 0; i5 < tableLines.length; ++i5) {
              if (tableLines[i5].trim() === "") {
                continue;
              }
              rawCells.push(
                tableLines[i5].split("|").map(function(s5) {
                  return s5.trim();
                })
              );
            }
            if (rawHeaders.length < rawStyles.length) {
              return rawTable;
            }
            for (i5 = 0; i5 < rawStyles.length; ++i5) {
              styles.push(parseStyles(rawStyles[i5]));
            }
            for (i5 = 0; i5 < rawHeaders.length; ++i5) {
              if (showdown2.helper.isUndefined(styles[i5])) {
                styles[i5] = "";
              }
              headers.push(parseHeaders(rawHeaders[i5], styles[i5]));
            }
            for (i5 = 0; i5 < rawCells.length; ++i5) {
              var row2 = [];
              for (var ii = 0; ii < headers.length; ++ii) {
                if (showdown2.helper.isUndefined(rawCells[i5][ii])) {
                }
                row2.push(parseCells(rawCells[i5][ii], styles[ii]));
              }
              cells.push(row2);
            }
            return buildTable(headers, cells);
          }
          text3 = globals2.converter._dispatch("tables.before", text3, options, globals2);
          text3 = text3.replace(/\\(\|)/g, showdown2.helper.escapeCharactersCallback);
          text3 = text3.replace(tableRgx, parseTable);
          text3 = text3.replace(singeColTblRgx, parseTable);
          text3 = globals2.converter._dispatch("tables.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("underline", function(text3, options, globals2) {
          "use strict";
          if (!options.underline) {
            return text3;
          }
          text3 = globals2.converter._dispatch("underline.before", text3, options, globals2);
          if (options.literalMidWordUnderscores) {
            text3 = text3.replace(/\b___(\S[\s\S]*?)___\b/g, function(wm, txt) {
              return "<u>" + txt + "</u>";
            });
            text3 = text3.replace(/\b__(\S[\s\S]*?)__\b/g, function(wm, txt) {
              return "<u>" + txt + "</u>";
            });
          } else {
            text3 = text3.replace(/___(\S[\s\S]*?)___/g, function(wm, m4) {
              return /\S$/.test(m4) ? "<u>" + m4 + "</u>" : wm;
            });
            text3 = text3.replace(/__(\S[\s\S]*?)__/g, function(wm, m4) {
              return /\S$/.test(m4) ? "<u>" + m4 + "</u>" : wm;
            });
          }
          text3 = text3.replace(/(_)/g, showdown2.helper.escapeCharactersCallback);
          text3 = globals2.converter._dispatch("underline.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("unescapeSpecialChars", function(text3, options, globals2) {
          "use strict";
          text3 = globals2.converter._dispatch("unescapeSpecialChars.before", text3, options, globals2);
          text3 = text3.replace(/E(\d+)E/g, function(wholeMatch, m1) {
            var charCodeToReplace = parseInt(m1);
            return String.fromCharCode(charCodeToReplace);
          });
          text3 = globals2.converter._dispatch("unescapeSpecialChars.after", text3, options, globals2);
          return text3;
        });
        showdown2.subParser("makeMarkdown.blockquote", function(node, globals2) {
          "use strict";
          var txt = "";
          if (node.hasChildNodes()) {
            var children = node.childNodes, childrenLength = children.length;
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              var innerTxt = showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
              if (innerTxt === "") {
                continue;
              }
              txt += innerTxt;
            }
          }
          txt = txt.trim();
          txt = "> " + txt.split("\n").join("\n> ");
          return txt;
        });
        showdown2.subParser("makeMarkdown.codeBlock", function(node, globals2) {
          "use strict";
          var lang = node.getAttribute("language"), num = node.getAttribute("precodenum");
          return "```" + lang + "\n" + globals2.preList[num] + "\n```";
        });
        showdown2.subParser("makeMarkdown.codeSpan", function(node) {
          "use strict";
          return "`" + node.innerHTML + "`";
        });
        showdown2.subParser("makeMarkdown.emphasis", function(node, globals2) {
          "use strict";
          var txt = "";
          if (node.hasChildNodes()) {
            txt += "*";
            var children = node.childNodes, childrenLength = children.length;
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
            }
            txt += "*";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.header", function(node, globals2, headerLevel) {
          "use strict";
          var headerMark = new Array(headerLevel + 1).join("#"), txt = "";
          if (node.hasChildNodes()) {
            txt = headerMark + " ";
            var children = node.childNodes, childrenLength = children.length;
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
            }
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.hr", function() {
          "use strict";
          return "---";
        });
        showdown2.subParser("makeMarkdown.image", function(node) {
          "use strict";
          var txt = "";
          if (node.hasAttribute("src")) {
            txt += "![" + node.getAttribute("alt") + "](";
            txt += "<" + node.getAttribute("src") + ">";
            if (node.hasAttribute("width") && node.hasAttribute("height")) {
              txt += " =" + node.getAttribute("width") + "x" + node.getAttribute("height");
            }
            if (node.hasAttribute("title")) {
              txt += ' "' + node.getAttribute("title") + '"';
            }
            txt += ")";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.links", function(node, globals2) {
          "use strict";
          var txt = "";
          if (node.hasChildNodes() && node.hasAttribute("href")) {
            var children = node.childNodes, childrenLength = children.length;
            txt = "[";
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
            }
            txt += "](";
            txt += "<" + node.getAttribute("href") + ">";
            if (node.hasAttribute("title")) {
              txt += ' "' + node.getAttribute("title") + '"';
            }
            txt += ")";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.list", function(node, globals2, type) {
          "use strict";
          var txt = "";
          if (!node.hasChildNodes()) {
            return "";
          }
          var listItems = node.childNodes, listItemsLenght = listItems.length, listNum = node.getAttribute("start") || 1;
          for (var i5 = 0; i5 < listItemsLenght; ++i5) {
            if (typeof listItems[i5].tagName === "undefined" || listItems[i5].tagName.toLowerCase() !== "li") {
              continue;
            }
            var bullet = "";
            if (type === "ol") {
              bullet = listNum.toString() + ". ";
            } else {
              bullet = "- ";
            }
            txt += bullet + showdown2.subParser("makeMarkdown.listItem")(listItems[i5], globals2);
            ++listNum;
          }
          txt += "\n<!-- -->\n";
          return txt.trim();
        });
        showdown2.subParser("makeMarkdown.listItem", function(node, globals2) {
          "use strict";
          var listItemTxt = "";
          var children = node.childNodes, childrenLenght = children.length;
          for (var i5 = 0; i5 < childrenLenght; ++i5) {
            listItemTxt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
          }
          if (!/\n$/.test(listItemTxt)) {
            listItemTxt += "\n";
          } else {
            listItemTxt = listItemTxt.split("\n").join("\n    ").replace(/^ {4}$/gm, "").replace(/\n\n+/g, "\n\n");
          }
          return listItemTxt;
        });
        showdown2.subParser("makeMarkdown.node", function(node, globals2, spansOnly) {
          "use strict";
          spansOnly = spansOnly || false;
          var txt = "";
          if (node.nodeType === 3) {
            return showdown2.subParser("makeMarkdown.txt")(node, globals2);
          }
          if (node.nodeType === 8) {
            return "<!--" + node.data + "-->\n\n";
          }
          if (node.nodeType !== 1) {
            return "";
          }
          var tagName = node.tagName.toLowerCase();
          switch (tagName) {
            case "h1":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals2, 1) + "\n\n";
              }
              break;
            case "h2":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals2, 2) + "\n\n";
              }
              break;
            case "h3":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals2, 3) + "\n\n";
              }
              break;
            case "h4":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals2, 4) + "\n\n";
              }
              break;
            case "h5":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals2, 5) + "\n\n";
              }
              break;
            case "h6":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.header")(node, globals2, 6) + "\n\n";
              }
              break;
            case "p":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.paragraph")(node, globals2) + "\n\n";
              }
              break;
            case "blockquote":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.blockquote")(node, globals2) + "\n\n";
              }
              break;
            case "hr":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.hr")(node, globals2) + "\n\n";
              }
              break;
            case "ol":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.list")(node, globals2, "ol") + "\n\n";
              }
              break;
            case "ul":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.list")(node, globals2, "ul") + "\n\n";
              }
              break;
            case "precode":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.codeBlock")(node, globals2) + "\n\n";
              }
              break;
            case "pre":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.pre")(node, globals2) + "\n\n";
              }
              break;
            case "table":
              if (!spansOnly) {
                txt = showdown2.subParser("makeMarkdown.table")(node, globals2) + "\n\n";
              }
              break;
            case "code":
              txt = showdown2.subParser("makeMarkdown.codeSpan")(node, globals2);
              break;
            case "em":
            case "i":
              txt = showdown2.subParser("makeMarkdown.emphasis")(node, globals2);
              break;
            case "strong":
            case "b":
              txt = showdown2.subParser("makeMarkdown.strong")(node, globals2);
              break;
            case "del":
              txt = showdown2.subParser("makeMarkdown.strikethrough")(node, globals2);
              break;
            case "a":
              txt = showdown2.subParser("makeMarkdown.links")(node, globals2);
              break;
            case "img":
              txt = showdown2.subParser("makeMarkdown.image")(node, globals2);
              break;
            default:
              txt = node.outerHTML + "\n\n";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.paragraph", function(node, globals2) {
          "use strict";
          var txt = "";
          if (node.hasChildNodes()) {
            var children = node.childNodes, childrenLength = children.length;
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
            }
          }
          txt = txt.trim();
          return txt;
        });
        showdown2.subParser("makeMarkdown.pre", function(node, globals2) {
          "use strict";
          var num = node.getAttribute("prenum");
          return "<pre>" + globals2.preList[num] + "</pre>";
        });
        showdown2.subParser("makeMarkdown.strikethrough", function(node, globals2) {
          "use strict";
          var txt = "";
          if (node.hasChildNodes()) {
            txt += "~~";
            var children = node.childNodes, childrenLength = children.length;
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
            }
            txt += "~~";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.strong", function(node, globals2) {
          "use strict";
          var txt = "";
          if (node.hasChildNodes()) {
            txt += "**";
            var children = node.childNodes, childrenLength = children.length;
            for (var i5 = 0; i5 < childrenLength; ++i5) {
              txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2);
            }
            txt += "**";
          }
          return txt;
        });
        showdown2.subParser("makeMarkdown.table", function(node, globals2) {
          "use strict";
          var txt = "", tableArray = [[], []], headings = node.querySelectorAll("thead>tr>th"), rows = node.querySelectorAll("tbody>tr"), i5, ii;
          for (i5 = 0; i5 < headings.length; ++i5) {
            var headContent = showdown2.subParser("makeMarkdown.tableCell")(headings[i5], globals2), allign = "---";
            if (headings[i5].hasAttribute("style")) {
              var style = headings[i5].getAttribute("style").toLowerCase().replace(/\s/g, "");
              switch (style) {
                case "text-align:left;":
                  allign = ":---";
                  break;
                case "text-align:right;":
                  allign = "---:";
                  break;
                case "text-align:center;":
                  allign = ":---:";
                  break;
              }
            }
            tableArray[0][i5] = headContent.trim();
            tableArray[1][i5] = allign;
          }
          for (i5 = 0; i5 < rows.length; ++i5) {
            var r5 = tableArray.push([]) - 1, cols = rows[i5].getElementsByTagName("td");
            for (ii = 0; ii < headings.length; ++ii) {
              var cellContent = " ";
              if (typeof cols[ii] !== "undefined") {
                cellContent = showdown2.subParser("makeMarkdown.tableCell")(cols[ii], globals2);
              }
              tableArray[r5].push(cellContent);
            }
          }
          var cellSpacesCount = 3;
          for (i5 = 0; i5 < tableArray.length; ++i5) {
            for (ii = 0; ii < tableArray[i5].length; ++ii) {
              var strLen = tableArray[i5][ii].length;
              if (strLen > cellSpacesCount) {
                cellSpacesCount = strLen;
              }
            }
          }
          for (i5 = 0; i5 < tableArray.length; ++i5) {
            for (ii = 0; ii < tableArray[i5].length; ++ii) {
              if (i5 === 1) {
                if (tableArray[i5][ii].slice(-1) === ":") {
                  tableArray[i5][ii] = showdown2.helper.padEnd(tableArray[i5][ii].slice(-1), cellSpacesCount - 1, "-") + ":";
                } else {
                  tableArray[i5][ii] = showdown2.helper.padEnd(tableArray[i5][ii], cellSpacesCount, "-");
                }
              } else {
                tableArray[i5][ii] = showdown2.helper.padEnd(tableArray[i5][ii], cellSpacesCount);
              }
            }
            txt += "| " + tableArray[i5].join(" | ") + " |\n";
          }
          return txt.trim();
        });
        showdown2.subParser("makeMarkdown.tableCell", function(node, globals2) {
          "use strict";
          var txt = "";
          if (!node.hasChildNodes()) {
            return "";
          }
          var children = node.childNodes, childrenLength = children.length;
          for (var i5 = 0; i5 < childrenLength; ++i5) {
            txt += showdown2.subParser("makeMarkdown.node")(children[i5], globals2, true);
          }
          return txt.trim();
        });
        showdown2.subParser("makeMarkdown.txt", function(node) {
          "use strict";
          var txt = node.nodeValue;
          txt = txt.replace(/ +/g, " ");
          txt = txt.replace(/NBSP;/g, " ");
          txt = showdown2.helper.unescapeHTMLEntities(txt);
          txt = txt.replace(/([*_~|`])/g, "\\$1");
          txt = txt.replace(/^(\s*)>/g, "\\$1>");
          txt = txt.replace(/^#/gm, "\\#");
          txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3");
          txt = txt.replace(/^( {0,3}\d+)\./gm, "$1\\.");
          txt = txt.replace(/^( {0,3})([+-])/gm, "$1\\$2");
          txt = txt.replace(/]([\s]*)\(/g, "\\]$1\\(");
          txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:");
          return txt;
        });
        var root = this;
        if (typeof define === "function" && define.amd) {
          define(function() {
            "use strict";
            return showdown2;
          });
        } else if (typeof module !== "undefined" && module.exports) {
          module.exports = showdown2;
        } else {
          root.showdown = showdown2;
        }
      }).call(exports);
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        var nativeCodeString = "[native code]";
        function classNames4() {
          var classes = [];
          for (var i5 = 0; i5 < arguments.length; i5++) {
            var arg = arguments[i5];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames4.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames4.default = classNames4;
          module.exports = classNames4;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames4;
          });
        } else {
          window.classNames = classNames4;
        }
      })();
    }
  });

  // node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js
  var require_memoize_browser_cjs = __commonJS({
    "node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function memoize7(fn) {
        var cache2 = {};
        return function(arg) {
          if (cache2[arg] === void 0)
            cache2[arg] = fn(arg);
          return cache2[arg];
        };
      }
      exports.default = memoize7;
    }
  });

  // node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js
  var require_is_prop_valid_browser_cjs = __commonJS({
    "node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _interopDefault(ex) {
        return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
      }
      var memoize7 = _interopDefault(require_memoize_browser_cjs());
      var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
      var index2 = memoize7(
        function(prop2) {
          return reactPropsRegex.test(prop2) || prop2.charCodeAt(0) === 111 && prop2.charCodeAt(1) === 110 && prop2.charCodeAt(2) < 91;
        }
      );
      exports.default = index2;
    }
  });

  // node_modules/@emotion/sheet/dist/emotion-sheet.cjs.dev.js
  var require_emotion_sheet_cjs_dev = __commonJS({
    "node_modules/@emotion/sheet/dist/emotion-sheet.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function sheetForTag(tag) {
        if (tag.sheet) {
          return tag.sheet;
        }
        for (var i5 = 0; i5 < document.styleSheets.length; i5++) {
          if (document.styleSheets[i5].ownerNode === tag) {
            return document.styleSheets[i5];
          }
        }
      }
      function createStyleElement(options) {
        var tag = document.createElement("style");
        tag.setAttribute("data-emotion", options.key);
        if (options.nonce !== void 0) {
          tag.setAttribute("nonce", options.nonce);
        }
        tag.appendChild(document.createTextNode(""));
        tag.setAttribute("data-s", "");
        return tag;
      }
      var StyleSheet = /* @__PURE__ */ function() {
        function StyleSheet2(options) {
          var _this = this;
          this._insertTag = function(tag) {
            var before;
            if (_this.tags.length === 0) {
              if (_this.insertionPoint) {
                before = _this.insertionPoint.nextSibling;
              } else if (_this.prepend) {
                before = _this.container.firstChild;
              } else {
                before = _this.before;
              }
            } else {
              before = _this.tags[_this.tags.length - 1].nextSibling;
            }
            _this.container.insertBefore(tag, before);
            _this.tags.push(tag);
          };
          this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
          this.tags = [];
          this.ctr = 0;
          this.nonce = options.nonce;
          this.key = options.key;
          this.container = options.container;
          this.prepend = options.prepend;
          this.insertionPoint = options.insertionPoint;
          this.before = null;
        }
        var _proto = StyleSheet2.prototype;
        _proto.hydrate = function hydrate2(nodes) {
          nodes.forEach(this._insertTag);
        };
        _proto.insert = function insert2(rule) {
          if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
            this._insertTag(createStyleElement(this));
          }
          var tag = this.tags[this.tags.length - 1];
          if (true) {
            var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
            if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
              console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
            }
            this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
          }
          if (this.isSpeedy) {
            var sheet = sheetForTag(tag);
            try {
              sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e4) {
              if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
                console.error('There was a problem inserting the following rule: "' + rule + '"', e4);
              }
            }
          } else {
            tag.appendChild(document.createTextNode(rule));
          }
          this.ctr++;
        };
        _proto.flush = function flush2() {
          this.tags.forEach(function(tag) {
            return tag.parentNode && tag.parentNode.removeChild(tag);
          });
          this.tags = [];
          this.ctr = 0;
          if (true) {
            this._alreadyInsertedOrderInsensitiveRule = false;
          }
        };
        return StyleSheet2;
      }();
      exports.StyleSheet = StyleSheet;
    }
  });

  // node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js
  var require_emotion_sheet_cjs = __commonJS({
    "node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_sheet_cjs_dev();
      }
    }
  });

  // node_modules/stylis/dist/umd/stylis.js
  var require_stylis = __commonJS({
    "node_modules/stylis/dist/umd/stylis.js"(exports, module) {
      (function(e4, r5) {
        typeof exports === "object" && typeof module !== "undefined" ? r5(exports) : typeof define === "function" && define.amd ? define(["exports"], r5) : (e4 = e4 || self, r5(e4.stylis = {}));
      })(exports, function(e4) {
        "use strict";
        var r5 = "-ms-";
        var a6 = "-moz-";
        var c6 = "-webkit-";
        var t5 = "comm";
        var n5 = "rule";
        var s5 = "decl";
        var i5 = "@page";
        var u4 = "@media";
        var o6 = "@import";
        var f5 = "@charset";
        var l5 = "@viewport";
        var p5 = "@supports";
        var h4 = "@document";
        var v5 = "@namespace";
        var d4 = "@keyframes";
        var b6 = "@font-face";
        var w4 = "@counter-style";
        var m4 = "@font-feature-values";
        var g5 = Math.abs;
        var k3 = String.fromCharCode;
        var $2 = Object.assign;
        function x4(e5, r6) {
          return A2(e5, 0) ^ 45 ? (((r6 << 2 ^ A2(e5, 0)) << 2 ^ A2(e5, 1)) << 2 ^ A2(e5, 2)) << 2 ^ A2(e5, 3) : 0;
        }
        function E3(e5) {
          return e5.trim();
        }
        function y5(e5, r6) {
          return (e5 = r6.exec(e5)) ? e5[0] : e5;
        }
        function T3(e5, r6, a7) {
          return e5.replace(r6, a7);
        }
        function O2(e5, r6) {
          return e5.indexOf(r6);
        }
        function A2(e5, r6) {
          return e5.charCodeAt(r6) | 0;
        }
        function M2(e5, r6, a7) {
          return e5.slice(r6, a7);
        }
        function C2(e5) {
          return e5.length;
        }
        function S3(e5) {
          return e5.length;
        }
        function R2(e5, r6) {
          return r6.push(e5), e5;
        }
        function z2(e5, r6) {
          return e5.map(r6).join("");
        }
        e4.line = 1;
        e4.column = 1;
        e4.length = 0;
        e4.position = 0;
        e4.character = 0;
        e4.characters = "";
        function N3(r6, a7, c7, t6, n6, s6, i6) {
          return { value: r6, root: a7, parent: c7, type: t6, props: n6, children: s6, line: e4.line, column: e4.column, length: i6, return: "" };
        }
        function P2(e5, r6) {
          return $2(N3("", null, null, "", null, null, 0), e5, { length: -e5.length }, r6);
        }
        function j2() {
          return e4.character;
        }
        function U() {
          e4.character = e4.position > 0 ? A2(e4.characters, --e4.position) : 0;
          if (e4.column--, e4.character === 10)
            e4.column = 1, e4.line--;
          return e4.character;
        }
        function _() {
          e4.character = e4.position < e4.length ? A2(e4.characters, e4.position++) : 0;
          if (e4.column++, e4.character === 10)
            e4.column = 1, e4.line++;
          return e4.character;
        }
        function F() {
          return A2(e4.characters, e4.position);
        }
        function I() {
          return e4.position;
        }
        function L3(r6, a7) {
          return M2(e4.characters, r6, a7);
        }
        function D3(e5) {
          switch (e5) {
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
              return 5;
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            case 59:
            case 123:
            case 125:
              return 4;
            case 58:
              return 3;
            case 34:
            case 39:
            case 40:
            case 91:
              return 2;
            case 41:
            case 93:
              return 1;
          }
          return 0;
        }
        function K(r6) {
          return e4.line = e4.column = 1, e4.length = C2(e4.characters = r6), e4.position = 0, [];
        }
        function V2(r6) {
          return e4.characters = "", r6;
        }
        function W2(r6) {
          return E3(L3(e4.position - 1, Z(r6 === 91 ? r6 + 2 : r6 === 40 ? r6 + 1 : r6)));
        }
        function Y(e5) {
          return V2(G2(K(e5)));
        }
        function B(r6) {
          while (e4.character = F())
            if (e4.character < 33)
              _();
            else
              break;
          return D3(r6) > 2 || D3(e4.character) > 3 ? "" : " ";
        }
        function G2(r6) {
          while (_())
            switch (D3(e4.character)) {
              case 0:
                R2(J(e4.position - 1), r6);
                break;
              case 2:
                R2(W2(e4.character), r6);
                break;
              default:
                R2(k3(e4.character), r6);
            }
          return r6;
        }
        function H3(r6, a7) {
          while (--a7 && _())
            if (e4.character < 48 || e4.character > 102 || e4.character > 57 && e4.character < 65 || e4.character > 70 && e4.character < 97)
              break;
          return L3(r6, I() + (a7 < 6 && F() == 32 && _() == 32));
        }
        function Z(r6) {
          while (_())
            switch (e4.character) {
              case r6:
                return e4.position;
              case 34:
              case 39:
                if (r6 !== 34 && r6 !== 39)
                  Z(e4.character);
                break;
              case 40:
                if (r6 === 41)
                  Z(r6);
                break;
              case 92:
                _();
                break;
            }
          return e4.position;
        }
        function q(r6, a7) {
          while (_())
            if (r6 + e4.character === 47 + 10)
              break;
            else if (r6 + e4.character === 42 + 42 && F() === 47)
              break;
          return "/*" + L3(a7, e4.position - 1) + "*" + k3(r6 === 47 ? r6 : _());
        }
        function J(r6) {
          while (!D3(F()))
            _();
          return L3(r6, e4.position);
        }
        function Q(e5) {
          return V2(X("", null, null, null, [""], e5 = K(e5), 0, [0], e5));
        }
        function X(e5, r6, a7, c7, t6, n6, s6, i6, u5) {
          var o7 = 0;
          var f6 = 0;
          var l6 = s6;
          var p6 = 0;
          var h5 = 0;
          var v6 = 0;
          var d5 = 1;
          var b7 = 1;
          var w5 = 1;
          var m5 = 0;
          var g6 = "";
          var $3 = t6;
          var x5 = n6;
          var E4 = c7;
          var y6 = g6;
          while (b7)
            switch (v6 = m5, m5 = _()) {
              case 40:
                if (v6 != 108 && A2(y6, l6 - 1) == 58) {
                  if (O2(y6 += T3(W2(m5), "&", "&\f"), "&\f") != -1)
                    w5 = -1;
                  break;
                }
              case 34:
              case 39:
              case 91:
                y6 += W2(m5);
                break;
              case 9:
              case 10:
              case 13:
              case 32:
                y6 += B(v6);
                break;
              case 92:
                y6 += H3(I() - 1, 7);
                continue;
              case 47:
                switch (F()) {
                  case 42:
                  case 47:
                    R2(re(q(_(), I()), r6, a7), u5);
                    break;
                  default:
                    y6 += "/";
                }
                break;
              case 123 * d5:
                i6[o7++] = C2(y6) * w5;
              case 125 * d5:
              case 59:
              case 0:
                switch (m5) {
                  case 0:
                  case 125:
                    b7 = 0;
                  case 59 + f6:
                    if (h5 > 0 && C2(y6) - l6)
                      R2(h5 > 32 ? ae(y6 + ";", c7, a7, l6 - 1) : ae(T3(y6, " ", "") + ";", c7, a7, l6 - 2), u5);
                    break;
                  case 59:
                    y6 += ";";
                  default:
                    R2(E4 = ee(y6, r6, a7, o7, f6, t6, i6, g6, $3 = [], x5 = [], l6), n6);
                    if (m5 === 123)
                      if (f6 === 0)
                        X(y6, r6, E4, E4, $3, n6, l6, i6, x5);
                      else
                        switch (p6 === 99 && A2(y6, 3) === 110 ? 100 : p6) {
                          case 100:
                          case 109:
                          case 115:
                            X(e5, E4, E4, c7 && R2(ee(e5, E4, E4, 0, 0, t6, i6, g6, t6, $3 = [], l6), x5), t6, x5, l6, i6, c7 ? $3 : x5);
                            break;
                          default:
                            X(y6, E4, E4, E4, [""], x5, 0, i6, x5);
                        }
                }
                o7 = f6 = h5 = 0, d5 = w5 = 1, g6 = y6 = "", l6 = s6;
                break;
              case 58:
                l6 = 1 + C2(y6), h5 = v6;
              default:
                if (d5 < 1) {
                  if (m5 == 123)
                    --d5;
                  else if (m5 == 125 && d5++ == 0 && U() == 125)
                    continue;
                }
                switch (y6 += k3(m5), m5 * d5) {
                  case 38:
                    w5 = f6 > 0 ? 1 : (y6 += "\f", -1);
                    break;
                  case 44:
                    i6[o7++] = (C2(y6) - 1) * w5, w5 = 1;
                    break;
                  case 64:
                    if (F() === 45)
                      y6 += W2(_());
                    p6 = F(), f6 = l6 = C2(g6 = y6 += J(I())), m5++;
                    break;
                  case 45:
                    if (v6 === 45 && C2(y6) == 2)
                      d5 = 0;
                }
            }
          return n6;
        }
        function ee(e5, r6, a7, c7, t6, s6, i6, u5, o7, f6, l6) {
          var p6 = t6 - 1;
          var h5 = t6 === 0 ? s6 : [""];
          var v6 = S3(h5);
          for (var d5 = 0, b7 = 0, w5 = 0; d5 < c7; ++d5)
            for (var m5 = 0, k4 = M2(e5, p6 + 1, p6 = g5(b7 = i6[d5])), $3 = e5; m5 < v6; ++m5)
              if ($3 = E3(b7 > 0 ? h5[m5] + " " + k4 : T3(k4, /&\f/g, h5[m5])))
                o7[w5++] = $3;
          return N3(e5, r6, a7, t6 === 0 ? n5 : u5, o7, f6, l6);
        }
        function re(e5, r6, a7) {
          return N3(e5, r6, a7, t5, k3(j2()), M2(e5, 2, -2), 0);
        }
        function ae(e5, r6, a7, c7) {
          return N3(e5, r6, a7, s5, M2(e5, 0, c7), M2(e5, c7 + 1, -1), c7);
        }
        function ce(e5, t6, n6) {
          switch (x4(e5, t6)) {
            case 5103:
              return c6 + "print-" + e5 + e5;
            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921:
            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005:
            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855:
            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
              return c6 + e5 + e5;
            case 4789:
              return a6 + e5 + e5;
            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
              return c6 + e5 + a6 + e5 + r5 + e5 + e5;
            case 5936:
              switch (A2(e5, t6 + 11)) {
                case 114:
                  return c6 + e5 + r5 + T3(e5, /[svh]\w+-[tblr]{2}/, "tb") + e5;
                case 108:
                  return c6 + e5 + r5 + T3(e5, /[svh]\w+-[tblr]{2}/, "tb-rl") + e5;
                case 45:
                  return c6 + e5 + r5 + T3(e5, /[svh]\w+-[tblr]{2}/, "lr") + e5;
              }
            case 6828:
            case 4268:
            case 2903:
              return c6 + e5 + r5 + e5 + e5;
            case 6165:
              return c6 + e5 + r5 + "flex-" + e5 + e5;
            case 5187:
              return c6 + e5 + T3(e5, /(\w+).+(:[^]+)/, c6 + "box-$1$2" + r5 + "flex-$1$2") + e5;
            case 5443:
              return c6 + e5 + r5 + "flex-item-" + T3(e5, /flex-|-self/g, "") + (!y5(e5, /flex-|baseline/) ? r5 + "grid-row-" + T3(e5, /flex-|-self/g, "") : "") + e5;
            case 4675:
              return c6 + e5 + r5 + "flex-line-pack" + T3(e5, /align-content|flex-|-self/g, "") + e5;
            case 5548:
              return c6 + e5 + r5 + T3(e5, "shrink", "negative") + e5;
            case 5292:
              return c6 + e5 + r5 + T3(e5, "basis", "preferred-size") + e5;
            case 6060:
              return c6 + "box-" + T3(e5, "-grow", "") + c6 + e5 + r5 + T3(e5, "grow", "positive") + e5;
            case 4554:
              return c6 + T3(e5, /([^-])(transform)/g, "$1" + c6 + "$2") + e5;
            case 6187:
              return T3(T3(T3(e5, /(zoom-|grab)/, c6 + "$1"), /(image-set)/, c6 + "$1"), e5, "") + e5;
            case 5495:
            case 3959:
              return T3(e5, /(image-set\([^]*)/, c6 + "$1$`$1");
            case 4968:
              return T3(T3(e5, /(.+:)(flex-)?(.*)/, c6 + "box-pack:$3" + r5 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + c6 + e5 + e5;
            case 4200:
              if (!y5(e5, /flex-|baseline/))
                return r5 + "grid-column-align" + M2(e5, t6) + e5;
              break;
            case 2592:
            case 3360:
              return r5 + T3(e5, "template-", "") + e5;
            case 4384:
            case 3616:
              if (n6 && n6.some(function(e6, r6) {
                return t6 = r6, y5(e6.props, /grid-\w+-end/);
              })) {
                return ~O2(e5 + (n6 = n6[t6].value), "span") ? e5 : r5 + T3(e5, "-start", "") + e5 + r5 + "grid-row-span:" + (~O2(n6, "span") ? y5(n6, /\d+/) : +y5(n6, /\d+/) - +y5(e5, /\d+/)) + ";";
              }
              return r5 + T3(e5, "-start", "") + e5;
            case 4896:
            case 4128:
              return n6 && n6.some(function(e6) {
                return y5(e6.props, /grid-\w+-start/);
              }) ? e5 : r5 + T3(T3(e5, "-end", "-span"), "span ", "") + e5;
            case 4095:
            case 3583:
            case 4068:
            case 2532:
              return T3(e5, /(.+)-inline(.+)/, c6 + "$1$2") + e5;
            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
              if (C2(e5) - 1 - t6 > 6)
                switch (A2(e5, t6 + 1)) {
                  case 109:
                    if (A2(e5, t6 + 4) !== 45)
                      break;
                  case 102:
                    return T3(e5, /(.+:)(.+)-([^]+)/, "$1" + c6 + "$2-$3$1" + a6 + (A2(e5, t6 + 3) == 108 ? "$3" : "$2-$3")) + e5;
                  case 115:
                    return ~O2(e5, "stretch") ? ce(T3(e5, "stretch", "fill-available"), t6, n6) + e5 : e5;
                }
              break;
            case 5152:
            case 5920:
              return T3(e5, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(a7, c7, t7, n7, s6, i6, u5) {
                return r5 + c7 + ":" + t7 + u5 + (n7 ? r5 + c7 + "-span:" + (s6 ? i6 : +i6 - +t7) + u5 : "") + e5;
              });
            case 4949:
              if (A2(e5, t6 + 6) === 121)
                return T3(e5, ":", ":" + c6) + e5;
              break;
            case 6444:
              switch (A2(e5, A2(e5, 14) === 45 ? 18 : 11)) {
                case 120:
                  return T3(e5, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + c6 + (A2(e5, 14) === 45 ? "inline-" : "") + "box$3$1" + c6 + "$2$3$1" + r5 + "$2box$3") + e5;
                case 100:
                  return T3(e5, ":", ":" + r5) + e5;
              }
              break;
            case 5719:
            case 2647:
            case 2135:
            case 3927:
            case 2391:
              return T3(e5, "scroll-", "scroll-snap-") + e5;
          }
          return e5;
        }
        function te(e5, r6) {
          var a7 = "";
          var c7 = S3(e5);
          for (var t6 = 0; t6 < c7; t6++)
            a7 += r6(e5[t6], t6, e5, r6) || "";
          return a7;
        }
        function ne(e5, r6, a7, c7) {
          switch (e5.type) {
            case o6:
            case s5:
              return e5.return = e5.return || e5.value;
            case t5:
              return "";
            case d4:
              return e5.return = e5.value + "{" + te(e5.children, c7) + "}";
            case n5:
              e5.value = e5.props.join(",");
          }
          return C2(a7 = te(e5.children, c7)) ? e5.return = e5.value + "{" + a7 + "}" : "";
        }
        function se(e5) {
          var r6 = S3(e5);
          return function(a7, c7, t6, n6) {
            var s6 = "";
            for (var i6 = 0; i6 < r6; i6++)
              s6 += e5[i6](a7, c7, t6, n6) || "";
            return s6;
          };
        }
        function ie(e5) {
          return function(r6) {
            if (!r6.root) {
              if (r6 = r6.return)
                e5(r6);
            }
          };
        }
        function ue(e5, t6, i6, u5) {
          if (e5.length > -1) {
            if (!e5.return)
              switch (e5.type) {
                case s5:
                  e5.return = ce(e5.value, e5.length, i6);
                  return;
                case d4:
                  return te([P2(e5, { value: T3(e5.value, "@", "@" + c6) })], u5);
                case n5:
                  if (e5.length)
                    return z2(e5.props, function(t7) {
                      switch (y5(t7, /(::plac\w+|:read-\w+)/)) {
                        case ":read-only":
                        case ":read-write":
                          return te([P2(e5, { props: [T3(t7, /:(read-\w+)/, ":" + a6 + "$1")] })], u5);
                        case "::placeholder":
                          return te([P2(e5, { props: [T3(t7, /:(plac\w+)/, ":" + c6 + "input-$1")] }), P2(e5, { props: [T3(t7, /:(plac\w+)/, ":" + a6 + "$1")] }), P2(e5, { props: [T3(t7, /:(plac\w+)/, r5 + "input-$1")] })], u5);
                      }
                      return "";
                    });
              }
          }
        }
        function oe(e5) {
          switch (e5.type) {
            case n5:
              e5.props = e5.props.map(function(r6) {
                return z2(Y(r6), function(r7, a7, c7) {
                  switch (A2(r7, 0)) {
                    case 12:
                      return M2(r7, 1, C2(r7));
                    case 0:
                    case 40:
                    case 43:
                    case 62:
                    case 126:
                      return r7;
                    case 58:
                      if (c7[++a7] === "global")
                        c7[a7] = "", c7[++a7] = "\f" + M2(c7[a7], a7 = 1, -1);
                    case 32:
                      return a7 === 1 ? "" : r7;
                    default:
                      switch (a7) {
                        case 0:
                          e5 = r7;
                          return S3(c7) > 1 ? "" : r7;
                        case (a7 = S3(c7) - 1):
                        case 2:
                          return a7 === 2 ? r7 + e5 + e5 : r7 + e5;
                        default:
                          return r7;
                      }
                  }
                });
              });
          }
        }
        e4.CHARSET = f5;
        e4.COMMENT = t5;
        e4.COUNTER_STYLE = w4;
        e4.DECLARATION = s5;
        e4.DOCUMENT = h4;
        e4.FONT_FACE = b6;
        e4.FONT_FEATURE_VALUES = m4;
        e4.IMPORT = o6;
        e4.KEYFRAMES = d4;
        e4.MEDIA = u4;
        e4.MOZ = a6;
        e4.MS = r5;
        e4.NAMESPACE = v5;
        e4.PAGE = i5;
        e4.RULESET = n5;
        e4.SUPPORTS = p5;
        e4.VIEWPORT = l5;
        e4.WEBKIT = c6;
        e4.abs = g5;
        e4.alloc = K;
        e4.append = R2;
        e4.assign = $2;
        e4.caret = I;
        e4.char = j2;
        e4.charat = A2;
        e4.combine = z2;
        e4.comment = re;
        e4.commenter = q;
        e4.compile = Q;
        e4.copy = P2;
        e4.dealloc = V2;
        e4.declaration = ae;
        e4.delimit = W2;
        e4.delimiter = Z;
        e4.escaping = H3;
        e4.from = k3;
        e4.hash = x4;
        e4.identifier = J;
        e4.indexof = O2;
        e4.match = y5;
        e4.middleware = se;
        e4.namespace = oe;
        e4.next = _;
        e4.node = N3;
        e4.parse = X;
        e4.peek = F;
        e4.prefix = ce;
        e4.prefixer = ue;
        e4.prev = U;
        e4.replace = T3;
        e4.ruleset = ee;
        e4.rulesheet = ie;
        e4.serialize = te;
        e4.sizeof = S3;
        e4.slice = L3;
        e4.stringify = ne;
        e4.strlen = C2;
        e4.substr = M2;
        e4.token = D3;
        e4.tokenize = Y;
        e4.tokenizer = G2;
        e4.trim = E3;
        e4.whitespace = B;
        Object.defineProperty(e4, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.dev.js
  var require_emotion_weak_memoize_cjs_dev = __commonJS({
    "node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var weakMemoize = function weakMemoize2(func) {
        var cache2 = /* @__PURE__ */ new WeakMap();
        return function(arg) {
          if (cache2.has(arg)) {
            return cache2.get(arg);
          }
          var ret = func(arg);
          cache2.set(arg, ret);
          return ret;
        };
      };
      exports.default = weakMemoize;
    }
  });

  // node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js
  var require_emotion_weak_memoize_cjs = __commonJS({
    "node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_weak_memoize_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js
  var require_emotion_memoize_cjs_dev = __commonJS({
    "node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function memoize7(fn) {
        var cache2 = /* @__PURE__ */ Object.create(null);
        return function(arg) {
          if (cache2[arg] === void 0)
            cache2[arg] = fn(arg);
          return cache2[arg];
        };
      }
      exports.default = memoize7;
    }
  });

  // node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js
  var require_emotion_memoize_cjs = __commonJS({
    "node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_memoize_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/cache/dist/emotion-cache.cjs.dev.js
  var require_emotion_cache_cjs_dev = __commonJS({
    "node_modules/@emotion/cache/dist/emotion-cache.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var sheet = require_emotion_sheet_cjs();
      var stylis = require_stylis();
      var weakMemoize = require_emotion_weak_memoize_cjs();
      var memoize7 = require_emotion_memoize_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var weakMemoize__default = /* @__PURE__ */ _interopDefault(weakMemoize);
      var memoize__default = /* @__PURE__ */ _interopDefault(memoize7);
      var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
        var previous = 0;
        var character = 0;
        while (true) {
          previous = character;
          character = stylis.peek();
          if (previous === 38 && character === 12) {
            points[index2] = 1;
          }
          if (stylis.token(character)) {
            break;
          }
          stylis.next();
        }
        return stylis.slice(begin, stylis.position);
      };
      var toRules = function toRules2(parsed, points) {
        var index2 = -1;
        var character = 44;
        do {
          switch (stylis.token(character)) {
            case 0:
              if (character === 38 && stylis.peek() === 12) {
                points[index2] = 1;
              }
              parsed[index2] += identifierWithPointTracking(stylis.position - 1, points, index2);
              break;
            case 2:
              parsed[index2] += stylis.delimit(character);
              break;
            case 4:
              if (character === 44) {
                parsed[++index2] = stylis.peek() === 58 ? "&\f" : "";
                points[index2] = parsed[index2].length;
                break;
              }
            default:
              parsed[index2] += stylis.from(character);
          }
        } while (character = stylis.next());
        return parsed;
      };
      var getRules = function getRules2(value, points) {
        return stylis.dealloc(toRules(stylis.alloc(value), points));
      };
      var fixedElements = /* @__PURE__ */ new WeakMap();
      var compat = function compat2(element) {
        if (element.type !== "rule" || !element.parent || element.length < 1) {
          return;
        }
        var value = element.value, parent = element.parent;
        var isImplicitRule = element.column === parent.column && element.line === parent.line;
        while (parent.type !== "rule") {
          parent = parent.parent;
          if (!parent)
            return;
        }
        if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
          return;
        }
        if (isImplicitRule) {
          return;
        }
        fixedElements.set(element, true);
        var points = [];
        var rules = getRules(value, points);
        var parentRules = parent.props;
        for (var i5 = 0, k3 = 0; i5 < rules.length; i5++) {
          for (var j2 = 0; j2 < parentRules.length; j2++, k3++) {
            element.props[k3] = points[i5] ? rules[i5].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i5];
          }
        }
      };
      var removeLabel = function removeLabel2(element) {
        if (element.type === "decl") {
          var value = element.value;
          if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
            element["return"] = "";
            element.value = "";
          }
        }
      };
      var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
      var isIgnoringComment = function isIgnoringComment2(element) {
        return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
      };
      var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache2) {
        return function(element, index2, children) {
          if (element.type !== "rule" || cache2.compat)
            return;
          var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
          if (unsafePseudoClasses) {
            var isNested = element.parent === children[0];
            var commentContainer = isNested ? children[0].children : children;
            for (var i5 = commentContainer.length - 1; i5 >= 0; i5--) {
              var node = commentContainer[i5];
              if (node.line < element.line) {
                break;
              }
              if (node.column < element.column) {
                if (isIgnoringComment(node)) {
                  return;
                }
                break;
              }
            }
            unsafePseudoClasses.forEach(function(unsafePseudoClass) {
              console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
            });
          }
        };
      };
      var isImportRule = function isImportRule2(element) {
        return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
      };
      var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
        for (var i5 = index2 - 1; i5 >= 0; i5--) {
          if (!isImportRule(children[i5])) {
            return true;
          }
        }
        return false;
      };
      var nullifyElement = function nullifyElement2(element) {
        element.type = "";
        element.value = "";
        element["return"] = "";
        element.children = "";
        element.props = "";
      };
      var incorrectImportAlarm = function incorrectImportAlarm2(element, index2, children) {
        if (!isImportRule(element)) {
          return;
        }
        if (element.parent) {
          console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
          nullifyElement(element);
        } else if (isPrependedWithRegularRules(index2, children)) {
          console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
          nullifyElement(element);
        }
      };
      function prefix2(value, length) {
        switch (stylis.hash(value, length)) {
          case 5103:
            return stylis.WEBKIT + "print-" + value + value;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return stylis.WEBKIT + value + value;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return stylis.WEBKIT + value + stylis.MOZ + value + stylis.MS + value + value;
          case 6828:
          case 4268:
            return stylis.WEBKIT + value + stylis.MS + value + value;
          case 6165:
            return stylis.WEBKIT + value + stylis.MS + "flex-" + value + value;
          case 5187:
            return stylis.WEBKIT + value + stylis.replace(value, /(\w+).+(:[^]+)/, stylis.WEBKIT + "box-$1$2" + stylis.MS + "flex-$1$2") + value;
          case 5443:
            return stylis.WEBKIT + value + stylis.MS + "flex-item-" + stylis.replace(value, /flex-|-self/, "") + value;
          case 4675:
            return stylis.WEBKIT + value + stylis.MS + "flex-line-pack" + stylis.replace(value, /align-content|flex-|-self/, "") + value;
          case 5548:
            return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, "shrink", "negative") + value;
          case 5292:
            return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, "basis", "preferred-size") + value;
          case 6060:
            return stylis.WEBKIT + "box-" + stylis.replace(value, "-grow", "") + stylis.WEBKIT + value + stylis.MS + stylis.replace(value, "grow", "positive") + value;
          case 4554:
            return stylis.WEBKIT + stylis.replace(value, /([^-])(transform)/g, "$1" + stylis.WEBKIT + "$2") + value;
          case 6187:
            return stylis.replace(stylis.replace(stylis.replace(value, /(zoom-|grab)/, stylis.WEBKIT + "$1"), /(image-set)/, stylis.WEBKIT + "$1"), value, "") + value;
          case 5495:
          case 3959:
            return stylis.replace(value, /(image-set\([^]*)/, stylis.WEBKIT + "$1$`$1");
          case 4968:
            return stylis.replace(stylis.replace(value, /(.+:)(flex-)?(.*)/, stylis.WEBKIT + "box-pack:$3" + stylis.MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + stylis.WEBKIT + value + value;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return stylis.replace(value, /(.+)-inline(.+)/, stylis.WEBKIT + "$1$2") + value;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (stylis.strlen(value) - 1 - length > 6)
              switch (stylis.charat(value, length + 1)) {
                case 109:
                  if (stylis.charat(value, length + 4) !== 45)
                    break;
                case 102:
                  return stylis.replace(value, /(.+:)(.+)-([^]+)/, "$1" + stylis.WEBKIT + "$2-$3$1" + stylis.MOZ + (stylis.charat(value, length + 3) == 108 ? "$3" : "$2-$3")) + value;
                case 115:
                  return ~stylis.indexof(value, "stretch") ? prefix2(stylis.replace(value, "stretch", "fill-available"), length) + value : value;
              }
            break;
          case 4949:
            if (stylis.charat(value, length + 1) !== 115)
              break;
          case 6444:
            switch (stylis.charat(value, stylis.strlen(value) - 3 - (~stylis.indexof(value, "!important") && 10))) {
              case 107:
                return stylis.replace(value, ":", ":" + stylis.WEBKIT) + value;
              case 101:
                return stylis.replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + stylis.WEBKIT + (stylis.charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + stylis.WEBKIT + "$2$3$1" + stylis.MS + "$2box$3") + value;
            }
            break;
          case 5936:
            switch (stylis.charat(value, length + 11)) {
              case 114:
                return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
              case 108:
                return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
              case 45:
                return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
            }
            return stylis.WEBKIT + value + stylis.MS + value + value;
        }
        return value;
      }
      var prefixer = function prefixer2(element, index2, children, callback) {
        if (element.length > -1) {
          if (!element["return"])
            switch (element.type) {
              case stylis.DECLARATION:
                element["return"] = prefix2(element.value, element.length);
                break;
              case stylis.KEYFRAMES:
                return stylis.serialize([stylis.copy(element, {
                  value: stylis.replace(element.value, "@", "@" + stylis.WEBKIT)
                })], callback);
              case stylis.RULESET:
                if (element.length)
                  return stylis.combine(element.props, function(value) {
                    switch (stylis.match(value, /(::plac\w+|:read-\w+)/)) {
                      case ":read-only":
                      case ":read-write":
                        return stylis.serialize([stylis.copy(element, {
                          props: [stylis.replace(value, /:(read-\w+)/, ":" + stylis.MOZ + "$1")]
                        })], callback);
                      case "::placeholder":
                        return stylis.serialize([stylis.copy(element, {
                          props: [stylis.replace(value, /:(plac\w+)/, ":" + stylis.WEBKIT + "input-$1")]
                        }), stylis.copy(element, {
                          props: [stylis.replace(value, /:(plac\w+)/, ":" + stylis.MOZ + "$1")]
                        }), stylis.copy(element, {
                          props: [stylis.replace(value, /:(plac\w+)/, stylis.MS + "input-$1")]
                        })], callback);
                    }
                    return "";
                  });
            }
        }
      };
      var isBrowser3 = typeof document !== "undefined";
      var getServerStylisCache = isBrowser3 ? void 0 : weakMemoize__default["default"](function() {
        return memoize__default["default"](function() {
          var cache2 = {};
          return function(name) {
            return cache2[name];
          };
        });
      });
      var defaultStylisPlugins = [prefixer];
      var createCache3 = function createCache4(options) {
        var key = options.key;
        if (!key) {
          throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
        }
        if (isBrowser3 && key === "css") {
          var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
          Array.prototype.forEach.call(ssrStyles, function(node) {
            var dataEmotionAttribute = node.getAttribute("data-emotion");
            if (dataEmotionAttribute.indexOf(" ") === -1) {
              return;
            }
            document.head.appendChild(node);
            node.setAttribute("data-s", "");
          });
        }
        var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
        if (true) {
          if (/[^a-z-]/.test(key)) {
            throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
          }
        }
        var inserted = {};
        var container;
        var nodesToHydrate = [];
        if (isBrowser3) {
          container = options.container || document.head;
          Array.prototype.forEach.call(
            document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
            function(node) {
              var attrib = node.getAttribute("data-emotion").split(" ");
              for (var i5 = 1; i5 < attrib.length; i5++) {
                inserted[attrib[i5]] = true;
              }
              nodesToHydrate.push(node);
            }
          );
        }
        var _insert;
        var omnipresentPlugins = [compat, removeLabel];
        if (true) {
          omnipresentPlugins.push(createUnsafeSelectorsAlarm({
            get compat() {
              return cache2.compat;
            }
          }), incorrectImportAlarm);
        }
        if (isBrowser3) {
          var currentSheet;
          var finalizingPlugins = [stylis.stringify, true ? function(element) {
            if (!element.root) {
              if (element["return"]) {
                currentSheet.insert(element["return"]);
              } else if (element.value && element.type !== stylis.COMMENT) {
                currentSheet.insert(element.value + "{}");
              }
            }
          } : stylis.rulesheet(function(rule) {
            currentSheet.insert(rule);
          })];
          var serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
          var stylis$1 = function stylis$12(styles) {
            return stylis.serialize(stylis.compile(styles), serializer);
          };
          _insert = function insert2(selector4, serialized, sheet2, shouldCache) {
            currentSheet = sheet2;
            if (serialized.map !== void 0) {
              currentSheet = {
                insert: function insert3(rule) {
                  sheet2.insert(rule + serialized.map);
                }
              };
            }
            stylis$1(selector4 ? selector4 + "{" + serialized.styles + "}" : serialized.styles);
            if (shouldCache) {
              cache2.inserted[serialized.name] = true;
            }
          };
        } else {
          var _finalizingPlugins = [stylis.stringify];
          var _serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));
          var _stylis = function _stylis2(styles) {
            return stylis.serialize(stylis.compile(styles), _serializer);
          };
          var serverStylisCache = getServerStylisCache(stylisPlugins)(key);
          var getRules2 = function getRules3(selector4, serialized) {
            var name = serialized.name;
            if (serverStylisCache[name] === void 0) {
              serverStylisCache[name] = _stylis(selector4 ? selector4 + "{" + serialized.styles + "}" : serialized.styles);
            }
            return serverStylisCache[name];
          };
          _insert = function _insert2(selector4, serialized, sheet2, shouldCache) {
            var name = serialized.name;
            var rules = getRules2(selector4, serialized);
            if (cache2.compat === void 0) {
              if (shouldCache) {
                cache2.inserted[name] = true;
              }
              if (serialized.map !== void 0) {
                return rules + serialized.map;
              }
              return rules;
            } else {
              if (shouldCache) {
                cache2.inserted[name] = rules;
              } else {
                return rules;
              }
            }
          };
        }
        var cache2 = {
          key,
          sheet: new sheet.StyleSheet({
            key,
            container,
            nonce: options.nonce,
            speedy: options.speedy,
            prepend: options.prepend,
            insertionPoint: options.insertionPoint
          }),
          nonce: options.nonce,
          inserted,
          registered: {},
          insert: _insert
        };
        cache2.sheet.hydrate(nodesToHydrate);
        return cache2;
      };
      exports.default = createCache3;
    }
  });

  // node_modules/@emotion/cache/dist/emotion-cache.cjs.js
  var require_emotion_cache_cjs = __commonJS({
    "node_modules/@emotion/cache/dist/emotion-cache.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_cache_cjs_dev();
      }
    }
  });

  // node_modules/@babel/runtime/helpers/extends.js
  var require_extends = __commonJS({
    "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
      function _extends5() {
        module.exports = _extends5 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i5 = 1; i5 < arguments.length; i5++) {
            var source = arguments[i5];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
        return _extends5.apply(this, arguments);
      }
      module.exports = _extends5, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef2 = REACT_FORWARD_REF_TYPE;
          var Fragment3 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode2 = REACT_STRICT_MODE_TYPE;
          var Suspense2 = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef2;
          exports.Fragment = Fragment3;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode2;
          exports.Suspense = Suspense2;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement2;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/hoist-non-react-statics/node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i5 = 0; i5 < keys.length; ++i5) {
            var key = keys[i5];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e4) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics;
    }
  });

  // node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.dev.js
  var require_emotion_react_isolated_hnrs_cjs_dev = __commonJS({
    "node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var hoistNonReactStatics$1 = require_hoist_non_react_statics_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var hoistNonReactStatics__default = /* @__PURE__ */ _interopDefault(hoistNonReactStatics$1);
      var hoistNonReactStatics = function(targetComponent, sourceComponent) {
        return hoistNonReactStatics__default["default"](targetComponent, sourceComponent);
      };
      exports.default = hoistNonReactStatics;
    }
  });

  // node_modules/@emotion/utils/dist/emotion-utils.cjs.dev.js
  var require_emotion_utils_cjs_dev = __commonJS({
    "node_modules/@emotion/utils/dist/emotion-utils.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var isBrowser3 = typeof document !== "undefined";
      function getRegisteredStyles(registered, registeredStyles, classNames4) {
        var rawClassName = "";
        classNames4.split(" ").forEach(function(className) {
          if (registered[className] !== void 0) {
            registeredStyles.push(registered[className] + ";");
          } else {
            rawClassName += className + " ";
          }
        });
        return rawClassName;
      }
      var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
        var className = cache2.key + "-" + serialized.name;
        if ((isStringTag === false || isBrowser3 === false && cache2.compat !== void 0) && cache2.registered[className] === void 0) {
          cache2.registered[className] = serialized.styles;
        }
      };
      var insertStyles2 = function insertStyles3(cache2, serialized, isStringTag) {
        registerStyles(cache2, serialized, isStringTag);
        var className = cache2.key + "-" + serialized.name;
        if (cache2.inserted[serialized.name] === void 0) {
          var stylesForSSR = "";
          var current = serialized;
          do {
            var maybeStyles = cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
            if (!isBrowser3 && maybeStyles !== void 0) {
              stylesForSSR += maybeStyles;
            }
            current = current.next;
          } while (current !== void 0);
          if (!isBrowser3 && stylesForSSR.length !== 0) {
            return stylesForSSR;
          }
        }
      };
      exports.getRegisteredStyles = getRegisteredStyles;
      exports.insertStyles = insertStyles2;
      exports.registerStyles = registerStyles;
    }
  });

  // node_modules/@emotion/utils/dist/emotion-utils.cjs.js
  var require_emotion_utils_cjs = __commonJS({
    "node_modules/@emotion/utils/dist/emotion-utils.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_utils_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/hash/dist/emotion-hash.cjs.dev.js
  var require_emotion_hash_cjs_dev = __commonJS({
    "node_modules/@emotion/hash/dist/emotion-hash.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function murmur2(str) {
        var h4 = 0;
        var k3, i5 = 0, len = str.length;
        for (; len >= 4; ++i5, len -= 4) {
          k3 = str.charCodeAt(i5) & 255 | (str.charCodeAt(++i5) & 255) << 8 | (str.charCodeAt(++i5) & 255) << 16 | (str.charCodeAt(++i5) & 255) << 24;
          k3 = (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16);
          k3 ^= k3 >>> 24;
          h4 = (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16) ^ (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
        }
        switch (len) {
          case 3:
            h4 ^= (str.charCodeAt(i5 + 2) & 255) << 16;
          case 2:
            h4 ^= (str.charCodeAt(i5 + 1) & 255) << 8;
          case 1:
            h4 ^= str.charCodeAt(i5) & 255;
            h4 = (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
        }
        h4 ^= h4 >>> 13;
        h4 = (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
        return ((h4 ^ h4 >>> 15) >>> 0).toString(36);
      }
      exports.default = murmur2;
    }
  });

  // node_modules/@emotion/hash/dist/emotion-hash.cjs.js
  var require_emotion_hash_cjs = __commonJS({
    "node_modules/@emotion/hash/dist/emotion-hash.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_hash_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/unitless/dist/emotion-unitless.cjs.dev.js
  var require_emotion_unitless_cjs_dev = __commonJS({
    "node_modules/@emotion/unitless/dist/emotion-unitless.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var unitlessKeys = {
        animationIterationCount: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      };
      exports.default = unitlessKeys;
    }
  });

  // node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js
  var require_emotion_unitless_cjs = __commonJS({
    "node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_unitless_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/serialize/dist/emotion-serialize.cjs.dev.js
  var require_emotion_serialize_cjs_dev = __commonJS({
    "node_modules/@emotion/serialize/dist/emotion-serialize.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var hashString = require_emotion_hash_cjs();
      var unitless = require_emotion_unitless_cjs();
      var memoize7 = require_emotion_memoize_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var hashString__default = /* @__PURE__ */ _interopDefault(hashString);
      var unitless__default = /* @__PURE__ */ _interopDefault(unitless);
      var memoize__default = /* @__PURE__ */ _interopDefault(memoize7);
      var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
      var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
      var hyphenateRegex = /[A-Z]|^ms/g;
      var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
      var isCustomProperty = function isCustomProperty2(property) {
        return property.charCodeAt(1) === 45;
      };
      var isProcessableValue = function isProcessableValue2(value) {
        return value != null && typeof value !== "boolean";
      };
      var processStyleName = /* @__PURE__ */ memoize__default["default"](function(styleName) {
        return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
      });
      var processStyleValue = function processStyleValue2(key, value) {
        switch (key) {
          case "animation":
          case "animationName": {
            if (typeof value === "string") {
              return value.replace(animationRegex, function(match, p1, p22) {
                cursor = {
                  name: p1,
                  styles: p22,
                  next: cursor
                };
                return p1;
              });
            }
          }
        }
        if (unitless__default["default"][key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
          return value + "px";
        }
        return value;
      };
      if (true) {
        contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
        contentValues = ["normal", "none", "initial", "inherit", "unset"];
        oldProcessStyleValue = processStyleValue;
        msPattern = /^-ms-/;
        hyphenPattern = /-(.)/g;
        hyphenatedCache = {};
        processStyleValue = function processStyleValue2(key, value) {
          if (key === "content") {
            if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
              throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
            }
          }
          var processed = oldProcessStyleValue(key, value);
          if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
            hyphenatedCache[key] = true;
            console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
              return _char.toUpperCase();
            }) + "?");
          }
          return processed;
        };
      }
      var contentValuePattern;
      var contentValues;
      var oldProcessStyleValue;
      var msPattern;
      var hyphenPattern;
      var hyphenatedCache;
      var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
      function handleInterpolation(mergedProps, registered, interpolation) {
        if (interpolation == null) {
          return "";
        }
        if (interpolation.__emotion_styles !== void 0) {
          if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
            throw new Error(noComponentSelectorMessage);
          }
          return interpolation;
        }
        switch (typeof interpolation) {
          case "boolean": {
            return "";
          }
          case "object": {
            if (interpolation.anim === 1) {
              cursor = {
                name: interpolation.name,
                styles: interpolation.styles,
                next: cursor
              };
              return interpolation.name;
            }
            if (interpolation.styles !== void 0) {
              var next2 = interpolation.next;
              if (next2 !== void 0) {
                while (next2 !== void 0) {
                  cursor = {
                    name: next2.name,
                    styles: next2.styles,
                    next: cursor
                  };
                  next2 = next2.next;
                }
              }
              var styles = interpolation.styles + ";";
              if (interpolation.map !== void 0) {
                styles += interpolation.map;
              }
              return styles;
            }
            return createStringFromObject(mergedProps, registered, interpolation);
          }
          case "function": {
            if (mergedProps !== void 0) {
              var previousCursor = cursor;
              var result = interpolation(mergedProps);
              cursor = previousCursor;
              return handleInterpolation(mergedProps, registered, result);
            } else if (true) {
              console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
            }
            break;
          }
          case "string":
            if (true) {
              var matched = [];
              var replaced = interpolation.replace(animationRegex, function(match, p1, p22) {
                var fakeVarName = "animation" + matched.length;
                matched.push("const " + fakeVarName + " = keyframes`" + p22.replace(/^@keyframes animation-\w+/, "") + "`");
                return "${" + fakeVarName + "}";
              });
              if (matched.length) {
                console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
              }
            }
            break;
        }
        if (registered == null) {
          return interpolation;
        }
        var cached = registered[interpolation];
        return cached !== void 0 ? cached : interpolation;
      }
      function createStringFromObject(mergedProps, registered, obj) {
        var string2 = "";
        if (Array.isArray(obj)) {
          for (var i5 = 0; i5 < obj.length; i5++) {
            string2 += handleInterpolation(mergedProps, registered, obj[i5]) + ";";
          }
        } else {
          for (var _key in obj) {
            var value = obj[_key];
            if (typeof value !== "object") {
              if (registered != null && registered[value] !== void 0) {
                string2 += _key + "{" + registered[value] + "}";
              } else if (isProcessableValue(value)) {
                string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
              }
            } else {
              if (_key === "NO_COMPONENT_SELECTOR" && true) {
                throw new Error(noComponentSelectorMessage);
              }
              if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
                for (var _i = 0; _i < value.length; _i++) {
                  if (isProcessableValue(value[_i])) {
                    string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                  }
                }
              } else {
                var interpolated = handleInterpolation(mergedProps, registered, value);
                switch (_key) {
                  case "animation":
                  case "animationName": {
                    string2 += processStyleName(_key) + ":" + interpolated + ";";
                    break;
                  }
                  default: {
                    if (_key === "undefined") {
                      console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                    }
                    string2 += _key + "{" + interpolated + "}";
                  }
                }
              }
            }
          }
        }
        return string2;
      }
      var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
      var sourceMapPattern;
      if (true) {
        sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
      }
      var cursor;
      var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
        if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
          return args[0];
        }
        var stringMode = true;
        var styles = "";
        cursor = void 0;
        var strings = args[0];
        if (strings == null || strings.raw === void 0) {
          stringMode = false;
          styles += handleInterpolation(mergedProps, registered, strings);
        } else {
          if (strings[0] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }
          styles += strings[0];
        }
        for (var i5 = 1; i5 < args.length; i5++) {
          styles += handleInterpolation(mergedProps, registered, args[i5]);
          if (stringMode) {
            if (strings[i5] === void 0) {
              console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
            }
            styles += strings[i5];
          }
        }
        var sourceMap;
        if (true) {
          styles = styles.replace(sourceMapPattern, function(match2) {
            sourceMap = match2;
            return "";
          });
        }
        labelPattern.lastIndex = 0;
        var identifierName = "";
        var match;
        while ((match = labelPattern.exec(styles)) !== null) {
          identifierName += "-" + match[1];
        }
        var name = hashString__default["default"](styles) + identifierName;
        if (true) {
          return {
            name,
            styles,
            map: sourceMap,
            next: cursor,
            toString: function toString() {
              return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
            }
          };
        }
        return {
          name,
          styles,
          next: cursor
        };
      };
      exports.serializeStyles = serializeStyles;
    }
  });

  // node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js
  var require_emotion_serialize_cjs = __commonJS({
    "node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_serialize_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.dev.js
  var require_emotion_use_insertion_effect_with_fallbacks_cjs_dev = __commonJS({
    "node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var React8 = require_react();
      function _interopNamespace(e4) {
        if (e4 && e4.__esModule)
          return e4;
        var n5 = /* @__PURE__ */ Object.create(null);
        if (e4) {
          Object.keys(e4).forEach(function(k3) {
            if (k3 !== "default") {
              var d4 = Object.getOwnPropertyDescriptor(e4, k3);
              Object.defineProperty(n5, k3, d4.get ? d4 : {
                enumerable: true,
                get: function() {
                  return e4[k3];
                }
              });
            }
          });
        }
        n5["default"] = e4;
        return Object.freeze(n5);
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React8);
      var isBrowser3 = typeof document !== "undefined";
      var syncFallback = function syncFallback2(create3) {
        return create3();
      };
      var useInsertionEffect = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : false;
      var useInsertionEffectAlwaysWithSyncFallback = !isBrowser3 ? syncFallback : useInsertionEffect || syncFallback;
      var useInsertionEffectWithLayoutFallback = useInsertionEffect || React8.useLayoutEffect;
      exports.useInsertionEffectAlwaysWithSyncFallback = useInsertionEffectAlwaysWithSyncFallback;
      exports.useInsertionEffectWithLayoutFallback = useInsertionEffectWithLayoutFallback;
    }
  });

  // node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js
  var require_emotion_use_insertion_effect_with_fallbacks_cjs = __commonJS({
    "node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_use_insertion_effect_with_fallbacks_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/react/dist/emotion-element-b63ca7c6.cjs.dev.js
  var require_emotion_element_b63ca7c6_cjs_dev = __commonJS({
    "node_modules/@emotion/react/dist/emotion-element-b63ca7c6.cjs.dev.js"(exports) {
      "use strict";
      var React8 = require_react();
      var createCache3 = require_emotion_cache_cjs();
      var _extends5 = require_extends();
      var weakMemoize = require_emotion_weak_memoize_cjs();
      var _isolatedHnrs_dist_emotionReact_isolatedHnrs = require_emotion_react_isolated_hnrs_cjs_dev();
      var utils = require_emotion_utils_cjs();
      var serialize2 = require_emotion_serialize_cjs();
      var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var createCache__default = /* @__PURE__ */ _interopDefault(createCache3);
      var weakMemoize__default = /* @__PURE__ */ _interopDefault(weakMemoize);
      var isBrowser3 = typeof document !== "undefined";
      var hasOwnProperty = {}.hasOwnProperty;
      var EmotionCacheContext = /* @__PURE__ */ React8.createContext(
        typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache__default["default"]({
          key: "css"
        }) : null
      );
      if (true) {
        EmotionCacheContext.displayName = "EmotionCacheContext";
      }
      var CacheProvider2 = EmotionCacheContext.Provider;
      var __unsafe_useEmotionCache = function useEmotionCache2() {
        return React8.useContext(EmotionCacheContext);
      };
      exports.withEmotionCache = function withEmotionCache(func) {
        return /* @__PURE__ */ React8.forwardRef(function(props, ref2) {
          var cache2 = React8.useContext(EmotionCacheContext);
          return func(props, cache2, ref2);
        });
      };
      if (!isBrowser3) {
        exports.withEmotionCache = function withEmotionCache(func) {
          return function(props) {
            var cache2 = React8.useContext(EmotionCacheContext);
            if (cache2 === null) {
              cache2 = createCache__default["default"]({
                key: "css"
              });
              return /* @__PURE__ */ React8.createElement(EmotionCacheContext.Provider, {
                value: cache2
              }, func(props, cache2));
            } else {
              return func(props, cache2);
            }
          };
        };
      }
      var ThemeContext = /* @__PURE__ */ React8.createContext({});
      if (true) {
        ThemeContext.displayName = "EmotionThemeContext";
      }
      var useTheme = function useTheme2() {
        return React8.useContext(ThemeContext);
      };
      var getTheme = function getTheme2(outerTheme, theme) {
        if (typeof theme === "function") {
          var mergedTheme = theme(outerTheme);
          if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
            throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
          }
          return mergedTheme;
        }
        if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
          throw new Error("[ThemeProvider] Please make your theme prop a plain object");
        }
        return _extends5({}, outerTheme, theme);
      };
      var createCacheWithTheme = /* @__PURE__ */ weakMemoize__default["default"](function(outerTheme) {
        return weakMemoize__default["default"](function(theme) {
          return getTheme(outerTheme, theme);
        });
      });
      var ThemeProvider = function ThemeProvider2(props) {
        var theme = React8.useContext(ThemeContext);
        if (props.theme !== theme) {
          theme = createCacheWithTheme(theme)(props.theme);
        }
        return /* @__PURE__ */ React8.createElement(ThemeContext.Provider, {
          value: theme
        }, props.children);
      };
      function withTheme(Component2) {
        var componentName = Component2.displayName || Component2.name || "Component";
        var render2 = function render3(props, ref2) {
          var theme = React8.useContext(ThemeContext);
          return /* @__PURE__ */ React8.createElement(Component2, _extends5({
            theme,
            ref: ref2
          }, props));
        };
        var WithTheme = /* @__PURE__ */ React8.forwardRef(render2);
        WithTheme.displayName = "WithTheme(" + componentName + ")";
        return _isolatedHnrs_dist_emotionReact_isolatedHnrs["default"](WithTheme, Component2);
      }
      var getLastPart = function getLastPart2(functionName) {
        var parts = functionName.split(".");
        return parts[parts.length - 1];
      };
      var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line) {
        var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
        if (match)
          return getLastPart(match[1]);
        match = /^([A-Za-z0-9$.]+)@/.exec(line);
        if (match)
          return getLastPart(match[1]);
        return void 0;
      };
      var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
      var sanitizeIdentifier = function sanitizeIdentifier2(identifier) {
        return identifier.replace(/\$/g, "-");
      };
      var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
        if (!stackTrace)
          return void 0;
        var lines = stackTrace.split("\n");
        for (var i5 = 0; i5 < lines.length; i5++) {
          var functionName = getFunctionNameFromStackTraceLine(lines[i5]);
          if (!functionName)
            continue;
          if (internalReactFunctionNames.has(functionName))
            break;
          if (/^[A-Z]/.test(functionName))
            return sanitizeIdentifier(functionName);
        }
        return void 0;
      };
      var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
      var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
      var createEmotionProps = function createEmotionProps2(type, props) {
        if (typeof props.css === "string" && props.css.indexOf(":") !== -1) {
          throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
        }
        var newProps = {};
        for (var key in props) {
          if (hasOwnProperty.call(props, key)) {
            newProps[key] = props[key];
          }
        }
        newProps[typePropName] = type;
        if (!!props.css && (typeof props.css !== "object" || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
          var label = getLabelFromStackTrace(new Error().stack);
          if (label)
            newProps[labelPropName] = label;
        }
        return newProps;
      };
      var Insertion = function Insertion2(_ref8) {
        var cache2 = _ref8.cache, serialized = _ref8.serialized, isStringTag = _ref8.isStringTag;
        utils.registerStyles(cache2, serialized, isStringTag);
        var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
          return utils.insertStyles(cache2, serialized, isStringTag);
        });
        if (!isBrowser3 && rules !== void 0) {
          var _ref22;
          var serializedNames = serialized.name;
          var next2 = serialized.next;
          while (next2 !== void 0) {
            serializedNames += " " + next2.name;
            next2 = next2.next;
          }
          return /* @__PURE__ */ React8.createElement("style", (_ref22 = {}, _ref22["data-emotion"] = cache2.key + " " + serializedNames, _ref22.dangerouslySetInnerHTML = {
            __html: rules
          }, _ref22.nonce = cache2.sheet.nonce, _ref22));
        }
        return null;
      };
      var Emotion = /* @__PURE__ */ exports.withEmotionCache(function(props, cache2, ref2) {
        var cssProp = props.css;
        if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
          cssProp = cache2.registered[cssProp];
        }
        var WrappedComponent = props[typePropName];
        var registeredStyles = [cssProp];
        var className = "";
        if (typeof props.className === "string") {
          className = utils.getRegisteredStyles(cache2.registered, registeredStyles, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serialize2.serializeStyles(registeredStyles, void 0, React8.useContext(ThemeContext));
        if (serialized.name.indexOf("-") === -1) {
          var labelFromStack = props[labelPropName];
          if (labelFromStack) {
            serialized = serialize2.serializeStyles([serialized, "label:" + labelFromStack + ";"]);
          }
        }
        className += cache2.key + "-" + serialized.name;
        var newProps = {};
        for (var key in props) {
          if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
            newProps[key] = props[key];
          }
        }
        newProps.ref = ref2;
        newProps.className = className;
        return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(Insertion, {
          cache: cache2,
          serialized,
          isStringTag: typeof WrappedComponent === "string"
        }), /* @__PURE__ */ React8.createElement(WrappedComponent, newProps));
      });
      if (true) {
        Emotion.displayName = "EmotionCssPropInternal";
      }
      exports.CacheProvider = CacheProvider2;
      exports.Emotion = Emotion;
      exports.ThemeContext = ThemeContext;
      exports.ThemeProvider = ThemeProvider;
      exports.__unsafe_useEmotionCache = __unsafe_useEmotionCache;
      exports.createEmotionProps = createEmotionProps;
      exports.hasOwnProperty = hasOwnProperty;
      exports.isBrowser = isBrowser3;
      exports.useTheme = useTheme;
      exports.withTheme = withTheme;
    }
  });

  // node_modules/@emotion/react/dist/emotion-react.cjs.dev.js
  var require_emotion_react_cjs_dev = __commonJS({
    "node_modules/@emotion/react/dist/emotion-react.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var React8 = require_react();
      require_emotion_cache_cjs();
      var emotionElement = require_emotion_element_b63ca7c6_cjs_dev();
      require_extends();
      require_emotion_weak_memoize_cjs();
      require_hoist_non_react_statics_cjs();
      require_emotion_react_isolated_hnrs_cjs_dev();
      var utils = require_emotion_utils_cjs();
      var serialize2 = require_emotion_serialize_cjs();
      var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
      var pkg = {
        name: "@emotion/react",
        version: "11.10.5",
        main: "dist/emotion-react.cjs.js",
        module: "dist/emotion-react.esm.js",
        browser: {
          "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
        },
        exports: {
          ".": {
            module: {
              worker: "./dist/emotion-react.worker.esm.js",
              browser: "./dist/emotion-react.browser.esm.js",
              "default": "./dist/emotion-react.esm.js"
            },
            "default": "./dist/emotion-react.cjs.js"
          },
          "./jsx-runtime": {
            module: {
              worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
              browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
              "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
            },
            "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
          },
          "./_isolated-hnrs": {
            module: {
              worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
              browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
              "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
            },
            "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
          },
          "./jsx-dev-runtime": {
            module: {
              worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
              browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
              "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
            },
            "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
          },
          "./package.json": "./package.json",
          "./types/css-prop": "./types/css-prop.d.ts",
          "./macro": "./macro.js"
        },
        types: "types/index.d.ts",
        files: [
          "src",
          "dist",
          "jsx-runtime",
          "jsx-dev-runtime",
          "_isolated-hnrs",
          "types/*.d.ts",
          "macro.js",
          "macro.d.ts",
          "macro.js.flow"
        ],
        sideEffects: false,
        author: "Emotion Contributors",
        license: "MIT",
        scripts: {
          "test:typescript": "dtslint types"
        },
        dependencies: {
          "@babel/runtime": "^7.18.3",
          "@emotion/babel-plugin": "^11.10.5",
          "@emotion/cache": "^11.10.5",
          "@emotion/serialize": "^1.1.1",
          "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
          "@emotion/utils": "^1.2.0",
          "@emotion/weak-memoize": "^0.3.0",
          "hoist-non-react-statics": "^3.3.1"
        },
        peerDependencies: {
          "@babel/core": "^7.0.0",
          react: ">=16.8.0"
        },
        peerDependenciesMeta: {
          "@babel/core": {
            optional: true
          },
          "@types/react": {
            optional: true
          }
        },
        devDependencies: {
          "@babel/core": "^7.18.5",
          "@definitelytyped/dtslint": "0.0.112",
          "@emotion/css": "11.10.5",
          "@emotion/css-prettifier": "1.1.1",
          "@emotion/server": "11.10.0",
          "@emotion/styled": "11.10.5",
          "html-tag-names": "^1.1.2",
          react: "16.14.0",
          "svg-tag-names": "^1.1.1",
          typescript: "^4.5.5"
        },
        repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
        publishConfig: {
          access: "public"
        },
        "umd:main": "dist/emotion-react.umd.min.js",
        preconstruct: {
          entrypoints: [
            "./index.js",
            "./jsx-runtime.js",
            "./jsx-dev-runtime.js",
            "./_isolated-hnrs.js"
          ],
          umdName: "emotionReact",
          exports: {
            envConditions: [
              "browser",
              "worker"
            ],
            extra: {
              "./types/css-prop": "./types/css-prop.d.ts",
              "./macro": "./macro.js"
            }
          }
        }
      };
      var jsx = function jsx2(type, props) {
        var args = arguments;
        if (props == null || !emotionElement.hasOwnProperty.call(props, "css")) {
          return React8.createElement.apply(void 0, args);
        }
        var argsLength = args.length;
        var createElementArgArray = new Array(argsLength);
        createElementArgArray[0] = emotionElement.Emotion;
        createElementArgArray[1] = emotionElement.createEmotionProps(type, props);
        for (var i5 = 2; i5 < argsLength; i5++) {
          createElementArgArray[i5] = args[i5];
        }
        return React8.createElement.apply(null, createElementArgArray);
      };
      var warnedAboutCssPropForGlobal = false;
      var Global = /* @__PURE__ */ emotionElement.withEmotionCache(function(props, cache2) {
        if (!warnedAboutCssPropForGlobal && (props.className || props.css)) {
          console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
          warnedAboutCssPropForGlobal = true;
        }
        var styles = props.styles;
        var serialized = serialize2.serializeStyles([styles], void 0, React8.useContext(emotionElement.ThemeContext));
        if (!emotionElement.isBrowser) {
          var _ref8;
          var serializedNames = serialized.name;
          var serializedStyles = serialized.styles;
          var next2 = serialized.next;
          while (next2 !== void 0) {
            serializedNames += " " + next2.name;
            serializedStyles += next2.styles;
            next2 = next2.next;
          }
          var shouldCache = cache2.compat === true;
          var rules = cache2.insert("", {
            name: serializedNames,
            styles: serializedStyles
          }, cache2.sheet, shouldCache);
          if (shouldCache) {
            return null;
          }
          return /* @__PURE__ */ React8.createElement("style", (_ref8 = {}, _ref8["data-emotion"] = cache2.key + "-global " + serializedNames, _ref8.dangerouslySetInnerHTML = {
            __html: rules
          }, _ref8.nonce = cache2.sheet.nonce, _ref8));
        }
        var sheetRef = React8.useRef();
        useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
          var key = cache2.key + "-global";
          var sheet = new cache2.sheet.constructor({
            key,
            nonce: cache2.sheet.nonce,
            container: cache2.sheet.container,
            speedy: cache2.sheet.isSpeedy
          });
          var rehydrating = false;
          var node = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
          if (cache2.sheet.tags.length) {
            sheet.before = cache2.sheet.tags[0];
          }
          if (node !== null) {
            rehydrating = true;
            node.setAttribute("data-emotion", key);
            sheet.hydrate([node]);
          }
          sheetRef.current = [sheet, rehydrating];
          return function() {
            sheet.flush();
          };
        }, [cache2]);
        useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
          var sheetRefCurrent = sheetRef.current;
          var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
          if (rehydrating) {
            sheetRefCurrent[1] = false;
            return;
          }
          if (serialized.next !== void 0) {
            utils.insertStyles(cache2, serialized.next, true);
          }
          if (sheet.tags.length) {
            var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
            sheet.before = element;
            sheet.flush();
          }
          cache2.insert("", serialized, sheet, false);
        }, [cache2, serialized.name]);
        return null;
      });
      if (true) {
        Global.displayName = "EmotionGlobal";
      }
      function css16() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return serialize2.serializeStyles(args);
      }
      var keyframes3 = function keyframes4() {
        var insertable = css16.apply(void 0, arguments);
        var name = "animation-" + insertable.name;
        return {
          name,
          styles: "@keyframes " + name + "{" + insertable.styles + "}",
          anim: 1,
          toString: function toString() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
          }
        };
      };
      var classnames48 = function classnames49(args) {
        var len = args.length;
        var i5 = 0;
        var cls = "";
        for (; i5 < len; i5++) {
          var arg = args[i5];
          if (arg == null)
            continue;
          var toAdd = void 0;
          switch (typeof arg) {
            case "boolean":
              break;
            case "object": {
              if (Array.isArray(arg)) {
                toAdd = classnames49(arg);
              } else {
                if (arg.styles !== void 0 && arg.name !== void 0) {
                  console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
                }
                toAdd = "";
                for (var k3 in arg) {
                  if (arg[k3] && k3) {
                    toAdd && (toAdd += " ");
                    toAdd += k3;
                  }
                }
              }
              break;
            }
            default: {
              toAdd = arg;
            }
          }
          if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
          }
        }
        return cls;
      };
      function merge2(registered, css17, className) {
        var registeredStyles = [];
        var rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
        if (registeredStyles.length < 2) {
          return className;
        }
        return rawClassName + css17(registeredStyles);
      }
      var Insertion = function Insertion2(_ref8) {
        var cache2 = _ref8.cache, serializedArr = _ref8.serializedArr;
        var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
          var rules2 = "";
          for (var i5 = 0; i5 < serializedArr.length; i5++) {
            var res = utils.insertStyles(cache2, serializedArr[i5], false);
            if (!emotionElement.isBrowser && res !== void 0) {
              rules2 += res;
            }
          }
          if (!emotionElement.isBrowser) {
            return rules2;
          }
        });
        if (!emotionElement.isBrowser && rules.length !== 0) {
          var _ref22;
          return /* @__PURE__ */ React8.createElement("style", (_ref22 = {}, _ref22["data-emotion"] = cache2.key + " " + serializedArr.map(function(serialized) {
            return serialized.name;
          }).join(" "), _ref22.dangerouslySetInnerHTML = {
            __html: rules
          }, _ref22.nonce = cache2.sheet.nonce, _ref22));
        }
        return null;
      };
      var ClassNames = /* @__PURE__ */ emotionElement.withEmotionCache(function(props, cache2) {
        var hasRendered = false;
        var serializedArr = [];
        var css17 = function css18() {
          if (hasRendered && true) {
            throw new Error("css can only be used during render");
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var serialized = serialize2.serializeStyles(args, cache2.registered);
          serializedArr.push(serialized);
          utils.registerStyles(cache2, serialized, false);
          return cache2.key + "-" + serialized.name;
        };
        var cx = function cx2() {
          if (hasRendered && true) {
            throw new Error("cx can only be used during render");
          }
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return merge2(cache2.registered, css17, classnames48(args));
        };
        var content = {
          css: css17,
          cx,
          theme: React8.useContext(emotionElement.ThemeContext)
        };
        var ele = props.children(content);
        hasRendered = true;
        return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(Insertion, {
          cache: cache2,
          serializedArr
        }), ele);
      });
      if (true) {
        ClassNames.displayName = "EmotionClassNames";
      }
      if (true) {
        isBrowser3 = typeof document !== "undefined";
        isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
        if (isBrowser3 && !isTestEnv) {
          globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser3 ? window : global;
          globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
          if (globalContext[globalKey]) {
            console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
          }
          globalContext[globalKey] = true;
        }
      }
      var isBrowser3;
      var isTestEnv;
      var globalContext;
      var globalKey;
      exports.CacheProvider = emotionElement.CacheProvider;
      exports.ThemeContext = emotionElement.ThemeContext;
      exports.ThemeProvider = emotionElement.ThemeProvider;
      exports.__unsafe_useEmotionCache = emotionElement.__unsafe_useEmotionCache;
      exports.useTheme = emotionElement.useTheme;
      Object.defineProperty(exports, "withEmotionCache", {
        enumerable: true,
        get: function() {
          return emotionElement.withEmotionCache;
        }
      });
      exports.withTheme = emotionElement.withTheme;
      exports.ClassNames = ClassNames;
      exports.Global = Global;
      exports.createElement = jsx;
      exports.css = css16;
      exports.jsx = jsx;
      exports.keyframes = keyframes3;
    }
  });

  // node_modules/@emotion/react/dist/emotion-react.cjs.js
  var require_emotion_react_cjs = __commonJS({
    "node_modules/@emotion/react/dist/emotion-react.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_react_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.cjs.dev.js
  var require_emotion_css_create_instance_cjs_dev = __commonJS({
    "node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var createCache3 = require_emotion_cache_cjs();
      var serialize2 = require_emotion_serialize_cjs();
      var utils = require_emotion_utils_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var createCache__default = /* @__PURE__ */ _interopDefault(createCache3);
      function insertWithoutScoping(cache2, serialized) {
        if (cache2.inserted[serialized.name] === void 0) {
          return cache2.insert("", serialized, cache2.sheet, true);
        }
      }
      function merge2(registered, css16, className) {
        var registeredStyles = [];
        var rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
        if (registeredStyles.length < 2) {
          return className;
        }
        return rawClassName + css16(registeredStyles);
      }
      var createEmotion = function createEmotion2(options) {
        var cache2 = createCache__default["default"](options);
        cache2.sheet.speedy = function(value) {
          if (this.ctr !== 0) {
            throw new Error("speedy must be changed before any rules are inserted");
          }
          this.isSpeedy = value;
        };
        cache2.compat = true;
        var css16 = function css17() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var serialized = serialize2.serializeStyles(args, cache2.registered, void 0);
          utils.insertStyles(cache2, serialized, false);
          return cache2.key + "-" + serialized.name;
        };
        var keyframes3 = function keyframes4() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          var serialized = serialize2.serializeStyles(args, cache2.registered);
          var animation = "animation-" + serialized.name;
          insertWithoutScoping(cache2, {
            name: serialized.name,
            styles: "@keyframes " + animation + "{" + serialized.styles + "}"
          });
          return animation;
        };
        var injectGlobal = function injectGlobal2() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          var serialized = serialize2.serializeStyles(args, cache2.registered);
          insertWithoutScoping(cache2, serialized);
        };
        var cx = function cx2() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return merge2(cache2.registered, css16, classnames48(args));
        };
        return {
          css: css16,
          cx,
          injectGlobal,
          keyframes: keyframes3,
          hydrate: function hydrate2(ids) {
            ids.forEach(function(key) {
              cache2.inserted[key] = true;
            });
          },
          flush: function flush2() {
            cache2.registered = {};
            cache2.inserted = {};
            cache2.sheet.flush();
          },
          sheet: cache2.sheet,
          cache: cache2,
          getRegisteredStyles: utils.getRegisteredStyles.bind(null, cache2.registered),
          merge: merge2.bind(null, cache2.registered, css16)
        };
      };
      var classnames48 = function classnames49(args) {
        var cls = "";
        for (var i5 = 0; i5 < args.length; i5++) {
          var arg = args[i5];
          if (arg == null)
            continue;
          var toAdd = void 0;
          switch (typeof arg) {
            case "boolean":
              break;
            case "object": {
              if (Array.isArray(arg)) {
                toAdd = classnames49(arg);
              } else {
                toAdd = "";
                for (var k3 in arg) {
                  if (arg[k3] && k3) {
                    toAdd && (toAdd += " ");
                    toAdd += k3;
                  }
                }
              }
              break;
            }
            default: {
              toAdd = arg;
            }
          }
          if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
          }
        }
        return cls;
      };
      exports.default = createEmotion;
    }
  });

  // node_modules/@emotion/css/dist/emotion-css.cjs.dev.js
  var require_emotion_css_cjs_dev = __commonJS({
    "node_modules/@emotion/css/dist/emotion-css.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      require_emotion_cache_cjs();
      require_emotion_serialize_cjs();
      require_emotion_utils_cjs();
      var createInstance_dist_emotionCssCreateInstance = require_emotion_css_create_instance_cjs_dev();
      var _createEmotion = createInstance_dist_emotionCssCreateInstance["default"]({
        key: "css"
      });
      var flush2 = _createEmotion.flush;
      var hydrate2 = _createEmotion.hydrate;
      var cx = _createEmotion.cx;
      var merge2 = _createEmotion.merge;
      var getRegisteredStyles = _createEmotion.getRegisteredStyles;
      var injectGlobal = _createEmotion.injectGlobal;
      var keyframes3 = _createEmotion.keyframes;
      var css16 = _createEmotion.css;
      var sheet = _createEmotion.sheet;
      var cache2 = _createEmotion.cache;
      exports.cache = cache2;
      exports.css = css16;
      exports.cx = cx;
      exports.flush = flush2;
      exports.getRegisteredStyles = getRegisteredStyles;
      exports.hydrate = hydrate2;
      exports.injectGlobal = injectGlobal;
      exports.keyframes = keyframes3;
      exports.merge = merge2;
      exports.sheet = sheet;
    }
  });

  // node_modules/@emotion/css/dist/emotion-css.cjs.js
  var require_emotion_css_cjs = __commonJS({
    "node_modules/@emotion/css/dist/emotion-css.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_css_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js
  var require_emotion_is_prop_valid_cjs_dev = __commonJS({
    "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var memoize7 = require_emotion_memoize_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var memoize__default = /* @__PURE__ */ _interopDefault(memoize7);
      var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
      var isPropValid = /* @__PURE__ */ memoize__default["default"](
        function(prop2) {
          return reactPropsRegex.test(prop2) || prop2.charCodeAt(0) === 111 && prop2.charCodeAt(1) === 110 && prop2.charCodeAt(2) < 91;
        }
      );
      exports.default = isPropValid;
    }
  });

  // node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js
  var require_emotion_is_prop_valid_cjs = __commonJS({
    "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_is_prop_valid_cjs_dev();
      }
    }
  });

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.dev.js
  var require_emotion_styled_base_cjs_dev = __commonJS({
    "node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.dev.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _extends5 = require_extends();
      var React8 = require_react();
      var isPropValid = require_emotion_is_prop_valid_cjs();
      var react = require_emotion_react_cjs();
      var utils = require_emotion_utils_cjs();
      var serialize2 = require_emotion_serialize_cjs();
      var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
      function _interopDefault(e4) {
        return e4 && e4.__esModule ? e4 : { "default": e4 };
      }
      var isPropValid__default = /* @__PURE__ */ _interopDefault(isPropValid);
      var testOmitPropsOnStringTag = isPropValid__default["default"];
      var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
        return key !== "theme";
      };
      var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
        return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
      };
      var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
        var shouldForwardProp;
        if (options) {
          var optionsShouldForwardProp = options.shouldForwardProp;
          shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
            return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
          } : optionsShouldForwardProp;
        }
        if (typeof shouldForwardProp !== "function" && isReal) {
          shouldForwardProp = tag.__emotion_forwardProp;
        }
        return shouldForwardProp;
      };
      var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
      var isBrowser3 = typeof document !== "undefined";
      var Insertion = function Insertion2(_ref8) {
        var cache2 = _ref8.cache, serialized = _ref8.serialized, isStringTag = _ref8.isStringTag;
        utils.registerStyles(cache2, serialized, isStringTag);
        var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
          return utils.insertStyles(cache2, serialized, isStringTag);
        });
        if (!isBrowser3 && rules !== void 0) {
          var _ref22;
          var serializedNames = serialized.name;
          var next2 = serialized.next;
          while (next2 !== void 0) {
            serializedNames += " " + next2.name;
            next2 = next2.next;
          }
          return /* @__PURE__ */ React8.createElement("style", (_ref22 = {}, _ref22["data-emotion"] = cache2.key + " " + serializedNames, _ref22.dangerouslySetInnerHTML = {
            __html: rules
          }, _ref22.nonce = cache2.sheet.nonce, _ref22));
        }
        return null;
      };
      var createStyled = function createStyled2(tag, options) {
        if (true) {
          if (tag === void 0) {
            throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
          }
        }
        var isReal = tag.__emotion_real === tag;
        var baseTag = isReal && tag.__emotion_base || tag;
        var identifierName;
        var targetClassName;
        if (options !== void 0) {
          identifierName = options.label;
          targetClassName = options.target;
        }
        var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
        var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
        var shouldUseAs = !defaultShouldForwardProp("as");
        return function() {
          var args = arguments;
          var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
          if (identifierName !== void 0) {
            styles.push("label:" + identifierName + ";");
          }
          if (args[0] == null || args[0].raw === void 0) {
            styles.push.apply(styles, args);
          } else {
            if (args[0][0] === void 0) {
              console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
            }
            styles.push(args[0][0]);
            var len = args.length;
            var i5 = 1;
            for (; i5 < len; i5++) {
              if (args[0][i5] === void 0) {
                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
              }
              styles.push(args[i5], args[0][i5]);
            }
          }
          var Styled = react.withEmotionCache(function(props, cache2, ref2) {
            var FinalTag = shouldUseAs && props.as || baseTag;
            var className = "";
            var classInterpolations = [];
            var mergedProps = props;
            if (props.theme == null) {
              mergedProps = {};
              for (var key in props) {
                mergedProps[key] = props[key];
              }
              mergedProps.theme = React8.useContext(react.ThemeContext);
            }
            if (typeof props.className === "string") {
              className = utils.getRegisteredStyles(cache2.registered, classInterpolations, props.className);
            } else if (props.className != null) {
              className = props.className + " ";
            }
            var serialized = serialize2.serializeStyles(styles.concat(classInterpolations), cache2.registered, mergedProps);
            className += cache2.key + "-" + serialized.name;
            if (targetClassName !== void 0) {
              className += " " + targetClassName;
            }
            var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
            var newProps = {};
            for (var _key in props) {
              if (shouldUseAs && _key === "as")
                continue;
              if (finalShouldForwardProp(_key)) {
                newProps[_key] = props[_key];
              }
            }
            newProps.className = className;
            newProps.ref = ref2;
            return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(Insertion, {
              cache: cache2,
              serialized,
              isStringTag: typeof FinalTag === "string"
            }), /* @__PURE__ */ React8.createElement(FinalTag, newProps));
          });
          Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
          Styled.defaultProps = tag.defaultProps;
          Styled.__emotion_real = Styled;
          Styled.__emotion_base = baseTag;
          Styled.__emotion_styles = styles;
          Styled.__emotion_forwardProp = shouldForwardProp;
          Object.defineProperty(Styled, "toString", {
            value: function value() {
              if (targetClassName === void 0 && true) {
                return "NO_COMPONENT_SELECTOR";
              }
              return "." + targetClassName;
            }
          });
          Styled.withComponent = function(nextTag, nextOptions) {
            return createStyled2(nextTag, _extends5({}, options, nextOptions, {
              shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
            })).apply(void 0, styles);
          };
          return Styled;
        };
      };
      exports.default = createStyled;
    }
  });

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.js
  var require_emotion_styled_base_cjs = __commonJS({
    "node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_emotion_styled_base_cjs_dev();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React8 = require_react();
          var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error2(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack4 = ReactDebugCurrentFrame.getStackAddendum();
              if (stack4 !== "") {
                format += "%s";
                args = args.concat([stack4]);
              }
              var argsWithFormat = args.map(function(item2) {
                return String(item2);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is2(x4, y5) {
            return x4 === y5 && (x4 !== 0 || 1 / x4 === 1 / y5) || x4 !== x4 && y5 !== y5;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is2;
          var useState15 = React8.useState, useEffect22 = React8.useEffect, useLayoutEffect6 = React8.useLayoutEffect, useDebugValue6 = React8.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore2(subscribe4, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React8.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState15({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect6(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe4, value, getSnapshot]);
            useEffect22(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe4(handleStoreChange);
            }, [subscribe4]);
            useDebugValue6(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error3) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe4, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM2;
          var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
          var useSyncExternalStore$2 = React8.useSyncExternalStore !== void 0 ? React8.useSyncExternalStore : shim;
          exports.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/highlight-words-core/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/highlight-words-core/dist/index.js"(exports, module) {
      module.exports = function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module2 = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.loaded = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        function(module2, exports2, __webpack_require__) {
          module2.exports = __webpack_require__(1);
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _utils = __webpack_require__(2);
          Object.defineProperty(exports2, "combineChunks", {
            enumerable: true,
            get: function get11() {
              return _utils.combineChunks;
            }
          });
          Object.defineProperty(exports2, "fillInChunks", {
            enumerable: true,
            get: function get11() {
              return _utils.fillInChunks;
            }
          });
          Object.defineProperty(exports2, "findAll", {
            enumerable: true,
            get: function get11() {
              return _utils.findAll;
            }
          });
          Object.defineProperty(exports2, "findChunks", {
            enumerable: true,
            get: function get11() {
              return _utils.findChunks;
            }
          });
        },
        function(module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var findAll2 = exports2.findAll = function findAll3(_ref8) {
            var autoEscape = _ref8.autoEscape, _ref$caseSensitive = _ref8.caseSensitive, caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive, _ref$findChunks = _ref8.findChunks, findChunks = _ref$findChunks === void 0 ? defaultFindChunks : _ref$findChunks, sanitize2 = _ref8.sanitize, searchWords = _ref8.searchWords, textToHighlight = _ref8.textToHighlight;
            return fillInChunks({
              chunksToHighlight: combineChunks({
                chunks: findChunks({
                  autoEscape,
                  caseSensitive,
                  sanitize: sanitize2,
                  searchWords,
                  textToHighlight
                })
              }),
              totalLength: textToHighlight ? textToHighlight.length : 0
            });
          };
          var combineChunks = exports2.combineChunks = function combineChunks2(_ref22) {
            var chunks = _ref22.chunks;
            chunks = chunks.sort(function(first, second) {
              return first.start - second.start;
            }).reduce(function(processedChunks, nextChunk) {
              if (processedChunks.length === 0) {
                return [nextChunk];
              } else {
                var prevChunk = processedChunks.pop();
                if (nextChunk.start <= prevChunk.end) {
                  var endIndex = Math.max(prevChunk.end, nextChunk.end);
                  processedChunks.push({ highlight: false, start: prevChunk.start, end: endIndex });
                } else {
                  processedChunks.push(prevChunk, nextChunk);
                }
                return processedChunks;
              }
            }, []);
            return chunks;
          };
          var defaultFindChunks = function defaultFindChunks2(_ref32) {
            var autoEscape = _ref32.autoEscape, caseSensitive = _ref32.caseSensitive, _ref3$sanitize = _ref32.sanitize, sanitize2 = _ref3$sanitize === void 0 ? defaultSanitize : _ref3$sanitize, searchWords = _ref32.searchWords, textToHighlight = _ref32.textToHighlight;
            textToHighlight = sanitize2(textToHighlight);
            return searchWords.filter(function(searchWord) {
              return searchWord;
            }).reduce(function(chunks, searchWord) {
              searchWord = sanitize2(searchWord);
              if (autoEscape) {
                searchWord = escapeRegExpFn(searchWord);
              }
              var regex = new RegExp(searchWord, caseSensitive ? "g" : "gi");
              var match = void 0;
              while (match = regex.exec(textToHighlight)) {
                var _start = match.index;
                var _end = regex.lastIndex;
                if (_end > _start) {
                  chunks.push({ highlight: false, start: _start, end: _end });
                }
                if (match.index === regex.lastIndex) {
                  regex.lastIndex++;
                }
              }
              return chunks;
            }, []);
          };
          exports2.findChunks = defaultFindChunks;
          var fillInChunks = exports2.fillInChunks = function fillInChunks2(_ref42) {
            var chunksToHighlight = _ref42.chunksToHighlight, totalLength = _ref42.totalLength;
            var allChunks = [];
            var append2 = function append3(start2, end, highlight) {
              if (end - start2 > 0) {
                allChunks.push({
                  start: start2,
                  end,
                  highlight
                });
              }
            };
            if (chunksToHighlight.length === 0) {
              append2(0, totalLength, false);
            } else {
              var lastIndex = 0;
              chunksToHighlight.forEach(function(chunk2) {
                append2(lastIndex, chunk2.start, false);
                append2(chunk2.start, chunk2.end, true);
                lastIndex = chunk2.end;
              });
              append2(lastIndex, totalLength, false);
            }
            return allChunks;
          };
          function defaultSanitize(string2) {
            return string2;
          }
          function escapeRegExpFn(string2) {
            return string2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          }
        }
      ]);
    }
  });

  // node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development2 = __commonJS({
    "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef2 = REACT_FORWARD_REF_TYPE;
          var Fragment3 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode2 = REACT_STRICT_MODE_TYPE;
          var Suspense2 = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef2;
          exports.Fragment = Fragment3;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode2;
          exports.Suspense = Suspense2;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement2;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/prop-types/node_modules/react-is/index.js
  var require_react_is2 = __commonJS({
    "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development2();
      }
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text3) {
          var message = "Warning: " + text3;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x4) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error2;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error2 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error2 = ex;
              }
              if (error2 && !(error2 instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
                loggedTypeFailures[error2.message] = true;
                var stack4 = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location + " type: " + error2.message + (stack4 != null ? stack4 : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is2();
      var assign2 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text3) {
          var message = "Warning: " + text3;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x4) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement2, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is2(x4, y5) {
          if (x4 === y5) {
            return x4 !== 0 || 1 / x4 === 1 / y5;
          } else {
            return x4 !== x4 && y5 !== y5;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate2) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey2 = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey2] && manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey2] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate2(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate2(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate2(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i5 = 0; i5 < propValue.length; i5++) {
              var error2 = typeChecker(propValue, i5, componentName, location, propFullName + "[" + i5 + "]", ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createElementTypeChecker() {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement2(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createElementTypeTypeChecker() {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate2(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i5 = 0; i5 < expectedValues.length; i5++) {
              if (is2(propValue, expectedValues[i5])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate2);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate2(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error2 instanceof Error) {
                  return error2;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i5 = 0; i5 < arrayOfTypeCheckers.length; i5++) {
            var checker = arrayOfTypeCheckers[i5];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i5 + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate2(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for (var i6 = 0; i6 < arrayOfTypeCheckers.length; i6++) {
              var checker2 = arrayOfTypeCheckers[i6];
              var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate2);
        }
        function createNodeChecker() {
          function validate2(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function invalidValidatorError(componentName, location, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign2({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement2(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is2();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/diff/lib/diff/base.js
  var require_base = __commonJS({
    "node_modules/diff/lib/diff/base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = Diff;
      function Diff() {
      }
      Diff.prototype = {
        diff: function diff(oldString, newString) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = options.callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          this.options = options;
          var self2 = this;
          function done(value) {
            if (callback) {
              setTimeout(function() {
                callback(void 0, value);
              }, 0);
              return true;
            } else {
              return value;
            }
          }
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
            newPos: -1,
            components: []
          }];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done([{
              value: this.join(newString),
              count: newString.length
            }]);
          }
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0;
              var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                bestPath[diagonalPath - 1] = void 0;
              }
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = void 0;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self2.pushComponent(basePath.components, void 0, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self2.pushComponent(basePath.components, true, void 0);
              }
              _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
                return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
              } else {
                bestPath[diagonalPath] = basePath;
              }
            }
            editLength++;
          }
          if (callback) {
            (function exec() {
              setTimeout(function() {
                if (editLength > maxEditLength) {
                  return callback();
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            })();
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
        pushComponent: function pushComponent(components, added, removed) {
          var last = components[components.length - 1];
          if (last && last.added === added && last.removed === removed) {
            components[components.length - 1] = {
              count: last.count + 1,
              added,
              removed
            };
          } else {
            components.push({
              count: 1,
              added,
              removed
            });
          }
        },
        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) {
            basePath.components.push({
              count: commonCount
            });
          }
          basePath.newPos = newPos;
          return oldPos;
        },
        equals: function equals(left, right) {
          if (this.options.comparator) {
            return this.options.comparator(left, right);
          } else {
            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
          }
        },
        removeEmpty: function removeEmpty(array) {
          var ret = [];
          for (var i5 = 0; i5 < array.length; i5++) {
            if (array[i5]) {
              ret.push(array[i5]);
            }
          }
          return ret;
        },
        castInput: function castInput(value) {
          return value;
        },
        tokenize: function tokenize(value) {
          return value.split("");
        },
        join: function join(chars) {
          return chars.join("");
        }
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = value.map(function(value2, i5) {
                var oldValue = oldString[oldPos + i5];
                return oldValue.length > value2.length ? oldValue : value2;
              });
              component.value = diff.join(value);
            } else {
              component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
    }
  });

  // node_modules/diff/lib/diff/character.js
  var require_character = __commonJS({
    "node_modules/diff/lib/diff/character.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.diffChars = diffChars2;
      exports.characterDiff = void 0;
      var _base = _interopRequireDefault(require_base());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var characterDiff = new _base.default();
      exports.characterDiff = characterDiff;
      function diffChars2(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
    }
  });

  // node_modules/autosize/dist/autosize.js
  var require_autosize = __commonJS({
    "node_modules/autosize/dist/autosize.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define(["module", "exports"], factory);
        } else if (typeof exports !== "undefined") {
          factory(module, exports);
        } else {
          var mod = {
            exports: {}
          };
          factory(mod, mod.exports);
          global2.autosize = mod.exports;
        }
      })(exports, function(module2, exports2) {
        "use strict";
        var map9 = typeof Map === "function" ? /* @__PURE__ */ new Map() : function() {
          var keys = [];
          var values = [];
          return {
            has: function has(key) {
              return keys.indexOf(key) > -1;
            },
            get: function get11(key) {
              return values[keys.indexOf(key)];
            },
            set: function set(key, value) {
              if (keys.indexOf(key) === -1) {
                keys.push(key);
                values.push(value);
              }
            },
            delete: function _delete(key) {
              var index2 = keys.indexOf(key);
              if (index2 > -1) {
                keys.splice(index2, 1);
                values.splice(index2, 1);
              }
            }
          };
        }();
        var createEvent2 = function createEvent3(name) {
          return new Event(name, { bubbles: true });
        };
        try {
          new Event("test");
        } catch (e4) {
          createEvent2 = function createEvent3(name) {
            var evt = document.createEvent("Event");
            evt.initEvent(name, true, false);
            return evt;
          };
        }
        function assign2(ta) {
          if (!ta || !ta.nodeName || ta.nodeName !== "TEXTAREA" || map9.has(ta))
            return;
          var heightOffset = null;
          var clientWidth = null;
          var cachedHeight = null;
          function init() {
            var style = window.getComputedStyle(ta, null);
            if (style.resize === "vertical") {
              ta.style.resize = "none";
            } else if (style.resize === "both") {
              ta.style.resize = "horizontal";
            }
            if (style.boxSizing === "content-box") {
              heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
            } else {
              heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
            }
            if (isNaN(heightOffset)) {
              heightOffset = 0;
            }
            update4();
          }
          function changeOverflow(value) {
            {
              var width3 = ta.style.width;
              ta.style.width = "0px";
              ta.offsetWidth;
              ta.style.width = width3;
            }
            ta.style.overflowY = value;
          }
          function getParentOverflows(el) {
            var arr = [];
            while (el && el.parentNode && el.parentNode instanceof Element) {
              if (el.parentNode.scrollTop) {
                arr.push({
                  node: el.parentNode,
                  scrollTop: el.parentNode.scrollTop
                });
              }
              el = el.parentNode;
            }
            return arr;
          }
          function resize() {
            if (ta.scrollHeight === 0) {
              return;
            }
            var overflows = getParentOverflows(ta);
            var docTop = document.documentElement && document.documentElement.scrollTop;
            ta.style.height = "";
            ta.style.height = ta.scrollHeight + heightOffset + "px";
            clientWidth = ta.clientWidth;
            overflows.forEach(function(el) {
              el.node.scrollTop = el.scrollTop;
            });
            if (docTop) {
              document.documentElement.scrollTop = docTop;
            }
          }
          function update4() {
            resize();
            var styleHeight = Math.round(parseFloat(ta.style.height));
            var computed = window.getComputedStyle(ta, null);
            var actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;
            if (actualHeight < styleHeight) {
              if (computed.overflowY === "hidden") {
                changeOverflow("scroll");
                resize();
                actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
              }
            } else {
              if (computed.overflowY !== "hidden") {
                changeOverflow("hidden");
                resize();
                actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
              }
            }
            if (cachedHeight !== actualHeight) {
              cachedHeight = actualHeight;
              var evt = createEvent2("autosize:resized");
              try {
                ta.dispatchEvent(evt);
              } catch (err) {
              }
            }
          }
          var pageResize = function pageResize2() {
            if (ta.clientWidth !== clientWidth) {
              update4();
            }
          };
          var destroy2 = function(style) {
            window.removeEventListener("resize", pageResize, false);
            ta.removeEventListener("input", update4, false);
            ta.removeEventListener("keyup", update4, false);
            ta.removeEventListener("autosize:destroy", destroy2, false);
            ta.removeEventListener("autosize:update", update4, false);
            Object.keys(style).forEach(function(key) {
              ta.style[key] = style[key];
            });
            map9.delete(ta);
          }.bind(ta, {
            height: ta.style.height,
            resize: ta.style.resize,
            overflowY: ta.style.overflowY,
            overflowX: ta.style.overflowX,
            wordWrap: ta.style.wordWrap
          });
          ta.addEventListener("autosize:destroy", destroy2, false);
          if ("onpropertychange" in ta && "oninput" in ta) {
            ta.addEventListener("keyup", update4, false);
          }
          window.addEventListener("resize", pageResize, false);
          ta.addEventListener("input", update4, false);
          ta.addEventListener("autosize:update", update4, false);
          ta.style.overflowX = "hidden";
          ta.style.wordWrap = "break-word";
          map9.set(ta, {
            destroy: destroy2,
            update: update4
          });
          init();
        }
        function destroy(ta) {
          var methods = map9.get(ta);
          if (methods) {
            methods.destroy();
          }
        }
        function update3(ta) {
          var methods = map9.get(ta);
          if (methods) {
            methods.update();
          }
        }
        var autosize = null;
        if (typeof window === "undefined" || typeof window.getComputedStyle !== "function") {
          autosize = function autosize2(el) {
            return el;
          };
          autosize.destroy = function(el) {
            return el;
          };
          autosize.update = function(el) {
            return el;
          };
        } else {
          autosize = function autosize2(el, options) {
            if (el) {
              Array.prototype.forEach.call(el.length ? el : [el], function(x4) {
                return assign2(x4, options);
              });
            }
            return el;
          };
          autosize.destroy = function(el) {
            if (el) {
              Array.prototype.forEach.call(el.length ? el : [el], destroy);
            }
            return el;
          };
          autosize.update = function(el) {
            if (el) {
              Array.prototype.forEach.call(el.length ? el : [el], update3);
            }
            return el;
          };
        }
        exports2.default = autosize;
        module2.exports = exports2["default"];
      });
    }
  });

  // node_modules/computed-style/dist/computedStyle.commonjs.js
  var require_computedStyle_commonjs = __commonJS({
    "node_modules/computed-style/dist/computedStyle.commonjs.js"(exports, module) {
      var computedStyle = function(el, prop2, getComputedStyle4) {
        getComputedStyle4 = window.getComputedStyle;
        return (getComputedStyle4 ? getComputedStyle4(el) : el.currentStyle)[prop2.replace(/-(\w)/gi, function(word, letter) {
          return letter.toUpperCase();
        })];
      };
      module.exports = computedStyle;
    }
  });

  // node_modules/line-height/lib/line-height.js
  var require_line_height = __commonJS({
    "node_modules/line-height/lib/line-height.js"(exports, module) {
      var computedStyle = require_computedStyle_commonjs();
      function lineHeight2(node) {
        var lnHeightStr = computedStyle(node, "line-height");
        var lnHeight = parseFloat(lnHeightStr, 10);
        if (lnHeightStr === lnHeight + "") {
          var _lnHeightStyle = node.style.lineHeight;
          node.style.lineHeight = lnHeightStr + "em";
          lnHeightStr = computedStyle(node, "line-height");
          lnHeight = parseFloat(lnHeightStr, 10);
          if (_lnHeightStyle) {
            node.style.lineHeight = _lnHeightStyle;
          } else {
            delete node.style.lineHeight;
          }
        }
        if (lnHeightStr.indexOf("pt") !== -1) {
          lnHeight *= 4;
          lnHeight /= 3;
        } else if (lnHeightStr.indexOf("mm") !== -1) {
          lnHeight *= 96;
          lnHeight /= 25.4;
        } else if (lnHeightStr.indexOf("cm") !== -1) {
          lnHeight *= 96;
          lnHeight /= 2.54;
        } else if (lnHeightStr.indexOf("in") !== -1) {
          lnHeight *= 96;
        } else if (lnHeightStr.indexOf("pc") !== -1) {
          lnHeight *= 16;
        }
        lnHeight = Math.round(lnHeight);
        if (lnHeightStr === "normal") {
          var nodeName = node.nodeName;
          var _node = document.createElement(nodeName);
          _node.innerHTML = "&nbsp;";
          if (nodeName.toUpperCase() === "TEXTAREA") {
            _node.setAttribute("rows", "1");
          }
          var fontSizeStr = computedStyle(node, "font-size");
          _node.style.fontSize = fontSizeStr;
          _node.style.padding = "0px";
          _node.style.border = "0px";
          var body = document.body;
          body.appendChild(_node);
          var height = _node.offsetHeight;
          lnHeight = height;
          body.removeChild(_node);
        }
        return lnHeight;
      }
      module.exports = lineHeight2;
    }
  });

  // node_modules/react-autosize-textarea/lib/TextareaAutosize.js
  var require_TextareaAutosize = __commonJS({
    "node_modules/react-autosize-textarea/lib/TextareaAutosize.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || function() {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b6) {
          d4.__proto__ = b6;
        } || function(d4, b6) {
          for (var p5 in b6)
            if (b6.hasOwnProperty(p5))
              d4[p5] = b6[p5];
        };
        return function(d4, b6) {
          extendStatics(d4, b6);
          function __2() {
            this.constructor = d4;
          }
          d4.prototype = b6 === null ? Object.create(b6) : (__2.prototype = b6.prototype, new __2());
        };
      }();
      var __assign2 = exports && exports.__assign || Object.assign || function(t5) {
        for (var s5, i5 = 1, n5 = arguments.length; i5 < n5; i5++) {
          s5 = arguments[i5];
          for (var p5 in s5)
            if (Object.prototype.hasOwnProperty.call(s5, p5))
              t5[p5] = s5[p5];
        }
        return t5;
      };
      var __rest2 = exports && exports.__rest || function(s5, e4) {
        var t5 = {};
        for (var p5 in s5)
          if (Object.prototype.hasOwnProperty.call(s5, p5) && e4.indexOf(p5) < 0)
            t5[p5] = s5[p5];
        if (s5 != null && typeof Object.getOwnPropertySymbols === "function") {
          for (var i5 = 0, p5 = Object.getOwnPropertySymbols(s5); i5 < p5.length; i5++)
            if (e4.indexOf(p5[i5]) < 0)
              t5[p5[i5]] = s5[p5[i5]];
        }
        return t5;
      };
      exports.__esModule = true;
      var React8 = require_react();
      var PropTypes = require_prop_types();
      var autosize = require_autosize();
      var _getLineHeight = require_line_height();
      var getLineHeight2 = _getLineHeight;
      var RESIZED = "autosize:resized";
      var TextareaAutosizeClass = function(_super) {
        __extends2(TextareaAutosizeClass2, _super);
        function TextareaAutosizeClass2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.state = {
            lineHeight: null
          };
          _this.textarea = null;
          _this.onResize = function(e4) {
            if (_this.props.onResize) {
              _this.props.onResize(e4);
            }
          };
          _this.updateLineHeight = function() {
            if (_this.textarea) {
              _this.setState({
                lineHeight: getLineHeight2(_this.textarea)
              });
            }
          };
          _this.onChange = function(e4) {
            var onChange = _this.props.onChange;
            _this.currentValue = e4.currentTarget.value;
            onChange && onChange(e4);
          };
          return _this;
        }
        TextareaAutosizeClass2.prototype.componentDidMount = function() {
          var _this = this;
          var _a = this.props, maxRows = _a.maxRows, async = _a.async;
          if (typeof maxRows === "number") {
            this.updateLineHeight();
          }
          if (typeof maxRows === "number" || async) {
            setTimeout(function() {
              return _this.textarea && autosize(_this.textarea);
            });
          } else {
            this.textarea && autosize(this.textarea);
          }
          if (this.textarea) {
            this.textarea.addEventListener(RESIZED, this.onResize);
          }
        };
        TextareaAutosizeClass2.prototype.componentWillUnmount = function() {
          if (this.textarea) {
            this.textarea.removeEventListener(RESIZED, this.onResize);
            autosize.destroy(this.textarea);
          }
        };
        TextareaAutosizeClass2.prototype.render = function() {
          var _this = this;
          var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest2(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight2 = _a.state.lineHeight;
          var maxHeight = maxRows && lineHeight2 ? lineHeight2 * maxRows : null;
          return React8.createElement("textarea", __assign2({}, props, { onChange: this.onChange, style: maxHeight ? __assign2({}, style, { maxHeight }) : style, ref: function(element) {
            _this.textarea = element;
            if (typeof _this.props.innerRef === "function") {
              _this.props.innerRef(element);
            } else if (_this.props.innerRef) {
              _this.props.innerRef.current = element;
            }
          } }), children);
        };
        TextareaAutosizeClass2.prototype.componentDidUpdate = function() {
          this.textarea && autosize.update(this.textarea);
        };
        TextareaAutosizeClass2.defaultProps = {
          rows: 1,
          async: false
        };
        TextareaAutosizeClass2.propTypes = {
          rows: PropTypes.number,
          maxRows: PropTypes.number,
          onResize: PropTypes.func,
          innerRef: PropTypes.any,
          async: PropTypes.bool
        };
        return TextareaAutosizeClass2;
      }(React8.Component);
      exports.TextareaAutosize = React8.forwardRef(function(props, ref2) {
        return React8.createElement(TextareaAutosizeClass, __assign2({}, props, { innerRef: ref2 }));
      });
    }
  });

  // node_modules/react-autosize-textarea/lib/index.js
  var require_lib = __commonJS({
    "node_modules/react-autosize-textarea/lib/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var TextareaAutosize_1 = require_TextareaAutosize();
      exports["default"] = TextareaAutosize_1.TextareaAutosize;
    }
  });

  // node_modules/traverse/index.js
  var require_traverse = __commonJS({
    "node_modules/traverse/index.js"(exports, module) {
      "use strict";
      function toS(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isDate2(obj) {
        return toS(obj) === "[object Date]";
      }
      function isRegExp(obj) {
        return toS(obj) === "[object RegExp]";
      }
      function isError2(obj) {
        return toS(obj) === "[object Error]";
      }
      function isBoolean(obj) {
        return toS(obj) === "[object Boolean]";
      }
      function isNumber(obj) {
        return toS(obj) === "[object Number]";
      }
      function isString2(obj) {
        return toS(obj) === "[object String]";
      }
      var isArray = Array.isArray || function isArray2(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
      function forEach(xs, fn) {
        if (xs.forEach) {
          return xs.forEach(fn);
        }
        for (var i5 = 0; i5 < xs.length; i5++) {
          fn(xs[i5], i5, xs);
        }
        return void 0;
      }
      var objectKeys = Object.keys || function keys(obj) {
        var res = [];
        for (var key in obj) {
          res.push(key);
        }
        return res;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty || function(obj, key) {
        return key in obj;
      };
      function copy2(src) {
        if (typeof src === "object" && src !== null) {
          var dst;
          if (isArray(src)) {
            dst = [];
          } else if (isDate2(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
          } else if (isRegExp(src)) {
            dst = new RegExp(src);
          } else if (isError2(src)) {
            dst = { message: src.message };
          } else if (isBoolean(src) || isNumber(src) || isString2(src)) {
            dst = Object(src);
          } else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
          } else if (src.constructor === Object) {
            dst = {};
          } else {
            var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
            var T3 = function T4() {
            };
            T3.prototype = proto;
            dst = new T3();
          }
          forEach(objectKeys(src), function(key) {
            dst[key] = src[key];
          });
          return dst;
        }
        return src;
      }
      function walk(root, cb2, immutable) {
        var path = [];
        var parents = [];
        var alive = true;
        return function walker(node_) {
          var node = immutable ? copy2(node_) : node_;
          var modifiers2 = {};
          var keepGoing = true;
          var state = {
            node,
            node_,
            path: [].concat(path),
            parent: parents[parents.length - 1],
            parents,
            key: path[path.length - 1],
            isRoot: path.length === 0,
            level: path.length,
            circular: null,
            update: function(x4, stopHere) {
              if (!state.isRoot) {
                state.parent.node[state.key] = x4;
              }
              state.node = x4;
              if (stopHere) {
                keepGoing = false;
              }
            },
            delete: function(stopHere) {
              delete state.parent.node[state.key];
              if (stopHere) {
                keepGoing = false;
              }
            },
            remove: function(stopHere) {
              if (isArray(state.parent.node)) {
                state.parent.node.splice(state.key, 1);
              } else {
                delete state.parent.node[state.key];
              }
              if (stopHere) {
                keepGoing = false;
              }
            },
            keys: null,
            before: function(f5) {
              modifiers2.before = f5;
            },
            after: function(f5) {
              modifiers2.after = f5;
            },
            pre: function(f5) {
              modifiers2.pre = f5;
            },
            post: function(f5) {
              modifiers2.post = f5;
            },
            stop: function() {
              alive = false;
            },
            block: function() {
              keepGoing = false;
            }
          };
          if (!alive) {
            return state;
          }
          function updateState() {
            if (typeof state.node === "object" && state.node !== null) {
              if (!state.keys || state.node_ !== state.node) {
                state.keys = objectKeys(state.node);
              }
              state.isLeaf = state.keys.length === 0;
              for (var i5 = 0; i5 < parents.length; i5++) {
                if (parents[i5].node_ === node_) {
                  state.circular = parents[i5];
                  break;
                }
              }
            } else {
              state.isLeaf = true;
              state.keys = null;
            }
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
          }
          updateState();
          var ret = cb2.call(state, state.node);
          if (ret !== void 0 && state.update) {
            state.update(ret);
          }
          if (modifiers2.before) {
            modifiers2.before.call(state, state.node);
          }
          if (!keepGoing) {
            return state;
          }
          if (typeof state.node === "object" && state.node !== null && !state.circular) {
            parents.push(state);
            updateState();
            forEach(state.keys, function(key, i5) {
              path.push(key);
              if (modifiers2.pre) {
                modifiers2.pre.call(state, state.node[key], key);
              }
              var child = walker(state.node[key]);
              if (immutable && hasOwnProperty.call(state.node, key)) {
                state.node[key] = child.node;
              }
              child.isLast = i5 === state.keys.length - 1;
              child.isFirst = i5 === 0;
              if (modifiers2.post) {
                modifiers2.post.call(state, child);
              }
              path.pop();
            });
            parents.pop();
          }
          if (modifiers2.after) {
            modifiers2.after.call(state, state.node);
          }
          return state;
        }(root).node;
      }
      function Traverse(obj) {
        this.value = obj;
      }
      Traverse.prototype.get = function(ps) {
        var node = this.value;
        for (var i5 = 0; i5 < ps.length; i5++) {
          var key = ps[i5];
          if (!node || !hasOwnProperty.call(node, key)) {
            return void 0;
          }
          node = node[key];
        }
        return node;
      };
      Traverse.prototype.has = function(ps) {
        var node = this.value;
        for (var i5 = 0; i5 < ps.length; i5++) {
          var key = ps[i5];
          if (!node || !hasOwnProperty.call(node, key)) {
            return false;
          }
          node = node[key];
        }
        return true;
      };
      Traverse.prototype.set = function(ps, value) {
        var node = this.value;
        for (var i5 = 0; i5 < ps.length - 1; i5++) {
          var key = ps[i5];
          if (!hasOwnProperty.call(node, key)) {
            node[key] = {};
          }
          node = node[key];
        }
        node[ps[i5]] = value;
        return value;
      };
      Traverse.prototype.map = function(cb2) {
        return walk(this.value, cb2, true);
      };
      Traverse.prototype.forEach = function(cb2) {
        this.value = walk(this.value, cb2, false);
        return this.value;
      };
      Traverse.prototype.reduce = function(cb2, init) {
        var skip = arguments.length === 1;
        var acc = skip ? this.value : init;
        this.forEach(function(x4) {
          if (!this.isRoot || !skip) {
            acc = cb2.call(this, acc, x4);
          }
        });
        return acc;
      };
      Traverse.prototype.paths = function() {
        var acc = [];
        this.forEach(function() {
          acc.push(this.path);
        });
        return acc;
      };
      Traverse.prototype.nodes = function() {
        var acc = [];
        this.forEach(function() {
          acc.push(this.node);
        });
        return acc;
      };
      Traverse.prototype.clone = function() {
        var parents = [];
        var nodes = [];
        return function clone2(src) {
          for (var i5 = 0; i5 < parents.length; i5++) {
            if (parents[i5] === src) {
              return nodes[i5];
            }
          }
          if (typeof src === "object" && src !== null) {
            var dst = copy2(src);
            parents.push(src);
            nodes.push(dst);
            forEach(objectKeys(src), function(key) {
              dst[key] = clone2(src[key]);
            });
            parents.pop();
            nodes.pop();
            return dst;
          }
          return src;
        }(this.value);
      };
      function traverse2(obj) {
        return new Traverse(obj);
      }
      forEach(objectKeys(Traverse.prototype), function(key) {
        traverse2[key] = function(obj) {
          var args = [].slice.call(arguments, 1);
          var t5 = new Traverse(obj);
          return t5[key].apply(t5, args);
        };
      });
      module.exports = traverse2;
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits3(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits3(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/@wordpress/data/build-module/index.js
  var import_turbo_combine_reducers2 = __toESM(require_turbo_combine_reducers());

  // node_modules/@wordpress/data/build-module/registry.js
  var import_lodash5 = __toESM(require_lodash());

  // node_modules/@wordpress/hooks/build-module/validateNamespace.js
  function validateNamespace(namespace) {
    if ("string" !== typeof namespace || "" === namespace) {
      console.error("The namespace must be a non-empty string.");
      return false;
    }
    if (!/^[a-zA-Z][a-zA-Z0-9_.\-\/]*$/.test(namespace)) {
      console.error("The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.");
      return false;
    }
    return true;
  }
  var validateNamespace_default = validateNamespace;

  // node_modules/@wordpress/hooks/build-module/validateHookName.js
  function validateHookName(hookName) {
    if ("string" !== typeof hookName || "" === hookName) {
      console.error("The hook name must be a non-empty string.");
      return false;
    }
    if (/^__/.test(hookName)) {
      console.error("The hook name cannot begin with `__`.");
      return false;
    }
    if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {
      console.error("The hook name can only contain numbers, letters, dashes, periods and underscores.");
      return false;
    }
    return true;
  }
  var validateHookName_default = validateHookName;

  // node_modules/@wordpress/hooks/build-module/createAddHook.js
  function createAddHook(hooks, storeKey) {
    return function addHook(hookName, namespace, callback) {
      let priority2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;
      const hooksStore = hooks[storeKey];
      if (!validateHookName_default(hookName)) {
        return;
      }
      if (!validateNamespace_default(namespace)) {
        return;
      }
      if ("function" !== typeof callback) {
        console.error("The hook callback must be a function.");
        return;
      }
      if ("number" !== typeof priority2) {
        console.error("If specified, the hook priority must be a number.");
        return;
      }
      const handler = {
        callback,
        priority: priority2,
        namespace
      };
      if (hooksStore[hookName]) {
        const handlers = hooksStore[hookName].handlers;
        let i5;
        for (i5 = handlers.length; i5 > 0; i5--) {
          if (priority2 >= handlers[i5 - 1].priority) {
            break;
          }
        }
        if (i5 === handlers.length) {
          handlers[i5] = handler;
        } else {
          handlers.splice(i5, 0, handler);
        }
        hooksStore.__current.forEach((hookInfo) => {
          if (hookInfo.name === hookName && hookInfo.currentIndex >= i5) {
            hookInfo.currentIndex++;
          }
        });
      } else {
        hooksStore[hookName] = {
          handlers: [handler],
          runs: 0
        };
      }
      if (hookName !== "hookAdded") {
        hooks.doAction("hookAdded", hookName, namespace, callback, priority2);
      }
    };
  }
  var createAddHook_default = createAddHook;

  // node_modules/@wordpress/hooks/build-module/createRemoveHook.js
  function createRemoveHook(hooks, storeKey) {
    let removeAll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return function removeHook(hookName, namespace) {
      const hooksStore = hooks[storeKey];
      if (!validateHookName_default(hookName)) {
        return;
      }
      if (!removeAll && !validateNamespace_default(namespace)) {
        return;
      }
      if (!hooksStore[hookName]) {
        return 0;
      }
      let handlersRemoved = 0;
      if (removeAll) {
        handlersRemoved = hooksStore[hookName].handlers.length;
        hooksStore[hookName] = {
          runs: hooksStore[hookName].runs,
          handlers: []
        };
      } else {
        const handlers = hooksStore[hookName].handlers;
        for (let i5 = handlers.length - 1; i5 >= 0; i5--) {
          if (handlers[i5].namespace === namespace) {
            handlers.splice(i5, 1);
            handlersRemoved++;
            hooksStore.__current.forEach((hookInfo) => {
              if (hookInfo.name === hookName && hookInfo.currentIndex >= i5) {
                hookInfo.currentIndex--;
              }
            });
          }
        }
      }
      if (hookName !== "hookRemoved") {
        hooks.doAction("hookRemoved", hookName, namespace);
      }
      return handlersRemoved;
    };
  }
  var createRemoveHook_default = createRemoveHook;

  // node_modules/@wordpress/hooks/build-module/createHasHook.js
  function createHasHook(hooks, storeKey) {
    return function hasHook(hookName, namespace) {
      const hooksStore = hooks[storeKey];
      if ("undefined" !== typeof namespace) {
        return hookName in hooksStore && hooksStore[hookName].handlers.some((hook) => hook.namespace === namespace);
      }
      return hookName in hooksStore;
    };
  }
  var createHasHook_default = createHasHook;

  // node_modules/@wordpress/hooks/build-module/createRunHook.js
  function createRunHook(hooks, storeKey) {
    let returnFirstArg = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return function runHooks(hookName) {
      const hooksStore = hooks[storeKey];
      if (!hooksStore[hookName]) {
        hooksStore[hookName] = {
          handlers: [],
          runs: 0
        };
      }
      hooksStore[hookName].runs++;
      const handlers = hooksStore[hookName].handlers;
      if (true) {
        if ("hookAdded" !== hookName && hooksStore.all) {
          handlers.push(...hooksStore.all.handlers);
        }
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (!handlers || !handlers.length) {
        return returnFirstArg ? args[0] : void 0;
      }
      const hookInfo = {
        name: hookName,
        currentIndex: 0
      };
      hooksStore.__current.push(hookInfo);
      while (hookInfo.currentIndex < handlers.length) {
        const handler = handlers[hookInfo.currentIndex];
        const result = handler.callback.apply(null, args);
        if (returnFirstArg) {
          args[0] = result;
        }
        hookInfo.currentIndex++;
      }
      hooksStore.__current.pop();
      if (returnFirstArg) {
        return args[0];
      }
    };
  }
  var createRunHook_default = createRunHook;

  // node_modules/@wordpress/hooks/build-module/createCurrentHook.js
  function createCurrentHook(hooks, storeKey) {
    return function currentHook() {
      var _hooksStore$__current, _hooksStore$__current2;
      const hooksStore = hooks[storeKey];
      return (_hooksStore$__current = (_hooksStore$__current2 = hooksStore.__current[hooksStore.__current.length - 1]) === null || _hooksStore$__current2 === void 0 ? void 0 : _hooksStore$__current2.name) !== null && _hooksStore$__current !== void 0 ? _hooksStore$__current : null;
    };
  }
  var createCurrentHook_default = createCurrentHook;

  // node_modules/@wordpress/hooks/build-module/createDoingHook.js
  function createDoingHook(hooks, storeKey) {
    return function doingHook(hookName) {
      const hooksStore = hooks[storeKey];
      if ("undefined" === typeof hookName) {
        return "undefined" !== typeof hooksStore.__current[0];
      }
      return hooksStore.__current[0] ? hookName === hooksStore.__current[0].name : false;
    };
  }
  var createDoingHook_default = createDoingHook;

  // node_modules/@wordpress/hooks/build-module/createDidHook.js
  function createDidHook(hooks, storeKey) {
    return function didHook(hookName) {
      const hooksStore = hooks[storeKey];
      if (!validateHookName_default(hookName)) {
        return;
      }
      return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;
    };
  }
  var createDidHook_default = createDidHook;

  // node_modules/@wordpress/hooks/build-module/createHooks.js
  var _Hooks = class {
    constructor() {
      this.actions = /* @__PURE__ */ Object.create(null);
      this.actions.__current = [];
      this.filters = /* @__PURE__ */ Object.create(null);
      this.filters.__current = [];
      this.addAction = createAddHook_default(this, "actions");
      this.addFilter = createAddHook_default(this, "filters");
      this.removeAction = createRemoveHook_default(this, "actions");
      this.removeFilter = createRemoveHook_default(this, "filters");
      this.hasAction = createHasHook_default(this, "actions");
      this.hasFilter = createHasHook_default(this, "filters");
      this.removeAllActions = createRemoveHook_default(this, "actions", true);
      this.removeAllFilters = createRemoveHook_default(this, "filters", true);
      this.doAction = createRunHook_default(this, "actions");
      this.applyFilters = createRunHook_default(this, "filters", true);
      this.currentAction = createCurrentHook_default(this, "actions");
      this.currentFilter = createCurrentHook_default(this, "filters");
      this.doingAction = createDoingHook_default(this, "actions");
      this.doingFilter = createDoingHook_default(this, "filters");
      this.didAction = createDidHook_default(this, "actions");
      this.didFilter = createDidHook_default(this, "filters");
    }
  };
  function createHooks() {
    return new _Hooks();
  }
  var createHooks_default = createHooks;

  // node_modules/@wordpress/hooks/build-module/index.js
  var defaultHooks = createHooks_default();
  var {
    addAction,
    addFilter,
    removeAction,
    removeFilter,
    hasAction,
    hasFilter,
    removeAllActions,
    removeAllFilters,
    doAction,
    applyFilters,
    currentAction,
    currentFilter,
    doingAction,
    doingFilter,
    didAction,
    didFilter,
    actions,
    filters
  } = defaultHooks;

  // node_modules/@wordpress/deprecated/build-module/index.js
  var logged = /* @__PURE__ */ Object.create(null);
  function deprecated(feature) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      since,
      version,
      alternative,
      plugin,
      link,
      hint
    } = options;
    const pluginMessage = plugin ? ` from ${plugin}` : "";
    const sinceMessage = since ? ` since version ${since}` : "";
    const versionMessage = version ? ` and will be removed${pluginMessage} in version ${version}` : "";
    const useInsteadMessage = alternative ? ` Please use ${alternative} instead.` : "";
    const linkMessage = link ? ` See: ${link}` : "";
    const hintMessage = hint ? ` Note: ${hint}` : "";
    const message = `${feature} is deprecated${sinceMessage}${versionMessage}.${useInsteadMessage}${linkMessage}${hintMessage}`;
    if (message in logged) {
      return;
    }
    doAction("deprecated", feature, options, message);
    console.warn(message);
    logged[message] = true;
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread2.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = null != arguments[i5] ? arguments[i5] : {};
      i5 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }

  // node_modules/redux/es/redux.js
  var $$observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  var randomString = function randomString2() {
    return Math.random().toString(36).substring(7).split("").join(".");
  };
  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };
  function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    var proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
  }
  function miniKindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "symbol":
      case "function": {
        return type;
      }
    }
    if (Array.isArray(val))
      return "array";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    var constructorName = ctorName(val);
    switch (constructorName) {
      case "Symbol":
      case "Promise":
      case "WeakMap":
      case "WeakSet":
      case "Map":
      case "Set":
        return constructorName;
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  }
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function kindOf(val) {
    var typeOfVal = typeof val;
    if (true) {
      typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
  }
  function createStore(reducer3, preloadedState, enhancer) {
    var _ref22;
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
      }
      return enhancer(createStore)(reducer3, preloadedState);
    }
    if (typeof reducer3 !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer3) + "'");
    }
    var currentReducer = reducer3;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe4(listener2) {
      if (typeof listener2 !== "function") {
        throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener2) + "'");
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener2);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index2 = nextListeners.indexOf(listener2);
        nextListeners.splice(index2, 1);
        currentListeners = null;
      };
    }
    function dispatch2(action) {
      if (!isPlainObject(action)) {
        throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
      }
      if (typeof action.type === "undefined") {
        throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i5 = 0; i5 < listeners.length; i5++) {
        var listener2 = listeners[i5];
        listener2();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
      }
      currentReducer = nextReducer;
      dispatch2({
        type: ActionTypes.REPLACE
      });
    }
    function observable() {
      var _ref8;
      var outerSubscribe = subscribe4;
      return _ref8 = {
        subscribe: function subscribe5(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
          }
          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }
          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        }
      }, _ref8[$$observable] = function() {
        return this;
      }, _ref8;
    }
    dispatch2({
      type: ActionTypes.INIT
    });
    return _ref22 = {
      dispatch: dispatch2,
      subscribe: subscribe4,
      getState,
      replaceReducer
    }, _ref22[$$observable] = observable, _ref22;
  }
  function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e4) {
    }
  }
  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
      return function(arg) {
        return arg;
      };
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce(function(a6, b6) {
      return function() {
        return a6(b6.apply(void 0, arguments));
      };
    });
  }
  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }
    return function(createStore2) {
      return function() {
        var store6 = createStore2.apply(void 0, arguments);
        var _dispatch = function dispatch2() {
          throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
        };
        var middlewareAPI = {
          getState: store6.getState,
          dispatch: function dispatch2() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain2 = middlewares.map(function(middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose.apply(void 0, chain2)(store6.dispatch);
        return _objectSpread2(_objectSpread2({}, store6), {}, {
          dispatch: _dispatch
        });
      };
    };
  }
  function isCrushed() {
  }
  if (typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
    warning('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
  }

  // node_modules/@wordpress/data/build-module/redux-store/index.js
  var import_lodash4 = __toESM(require_lodash());
  var import_turbo_combine_reducers = __toESM(require_turbo_combine_reducers());
  var import_equivalent_key_map2 = __toESM(require_equivalent_key_map());

  // node_modules/@wordpress/redux-routine/build-module/is-generator.js
  function isGenerator(object) {
    return !!object && typeof object[Symbol.iterator] === "function" && typeof object.next === "function";
  }

  // node_modules/@wordpress/redux-routine/build-module/runtime.js
  var import_rungen = __toESM(require_dist());

  // node_modules/is-promise/index.mjs
  function isPromise(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  }

  // node_modules/is-plain-object/dist/is-plain-object.mjs
  function isObject(o6) {
    return Object.prototype.toString.call(o6) === "[object Object]";
  }
  function isPlainObject2(o6) {
    var ctor, prot;
    if (isObject(o6) === false)
      return false;
    ctor = o6.constructor;
    if (ctor === void 0)
      return true;
    prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }

  // node_modules/@wordpress/redux-routine/build-module/is-action.js
  function isAction(object) {
    return isPlainObject2(object) && typeof object.type === "string";
  }
  function isActionOfType(object, expectedType) {
    return isAction(object) && object.type === expectedType;
  }

  // node_modules/@wordpress/redux-routine/build-module/runtime.js
  function createRuntime() {
    let controls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let dispatch2 = arguments.length > 1 ? arguments[1] : void 0;
    const rungenControls = Object.entries(controls).map((_ref8) => {
      let [actionType, control] = _ref8;
      return (value, next2, iterate, yieldNext, yieldError) => {
        if (!isActionOfType(value, actionType)) {
          return false;
        }
        const routine = control(value);
        if (isPromise(routine)) {
          routine.then(yieldNext, yieldError);
        } else {
          yieldNext(routine);
        }
        return true;
      };
    });
    const unhandledActionControl = (value, next2) => {
      if (!isAction(value)) {
        return false;
      }
      dispatch2(value);
      next2();
      return true;
    };
    rungenControls.push(unhandledActionControl);
    const rungenRuntime = (0, import_rungen.create)(rungenControls);
    return (action) => new Promise((resolve, reject) => rungenRuntime(action, (result) => {
      if (isAction(result)) {
        dispatch2(result);
      }
      resolve(result);
    }, reject));
  }

  // node_modules/@wordpress/redux-routine/build-module/index.js
  function createMiddleware() {
    let controls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return (store6) => {
      const runtime = createRuntime(controls, store6.dispatch);
      return (next2) => (action) => {
        if (!isGenerator(action)) {
          return next2(action);
        }
        return runtime(action);
      };
    };
  }

  // node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // node_modules/lower-case/dist.es2015/index.js
  function lowerCase(str) {
    return str.toLowerCase();
  }

  // node_modules/no-case/dist.es2015/index.js
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start2 = 0;
    var end = result.length;
    while (result.charAt(start2) === "\0")
      start2++;
    while (result.charAt(end - 1) === "\0")
      end--;
    return result.slice(start2, end).split("\0").map(transform).join(delimiter);
  }
  function replace(input, re, value) {
    if (re instanceof RegExp)
      return input.replace(re, value);
    return re.reduce(function(input2, re2) {
      return input2.replace(re2, value);
    }, input);
  }

  // node_modules/pascal-case/dist.es2015/index.js
  function pascalCaseTransform(input, index2) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index2 > 0 && firstChar >= "0" && firstChar <= "9") {
      return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
  }
  function pascalCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
  }

  // node_modules/upper-case-first/dist.es2015/index.js
  function upperCaseFirst(input) {
    return input.charAt(0).toUpperCase() + input.substr(1);
  }

  // node_modules/capital-case/dist.es2015/index.js
  function capitalCaseTransform(input) {
    return upperCaseFirst(input.toLowerCase());
  }
  function capitalCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({ delimiter: " ", transform: capitalCaseTransform }, options));
  }

  // node_modules/dot-case/dist.es2015/index.js
  function dotCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({ delimiter: "." }, options));
  }

  // node_modules/param-case/dist.es2015/index.js
  function paramCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return dotCase(input, __assign({ delimiter: "-" }, options));
  }

  // node_modules/@wordpress/compose/build-module/utils/create-higher-order-component/index.js
  function createHigherOrderComponent(mapComponent, modifierName) {
    return (Inner) => {
      const Outer = mapComponent(Inner);
      Outer.displayName = hocName(modifierName, Inner);
      return Outer;
    };
  }
  var hocName = (name, Inner) => {
    const inner = Inner.displayName || Inner.name || "Component";
    const outer = pascalCase(name !== null && name !== void 0 ? name : "");
    return `${outer}(${inner})`;
  };

  // node_modules/@wordpress/compose/build-module/utils/debounce/index.js
  var debounce = (func, wait, options) => {
    let lastArgs;
    let lastThis;
    let maxWait = 0;
    let result;
    let timerId;
    let lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    if (options) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      if (options.maxWait !== void 0) {
        maxWait = Math.max(options.maxWait, wait);
      }
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      const args = lastArgs;
      const thisArg = lastThis;
      lastArgs = void 0;
      lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function startTimer(pendingFunc, waitTime) {
      timerId = setTimeout(pendingFunc, waitTime);
    }
    function cancelTimer() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      startTimer(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function getTimeSinceLastCall(time) {
      return time - (lastCallTime || 0);
    }
    function remainingWait(time) {
      const timeSinceLastCall = getTimeSinceLastCall(time);
      const timeSinceLastInvoke = time - lastInvokeTime;
      const timeWaiting = wait - timeSinceLastCall;
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      const timeSinceLastCall = getTimeSinceLastCall(time);
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      startTimer(timerExpired, remainingWait(time));
      return void 0;
    }
    function clearTimer() {
      timerId = void 0;
    }
    function trailingEdge(time) {
      clearTimer();
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      cancelTimer();
      lastInvokeTime = 0;
      clearTimer();
      lastArgs = lastCallTime = lastThis = void 0;
    }
    function flush2() {
      return pending() ? trailingEdge(Date.now()) : result;
    }
    function pending() {
      return timerId !== void 0;
    }
    function debounced() {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      lastArgs = args;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (!pending()) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          startTimer(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (!pending()) {
        startTimer(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush2;
    debounced.pending = pending;
    return debounced;
  };

  // node_modules/@wordpress/compose/build-module/utils/throttle/index.js
  var throttle = (func, wait, options) => {
    let leading = true;
    let trailing = true;
    if (options) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      leading,
      trailing,
      maxWait: wait
    });
  };

  // node_modules/@wordpress/compose/build-module/higher-order/pipe.js
  var basePipe = function() {
    let reverse2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    return function() {
      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }
      return function() {
        const functions = funcs.flat();
        if (reverse2) {
          functions.reverse();
        }
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return functions.reduce((prev, func) => [func(...prev)], args)[0];
      };
    };
  };
  var pipe = basePipe();
  var pipe_default = pipe;

  // node_modules/@wordpress/compose/build-module/higher-order/compose.js
  var compose2 = basePipe(true);
  var compose_default = compose2;

  // node_modules/@wordpress/element/build-module/react.js
  var import_react = __toESM(require_react());
  function concatChildren() {
    for (var _len = arguments.length, childrenArguments = new Array(_len), _key = 0; _key < _len; _key++) {
      childrenArguments[_key] = arguments[_key];
    }
    return childrenArguments.reduce((accumulator, children, i5) => {
      import_react.Children.forEach(children, (child, j2) => {
        if (child && "string" !== typeof child) {
          child = (0, import_react.cloneElement)(child, {
            key: [i5, j2].join()
          });
        }
        accumulator.push(child);
      });
      return accumulator;
    }, []);
  }

  // node_modules/@wordpress/element/build-module/create-interpolate-element.js
  var indoc;
  var offset;
  var output;
  var stack;
  var tokenizer = /<(\/)?(\w+)\s*(\/)?>/g;
  function createFrame(element, tokenStart, tokenLength, prevOffset, leadingTextStart) {
    return {
      element,
      tokenStart,
      tokenLength,
      prevOffset,
      leadingTextStart,
      children: []
    };
  }
  var createInterpolateElement = (interpolatedString, conversionMap) => {
    indoc = interpolatedString;
    offset = 0;
    output = [];
    stack = [];
    tokenizer.lastIndex = 0;
    if (!isValidConversionMap(conversionMap)) {
      throw new TypeError("The conversionMap provided is not valid. It must be an object with values that are WPElements");
    }
    do {
    } while (proceed(conversionMap));
    return (0, import_react.createElement)(import_react.Fragment, null, ...output);
  };
  var isValidConversionMap = (conversionMap) => {
    const isObject5 = typeof conversionMap === "object";
    const values = isObject5 && Object.values(conversionMap);
    return isObject5 && values.length && values.every((element) => (0, import_react.isValidElement)(element));
  };
  function proceed(conversionMap) {
    const next2 = nextToken();
    const [tokenType, name, startOffset, tokenLength] = next2;
    const stackDepth = stack.length;
    const leadingTextStart = startOffset > offset ? offset : null;
    if (!conversionMap[name]) {
      addText();
      return false;
    }
    switch (tokenType) {
      case "no-more-tokens":
        if (stackDepth !== 0) {
          const {
            leadingTextStart: stackLeadingText,
            tokenStart
          } = stack.pop();
          output.push(indoc.substr(stackLeadingText, tokenStart));
        }
        addText();
        return false;
      case "self-closed":
        if (0 === stackDepth) {
          if (null !== leadingTextStart) {
            output.push(indoc.substr(leadingTextStart, startOffset - leadingTextStart));
          }
          output.push(conversionMap[name]);
          offset = startOffset + tokenLength;
          return true;
        }
        addChild(createFrame(conversionMap[name], startOffset, tokenLength));
        offset = startOffset + tokenLength;
        return true;
      case "opener":
        stack.push(createFrame(conversionMap[name], startOffset, tokenLength, startOffset + tokenLength, leadingTextStart));
        offset = startOffset + tokenLength;
        return true;
      case "closer":
        if (1 === stackDepth) {
          closeOuterElement(startOffset);
          offset = startOffset + tokenLength;
          return true;
        }
        const stackTop = stack.pop();
        const text3 = indoc.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);
        stackTop.children.push(text3);
        stackTop.prevOffset = startOffset + tokenLength;
        const frame2 = createFrame(stackTop.element, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);
        frame2.children = stackTop.children;
        addChild(frame2);
        offset = startOffset + tokenLength;
        return true;
      default:
        addText();
        return false;
    }
  }
  function nextToken() {
    const matches2 = tokenizer.exec(indoc);
    if (null === matches2) {
      return ["no-more-tokens"];
    }
    const startedAt = matches2.index;
    const [match, isClosing, name, isSelfClosed] = matches2;
    const length = match.length;
    if (isSelfClosed) {
      return ["self-closed", name, startedAt, length];
    }
    if (isClosing) {
      return ["closer", name, startedAt, length];
    }
    return ["opener", name, startedAt, length];
  }
  function addText() {
    const length = indoc.length - offset;
    if (0 === length) {
      return;
    }
    output.push(indoc.substr(offset, length));
  }
  function addChild(frame2) {
    const {
      element,
      tokenStart,
      tokenLength,
      prevOffset,
      children
    } = frame2;
    const parent = stack[stack.length - 1];
    const text3 = indoc.substr(parent.prevOffset, tokenStart - parent.prevOffset);
    if (text3) {
      parent.children.push(text3);
    }
    parent.children.push((0, import_react.cloneElement)(element, null, ...children));
    parent.prevOffset = prevOffset ? prevOffset : tokenStart + tokenLength;
  }
  function closeOuterElement(endOffset) {
    const {
      element,
      leadingTextStart,
      prevOffset,
      tokenStart,
      children
    } = stack.pop();
    const text3 = endOffset ? indoc.substr(prevOffset, endOffset - prevOffset) : indoc.substr(prevOffset);
    if (text3) {
      children.push(text3);
    }
    if (null !== leadingTextStart) {
      output.push(indoc.substr(leadingTextStart, tokenStart - leadingTextStart));
    }
    output.push((0, import_react.cloneElement)(element, null, ...children));
  }
  var create_interpolate_element_default = createInterpolateElement;

  // node_modules/@wordpress/element/build-module/react-platform.js
  var import_react_dom = __toESM(require_react_dom());

  // node_modules/@wordpress/element/build-module/utils.js
  var isEmptyElement = (element) => {
    if (typeof element === "number") {
      return false;
    }
    if (typeof (element === null || element === void 0 ? void 0 : element.valueOf()) === "string" || Array.isArray(element)) {
      return !element.length;
    }
    return !element;
  };

  // node_modules/@wordpress/element/build-module/platform.js
  var Platform = {
    OS: "web",
    select: (spec) => "web" in spec ? spec.web : spec.default,
    isWeb: true
  };
  var platform_default = Platform;

  // node_modules/@wordpress/escape-html/build-module/escape-greater.js
  function __unstableEscapeGreaterThan(value) {
    return value.replace(/>/g, "&gt;");
  }

  // node_modules/@wordpress/escape-html/build-module/index.js
  var REGEXP_INVALID_ATTRIBUTE_NAME = /[\u007F-\u009F "'>/="\uFDD0-\uFDEF]/;
  function escapeAmpersand(value) {
    return value.replace(/&(?!([a-z0-9]+|#[0-9]+|#x[a-f0-9]+);)/gi, "&amp;");
  }
  function escapeQuotationMark(value) {
    return value.replace(/"/g, "&quot;");
  }
  function escapeLessThan(value) {
    return value.replace(/</g, "&lt;");
  }
  function escapeAttribute(value) {
    return __unstableEscapeGreaterThan(escapeQuotationMark(escapeAmpersand(value)));
  }
  function escapeHTML(value) {
    return escapeLessThan(escapeAmpersand(value));
  }
  function escapeEditableHTML(value) {
    return escapeLessThan(value.replace(/&/g, "&amp;"));
  }
  function isValidAttributeName(name) {
    return !REGEXP_INVALID_ATTRIBUTE_NAME.test(name);
  }

  // node_modules/@wordpress/element/build-module/raw-html.js
  function RawHTML(_ref8) {
    let {
      children,
      ...props
    } = _ref8;
    let rawHtml = "";
    import_react.Children.toArray(children).forEach((child) => {
      if (typeof child === "string" && child.trim() !== "") {
        rawHtml += child;
      }
    });
    return (0, import_react.createElement)("div", {
      dangerouslySetInnerHTML: {
        __html: rawHtml
      },
      ...props
    });
  }

  // node_modules/@wordpress/element/build-module/serialize.js
  var {
    Provider,
    Consumer
  } = (0, import_react.createContext)(void 0);
  var ForwardRef = (0, import_react.forwardRef)(() => {
    return null;
  });
  var ATTRIBUTES_TYPES = /* @__PURE__ */ new Set(["string", "boolean", "number"]);
  var SELF_CLOSING_TAGS = /* @__PURE__ */ new Set(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
  var BOOLEAN_ATTRIBUTES = /* @__PURE__ */ new Set(["allowfullscreen", "allowpaymentrequest", "allowusermedia", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "download", "formnovalidate", "hidden", "ismap", "itemscope", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected", "typemustmatch"]);
  var ENUMERATED_ATTRIBUTES = /* @__PURE__ */ new Set(["autocapitalize", "autocomplete", "charset", "contenteditable", "crossorigin", "decoding", "dir", "draggable", "enctype", "formenctype", "formmethod", "http-equiv", "inputmode", "kind", "method", "preload", "scope", "shape", "spellcheck", "translate", "type", "wrap"]);
  var CSS_PROPERTIES_SUPPORTS_UNITLESS = /* @__PURE__ */ new Set(["animation", "animationIterationCount", "baselineShift", "borderImageOutset", "borderImageSlice", "borderImageWidth", "columnCount", "cx", "cy", "fillOpacity", "flexGrow", "flexShrink", "floodOpacity", "fontWeight", "gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart", "lineHeight", "opacity", "order", "orphans", "r", "rx", "ry", "shapeImageThreshold", "stopOpacity", "strokeDasharray", "strokeDashoffset", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "tabSize", "widows", "x", "y", "zIndex", "zoom"]);
  function hasPrefix(string2, prefixes2) {
    return prefixes2.some((prefix2) => string2.indexOf(prefix2) === 0);
  }
  function isInternalAttribute(attribute) {
    return "key" === attribute || "children" === attribute;
  }
  function getNormalAttributeValue(attribute, value) {
    switch (attribute) {
      case "style":
        return renderStyle(value);
    }
    return value;
  }
  var SVG_ATTRIBUTE_WITH_DASHES_LIST = ["accentHeight", "alignmentBaseline", "arabicForm", "baselineShift", "capHeight", "clipPath", "clipRule", "colorInterpolation", "colorInterpolationFilters", "colorProfile", "colorRendering", "dominantBaseline", "enableBackground", "fillOpacity", "fillRule", "floodColor", "floodOpacity", "fontFamily", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontWeight", "glyphName", "glyphOrientationHorizontal", "glyphOrientationVertical", "horizAdvX", "horizOriginX", "imageRendering", "letterSpacing", "lightingColor", "markerEnd", "markerMid", "markerStart", "overlinePosition", "overlineThickness", "paintOrder", "panose1", "pointerEvents", "renderingIntent", "shapeRendering", "stopColor", "stopOpacity", "strikethroughPosition", "strikethroughThickness", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "textAnchor", "textDecoration", "textRendering", "underlinePosition", "underlineThickness", "unicodeBidi", "unicodeRange", "unitsPerEm", "vAlphabetic", "vHanging", "vIdeographic", "vMathematical", "vectorEffect", "vertAdvY", "vertOriginX", "vertOriginY", "wordSpacing", "writingMode", "xmlnsXlink", "xHeight"].reduce((map9, attribute) => {
    map9[attribute.toLowerCase()] = attribute;
    return map9;
  }, {});
  var CASE_SENSITIVE_SVG_ATTRIBUTES = ["allowReorder", "attributeName", "attributeType", "autoReverse", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "contentScriptType", "contentStyleType", "diffuseConstant", "edgeMode", "externalResourcesRequired", "filterRes", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "suppressContentEditableWarning", "suppressHydrationWarning", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector"].reduce((map9, attribute) => {
    map9[attribute.toLowerCase()] = attribute;
    return map9;
  }, {});
  var SVG_ATTRIBUTES_WITH_COLONS = ["xlink:actuate", "xlink:arcrole", "xlink:href", "xlink:role", "xlink:show", "xlink:title", "xlink:type", "xml:base", "xml:lang", "xml:space", "xmlns:xlink"].reduce((map9, attribute) => {
    map9[attribute.replace(":", "").toLowerCase()] = attribute;
    return map9;
  }, {});
  function getNormalAttributeName(attribute) {
    switch (attribute) {
      case "htmlFor":
        return "for";
      case "className":
        return "class";
    }
    const attributeLowerCase = attribute.toLowerCase();
    if (CASE_SENSITIVE_SVG_ATTRIBUTES[attributeLowerCase]) {
      return CASE_SENSITIVE_SVG_ATTRIBUTES[attributeLowerCase];
    } else if (SVG_ATTRIBUTE_WITH_DASHES_LIST[attributeLowerCase]) {
      return paramCase(SVG_ATTRIBUTE_WITH_DASHES_LIST[attributeLowerCase]);
    } else if (SVG_ATTRIBUTES_WITH_COLONS[attributeLowerCase]) {
      return SVG_ATTRIBUTES_WITH_COLONS[attributeLowerCase];
    }
    return attributeLowerCase;
  }
  function getNormalStylePropertyName(property) {
    if (property.startsWith("--")) {
      return property;
    }
    if (hasPrefix(property, ["ms", "O", "Moz", "Webkit"])) {
      return "-" + paramCase(property);
    }
    return paramCase(property);
  }
  function getNormalStylePropertyValue(property, value) {
    if (typeof value === "number" && 0 !== value && !CSS_PROPERTIES_SUPPORTS_UNITLESS.has(property)) {
      return value + "px";
    }
    return value;
  }
  function renderElement(element, context2) {
    let legacyContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (null === element || void 0 === element || false === element) {
      return "";
    }
    if (Array.isArray(element)) {
      return renderChildren(element, context2, legacyContext);
    }
    switch (typeof element) {
      case "string":
        return escapeHTML(element);
      case "number":
        return element.toString();
    }
    const {
      type,
      props
    } = element;
    switch (type) {
      case import_react.StrictMode:
      case import_react.Fragment:
        return renderChildren(props.children, context2, legacyContext);
      case RawHTML:
        const {
          children,
          ...wrapperProps
        } = props;
        return renderNativeComponent(!Object.keys(wrapperProps).length ? null : "div", {
          ...wrapperProps,
          dangerouslySetInnerHTML: {
            __html: children
          }
        }, context2, legacyContext);
    }
    switch (typeof type) {
      case "string":
        return renderNativeComponent(type, props, context2, legacyContext);
      case "function":
        if (type.prototype && typeof type.prototype.render === "function") {
          return renderComponent(type, props, context2, legacyContext);
        }
        return renderElement(type(props, legacyContext), context2, legacyContext);
    }
    switch (type && type.$$typeof) {
      case Provider.$$typeof:
        return renderChildren(props.children, props.value, legacyContext);
      case Consumer.$$typeof:
        return renderElement(props.children(context2 || type._currentValue), context2, legacyContext);
      case ForwardRef.$$typeof:
        return renderElement(type.render(props), context2, legacyContext);
    }
    return "";
  }
  function renderNativeComponent(type, props, context2) {
    let legacyContext = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    let content = "";
    if (type === "textarea" && props.hasOwnProperty("value")) {
      content = renderChildren(props.value, context2, legacyContext);
      const {
        value,
        ...restProps
      } = props;
      props = restProps;
    } else if (props.dangerouslySetInnerHTML && typeof props.dangerouslySetInnerHTML.__html === "string") {
      content = props.dangerouslySetInnerHTML.__html;
    } else if (typeof props.children !== "undefined") {
      content = renderChildren(props.children, context2, legacyContext);
    }
    if (!type) {
      return content;
    }
    const attributes = renderAttributes(props);
    if (SELF_CLOSING_TAGS.has(type)) {
      return "<" + type + attributes + "/>";
    }
    return "<" + type + attributes + ">" + content + "</" + type + ">";
  }
  function renderComponent(Component2, props, context2) {
    let legacyContext = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const instance = new Component2(props, legacyContext);
    if (typeof instance.getChildContext === "function") {
      Object.assign(
        legacyContext,
        instance.getChildContext()
      );
    }
    const html2 = renderElement(instance.render(), context2, legacyContext);
    return html2;
  }
  function renderChildren(children, context2) {
    let legacyContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let result = "";
    children = Array.isArray(children) ? children : [children];
    for (let i5 = 0; i5 < children.length; i5++) {
      const child = children[i5];
      result += renderElement(child, context2, legacyContext);
    }
    return result;
  }
  function renderAttributes(props) {
    let result = "";
    for (const key in props) {
      const attribute = getNormalAttributeName(key);
      if (!isValidAttributeName(attribute)) {
        continue;
      }
      let value = getNormalAttributeValue(key, props[key]);
      if (!ATTRIBUTES_TYPES.has(typeof value)) {
        continue;
      }
      if (isInternalAttribute(key)) {
        continue;
      }
      const isBooleanAttribute = BOOLEAN_ATTRIBUTES.has(attribute);
      if (isBooleanAttribute && value === false) {
        continue;
      }
      const isMeaningfulAttribute = isBooleanAttribute || hasPrefix(key, ["data-", "aria-"]) || ENUMERATED_ATTRIBUTES.has(attribute);
      if (typeof value === "boolean" && !isMeaningfulAttribute) {
        continue;
      }
      result += " " + attribute;
      if (isBooleanAttribute) {
        continue;
      }
      if (typeof value === "string") {
        value = escapeAttribute(value);
      }
      result += '="' + value + '"';
    }
    return result;
  }
  function renderStyle(style) {
    if (!isPlainObject2(style)) {
      return style;
    }
    let result;
    for (const property in style) {
      const value = style[property];
      if (null === value || void 0 === value) {
        continue;
      }
      if (result) {
        result += ";";
      } else {
        result = "";
      }
      const normalName = getNormalStylePropertyName(property);
      const normalValue = getNormalStylePropertyValue(property, value);
      result += normalName + ":" + normalValue;
    }
    return result;
  }
  var serialize_default = renderElement;

  // node_modules/@wordpress/compose/build-module/higher-order/if-condition/index.js
  function ifCondition(predicate) {
    return createHigherOrderComponent((WrappedComponent) => (props) => {
      if (!predicate(props)) {
        return null;
      }
      return (0, import_react.createElement)(WrappedComponent, props);
    }, "ifCondition");
  }
  var if_condition_default = ifCondition;

  // node_modules/@wordpress/is-shallow-equal/build-module/objects.js
  function isShallowEqualObjects(a6, b6) {
    if (a6 === b6) {
      return true;
    }
    const aKeys = Object.keys(a6);
    const bKeys = Object.keys(b6);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    let i5 = 0;
    while (i5 < aKeys.length) {
      const key = aKeys[i5];
      const aValue = a6[key];
      if (aValue === void 0 && !b6.hasOwnProperty(key) || aValue !== b6[key]) {
        return false;
      }
      i5++;
    }
    return true;
  }

  // node_modules/@wordpress/is-shallow-equal/build-module/arrays.js
  function isShallowEqualArrays(a6, b6) {
    if (a6 === b6) {
      return true;
    }
    if (a6.length !== b6.length) {
      return false;
    }
    for (let i5 = 0, len = a6.length; i5 < len; i5++) {
      if (a6[i5] !== b6[i5]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@wordpress/is-shallow-equal/build-module/index.js
  function isShallowEqual(a6, b6) {
    if (a6 && b6) {
      if (a6.constructor === Object && b6.constructor === Object) {
        return isShallowEqualObjects(a6, b6);
      } else if (Array.isArray(a6) && Array.isArray(b6)) {
        return isShallowEqualArrays(a6, b6);
      }
    }
    return a6 === b6;
  }

  // node_modules/@wordpress/compose/build-module/higher-order/pure/index.js
  var pure = createHigherOrderComponent(function(WrappedComponent) {
    if (WrappedComponent.prototype instanceof import_react.Component) {
      return class extends WrappedComponent {
        shouldComponentUpdate(nextProps, nextState) {
          return !isShallowEqual(nextProps, this.props) || !isShallowEqual(nextState, this.state);
        }
      };
    }
    return class extends import_react.Component {
      shouldComponentUpdate(nextProps) {
        return !isShallowEqual(nextProps, this.props);
      }
      render() {
        return (0, import_react.createElement)(WrappedComponent, this.props);
      }
    };
  }, "pure");
  var pure_default = pure;

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-instance-id/index.js
  var instanceMap = /* @__PURE__ */ new WeakMap();
  function createId(object) {
    const instances = instanceMap.get(object) || 0;
    instanceMap.set(object, instances + 1);
    return instances;
  }
  function useInstanceId(object, prefix2, preferredId) {
    return (0, import_react.useMemo)(() => {
      if (preferredId)
        return preferredId;
      const id2 = createId(object);
      return prefix2 ? `${prefix2}-${id2}` : id2;
    }, [object]);
  }
  var use_instance_id_default = useInstanceId;

  // node_modules/@wordpress/keycodes/build-module/index.js
  var import_lodash = __toESM(require_lodash());

  // node_modules/@wordpress/i18n/build-module/sprintf.js
  var import_memize = __toESM(require_memize());
  var import_sprintf_js = __toESM(require_sprintf());
  var logErrorOnce = (0, import_memize.default)(console.error);
  function sprintf(format) {
    try {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return import_sprintf_js.default.sprintf(format, ...args);
    } catch (error2) {
      if (error2 instanceof Error) {
        logErrorOnce("sprintf error: \n\n" + error2.toString());
      }
      return format;
    }
  }

  // node_modules/@tannin/postfix/index.js
  var PRECEDENCE;
  var OPENERS;
  var TERMINATORS;
  var PATTERN;
  PRECEDENCE = {
    "(": 9,
    "!": 8,
    "*": 7,
    "/": 7,
    "%": 7,
    "+": 6,
    "-": 6,
    "<": 5,
    "<=": 5,
    ">": 5,
    ">=": 5,
    "==": 4,
    "!=": 4,
    "&&": 3,
    "||": 2,
    "?": 1,
    "?:": 1
  };
  OPENERS = ["(", "?"];
  TERMINATORS = {
    ")": ["("],
    ":": ["?", "?:"]
  };
  PATTERN = /<=|>=|==|!=|&&|\|\||\?:|\(|!|\*|\/|%|\+|-|<|>|\?|\)|:/;
  function postfix(expression) {
    var terms = [], stack4 = [], match, operator, term, element;
    while (match = expression.match(PATTERN)) {
      operator = match[0];
      term = expression.substr(0, match.index).trim();
      if (term) {
        terms.push(term);
      }
      while (element = stack4.pop()) {
        if (TERMINATORS[operator]) {
          if (TERMINATORS[operator][0] === element) {
            operator = TERMINATORS[operator][1] || operator;
            break;
          }
        } else if (OPENERS.indexOf(element) >= 0 || PRECEDENCE[element] < PRECEDENCE[operator]) {
          stack4.push(element);
          break;
        }
        terms.push(element);
      }
      if (!TERMINATORS[operator]) {
        stack4.push(operator);
      }
      expression = expression.substr(match.index + operator.length);
    }
    expression = expression.trim();
    if (expression) {
      terms.push(expression);
    }
    return terms.concat(stack4.reverse());
  }

  // node_modules/@tannin/evaluate/index.js
  var OPERATORS = {
    "!": function(a6) {
      return !a6;
    },
    "*": function(a6, b6) {
      return a6 * b6;
    },
    "/": function(a6, b6) {
      return a6 / b6;
    },
    "%": function(a6, b6) {
      return a6 % b6;
    },
    "+": function(a6, b6) {
      return a6 + b6;
    },
    "-": function(a6, b6) {
      return a6 - b6;
    },
    "<": function(a6, b6) {
      return a6 < b6;
    },
    "<=": function(a6, b6) {
      return a6 <= b6;
    },
    ">": function(a6, b6) {
      return a6 > b6;
    },
    ">=": function(a6, b6) {
      return a6 >= b6;
    },
    "==": function(a6, b6) {
      return a6 === b6;
    },
    "!=": function(a6, b6) {
      return a6 !== b6;
    },
    "&&": function(a6, b6) {
      return a6 && b6;
    },
    "||": function(a6, b6) {
      return a6 || b6;
    },
    "?:": function(a6, b6, c6) {
      if (a6) {
        throw b6;
      }
      return c6;
    }
  };
  function evaluate(postfix2, variables) {
    var stack4 = [], i5, j2, args, getOperatorResult, term, value;
    for (i5 = 0; i5 < postfix2.length; i5++) {
      term = postfix2[i5];
      getOperatorResult = OPERATORS[term];
      if (getOperatorResult) {
        j2 = getOperatorResult.length;
        args = Array(j2);
        while (j2--) {
          args[j2] = stack4.pop();
        }
        try {
          value = getOperatorResult.apply(null, args);
        } catch (earlyReturn) {
          return earlyReturn;
        }
      } else if (variables.hasOwnProperty(term)) {
        value = variables[term];
      } else {
        value = +term;
      }
      stack4.push(value);
    }
    return stack4[0];
  }

  // node_modules/@tannin/compile/index.js
  function compile(expression) {
    var terms = postfix(expression);
    return function(variables) {
      return evaluate(terms, variables);
    };
  }

  // node_modules/@tannin/plural-forms/index.js
  function pluralForms(expression) {
    var evaluate2 = compile(expression);
    return function(n5) {
      return +evaluate2({ n: n5 });
    };
  }

  // node_modules/tannin/index.js
  var DEFAULT_OPTIONS = {
    contextDelimiter: "",
    onMissingKey: null
  };
  function getPluralExpression(pf) {
    var parts, i5, part;
    parts = pf.split(";");
    for (i5 = 0; i5 < parts.length; i5++) {
      part = parts[i5].trim();
      if (part.indexOf("plural=") === 0) {
        return part.substr(7);
      }
    }
  }
  function Tannin(data, options) {
    var key;
    this.data = data;
    this.pluralForms = {};
    this.options = {};
    for (key in DEFAULT_OPTIONS) {
      this.options[key] = options !== void 0 && key in options ? options[key] : DEFAULT_OPTIONS[key];
    }
  }
  Tannin.prototype.getPluralForm = function(domain, n5) {
    var getPluralForm = this.pluralForms[domain], config2, plural, pf;
    if (!getPluralForm) {
      config2 = this.data[domain][""];
      pf = config2["Plural-Forms"] || config2["plural-forms"] || config2.plural_forms;
      if (typeof pf !== "function") {
        plural = getPluralExpression(
          config2["Plural-Forms"] || config2["plural-forms"] || config2.plural_forms
        );
        pf = pluralForms(plural);
      }
      getPluralForm = this.pluralForms[domain] = pf;
    }
    return getPluralForm(n5);
  };
  Tannin.prototype.dcnpgettext = function(domain, context2, singular, plural, n5) {
    var index2, key, entry;
    if (n5 === void 0) {
      index2 = 0;
    } else {
      index2 = this.getPluralForm(domain, n5);
    }
    key = singular;
    if (context2) {
      key = context2 + this.options.contextDelimiter + singular;
    }
    entry = this.data[domain][key];
    if (entry && entry[index2]) {
      return entry[index2];
    }
    if (this.options.onMissingKey) {
      this.options.onMissingKey(singular, domain);
    }
    return index2 === 0 ? singular : plural;
  };

  // node_modules/@wordpress/i18n/build-module/create-i18n.js
  var DEFAULT_LOCALE_DATA = {
    "": {
      plural_forms(n5) {
        return n5 === 1 ? 0 : 1;
      }
    }
  };
  var I18N_HOOK_REGEXP = /^i18n\.(n?gettext|has_translation)(_|$)/;
  var createI18n = (initialData, initialDomain, hooks) => {
    const tannin = new Tannin({});
    const listeners = /* @__PURE__ */ new Set();
    const notifyListeners = () => {
      listeners.forEach((listener2) => listener2());
    };
    const subscribe4 = (callback) => {
      listeners.add(callback);
      return () => listeners.delete(callback);
    };
    const getLocaleData2 = function() {
      let domain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
      return tannin.data[domain];
    };
    const doSetLocaleData = function(data) {
      var _tannin$data$domain;
      let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
      tannin.data[domain] = {
        ...tannin.data[domain],
        ...data
      };
      tannin.data[domain][""] = {
        ...DEFAULT_LOCALE_DATA[""],
        ...(_tannin$data$domain = tannin.data[domain]) === null || _tannin$data$domain === void 0 ? void 0 : _tannin$data$domain[""]
      };
      delete tannin.pluralForms[domain];
    };
    const setLocaleData2 = (data, domain) => {
      doSetLocaleData(data, domain);
      notifyListeners();
    };
    const addLocaleData = function(data) {
      var _tannin$data$domain2;
      let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
      tannin.data[domain] = {
        ...tannin.data[domain],
        ...data,
        "": {
          ...DEFAULT_LOCALE_DATA[""],
          ...(_tannin$data$domain2 = tannin.data[domain]) === null || _tannin$data$domain2 === void 0 ? void 0 : _tannin$data$domain2[""],
          ...data === null || data === void 0 ? void 0 : data[""]
        }
      };
      delete tannin.pluralForms[domain];
      notifyListeners();
    };
    const resetLocaleData2 = (data, domain) => {
      tannin.data = {};
      tannin.pluralForms = {};
      setLocaleData2(data, domain);
    };
    const dcnpgettext = function() {
      let domain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
      let context2 = arguments.length > 1 ? arguments[1] : void 0;
      let single = arguments.length > 2 ? arguments[2] : void 0;
      let plural = arguments.length > 3 ? arguments[3] : void 0;
      let number2 = arguments.length > 4 ? arguments[4] : void 0;
      if (!tannin.data[domain]) {
        doSetLocaleData(void 0, domain);
      }
      return tannin.dcnpgettext(domain, context2, single, plural, number2);
    };
    const getFilterDomain = function() {
      let domain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
      return domain;
    };
    const __2 = (text3, domain) => {
      let translation = dcnpgettext(domain, void 0, text3);
      if (!hooks) {
        return translation;
      }
      translation = hooks.applyFilters("i18n.gettext", translation, text3, domain);
      return hooks.applyFilters("i18n.gettext_" + getFilterDomain(domain), translation, text3, domain);
    };
    const _x2 = (text3, context2, domain) => {
      let translation = dcnpgettext(domain, context2, text3);
      if (!hooks) {
        return translation;
      }
      translation = hooks.applyFilters("i18n.gettext_with_context", translation, text3, context2, domain);
      return hooks.applyFilters("i18n.gettext_with_context_" + getFilterDomain(domain), translation, text3, context2, domain);
    };
    const _n2 = (single, plural, number2, domain) => {
      let translation = dcnpgettext(domain, void 0, single, plural, number2);
      if (!hooks) {
        return translation;
      }
      translation = hooks.applyFilters("i18n.ngettext", translation, single, plural, number2, domain);
      return hooks.applyFilters("i18n.ngettext_" + getFilterDomain(domain), translation, single, plural, number2, domain);
    };
    const _nx2 = (single, plural, number2, context2, domain) => {
      let translation = dcnpgettext(domain, context2, single, plural, number2);
      if (!hooks) {
        return translation;
      }
      translation = hooks.applyFilters("i18n.ngettext_with_context", translation, single, plural, number2, context2, domain);
      return hooks.applyFilters("i18n.ngettext_with_context_" + getFilterDomain(domain), translation, single, plural, number2, context2, domain);
    };
    const isRTL3 = () => {
      return "rtl" === _x2("ltr", "text direction");
    };
    const hasTranslation2 = (single, context2, domain) => {
      var _tannin$data, _tannin$data2;
      const key = context2 ? context2 + "" + single : single;
      let result = !!((_tannin$data = tannin.data) !== null && _tannin$data !== void 0 && (_tannin$data2 = _tannin$data[domain !== null && domain !== void 0 ? domain : "default"]) !== null && _tannin$data2 !== void 0 && _tannin$data2[key]);
      if (hooks) {
        result = hooks.applyFilters("i18n.has_translation", result, single, context2, domain);
        result = hooks.applyFilters("i18n.has_translation_" + getFilterDomain(domain), result, single, context2, domain);
      }
      return result;
    };
    if (initialData) {
      setLocaleData2(initialData, initialDomain);
    }
    if (hooks) {
      const onHookAddedOrRemoved = (hookName) => {
        if (I18N_HOOK_REGEXP.test(hookName)) {
          notifyListeners();
        }
      };
      hooks.addAction("hookAdded", "core/i18n", onHookAddedOrRemoved);
      hooks.addAction("hookRemoved", "core/i18n", onHookAddedOrRemoved);
    }
    return {
      getLocaleData: getLocaleData2,
      setLocaleData: setLocaleData2,
      addLocaleData,
      resetLocaleData: resetLocaleData2,
      subscribe: subscribe4,
      __: __2,
      _x: _x2,
      _n: _n2,
      _nx: _nx2,
      isRTL: isRTL3,
      hasTranslation: hasTranslation2
    };
  };

  // node_modules/@wordpress/i18n/build-module/default-i18n.js
  var i18n = createI18n(void 0, void 0, defaultHooks);
  var getLocaleData = i18n.getLocaleData.bind(i18n);
  var setLocaleData = i18n.setLocaleData.bind(i18n);
  var resetLocaleData = i18n.resetLocaleData.bind(i18n);
  var subscribe = i18n.subscribe.bind(i18n);
  var __ = i18n.__.bind(i18n);
  var _x = i18n._x.bind(i18n);
  var _n = i18n._n.bind(i18n);
  var _nx = i18n._nx.bind(i18n);
  var isRTL = i18n.isRTL.bind(i18n);
  var hasTranslation = i18n.hasTranslation.bind(i18n);

  // node_modules/@wordpress/keycodes/build-module/platform.js
  function isAppleOS() {
    let _window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (!_window2) {
      if (typeof window === "undefined") {
        return false;
      }
      _window2 = window;
    }
    const {
      platform
    } = _window2.navigator;
    return platform.indexOf("Mac") !== -1 || ["iPad", "iPhone"].includes(platform);
  }

  // node_modules/@wordpress/keycodes/build-module/index.js
  var BACKSPACE = 8;
  var TAB = 9;
  var ENTER = 13;
  var ESCAPE = 27;
  var SPACE = 32;
  var LEFT = 37;
  var UP = 38;
  var RIGHT = 39;
  var DOWN = 40;
  var DELETE = 46;
  var ALT = "alt";
  var CTRL = "ctrl";
  var COMMAND = "meta";
  var SHIFT = "shift";
  var modifiers = {
    primary: (_isApple) => _isApple() ? [COMMAND] : [CTRL],
    primaryShift: (_isApple) => _isApple() ? [SHIFT, COMMAND] : [CTRL, SHIFT],
    primaryAlt: (_isApple) => _isApple() ? [ALT, COMMAND] : [CTRL, ALT],
    secondary: (_isApple) => _isApple() ? [SHIFT, ALT, COMMAND] : [CTRL, SHIFT, ALT],
    access: (_isApple) => _isApple() ? [CTRL, ALT] : [SHIFT, ALT],
    ctrl: () => [CTRL],
    alt: () => [ALT],
    ctrlShift: () => [CTRL, SHIFT],
    shift: () => [SHIFT],
    shiftAlt: () => [SHIFT, ALT],
    undefined: () => []
  };
  var rawShortcut = (0, import_lodash.mapValues)(modifiers, (modifier) => {
    return function(character) {
      let _isApple = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isAppleOS;
      return [...modifier(_isApple), character.toLowerCase()].join("+");
    };
  });
  var displayShortcutList = (0, import_lodash.mapValues)(modifiers, (modifier) => {
    return function(character) {
      let _isApple = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isAppleOS;
      const isApple = _isApple();
      const replacementKeyMap = {
        [ALT]: isApple ? "\u2325" : "Alt",
        [CTRL]: isApple ? "\u2303" : "Ctrl",
        [COMMAND]: "\u2318",
        [SHIFT]: isApple ? "\u21E7" : "Shift"
      };
      const modifierKeys = modifier(_isApple).reduce(
        (accumulator, key) => {
          const replacementKey = (0, import_lodash.get)(replacementKeyMap, key, key);
          if (isApple) {
            return [...accumulator, replacementKey];
          }
          return [...accumulator, replacementKey, "+"];
        },
        []
      );
      const capitalizedCharacter = capitalCase(character, {
        stripRegexp: /[^A-Z0-9`,\.\\]/gi
      });
      return [...modifierKeys, capitalizedCharacter];
    };
  });
  var displayShortcut = (0, import_lodash.mapValues)(displayShortcutList, (shortcutList) => {
    return function(character) {
      let _isApple = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isAppleOS;
      return shortcutList(character, _isApple).join("");
    };
  });
  var shortcutAriaLabel = (0, import_lodash.mapValues)(modifiers, (modifier) => {
    return function(character) {
      let _isApple = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isAppleOS;
      const isApple = _isApple();
      const replacementKeyMap = {
        [SHIFT]: "Shift",
        [COMMAND]: isApple ? "Command" : "Control",
        [CTRL]: "Control",
        [ALT]: isApple ? "Option" : "Alt",
        ",": __("Comma"),
        ".": __("Period"),
        "`": __("Backtick")
      };
      return [...modifier(_isApple), character].map((key) => capitalCase((0, import_lodash.get)(replacementKeyMap, key, key))).join(isApple ? " " : " + ");
    };
  });
  function getEventModifiers(event) {
    return [ALT, CTRL, COMMAND, SHIFT].filter((key) => event[`${key}Key`]);
  }
  var isKeyboardEvent = (0, import_lodash.mapValues)(modifiers, (getModifiers) => {
    return function(event, character) {
      let _isApple = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isAppleOS;
      const mods = getModifiers(_isApple);
      const eventMods = getEventModifiers(event);
      const modsDiff = mods.filter((mod) => !eventMods.includes(mod));
      const eventModsDiff = eventMods.filter((mod) => !mods.includes(mod));
      if (modsDiff.length > 0 || eventModsDiff.length > 0) {
        return false;
      }
      let key = event.key.toLowerCase();
      if (!character) {
        return mods.includes(
          key
        );
      }
      if (event.altKey && character.length === 1) {
        key = String.fromCharCode(event.keyCode).toLowerCase();
      }
      if (!_isApple()) {
        if (event.shiftKey && character.length === 1 && event.code === "Comma") {
          key = ",";
        }
      }
      if (character === "del") {
        character = "delete";
      }
      return key === character.toLowerCase();
    };
  });

  // node_modules/@wordpress/dom/build-module/focusable.js
  var focusable_exports = {};
  __export(focusable_exports, {
    find: () => find
  });
  function buildSelector(sequential) {
    return [sequential ? '[tabindex]:not([tabindex^="-"])' : "[tabindex]", "a[href]", "button:not([disabled])", 'input:not([type="hidden"]):not([disabled])', "select:not([disabled])", "textarea:not([disabled])", 'iframe:not([tabindex^="-"])', "object", "embed", "area[href]", "[contenteditable]:not([contenteditable=false])"].join(",");
  }
  function isVisible(element) {
    return element.offsetWidth > 0 || element.offsetHeight > 0 || element.getClientRects().length > 0;
  }
  function isValidFocusableArea(element) {
    const map9 = element.closest("map[name]");
    if (!map9) {
      return false;
    }
    const img = element.ownerDocument.querySelector('img[usemap="#' + map9.name + '"]');
    return !!img && isVisible(img);
  }
  function find(context2) {
    let {
      sequential = false
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const elements = context2.querySelectorAll(buildSelector(sequential));
    return Array.from(elements).filter((element) => {
      if (!isVisible(element)) {
        return false;
      }
      const {
        nodeName
      } = element;
      if ("AREA" === nodeName) {
        return isValidFocusableArea(
          element
        );
      }
      return true;
    });
  }

  // node_modules/@wordpress/dom/build-module/tabbable.js
  var tabbable_exports = {};
  __export(tabbable_exports, {
    find: () => find2,
    findNext: () => findNext,
    findPrevious: () => findPrevious,
    isTabbableIndex: () => isTabbableIndex
  });
  function getTabIndex(element) {
    const tabIndex = element.getAttribute("tabindex");
    return tabIndex === null ? 0 : parseInt(tabIndex, 10);
  }
  function isTabbableIndex(element) {
    return getTabIndex(element) !== -1;
  }
  function createStatefulCollapseRadioGroup() {
    const CHOSEN_RADIO_BY_NAME = {};
    return function collapseRadioGroup(result, element) {
      const {
        nodeName,
        type,
        checked,
        name
      } = element;
      if (nodeName !== "INPUT" || type !== "radio" || !name) {
        return result.concat(element);
      }
      const hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty(name);
      const isChosen = checked || !hasChosen;
      if (!isChosen) {
        return result;
      }
      if (hasChosen) {
        const hadChosenElement = CHOSEN_RADIO_BY_NAME[name];
        result = result.filter((e4) => e4 !== hadChosenElement);
      }
      CHOSEN_RADIO_BY_NAME[name] = element;
      return result.concat(element);
    };
  }
  function mapElementToObjectTabbable(element, index2) {
    return {
      element,
      index: index2
    };
  }
  function mapObjectTabbableToElement(object) {
    return object.element;
  }
  function compareObjectTabbables(a6, b6) {
    const aTabIndex = getTabIndex(a6.element);
    const bTabIndex = getTabIndex(b6.element);
    if (aTabIndex === bTabIndex) {
      return a6.index - b6.index;
    }
    return aTabIndex - bTabIndex;
  }
  function filterTabbable(focusables) {
    return focusables.filter(isTabbableIndex).map(mapElementToObjectTabbable).sort(compareObjectTabbables).map(mapObjectTabbableToElement).reduce(createStatefulCollapseRadioGroup(), []);
  }
  function find2(context2) {
    return filterTabbable(find(context2));
  }
  function findPrevious(element) {
    const focusables = find(element.ownerDocument.body);
    const index2 = focusables.indexOf(element);
    if (index2 === -1) {
      return void 0;
    }
    focusables.length = index2;
    const tabbable = filterTabbable(focusables);
    return tabbable[tabbable.length - 1];
  }
  function findNext(element) {
    const focusables = find(element.ownerDocument.body);
    const index2 = focusables.indexOf(element);
    const remaining = focusables.slice(index2 + 1);
    return filterTabbable(remaining)[0];
  }

  // node_modules/@wordpress/dom/build-module/utils/assert-is-defined.js
  function assertIsDefined(val, name) {
    if (val === void 0 || val === null) {
      throw new Error(`Expected '${name}' to be defined, but received ${val}`);
    }
  }

  // node_modules/@wordpress/dom/build-module/dom/get-rectangle-from-range.js
  function getRectangleFromRange(range) {
    if (!range.collapsed) {
      const rects2 = Array.from(range.getClientRects());
      if (rects2.length === 1) {
        return rects2[0];
      }
      const filteredRects = rects2.filter((_ref8) => {
        let {
          width: width3
        } = _ref8;
        return width3 > 1;
      });
      if (filteredRects.length === 0) {
        return range.getBoundingClientRect();
      }
      if (filteredRects.length === 1) {
        return filteredRects[0];
      }
      let {
        top: furthestTop,
        bottom: furthestBottom,
        left: furthestLeft,
        right: furthestRight
      } = filteredRects[0];
      for (const {
        top,
        bottom,
        left,
        right
      } of filteredRects) {
        if (top < furthestTop)
          furthestTop = top;
        if (bottom > furthestBottom)
          furthestBottom = bottom;
        if (left < furthestLeft)
          furthestLeft = left;
        if (right > furthestRight)
          furthestRight = right;
      }
      return new window.DOMRect(furthestLeft, furthestTop, furthestRight - furthestLeft, furthestBottom - furthestTop);
    }
    const {
      startContainer
    } = range;
    const {
      ownerDocument
    } = startContainer;
    if (startContainer.nodeName === "BR") {
      const {
        parentNode
      } = startContainer;
      assertIsDefined(parentNode, "parentNode");
      const index2 = Array.from(parentNode.childNodes).indexOf(startContainer);
      assertIsDefined(ownerDocument, "ownerDocument");
      range = ownerDocument.createRange();
      range.setStart(parentNode, index2);
      range.setEnd(parentNode, index2);
    }
    const rects = range.getClientRects();
    if (rects.length > 1) {
      return null;
    }
    let rect = rects[0];
    if (!rect) {
      assertIsDefined(ownerDocument, "ownerDocument");
      const padNode = ownerDocument.createTextNode("\u200B");
      range = range.cloneRange();
      range.insertNode(padNode);
      rect = range.getClientRects()[0];
      assertIsDefined(padNode.parentNode, "padNode.parentNode");
      padNode.parentNode.removeChild(padNode);
    }
    return rect;
  }

  // node_modules/@wordpress/dom/build-module/dom/compute-caret-rect.js
  function computeCaretRect(win) {
    const selection2 = win.getSelection();
    assertIsDefined(selection2, "selection");
    const range = selection2.rangeCount ? selection2.getRangeAt(0) : null;
    if (!range) {
      return null;
    }
    return getRectangleFromRange(range);
  }

  // node_modules/@wordpress/dom/build-module/dom/is-html-input-element.js
  function isHTMLInputElement(node) {
    return (node === null || node === void 0 ? void 0 : node.nodeName) === "INPUT";
  }

  // node_modules/@wordpress/dom/build-module/dom/is-text-field.js
  function isTextField(node) {
    const nonTextInputs = ["button", "checkbox", "hidden", "file", "radio", "image", "range", "reset", "submit", "number", "email", "time"];
    return isHTMLInputElement(node) && node.type && !nonTextInputs.includes(node.type) || node.nodeName === "TEXTAREA" || node.contentEditable === "true";
  }

  // node_modules/@wordpress/dom/build-module/dom/get-computed-style.js
  function getComputedStyle2(element) {
    assertIsDefined(element.ownerDocument.defaultView, "element.ownerDocument.defaultView");
    return element.ownerDocument.defaultView.getComputedStyle(element);
  }

  // node_modules/@wordpress/dom/build-module/dom/get-scroll-container.js
  function getScrollContainer(node) {
    if (!node) {
      return void 0;
    }
    if (node.scrollHeight > node.clientHeight) {
      const {
        overflowY
      } = getComputedStyle2(node);
      if (/(auto|scroll)/.test(overflowY)) {
        return node;
      }
    }
    if (node.ownerDocument === node.parentNode) {
      return node;
    }
    return getScrollContainer(
      node.parentNode
    );
  }

  // node_modules/@wordpress/dom/build-module/dom/is-input-or-text-area.js
  function isInputOrTextArea(element) {
    return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
  }

  // node_modules/@wordpress/dom/build-module/dom/is-entirely-selected.js
  function isEntirelySelected(element) {
    if (isInputOrTextArea(element)) {
      return element.selectionStart === 0 && element.value.length === element.selectionEnd;
    }
    if (!element.isContentEditable) {
      return true;
    }
    const {
      ownerDocument
    } = element;
    const {
      defaultView
    } = ownerDocument;
    assertIsDefined(defaultView, "defaultView");
    const selection2 = defaultView.getSelection();
    assertIsDefined(selection2, "selection");
    const range = selection2.rangeCount ? selection2.getRangeAt(0) : null;
    if (!range) {
      return true;
    }
    const {
      startContainer,
      endContainer,
      startOffset,
      endOffset
    } = range;
    if (startContainer === element && endContainer === element && startOffset === 0 && endOffset === element.childNodes.length) {
      return true;
    }
    const lastChild = element.lastChild;
    assertIsDefined(lastChild, "lastChild");
    const endContainerContentLength = endContainer.nodeType === endContainer.TEXT_NODE ? endContainer.data.length : endContainer.childNodes.length;
    return isDeepChild(startContainer, element, "firstChild") && isDeepChild(endContainer, element, "lastChild") && startOffset === 0 && endOffset === endContainerContentLength;
  }
  function isDeepChild(query2, container, propName) {
    let candidate = container;
    do {
      if (query2 === candidate) {
        return true;
      }
      candidate = candidate[propName];
    } while (candidate);
    return false;
  }

  // node_modules/@wordpress/dom/build-module/dom/is-form-element.js
  function isFormElement(element) {
    if (!element) {
      return false;
    }
    const {
      tagName
    } = element;
    const checkForInputTextarea = isInputOrTextArea(element);
    return checkForInputTextarea || tagName === "BUTTON" || tagName === "SELECT";
  }

  // node_modules/@wordpress/dom/build-module/dom/is-rtl.js
  function isRTL2(element) {
    return getComputedStyle2(element).direction === "rtl";
  }

  // node_modules/@wordpress/dom/build-module/dom/get-range-height.js
  function getRangeHeight(range) {
    const rects = Array.from(range.getClientRects());
    if (!rects.length) {
      return;
    }
    const highestTop = Math.min(...rects.map((_ref8) => {
      let {
        top
      } = _ref8;
      return top;
    }));
    const lowestBottom = Math.max(...rects.map((_ref22) => {
      let {
        bottom
      } = _ref22;
      return bottom;
    }));
    return lowestBottom - highestTop;
  }

  // node_modules/@wordpress/dom/build-module/dom/is-selection-forward.js
  function isSelectionForward(selection2) {
    const {
      anchorNode,
      focusNode,
      anchorOffset,
      focusOffset
    } = selection2;
    assertIsDefined(anchorNode, "anchorNode");
    assertIsDefined(focusNode, "focusNode");
    const position = anchorNode.compareDocumentPosition(focusNode);
    if (position & anchorNode.DOCUMENT_POSITION_PRECEDING) {
      return false;
    }
    if (position & anchorNode.DOCUMENT_POSITION_FOLLOWING) {
      return true;
    }
    if (position === 0) {
      return anchorOffset <= focusOffset;
    }
    return true;
  }

  // node_modules/@wordpress/dom/build-module/dom/caret-range-from-point.js
  function caretRangeFromPoint(doc, x4, y5) {
    if (doc.caretRangeFromPoint) {
      return doc.caretRangeFromPoint(x4, y5);
    }
    if (!doc.caretPositionFromPoint) {
      return null;
    }
    const point = doc.caretPositionFromPoint(x4, y5);
    if (!point) {
      return null;
    }
    const range = doc.createRange();
    range.setStart(point.offsetNode, point.offset);
    range.collapse(true);
    return range;
  }

  // node_modules/@wordpress/dom/build-module/dom/hidden-caret-range-from-point.js
  function hiddenCaretRangeFromPoint(doc, x4, y5, container) {
    const originalZIndex = container.style.zIndex;
    const originalPosition = container.style.position;
    const {
      position = "static"
    } = getComputedStyle2(container);
    if (position === "static") {
      container.style.position = "relative";
    }
    container.style.zIndex = "10000";
    const range = caretRangeFromPoint(doc, x4, y5);
    container.style.zIndex = originalZIndex;
    container.style.position = originalPosition;
    return range;
  }

  // node_modules/@wordpress/dom/build-module/dom/is-edge.js
  function isEdge(container, isReverse) {
    let onlyVertical = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (isInputOrTextArea(container) && typeof container.selectionStart === "number") {
      if (container.selectionStart !== container.selectionEnd) {
        return false;
      }
      if (isReverse) {
        return container.selectionStart === 0;
      }
      return container.value.length === container.selectionStart;
    }
    if (!container.isContentEditable) {
      return true;
    }
    const {
      ownerDocument
    } = container;
    const {
      defaultView
    } = ownerDocument;
    assertIsDefined(defaultView, "defaultView");
    const selection2 = defaultView.getSelection();
    if (!selection2 || !selection2.rangeCount) {
      return false;
    }
    const range = selection2.getRangeAt(0);
    const collapsedRange = range.cloneRange();
    const isForward = isSelectionForward(selection2);
    const isCollapsed = selection2.isCollapsed;
    if (!isCollapsed) {
      collapsedRange.collapse(!isForward);
    }
    const collapsedRangeRect = getRectangleFromRange(collapsedRange);
    const rangeRect = getRectangleFromRange(range);
    if (!collapsedRangeRect || !rangeRect) {
      return false;
    }
    const rangeHeight = getRangeHeight(range);
    if (!isCollapsed && rangeHeight && rangeHeight > collapsedRangeRect.height && isForward === isReverse) {
      return false;
    }
    const isReverseDir = isRTL2(container) ? !isReverse : isReverse;
    const containerRect = container.getBoundingClientRect();
    const x4 = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;
    const y5 = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;
    const testRange = hiddenCaretRangeFromPoint(
      ownerDocument,
      x4,
      y5,
      container
    );
    if (!testRange) {
      return false;
    }
    const testRect = getRectangleFromRange(testRange);
    if (!testRect) {
      return false;
    }
    const verticalSide = isReverse ? "top" : "bottom";
    const horizontalSide = isReverseDir ? "left" : "right";
    const verticalDiff = testRect[verticalSide] - rangeRect[verticalSide];
    const horizontalDiff = testRect[horizontalSide] - collapsedRangeRect[horizontalSide];
    const hasVerticalDiff = Math.abs(verticalDiff) <= 1;
    const hasHorizontalDiff = Math.abs(horizontalDiff) <= 1;
    return onlyVertical ? hasVerticalDiff : hasVerticalDiff && hasHorizontalDiff;
  }

  // node_modules/@wordpress/dom/build-module/dom/is-horizontal-edge.js
  function isHorizontalEdge(container, isReverse) {
    return isEdge(container, isReverse);
  }

  // node_modules/@wordpress/dom/build-module/dom/is-vertical-edge.js
  function isVerticalEdge(container, isReverse) {
    return isEdge(container, isReverse, true);
  }

  // node_modules/@wordpress/dom/build-module/dom/place-caret-at-edge.js
  function getRange(container, isReverse, x4) {
    const {
      ownerDocument
    } = container;
    const isReverseDir = isRTL2(container) ? !isReverse : isReverse;
    const containerRect = container.getBoundingClientRect();
    if (x4 === void 0) {
      x4 = isReverse ? containerRect.right - 1 : containerRect.left + 1;
    } else if (x4 <= containerRect.left) {
      x4 = containerRect.left + 1;
    } else if (x4 >= containerRect.right) {
      x4 = containerRect.right - 1;
    }
    const y5 = isReverseDir ? containerRect.bottom - 1 : containerRect.top + 1;
    return hiddenCaretRangeFromPoint(ownerDocument, x4, y5, container);
  }
  function placeCaretAtEdge(container, isReverse, x4) {
    if (!container) {
      return;
    }
    container.focus();
    if (isInputOrTextArea(container)) {
      if (typeof container.selectionStart !== "number") {
        return;
      }
      if (isReverse) {
        container.selectionStart = container.value.length;
        container.selectionEnd = container.value.length;
      } else {
        container.selectionStart = 0;
        container.selectionEnd = 0;
      }
      return;
    }
    if (!container.isContentEditable) {
      return;
    }
    let range = getRange(container, isReverse, x4);
    if (!range || !range.startContainer || !container.contains(range.startContainer)) {
      container.scrollIntoView(isReverse);
      range = range = getRange(container, isReverse, x4);
      if (!range || !range.startContainer || !container.contains(range.startContainer)) {
        return;
      }
    }
    const {
      ownerDocument
    } = container;
    const {
      defaultView
    } = ownerDocument;
    assertIsDefined(defaultView, "defaultView");
    const selection2 = defaultView.getSelection();
    assertIsDefined(selection2, "selection");
    selection2.removeAllRanges();
    selection2.addRange(range);
  }

  // node_modules/@wordpress/dom/build-module/dom/place-caret-at-horizontal-edge.js
  function placeCaretAtHorizontalEdge(container, isReverse) {
    return placeCaretAtEdge(container, isReverse, void 0);
  }

  // node_modules/@wordpress/dom/build-module/dom/place-caret-at-vertical-edge.js
  function placeCaretAtVerticalEdge(container, isReverse, rect) {
    return placeCaretAtEdge(container, isReverse, rect === null || rect === void 0 ? void 0 : rect.left);
  }

  // node_modules/@wordpress/dom/build-module/dom/insert-after.js
  function insertAfter(newNode, referenceNode) {
    assertIsDefined(referenceNode.parentNode, "referenceNode.parentNode");
    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
  }

  // node_modules/@wordpress/dom/build-module/dom/remove.js
  function remove(node) {
    assertIsDefined(node.parentNode, "node.parentNode");
    node.parentNode.removeChild(node);
  }

  // node_modules/@wordpress/dom/build-module/dom/replace.js
  function replace2(processedNode, newNode) {
    assertIsDefined(processedNode.parentNode, "processedNode.parentNode");
    insertAfter(newNode, processedNode.parentNode);
    remove(processedNode);
  }

  // node_modules/@wordpress/dom/build-module/dom/unwrap.js
  function unwrap(node) {
    const parent = node.parentNode;
    assertIsDefined(parent, "node.parentNode");
    while (node.firstChild) {
      parent.insertBefore(node.firstChild, node);
    }
    parent.removeChild(node);
  }

  // node_modules/@wordpress/dom/build-module/dom/replace-tag.js
  function replaceTag(node, tagName) {
    const newNode = node.ownerDocument.createElement(tagName);
    while (node.firstChild) {
      newNode.appendChild(node.firstChild);
    }
    assertIsDefined(node.parentNode, "node.parentNode");
    node.parentNode.replaceChild(newNode, node);
    return newNode;
  }

  // node_modules/@wordpress/dom/build-module/dom/wrap.js
  function wrap(newNode, referenceNode) {
    assertIsDefined(referenceNode.parentNode, "referenceNode.parentNode");
    referenceNode.parentNode.insertBefore(newNode, referenceNode);
    newNode.appendChild(referenceNode);
  }

  // node_modules/@wordpress/dom/build-module/dom/safe-html.js
  function safeHTML(html2) {
    const {
      body
    } = document.implementation.createHTMLDocument("");
    body.innerHTML = html2;
    const elements = body.getElementsByTagName("*");
    let elementIndex = elements.length;
    while (elementIndex--) {
      const element = elements[elementIndex];
      if (element.tagName === "SCRIPT") {
        remove(element);
      } else {
        let attributeIndex = element.attributes.length;
        while (attributeIndex--) {
          const {
            name: key
          } = element.attributes[attributeIndex];
          if (key.startsWith("on")) {
            element.removeAttribute(key);
          }
        }
      }
    }
    return body.innerHTML;
  }

  // node_modules/@wordpress/dom/build-module/dom/strip-html.js
  function stripHTML(html2) {
    html2 = safeHTML(html2);
    const doc = document.implementation.createHTMLDocument("");
    doc.body.innerHTML = html2;
    return doc.body.textContent || "";
  }

  // node_modules/@wordpress/dom/build-module/dom/is-empty.js
  function isEmpty(element) {
    switch (element.nodeType) {
      case element.TEXT_NODE:
        return /^[ \f\n\r\t\v\u00a0]*$/.test(element.nodeValue || "");
      case element.ELEMENT_NODE:
        if (element.hasAttributes()) {
          return false;
        } else if (!element.hasChildNodes()) {
          return true;
        }
        return Array.from(element.childNodes).every(isEmpty);
      default:
        return true;
    }
  }

  // node_modules/@wordpress/dom/build-module/phrasing-content.js
  var textContentSchema = {
    strong: {},
    em: {},
    s: {},
    del: {},
    ins: {},
    a: {
      attributes: ["href", "target", "rel", "id"]
    },
    code: {},
    abbr: {
      attributes: ["title"]
    },
    sub: {},
    sup: {},
    br: {},
    small: {},
    q: {
      attributes: ["cite"]
    },
    dfn: {
      attributes: ["title"]
    },
    data: {
      attributes: ["value"]
    },
    time: {
      attributes: ["datetime"]
    },
    var: {},
    samp: {},
    kbd: {},
    i: {},
    b: {},
    u: {},
    mark: {},
    ruby: {},
    rt: {},
    rp: {},
    bdi: {
      attributes: ["dir"]
    },
    bdo: {
      attributes: ["dir"]
    },
    wbr: {},
    "#text": {}
  };
  var excludedElements = ["#text", "br"];
  Object.keys(textContentSchema).filter((element) => !excludedElements.includes(element)).forEach((tag) => {
    const {
      [tag]: removedTag,
      ...restSchema
    } = textContentSchema;
    textContentSchema[tag].children = restSchema;
  });
  var embeddedContentSchema = {
    audio: {
      attributes: ["src", "preload", "autoplay", "mediagroup", "loop", "muted"]
    },
    canvas: {
      attributes: ["width", "height"]
    },
    embed: {
      attributes: ["src", "type", "width", "height"]
    },
    img: {
      attributes: ["alt", "src", "srcset", "usemap", "ismap", "width", "height"]
    },
    object: {
      attributes: ["data", "type", "name", "usemap", "form", "width", "height"]
    },
    video: {
      attributes: ["src", "poster", "preload", "autoplay", "mediagroup", "loop", "muted", "controls", "width", "height"]
    }
  };
  var phrasingContentSchema = {
    ...textContentSchema,
    ...embeddedContentSchema
  };
  function getPhrasingContentSchema(context2) {
    if (context2 !== "paste") {
      return phrasingContentSchema;
    }
    const {
      u: u4,
      abbr,
      data,
      time,
      wbr,
      bdi,
      bdo,
      ...remainingContentSchema
    } = {
      ...phrasingContentSchema,
      ins: {
        children: phrasingContentSchema.ins.children
      },
      del: {
        children: phrasingContentSchema.del.children
      }
    };
    return remainingContentSchema;
  }
  function isPhrasingContent(node) {
    const tag = node.nodeName.toLowerCase();
    return getPhrasingContentSchema().hasOwnProperty(tag) || tag === "span";
  }
  function isTextContent(node) {
    const tag = node.nodeName.toLowerCase();
    return textContentSchema.hasOwnProperty(tag) || tag === "span";
  }

  // node_modules/@wordpress/dom/build-module/dom/is-element.js
  function isElement(node) {
    return !!node && node.nodeType === node.ELEMENT_NODE;
  }

  // node_modules/@wordpress/dom/build-module/dom/clean-node-list.js
  var noop = () => {
  };
  function cleanNodeList(nodeList, doc, schema, inline) {
    Array.from(nodeList).forEach((node) => {
      var _schema$tag$isMatch, _schema$tag;
      const tag = node.nodeName.toLowerCase();
      if (schema.hasOwnProperty(tag) && (!schema[tag].isMatch || (_schema$tag$isMatch = (_schema$tag = schema[tag]).isMatch) !== null && _schema$tag$isMatch !== void 0 && _schema$tag$isMatch.call(_schema$tag, node))) {
        if (isElement(node)) {
          const {
            attributes = [],
            classes = [],
            children,
            require: require2 = [],
            allowEmpty
          } = schema[tag];
          if (children && !allowEmpty && isEmpty(node)) {
            remove(node);
            return;
          }
          if (node.hasAttributes()) {
            Array.from(node.attributes).forEach((_ref8) => {
              let {
                name
              } = _ref8;
              if (name !== "class" && !attributes.includes(name)) {
                node.removeAttribute(name);
              }
            });
            if (node.classList && node.classList.length) {
              const mattchers = classes.map((item2) => {
                if (typeof item2 === "string") {
                  return (className) => className === item2;
                } else if (item2 instanceof RegExp) {
                  return (className) => item2.test(className);
                }
                return noop;
              });
              Array.from(node.classList).forEach((name) => {
                if (!mattchers.some((isMatch) => isMatch(name))) {
                  node.classList.remove(name);
                }
              });
              if (!node.classList.length) {
                node.removeAttribute("class");
              }
            }
          }
          if (node.hasChildNodes()) {
            if (children === "*") {
              return;
            }
            if (children) {
              if (require2.length && !node.querySelector(require2.join(","))) {
                cleanNodeList(node.childNodes, doc, schema, inline);
                unwrap(node);
              } else if (node.parentNode && node.parentNode.nodeName === "BODY" && isPhrasingContent(node)) {
                cleanNodeList(node.childNodes, doc, schema, inline);
                if (Array.from(node.childNodes).some((child) => !isPhrasingContent(child))) {
                  unwrap(node);
                }
              } else {
                cleanNodeList(node.childNodes, doc, children, inline);
              }
            } else {
              while (node.firstChild) {
                remove(node.firstChild);
              }
            }
          }
        }
      } else {
        cleanNodeList(node.childNodes, doc, schema, inline);
        if (inline && !isPhrasingContent(node) && node.nextElementSibling) {
          insertAfter(doc.createElement("br"), node);
        }
        unwrap(node);
      }
    });
  }

  // node_modules/@wordpress/dom/build-module/dom/remove-invalid-html.js
  function removeInvalidHTML(HTML, schema, inline) {
    const doc = document.implementation.createHTMLDocument("");
    doc.body.innerHTML = HTML;
    cleanNodeList(doc.body.childNodes, doc, schema, inline);
    return doc.body.innerHTML;
  }

  // node_modules/@wordpress/dom/build-module/data-transfer.js
  function getFilesFromDataTransfer(dataTransfer) {
    const files = Array.from(dataTransfer.files);
    Array.from(dataTransfer.items).forEach((item2) => {
      const file = item2.getAsFile();
      if (file && !files.find((_ref8) => {
        let {
          name,
          type,
          size
        } = _ref8;
        return name === file.name && type === file.type && size === file.size;
      })) {
        files.push(file);
      }
    });
    return files;
  }

  // node_modules/@wordpress/dom/build-module/index.js
  var focus = {
    focusable: focusable_exports,
    tabbable: tabbable_exports
  };

  // node_modules/@wordpress/compose/build-module/hooks/use-ref-effect/index.js
  function useRefEffect(callback, dependencies) {
    const cleanup = (0, import_react.useRef)();
    return (0, import_react.useCallback)((node) => {
      if (node) {
        cleanup.current = callback(node);
      } else if (cleanup.current) {
        cleanup.current();
      }
    }, dependencies);
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-constrained-tabbing/index.js
  function useConstrainedTabbing() {
    return useRefEffect((node) => {
      let timeoutId;
      function onKeyDown(event) {
        const {
          keyCode,
          shiftKey,
          target
        } = event;
        if (keyCode !== TAB) {
          return;
        }
        const action = shiftKey ? "findPrevious" : "findNext";
        const nextElement = focus.tabbable[action](
          target
        ) || null;
        if (node.contains(nextElement)) {
          return;
        }
        const domAction = shiftKey ? "append" : "prepend";
        const {
          ownerDocument
        } = node;
        const trap = ownerDocument.createElement("div");
        trap.tabIndex = -1;
        node[domAction](trap);
        trap.focus();
        timeoutId = setTimeout(() => node.removeChild(trap));
      }
      node.addEventListener("keydown", onKeyDown);
      return () => {
        node.removeEventListener("keydown", onKeyDown);
        clearTimeout(timeoutId);
      };
    }, []);
  }
  var use_constrained_tabbing_default = useConstrainedTabbing;

  // node_modules/@wordpress/compose/build-module/hooks/use-copy-to-clipboard/index.js
  var import_clipboard = __toESM(require_clipboard());
  function useUpdatedRef(value) {
    const ref2 = (0, import_react.useRef)(value);
    ref2.current = value;
    return ref2;
  }
  function useCopyToClipboard(text3, onSuccess) {
    const textRef = useUpdatedRef(text3);
    const onSuccessRef = useUpdatedRef(onSuccess);
    return useRefEffect((node) => {
      const clipboard = new import_clipboard.default(node, {
        text() {
          return typeof textRef.current === "function" ? textRef.current() : textRef.current || "";
        }
      });
      clipboard.on("success", (_ref8) => {
        let {
          clearSelection
        } = _ref8;
        clearSelection();
        node.focus();
        if (onSuccessRef.current) {
          onSuccessRef.current();
        }
      });
      return () => {
        clipboard.destroy();
      };
    }, []);
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-focus-on-mount/index.js
  function useFocusOnMount() {
    let focusOnMount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "firstElement";
    const focusOnMountRef = (0, import_react.useRef)(focusOnMount);
    (0, import_react.useEffect)(() => {
      focusOnMountRef.current = focusOnMount;
    }, [focusOnMount]);
    return (0, import_react.useCallback)((node) => {
      var _node$ownerDocument$a, _node$ownerDocument;
      if (!node || focusOnMountRef.current === false) {
        return;
      }
      if (node.contains((_node$ownerDocument$a = (_node$ownerDocument = node.ownerDocument) === null || _node$ownerDocument === void 0 ? void 0 : _node$ownerDocument.activeElement) !== null && _node$ownerDocument$a !== void 0 ? _node$ownerDocument$a : null)) {
        return;
      }
      let target = node;
      if (focusOnMountRef.current === "firstElement") {
        const firstTabbable = focus.tabbable.find(node)[0];
        if (firstTabbable) {
          target = firstTabbable;
        }
      }
      target.focus({
        preventScroll: true
      });
    }, []);
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-focus-return/index.js
  function useFocusReturn(onFocusReturn) {
    const ref2 = (0, import_react.useRef)(null);
    const focusedBeforeMount = (0, import_react.useRef)(null);
    const onFocusReturnRef = (0, import_react.useRef)(onFocusReturn);
    (0, import_react.useEffect)(() => {
      onFocusReturnRef.current = onFocusReturn;
    }, [onFocusReturn]);
    return (0, import_react.useCallback)((node) => {
      if (node) {
        ref2.current = node;
        if (focusedBeforeMount.current) {
          return;
        }
        focusedBeforeMount.current = node.ownerDocument.activeElement;
      } else if (focusedBeforeMount.current) {
        var _ref$current, _ref$current2, _ref$current3;
        const isFocused = (_ref$current = ref2.current) === null || _ref$current === void 0 ? void 0 : _ref$current.contains((_ref$current2 = ref2.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.ownerDocument.activeElement);
        if ((_ref$current3 = ref2.current) !== null && _ref$current3 !== void 0 && _ref$current3.isConnected && !isFocused) {
          return;
        }
        if (onFocusReturnRef.current) {
          onFocusReturnRef.current();
        } else {
          var _focusedBeforeMount$c;
          (_focusedBeforeMount$c = focusedBeforeMount.current) === null || _focusedBeforeMount$c === void 0 ? void 0 : _focusedBeforeMount$c.focus();
        }
      }
    }, []);
  }
  var use_focus_return_default = useFocusReturn;

  // node_modules/@wordpress/compose/build-module/hooks/use-focus-outside/index.js
  var INPUT_BUTTON_TYPES = ["button", "submit"];
  function isFocusNormalizedButton(eventTarget) {
    if (!(eventTarget instanceof window.HTMLElement)) {
      return false;
    }
    switch (eventTarget.nodeName) {
      case "A":
      case "BUTTON":
        return true;
      case "INPUT":
        return INPUT_BUTTON_TYPES.includes(eventTarget.type);
    }
    return false;
  }
  function useFocusOutside(onFocusOutside) {
    const currentOnFocusOutside = (0, import_react.useRef)(onFocusOutside);
    (0, import_react.useEffect)(() => {
      currentOnFocusOutside.current = onFocusOutside;
    }, [onFocusOutside]);
    const preventBlurCheck = (0, import_react.useRef)(false);
    const blurCheckTimeoutId = (0, import_react.useRef)();
    const cancelBlurCheck = (0, import_react.useCallback)(() => {
      clearTimeout(blurCheckTimeoutId.current);
    }, []);
    (0, import_react.useEffect)(() => {
      return () => cancelBlurCheck();
    }, []);
    (0, import_react.useEffect)(() => {
      if (!onFocusOutside) {
        cancelBlurCheck();
      }
    }, [onFocusOutside, cancelBlurCheck]);
    const normalizeButtonFocus = (0, import_react.useCallback)((event) => {
      const {
        type,
        target
      } = event;
      const isInteractionEnd = ["mouseup", "touchend"].includes(type);
      if (isInteractionEnd) {
        preventBlurCheck.current = false;
      } else if (isFocusNormalizedButton(target)) {
        preventBlurCheck.current = true;
      }
    }, []);
    const queueBlurCheck = (0, import_react.useCallback)((event) => {
      event.persist();
      if (preventBlurCheck.current) {
        return;
      }
      blurCheckTimeoutId.current = setTimeout(() => {
        if (!document.hasFocus()) {
          event.preventDefault();
          return;
        }
        if ("function" === typeof currentOnFocusOutside.current) {
          currentOnFocusOutside.current(event);
        }
      }, 0);
    }, []);
    return {
      onFocus: cancelBlurCheck,
      onMouseDown: normalizeButtonFocus,
      onMouseUp: normalizeButtonFocus,
      onTouchStart: normalizeButtonFocus,
      onTouchEnd: normalizeButtonFocus,
      onBlur: queueBlurCheck
    };
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-merge-refs/index.js
  function assignRef(ref2, value) {
    if (typeof ref2 === "function") {
      ref2(value);
    } else if (ref2 && ref2.hasOwnProperty("current")) {
      ref2.current = value;
    }
  }
  function useMergeRefs(refs) {
    const element = (0, import_react.useRef)();
    const isAttached = (0, import_react.useRef)(false);
    const didElementChange = (0, import_react.useRef)(false);
    const previousRefs = (0, import_react.useRef)([]);
    const currentRefs = (0, import_react.useRef)(refs);
    currentRefs.current = refs;
    (0, import_react.useLayoutEffect)(() => {
      if (didElementChange.current === false && isAttached.current === true) {
        refs.forEach((ref2, index2) => {
          const previousRef = previousRefs.current[index2];
          if (ref2 !== previousRef) {
            assignRef(previousRef, null);
            assignRef(ref2, element.current);
          }
        });
      }
      previousRefs.current = refs;
    }, refs);
    (0, import_react.useLayoutEffect)(() => {
      didElementChange.current = false;
    });
    return (0, import_react.useCallback)((value) => {
      assignRef(element, value);
      didElementChange.current = true;
      isAttached.current = value !== null;
      const refsToAssign = value ? currentRefs.current : previousRefs.current;
      for (const ref2 of refsToAssign) {
        assignRef(ref2, value);
      }
    }, []);
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-dialog/index.js
  function useDialog(options) {
    const currentOptions = (0, import_react.useRef)();
    (0, import_react.useEffect)(() => {
      currentOptions.current = options;
    }, Object.values(options));
    const constrainedTabbingRef = use_constrained_tabbing_default();
    const focusOnMountRef = useFocusOnMount(options.focusOnMount);
    const focusReturnRef = use_focus_return_default();
    const focusOutsideProps = useFocusOutside((event) => {
      var _currentOptions$curre, _currentOptions$curre2;
      if ((_currentOptions$curre = currentOptions.current) !== null && _currentOptions$curre !== void 0 && _currentOptions$curre.__unstableOnClose) {
        currentOptions.current.__unstableOnClose("focus-outside", event);
      } else if ((_currentOptions$curre2 = currentOptions.current) !== null && _currentOptions$curre2 !== void 0 && _currentOptions$curre2.onClose) {
        currentOptions.current.onClose();
      }
    });
    const closeOnEscapeRef = (0, import_react.useCallback)((node) => {
      if (!node) {
        return;
      }
      node.addEventListener("keydown", (event) => {
        var _currentOptions$curre3;
        if (event.keyCode === ESCAPE && !event.defaultPrevented && (_currentOptions$curre3 = currentOptions.current) !== null && _currentOptions$curre3 !== void 0 && _currentOptions$curre3.onClose) {
          event.preventDefault();
          currentOptions.current.onClose();
        }
      });
    }, []);
    return [useMergeRefs([options.focusOnMount !== false ? constrainedTabbingRef : null, options.focusOnMount !== false ? focusReturnRef : null, options.focusOnMount !== false ? focusOnMountRef : null, closeOnEscapeRef]), {
      ...focusOutsideProps,
      tabIndex: -1
    }];
  }
  var use_dialog_default = useDialog;

  // node_modules/@wordpress/compose/build-module/hooks/use-disabled/index.js
  function useDisabled() {
    let {
      isDisabled: isDisabledProp = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return useRefEffect((node) => {
      if (isDisabledProp) {
        return;
      }
      const updates = [];
      const disable = () => {
        node.childNodes.forEach((child) => {
          if (!(child instanceof HTMLElement)) {
            return;
          }
          if (!child.getAttribute("inert")) {
            child.setAttribute("inert", "true");
            updates.push(() => {
              child.removeAttribute("inert");
            });
          }
        });
      };
      const debouncedDisable = debounce(disable, 0, {
        leading: true
      });
      disable();
      const observer = new window.MutationObserver(debouncedDisable);
      observer.observe(node, {
        childList: true
      });
      return () => {
        if (observer) {
          observer.disconnect();
        }
        debouncedDisable.cancel();
        updates.forEach((update3) => update3());
      };
    }, [isDisabledProp]);
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-isomorphic-layout-effect/index.js
  var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
  var use_isomorphic_layout_effect_default = useIsomorphicLayoutEffect;

  // node_modules/@wordpress/compose/build-module/hooks/use-media-query/index.js
  function useMediaQuery(query2) {
    const [match, setMatch] = (0, import_react.useState)(() => !!(query2 && typeof window !== "undefined" && window.matchMedia(query2).matches));
    (0, import_react.useEffect)(() => {
      if (!query2) {
        return;
      }
      const updateMatch = () => setMatch(window.matchMedia(query2).matches);
      updateMatch();
      const list = window.matchMedia(query2);
      list.addListener(updateMatch);
      return () => {
        list.removeListener(updateMatch);
      };
    }, [query2]);
    return !!query2 && match;
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-previous/index.js
  function usePrevious(value) {
    const ref2 = (0, import_react.useRef)();
    (0, import_react.useEffect)(() => {
      ref2.current = value;
    }, [value]);
    return ref2.current;
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-reduced-motion/index.js
  var useReducedMotion = () => useMediaQuery("(prefers-reduced-motion: reduce)");
  var use_reduced_motion_default = useReducedMotion;

  // node_modules/@wordpress/compose/build-module/hooks/use-viewport-match/index.js
  var BREAKPOINTS = {
    huge: 1440,
    wide: 1280,
    large: 960,
    medium: 782,
    small: 600,
    mobile: 480
  };
  var CONDITIONS = {
    ">=": "min-width",
    "<": "max-width"
  };
  var OPERATOR_EVALUATORS = {
    ">=": (breakpointValue, width3) => width3 >= breakpointValue,
    "<": (breakpointValue, width3) => width3 < breakpointValue
  };
  var ViewportMatchWidthContext = (0, import_react.createContext)(
    null
  );
  var useViewportMatch = function(breakpoint) {
    let operator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ">=";
    const simulatedWidth = (0, import_react.useContext)(ViewportMatchWidthContext);
    const mediaQuery = !simulatedWidth && `(${CONDITIONS[operator]}: ${BREAKPOINTS[breakpoint]}px)`;
    const mediaQueryResult = useMediaQuery(mediaQuery || void 0);
    if (simulatedWidth) {
      return OPERATOR_EVALUATORS[operator](BREAKPOINTS[breakpoint], simulatedWidth);
    }
    return mediaQueryResult;
  };
  useViewportMatch.__experimentalWidthProvider = ViewportMatchWidthContext.Provider;
  var use_viewport_match_default = useViewportMatch;

  // node_modules/@wordpress/compose/build-module/hooks/use-resize-observer/index.js
  function useResolvedElement(subscriber, refOrElement) {
    const callbackRefElement = (0, import_react.useRef)(null);
    const lastReportRef = (0, import_react.useRef)(null);
    const cleanupRef = (0, import_react.useRef)();
    const callSubscriber = (0, import_react.useCallback)(() => {
      let element = null;
      if (callbackRefElement.current) {
        element = callbackRefElement.current;
      } else if (refOrElement) {
        if (refOrElement instanceof HTMLElement) {
          element = refOrElement;
        } else {
          element = refOrElement.current;
        }
      }
      if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.reporter === callSubscriber) {
        return;
      }
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = null;
      }
      lastReportRef.current = {
        reporter: callSubscriber,
        element
      };
      if (element) {
        cleanupRef.current = subscriber(element);
      }
    }, [refOrElement, subscriber]);
    (0, import_react.useEffect)(() => {
      callSubscriber();
    }, [callSubscriber]);
    return (0, import_react.useCallback)((element) => {
      callbackRefElement.current = element;
      callSubscriber();
    }, [callSubscriber]);
  }
  var extractSize = (entry, boxProp, sizeType) => {
    if (!entry[boxProp]) {
      if (boxProp === "contentBoxSize") {
        return entry.contentRect[sizeType === "inlineSize" ? "width" : "height"];
      }
      return void 0;
    }
    return entry[boxProp][0] ? entry[boxProp][0][sizeType] : entry[boxProp][sizeType];
  };
  function useResizeObserver() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const onResize = opts.onResize;
    const onResizeRef = (0, import_react.useRef)(void 0);
    onResizeRef.current = onResize;
    const round = opts.round || Math.round;
    const resizeObserverRef = (0, import_react.useRef)();
    const [size, setSize] = (0, import_react.useState)({
      width: void 0,
      height: void 0
    });
    const didUnmount = (0, import_react.useRef)(false);
    (0, import_react.useEffect)(() => {
      return () => {
        didUnmount.current = true;
      };
    }, []);
    const previous = (0, import_react.useRef)({
      width: void 0,
      height: void 0
    });
    const refCallback = useResolvedElement((0, import_react.useCallback)((element) => {
      if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {
        resizeObserverRef.current = {
          box: opts.box,
          round,
          instance: new ResizeObserver((entries) => {
            const entry = entries[0];
            let boxProp = "borderBoxSize";
            if (opts.box === "border-box") {
              boxProp = "borderBoxSize";
            } else {
              boxProp = opts.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize";
            }
            const reportedWidth = extractSize(entry, boxProp, "inlineSize");
            const reportedHeight = extractSize(entry, boxProp, "blockSize");
            const newWidth = reportedWidth ? round(reportedWidth) : void 0;
            const newHeight = reportedHeight ? round(reportedHeight) : void 0;
            if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
              const newSize = {
                width: newWidth,
                height: newHeight
              };
              previous.current.width = newWidth;
              previous.current.height = newHeight;
              if (onResizeRef.current) {
                onResizeRef.current(newSize);
              } else if (!didUnmount.current) {
                setSize(newSize);
              }
            }
          })
        };
      }
      resizeObserverRef.current.instance.observe(element, {
        box: opts.box
      });
      return () => {
        if (resizeObserverRef.current) {
          resizeObserverRef.current.instance.unobserve(element);
        }
      };
    }, [opts.box, round]), opts.ref);
    return (0, import_react.useMemo)(() => ({
      ref: refCallback,
      width: size.width,
      height: size.height
    }), [refCallback, size ? size.width : null, size ? size.height : null]);
  }
  function useResizeAware() {
    const {
      ref: ref2,
      width: width3,
      height
    } = useResizeObserver();
    const sizes = (0, import_react.useMemo)(() => {
      return {
        width: width3 !== null && width3 !== void 0 ? width3 : null,
        height: height !== null && height !== void 0 ? height : null
      };
    }, [width3, height]);
    const resizeListener = (0, import_react.createElement)("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        pointerEvents: "none",
        opacity: 0,
        overflow: "hidden",
        zIndex: -1
      },
      "aria-hidden": "true",
      ref: ref2
    });
    return [resizeListener, sizes];
  }

  // node_modules/@wordpress/priority-queue/build-module/request-idle-callback.js
  var import_requestidlecallback = __toESM(require_requestidlecallback());
  function createRequestIdleCallback() {
    if (typeof window === "undefined") {
      return (callback) => {
        setTimeout(() => callback(Date.now()), 0);
      };
    }
    return window.requestIdleCallback;
  }
  var request_idle_callback_default = createRequestIdleCallback();

  // node_modules/@wordpress/priority-queue/build-module/index.js
  var createQueue = () => {
    let waitingList = [];
    let elementsMap = /* @__PURE__ */ new WeakMap();
    let isRunning = false;
    const runWaitingList = (deadline) => {
      const hasTimeRemaining = typeof deadline === "number" ? () => false : () => deadline.timeRemaining() > 0;
      do {
        if (waitingList.length === 0) {
          isRunning = false;
          return;
        }
        const nextElement = waitingList.shift();
        const callback = elementsMap.get(nextElement);
        callback();
        elementsMap.delete(nextElement);
      } while (hasTimeRemaining());
      request_idle_callback_default(runWaitingList);
    };
    const add2 = (element, item2) => {
      if (!elementsMap.has(element)) {
        waitingList.push(element);
      }
      elementsMap.set(element, item2);
      if (!isRunning) {
        isRunning = true;
        request_idle_callback_default(runWaitingList);
      }
    };
    const flush2 = (element) => {
      if (!elementsMap.has(element)) {
        return false;
      }
      const index2 = waitingList.indexOf(element);
      waitingList.splice(index2, 1);
      const callback = elementsMap.get(element);
      elementsMap.delete(element);
      callback();
      return true;
    };
    const cancel = (element) => {
      if (!elementsMap.has(element)) {
        return false;
      }
      const index2 = waitingList.indexOf(element);
      waitingList.splice(index2, 1);
      elementsMap.delete(element);
      return true;
    };
    const reset2 = () => {
      waitingList = [];
      elementsMap = /* @__PURE__ */ new WeakMap();
      isRunning = false;
    };
    return {
      add: add2,
      flush: flush2,
      cancel,
      reset: reset2
    };
  };

  // node_modules/@wordpress/compose/build-module/hooks/use-async-list/index.js
  function getFirstItemsPresentInState(list, state) {
    const firstItems = [];
    for (let i5 = 0; i5 < list.length; i5++) {
      const item2 = list[i5];
      if (!state.includes(item2)) {
        break;
      }
      firstItems.push(item2);
    }
    return firstItems;
  }
  function useAsyncList(list) {
    let config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      step: 1
    };
    const {
      step = 1
    } = config2;
    const [current, setCurrent] = (0, import_react.useState)([]);
    (0, import_react.useEffect)(() => {
      let firstItems = getFirstItemsPresentInState(list, current);
      if (firstItems.length < step) {
        firstItems = firstItems.concat(list.slice(firstItems.length, step));
      }
      setCurrent(firstItems);
      let nextIndex = firstItems.length;
      const asyncQueue = createQueue();
      const append2 = () => {
        if (list.length <= nextIndex) {
          return;
        }
        setCurrent((state) => [...state, ...list.slice(nextIndex, nextIndex + step)]);
        nextIndex += step;
        asyncQueue.add({}, append2);
      };
      asyncQueue.add({}, append2);
      return () => asyncQueue.reset();
    }, [list]);
    return current;
  }
  var use_async_list_default = useAsyncList;

  // node_modules/use-memo-one/dist/use-memo-one.esm.js
  var import_react5 = __toESM(require_react());
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i5 = 0; i5 < newInputs.length; i5++) {
      if (newInputs[i5] !== lastInputs[i5]) {
        return false;
      }
    }
    return true;
  }
  function useMemoOne(getResult, inputs) {
    var initial = (0, import_react5.useState)(function() {
      return {
        inputs,
        result: getResult()
      };
    })[0];
    var isFirstRun = (0, import_react5.useRef)(true);
    var committed = (0, import_react5.useRef)(initial);
    var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
    var cache2 = useCache ? committed.current : {
      inputs,
      result: getResult()
    };
    (0, import_react5.useEffect)(function() {
      isFirstRun.current = false;
      committed.current = cache2;
    }, [cache2]);
    return cache2.result;
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-debounce/index.js
  function useDebounce(fn, wait, options) {
    const debounced = useMemoOne(() => debounce(fn, wait !== null && wait !== void 0 ? wait : 0, options), [fn, wait, options]);
    (0, import_react.useEffect)(() => () => debounced.cancel(), [debounced]);
    return debounced;
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-throttle/index.js
  function useThrottle(fn, wait, options) {
    const throttled = useMemoOne(() => throttle(fn, wait !== null && wait !== void 0 ? wait : 0, options), [fn, wait, options]);
    (0, import_react.useEffect)(() => () => throttled.cancel(), [throttled]);
    return throttled;
  }

  // node_modules/@wordpress/compose/build-module/hooks/use-drop-zone/index.js
  function useFreshRef(value) {
    const ref2 = (0, import_react.useRef)();
    ref2.current = value;
    return ref2;
  }
  function useDropZone(_ref8) {
    let {
      isDisabled,
      onDrop: _onDrop,
      onDragStart: _onDragStart,
      onDragEnter: _onDragEnter,
      onDragLeave: _onDragLeave,
      onDragEnd: _onDragEnd,
      onDragOver: _onDragOver
    } = _ref8;
    const onDropRef = useFreshRef(_onDrop);
    const onDragStartRef = useFreshRef(_onDragStart);
    const onDragEnterRef = useFreshRef(_onDragEnter);
    const onDragLeaveRef = useFreshRef(_onDragLeave);
    const onDragEndRef = useFreshRef(_onDragEnd);
    const onDragOverRef = useFreshRef(_onDragOver);
    return useRefEffect((element) => {
      if (isDisabled) {
        return;
      }
      let isDragging = false;
      const {
        ownerDocument
      } = element;
      function isElementInZone(targetToCheck) {
        const {
          defaultView
        } = ownerDocument;
        if (!targetToCheck || !defaultView || !(targetToCheck instanceof defaultView.HTMLElement) || !element.contains(targetToCheck)) {
          return false;
        }
        let elementToCheck = targetToCheck;
        do {
          if (elementToCheck.dataset.isDropZone) {
            return elementToCheck === element;
          }
        } while (elementToCheck = elementToCheck.parentElement);
        return false;
      }
      function maybeDragStart(event) {
        if (isDragging) {
          return;
        }
        isDragging = true;
        ownerDocument.addEventListener("dragend", maybeDragEnd);
        ownerDocument.addEventListener("mousemove", maybeDragEnd);
        if (onDragStartRef.current) {
          onDragStartRef.current(event);
        }
      }
      function onDragEnter(event) {
        event.preventDefault();
        if (element.contains(
          event.relatedTarget
        )) {
          return;
        }
        if (onDragEnterRef.current) {
          onDragEnterRef.current(event);
        }
      }
      function onDragOver(event) {
        if (!event.defaultPrevented && onDragOverRef.current) {
          onDragOverRef.current(event);
        }
        event.preventDefault();
      }
      function onDragLeave(event) {
        if (isElementInZone(event.relatedTarget)) {
          return;
        }
        if (onDragLeaveRef.current) {
          onDragLeaveRef.current(event);
        }
      }
      function onDrop(event) {
        if (event.defaultPrevented) {
          return;
        }
        event.preventDefault();
        event.dataTransfer && event.dataTransfer.files.length;
        if (onDropRef.current) {
          onDropRef.current(event);
        }
        maybeDragEnd(event);
      }
      function maybeDragEnd(event) {
        if (!isDragging) {
          return;
        }
        isDragging = false;
        ownerDocument.removeEventListener("dragend", maybeDragEnd);
        ownerDocument.removeEventListener("mousemove", maybeDragEnd);
        if (onDragEndRef.current) {
          onDragEndRef.current(event);
        }
      }
      element.dataset.isDropZone = "true";
      element.addEventListener("drop", onDrop);
      element.addEventListener("dragenter", onDragEnter);
      element.addEventListener("dragover", onDragOver);
      element.addEventListener("dragleave", onDragLeave);
      ownerDocument.addEventListener("dragenter", maybeDragStart);
      return () => {
        delete element.dataset.isDropZone;
        element.removeEventListener("drop", onDrop);
        element.removeEventListener("dragenter", onDragEnter);
        element.removeEventListener("dragover", onDragOver);
        element.removeEventListener("dragleave", onDragLeave);
        ownerDocument.removeEventListener("dragend", maybeDragEnd);
        ownerDocument.removeEventListener("mousemove", maybeDragEnd);
        ownerDocument.removeEventListener("dragenter", maybeDragStart);
      };
    }, [isDisabled]);
  }

  // node_modules/@wordpress/data/build-module/factory.js
  function createRegistryControl(registryControl) {
    registryControl.isRegistryControl = true;
    return registryControl;
  }

  // node_modules/@wordpress/data/build-module/controls.js
  var SELECT = "@@data/SELECT";
  var RESOLVE_SELECT = "@@data/RESOLVE_SELECT";
  var DISPATCH = "@@data/DISPATCH";
  var builtinControls = {
    [SELECT]: createRegistryControl((registry) => (_ref8) => {
      let {
        storeKey,
        selectorName,
        args
      } = _ref8;
      return registry.select(storeKey)[selectorName](...args);
    }),
    [RESOLVE_SELECT]: createRegistryControl((registry) => (_ref22) => {
      let {
        storeKey,
        selectorName,
        args
      } = _ref22;
      const method = registry.select(storeKey)[selectorName].hasResolver ? "resolveSelect" : "select";
      return registry[method](storeKey)[selectorName](...args);
    }),
    [DISPATCH]: createRegistryControl((registry) => (_ref32) => {
      let {
        storeKey,
        actionName,
        args
      } = _ref32;
      return registry.dispatch(storeKey)[actionName](...args);
    })
  };

  // node_modules/@wordpress/data/build-module/promise-middleware.js
  var promiseMiddleware = () => (next2) => (action) => {
    if (isPromise(action)) {
      return action.then((resolvedAction) => {
        if (resolvedAction) {
          return next2(resolvedAction);
        }
      });
    }
    return next2(action);
  };
  var promise_middleware_default = promiseMiddleware;

  // node_modules/@wordpress/data/build-module/resolvers-cache-middleware.js
  var import_lodash2 = __toESM(require_lodash());

  // node_modules/@wordpress/data/build-module/store/index.js
  var coreDataStore = {
    name: "core/data",
    instantiate(registry) {
      const getCoreDataSelector = (selectorName) => function(key) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return registry.select(key)[selectorName](...args);
      };
      const getCoreDataAction = (actionName) => function(key) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return registry.dispatch(key)[actionName](...args);
      };
      return {
        getSelectors() {
          return Object.fromEntries(["getIsResolving", "hasStartedResolution", "hasFinishedResolution", "isResolving", "getCachedResolvers"].map((selectorName) => [selectorName, getCoreDataSelector(selectorName)]));
        },
        getActions() {
          return Object.fromEntries(["startResolution", "finishResolution", "invalidateResolution", "invalidateResolutionForStore", "invalidateResolutionForStoreSelector"].map((actionName) => [actionName, getCoreDataAction(actionName)]));
        },
        subscribe() {
          return () => () => {
          };
        }
      };
    }
  };
  var store_default = coreDataStore;

  // node_modules/@wordpress/data/build-module/resolvers-cache-middleware.js
  var createResolversCacheMiddleware = (registry, reducerKey) => () => (next2) => (action) => {
    const resolvers = registry.select(store_default).getCachedResolvers(reducerKey);
    Object.entries(resolvers).forEach((_ref8) => {
      let [selectorName, resolversByArgs] = _ref8;
      const resolver = (0, import_lodash2.get)(registry.stores, [reducerKey, "resolvers", selectorName]);
      if (!resolver || !resolver.shouldInvalidate) {
        return;
      }
      resolversByArgs.forEach((value, args) => {
        if ((value === null || value === void 0 ? void 0 : value.status) !== "finished" && (value === null || value === void 0 ? void 0 : value.status) !== "error" || !resolver.shouldInvalidate(action, ...args)) {
          return;
        }
        registry.dispatch(store_default).invalidateResolution(reducerKey, selectorName, args);
      });
    });
    return next2(action);
  };
  var resolvers_cache_middleware_default = createResolversCacheMiddleware;

  // node_modules/@wordpress/data/build-module/redux-store/thunk-middleware.js
  function createThunkMiddleware(args) {
    return () => (next2) => (action) => {
      if (typeof action === "function") {
        return action(args);
      }
      return next2(action);
    };
  }

  // node_modules/@wordpress/data/build-module/redux-store/metadata/reducer.js
  var import_equivalent_key_map = __toESM(require_equivalent_key_map());

  // node_modules/@wordpress/data/build-module/redux-store/metadata/utils.js
  var onSubKey = (actionProperty) => (reducer3) => function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    const key = action[actionProperty];
    if (key === void 0) {
      return state;
    }
    const nextKeyState = reducer3(state[key], action);
    if (nextKeyState === state[key]) {
      return state;
    }
    return {
      ...state,
      [key]: nextKeyState
    };
  };
  function selectorArgsToStateKey(args) {
    if (args === void 0 || args === null) {
      return [];
    }
    const len = args.length;
    let idx = len;
    while (idx > 0 && args[idx - 1] === void 0) {
      idx--;
    }
    return idx === len ? args : args.slice(0, idx);
  }

  // node_modules/@wordpress/data/build-module/redux-store/metadata/reducer.js
  var subKeysIsResolved = onSubKey("selectorName")(function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new import_equivalent_key_map.default();
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "START_RESOLUTION": {
        const nextState = new import_equivalent_key_map.default(state);
        nextState.set(selectorArgsToStateKey(action.args), {
          status: "resolving"
        });
        return nextState;
      }
      case "FINISH_RESOLUTION": {
        const nextState = new import_equivalent_key_map.default(state);
        nextState.set(selectorArgsToStateKey(action.args), {
          status: "finished"
        });
        return nextState;
      }
      case "FAIL_RESOLUTION": {
        const nextState = new import_equivalent_key_map.default(state);
        nextState.set(selectorArgsToStateKey(action.args), {
          status: "error",
          error: action.error
        });
        return nextState;
      }
      case "START_RESOLUTIONS": {
        const nextState = new import_equivalent_key_map.default(state);
        for (const resolutionArgs of action.args) {
          nextState.set(selectorArgsToStateKey(resolutionArgs), {
            status: "resolving"
          });
        }
        return nextState;
      }
      case "FINISH_RESOLUTIONS": {
        const nextState = new import_equivalent_key_map.default(state);
        for (const resolutionArgs of action.args) {
          nextState.set(selectorArgsToStateKey(resolutionArgs), {
            status: "finished"
          });
        }
        return nextState;
      }
      case "FAIL_RESOLUTIONS": {
        const nextState = new import_equivalent_key_map.default(state);
        action.args.forEach((resolutionArgs, idx) => {
          const resolutionState = {
            status: "error",
            error: void 0
          };
          const error2 = action.errors[idx];
          if (error2) {
            resolutionState.error = error2;
          }
          nextState.set(selectorArgsToStateKey(resolutionArgs), resolutionState);
        });
        return nextState;
      }
      case "INVALIDATE_RESOLUTION": {
        const nextState = new import_equivalent_key_map.default(state);
        nextState.delete(selectorArgsToStateKey(action.args));
        return nextState;
      }
    }
    return state;
  });
  var isResolved = function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "INVALIDATE_RESOLUTION_FOR_STORE":
        return {};
      case "INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR": {
        if (action.selectorName in state) {
          const {
            [action.selectorName]: removedSelector,
            ...restState
          } = state;
          return restState;
        }
        return state;
      }
      case "START_RESOLUTION":
      case "FINISH_RESOLUTION":
      case "FAIL_RESOLUTION":
      case "START_RESOLUTIONS":
      case "FINISH_RESOLUTIONS":
      case "FAIL_RESOLUTIONS":
      case "INVALIDATE_RESOLUTION":
        return subKeysIsResolved(state, action);
    }
    return state;
  };
  var reducer_default = isResolved;

  // node_modules/@wordpress/data/build-module/redux-store/metadata/selectors.js
  var selectors_exports = {};
  __export(selectors_exports, {
    getCachedResolvers: () => getCachedResolvers,
    getIsResolving: () => getIsResolving,
    getResolutionError: () => getResolutionError,
    getResolutionState: () => getResolutionState,
    hasFinishedResolution: () => hasFinishedResolution,
    hasResolutionFailed: () => hasResolutionFailed,
    hasStartedResolution: () => hasStartedResolution,
    isResolving: () => isResolving
  });
  var import_lodash3 = __toESM(require_lodash());
  function getResolutionState(state, selectorName, args) {
    const map9 = (0, import_lodash3.get)(state, [selectorName]);
    if (!map9) {
      return;
    }
    return map9.get(selectorArgsToStateKey(args));
  }
  function getIsResolving(state, selectorName, args) {
    const resolutionState = getResolutionState(state, selectorName, args);
    return resolutionState && resolutionState.status === "resolving";
  }
  function hasStartedResolution(state, selectorName, args) {
    return getResolutionState(state, selectorName, args) !== void 0;
  }
  function hasFinishedResolution(state, selectorName, args) {
    var _getResolutionState;
    const status = (_getResolutionState = getResolutionState(state, selectorName, args)) === null || _getResolutionState === void 0 ? void 0 : _getResolutionState.status;
    return status === "finished" || status === "error";
  }
  function hasResolutionFailed(state, selectorName, args) {
    var _getResolutionState2;
    return ((_getResolutionState2 = getResolutionState(state, selectorName, args)) === null || _getResolutionState2 === void 0 ? void 0 : _getResolutionState2.status) === "error";
  }
  function getResolutionError(state, selectorName, args) {
    const resolutionState = getResolutionState(state, selectorName, args);
    return (resolutionState === null || resolutionState === void 0 ? void 0 : resolutionState.status) === "error" ? resolutionState.error : null;
  }
  function isResolving(state, selectorName, args) {
    var _getResolutionState3;
    return ((_getResolutionState3 = getResolutionState(state, selectorName, args)) === null || _getResolutionState3 === void 0 ? void 0 : _getResolutionState3.status) === "resolving";
  }
  function getCachedResolvers(state) {
    return state;
  }

  // node_modules/@wordpress/data/build-module/redux-store/metadata/actions.js
  var actions_exports = {};
  __export(actions_exports, {
    failResolution: () => failResolution,
    failResolutions: () => failResolutions,
    finishResolution: () => finishResolution,
    finishResolutions: () => finishResolutions,
    invalidateResolution: () => invalidateResolution,
    invalidateResolutionForStore: () => invalidateResolutionForStore,
    invalidateResolutionForStoreSelector: () => invalidateResolutionForStoreSelector,
    startResolution: () => startResolution,
    startResolutions: () => startResolutions
  });
  function startResolution(selectorName, args) {
    return {
      type: "START_RESOLUTION",
      selectorName,
      args
    };
  }
  function finishResolution(selectorName, args) {
    return {
      type: "FINISH_RESOLUTION",
      selectorName,
      args
    };
  }
  function failResolution(selectorName, args, error2) {
    return {
      type: "FAIL_RESOLUTION",
      selectorName,
      args,
      error: error2
    };
  }
  function startResolutions(selectorName, args) {
    return {
      type: "START_RESOLUTIONS",
      selectorName,
      args
    };
  }
  function finishResolutions(selectorName, args) {
    return {
      type: "FINISH_RESOLUTIONS",
      selectorName,
      args
    };
  }
  function failResolutions(selectorName, args, errors) {
    return {
      type: "FAIL_RESOLUTIONS",
      selectorName,
      args,
      errors
    };
  }
  function invalidateResolution(selectorName, args) {
    return {
      type: "INVALIDATE_RESOLUTION",
      selectorName,
      args
    };
  }
  function invalidateResolutionForStore() {
    return {
      type: "INVALIDATE_RESOLUTION_FOR_STORE"
    };
  }
  function invalidateResolutionForStoreSelector(selectorName) {
    return {
      type: "INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR",
      selectorName
    };
  }

  // node_modules/@wordpress/data/build-module/redux-store/index.js
  var trimUndefinedValues = (array) => {
    const result = [...array];
    for (let i5 = result.length - 1; i5 >= 0; i5--) {
      if (result[i5] === void 0) {
        result.splice(i5, 1);
      }
    }
    return result;
  };
  function createResolversCache() {
    const cache2 = {};
    return {
      isRunning(selectorName, args) {
        return cache2[selectorName] && cache2[selectorName].get(trimUndefinedValues(args));
      },
      clear(selectorName, args) {
        if (cache2[selectorName]) {
          cache2[selectorName].delete(trimUndefinedValues(args));
        }
      },
      markAsRunning(selectorName, args) {
        if (!cache2[selectorName]) {
          cache2[selectorName] = new import_equivalent_key_map2.default();
        }
        cache2[selectorName].set(trimUndefinedValues(args), true);
      }
    };
  }
  function createReduxStore(key, options) {
    return {
      name: key,
      instantiate: (registry) => {
        const reducer3 = options.reducer;
        const thunkArgs = {
          registry,
          get dispatch() {
            return Object.assign((action) => store6.dispatch(action), getActions());
          },
          get select() {
            return Object.assign((selector4) => selector4(store6.__unstableOriginalGetState()), getSelectors());
          },
          get resolveSelect() {
            return getResolveSelectors();
          }
        };
        const store6 = instantiateReduxStore(key, options, registry, thunkArgs);
        const resolversCache = createResolversCache();
        let resolvers;
        const actions2 = mapActions({
          ...actions_exports,
          ...options.actions
        }, store6);
        let selectors = mapSelectors({
          ...(0, import_lodash4.mapValues)(selectors_exports, (selector4) => function(state) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return selector4(state.metadata, ...args);
          }),
          ...(0, import_lodash4.mapValues)(options.selectors, (selector4) => {
            if (selector4.isRegistrySelector) {
              selector4.registry = registry;
            }
            return function(state) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return selector4(state.root, ...args);
            };
          })
        }, store6);
        if (options.resolvers) {
          const result = mapResolvers(options.resolvers, selectors, store6, resolversCache);
          resolvers = result.resolvers;
          selectors = result.selectors;
        }
        const resolveSelectors = mapResolveSelectors(selectors, store6);
        const suspendSelectors = mapSuspendSelectors(selectors, store6);
        const getSelectors = () => selectors;
        const getActions = () => actions2;
        const getResolveSelectors = () => resolveSelectors;
        const getSuspendSelectors = () => suspendSelectors;
        store6.__unstableOriginalGetState = store6.getState;
        store6.getState = () => store6.__unstableOriginalGetState().root;
        const subscribe4 = store6 && ((listener2) => {
          let lastState = store6.__unstableOriginalGetState();
          return store6.subscribe(() => {
            const state = store6.__unstableOriginalGetState();
            const hasChanged = state !== lastState;
            lastState = state;
            if (hasChanged) {
              listener2();
            }
          });
        });
        return {
          reducer: reducer3,
          store: store6,
          actions: actions2,
          selectors,
          resolvers,
          getSelectors,
          getResolveSelectors,
          getSuspendSelectors,
          getActions,
          subscribe: subscribe4
        };
      }
    };
  }
  function instantiateReduxStore(key, options, registry, thunkArgs) {
    const controls = {
      ...options.controls,
      ...builtinControls
    };
    const normalizedControls = (0, import_lodash4.mapValues)(controls, (control) => control.isRegistryControl ? control(registry) : control);
    const middlewares = [resolvers_cache_middleware_default(registry, key), promise_middleware_default, createMiddleware(normalizedControls), createThunkMiddleware(thunkArgs)];
    const enhancers = [applyMiddleware(...middlewares)];
    if (typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__) {
      enhancers.push(window.__REDUX_DEVTOOLS_EXTENSION__({
        name: key,
        instanceId: key
      }));
    }
    const {
      reducer: reducer3,
      initialState
    } = options;
    const enhancedReducer = (0, import_turbo_combine_reducers.default)({
      metadata: reducer_default,
      root: reducer3
    });
    return createStore(enhancedReducer, {
      root: initialState
    }, compose_default(enhancers));
  }
  function mapSelectors(selectors, store6) {
    const createStateSelector = (registrySelector) => {
      const selector4 = function runSelector() {
        const argsLength = arguments.length;
        const args = new Array(argsLength + 1);
        args[0] = store6.__unstableOriginalGetState();
        for (let i5 = 0; i5 < argsLength; i5++) {
          args[i5 + 1] = arguments[i5];
        }
        return registrySelector(...args);
      };
      selector4.hasResolver = false;
      return selector4;
    };
    return (0, import_lodash4.mapValues)(selectors, createStateSelector);
  }
  function mapActions(actions2, store6) {
    const createBoundAction = (action) => function() {
      return Promise.resolve(store6.dispatch(action(...arguments)));
    };
    return (0, import_lodash4.mapValues)(actions2, createBoundAction);
  }
  function mapResolveSelectors(selectors, store6) {
    const {
      getIsResolving: getIsResolving2,
      hasStartedResolution: hasStartedResolution2,
      hasFinishedResolution: hasFinishedResolution2,
      hasResolutionFailed: hasResolutionFailed2,
      isResolving: isResolving2,
      getCachedResolvers: getCachedResolvers2,
      getResolutionState: getResolutionState2,
      getResolutionError: getResolutionError2,
      ...storeSelectors
    } = selectors;
    return (0, import_lodash4.mapValues)(storeSelectors, (selector4, selectorName) => {
      if (!selector4.hasResolver) {
        return async function() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return selector4.apply(null, args);
        };
      }
      return function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return new Promise((resolve, reject) => {
          const hasFinished = () => selectors.hasFinishedResolution(selectorName, args);
          const finalize = (result2) => {
            const hasFailed = selectors.hasResolutionFailed(selectorName, args);
            if (hasFailed) {
              const error2 = selectors.getResolutionError(selectorName, args);
              reject(error2);
            } else {
              resolve(result2);
            }
          };
          const getResult = () => selector4.apply(null, args);
          const result = getResult();
          if (hasFinished()) {
            return finalize(result);
          }
          const unsubscribe = store6.subscribe(() => {
            if (hasFinished()) {
              unsubscribe();
              finalize(getResult());
            }
          });
        });
      };
    });
  }
  function mapSuspendSelectors(selectors, store6) {
    return (0, import_lodash4.mapValues)(selectors, (selector4, selectorName) => {
      if (!selector4.hasResolver) {
        return selector4;
      }
      return function() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        const result = selector4.apply(null, args);
        if (selectors.hasFinishedResolution(selectorName, args)) {
          if (selectors.hasResolutionFailed(selectorName, args)) {
            throw selectors.getResolutionError(selectorName, args);
          }
          return result;
        }
        throw new Promise((resolve) => {
          const unsubscribe = store6.subscribe(() => {
            if (selectors.hasFinishedResolution(selectorName, args)) {
              resolve();
              unsubscribe();
            }
          });
        });
      };
    });
  }
  function mapResolvers(resolvers, selectors, store6, resolversCache) {
    const mappedResolvers = (0, import_lodash4.mapValues)(resolvers, (resolver) => {
      if (resolver.fulfill) {
        return resolver;
      }
      return {
        ...resolver,
        fulfill: resolver
      };
    });
    const mapSelector = (selector4, selectorName) => {
      const resolver = resolvers[selectorName];
      if (!resolver) {
        selector4.hasResolver = false;
        return selector4;
      }
      const selectorResolver = function() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        async function fulfillSelector() {
          const state = store6.getState();
          if (resolversCache.isRunning(selectorName, args) || typeof resolver.isFulfilled === "function" && resolver.isFulfilled(state, ...args)) {
            return;
          }
          const {
            metadata
          } = store6.__unstableOriginalGetState();
          if (hasStartedResolution(metadata, selectorName, args)) {
            return;
          }
          resolversCache.markAsRunning(selectorName, args);
          setTimeout(async () => {
            resolversCache.clear(selectorName, args);
            store6.dispatch(startResolution(selectorName, args));
            try {
              await fulfillResolver(store6, mappedResolvers, selectorName, ...args);
              store6.dispatch(finishResolution(selectorName, args));
            } catch (error2) {
              store6.dispatch(failResolution(selectorName, args, error2));
            }
          });
        }
        fulfillSelector(...args);
        return selector4(...args);
      };
      selectorResolver.hasResolver = true;
      return selectorResolver;
    };
    return {
      resolvers: mappedResolvers,
      selectors: (0, import_lodash4.mapValues)(selectors, mapSelector)
    };
  }
  async function fulfillResolver(store6, resolvers, selectorName) {
    const resolver = (0, import_lodash4.get)(resolvers, [selectorName]);
    if (!resolver) {
      return;
    }
    for (var _len7 = arguments.length, args = new Array(_len7 > 3 ? _len7 - 3 : 0), _key7 = 3; _key7 < _len7; _key7++) {
      args[_key7 - 3] = arguments[_key7];
    }
    const action = resolver.fulfill(...args);
    if (action) {
      await store6.dispatch(action);
    }
  }

  // node_modules/@wordpress/data/build-module/utils/emitter.js
  function createEmitter() {
    let isPaused2 = false;
    let isPending = false;
    const listeners = /* @__PURE__ */ new Set();
    const notifyListeners = () => Array.from(listeners).forEach((listener2) => listener2());
    return {
      get isPaused() {
        return isPaused2;
      },
      subscribe(listener2) {
        listeners.add(listener2);
        return () => listeners.delete(listener2);
      },
      pause() {
        isPaused2 = true;
      },
      resume() {
        isPaused2 = false;
        if (isPending) {
          isPending = false;
          notifyListeners();
        }
      },
      emit() {
        if (isPaused2) {
          isPending = true;
          return;
        }
        notifyListeners();
      }
    };
  }

  // node_modules/@wordpress/data/build-module/registry.js
  function isObject2(object) {
    return object !== null && typeof object === "object";
  }
  function createRegistry() {
    let storeConfigs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const stores = {};
    const emitter = createEmitter();
    const listeningStores = /* @__PURE__ */ new Set();
    function globalListener() {
      emitter.emit();
    }
    const subscribe4 = (listener2) => {
      return emitter.subscribe(listener2);
    };
    function select2(storeNameOrDescriptor) {
      const storeName = isObject2(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor;
      listeningStores.add(storeName);
      const store6 = stores[storeName];
      if (store6) {
        return store6.getSelectors();
      }
      return parent === null || parent === void 0 ? void 0 : parent.select(storeName);
    }
    function __unstableMarkListeningStores(callback, ref2) {
      listeningStores.clear();
      try {
        return callback.call(this);
      } finally {
        ref2.current = Array.from(listeningStores);
      }
    }
    function resolveSelect2(storeNameOrDescriptor) {
      const storeName = isObject2(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor;
      listeningStores.add(storeName);
      const store6 = stores[storeName];
      if (store6) {
        return store6.getResolveSelectors();
      }
      return parent && parent.resolveSelect(storeName);
    }
    function suspendSelect2(storeNameOrDescriptor) {
      const storeName = isObject2(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor;
      listeningStores.add(storeName);
      const store6 = stores[storeName];
      if (store6) {
        return store6.getSuspendSelectors();
      }
      return parent && parent.suspendSelect(storeName);
    }
    function dispatch2(storeNameOrDescriptor) {
      const storeName = isObject2(storeNameOrDescriptor) ? storeNameOrDescriptor.name : storeNameOrDescriptor;
      const store6 = stores[storeName];
      if (store6) {
        return store6.getActions();
      }
      return parent && parent.dispatch(storeName);
    }
    function withPlugins(attributes) {
      return (0, import_lodash5.mapValues)(attributes, (attribute, key) => {
        if (typeof attribute !== "function") {
          return attribute;
        }
        return function() {
          return registry[key].apply(null, arguments);
        };
      });
    }
    function registerStoreInstance(name, store6) {
      if (typeof store6.getSelectors !== "function") {
        throw new TypeError("store.getSelectors must be a function");
      }
      if (typeof store6.getActions !== "function") {
        throw new TypeError("store.getActions must be a function");
      }
      if (typeof store6.subscribe !== "function") {
        throw new TypeError("store.subscribe must be a function");
      }
      store6.emitter = createEmitter();
      const currentSubscribe = store6.subscribe;
      store6.subscribe = (listener2) => {
        const unsubscribeFromEmitter = store6.emitter.subscribe(listener2);
        const unsubscribeFromStore = currentSubscribe(() => {
          if (store6.emitter.isPaused) {
            store6.emitter.emit();
            return;
          }
          listener2();
        });
        return () => {
          unsubscribeFromStore === null || unsubscribeFromStore === void 0 ? void 0 : unsubscribeFromStore();
          unsubscribeFromEmitter === null || unsubscribeFromEmitter === void 0 ? void 0 : unsubscribeFromEmitter();
        };
      };
      stores[name] = store6;
      store6.subscribe(globalListener);
    }
    function register2(store6) {
      registerStoreInstance(store6.name, store6.instantiate(registry));
    }
    function registerGenericStore2(name, store6) {
      deprecated("wp.data.registerGenericStore", {
        since: "5.9",
        alternative: "wp.data.register( storeDescriptor )"
      });
      registerStoreInstance(name, store6);
    }
    function registerStore2(storeName, options) {
      if (!options.reducer) {
        throw new TypeError("Must specify store reducer");
      }
      const store6 = createReduxStore(storeName, options).instantiate(registry);
      registerStoreInstance(storeName, store6);
      return store6.store;
    }
    function __unstableSubscribeStore(storeName, handler) {
      if (storeName in stores) {
        return stores[storeName].subscribe(handler);
      }
      if (!parent) {
        return subscribe4(handler);
      }
      return parent.__unstableSubscribeStore(storeName, handler);
    }
    function batch(callback) {
      emitter.pause();
      Object.values(stores).forEach((store6) => store6.emitter.pause());
      callback();
      emitter.resume();
      Object.values(stores).forEach((store6) => store6.emitter.resume());
    }
    let registry = {
      batch,
      stores,
      namespaces: stores,
      subscribe: subscribe4,
      select: select2,
      resolveSelect: resolveSelect2,
      suspendSelect: suspendSelect2,
      dispatch: dispatch2,
      use: use3,
      register: register2,
      registerGenericStore: registerGenericStore2,
      registerStore: registerStore2,
      __unstableMarkListeningStores,
      __unstableSubscribeStore
    };
    function use3(plugin, options) {
      if (!plugin) {
        return;
      }
      registry = {
        ...registry,
        ...plugin(registry, options)
      };
      return registry;
    }
    registry.register(store_default);
    for (const [name, config2] of Object.entries(storeConfigs)) {
      registry.register(createReduxStore(name, config2));
    }
    if (parent) {
      parent.subscribe(globalListener);
    }
    return withPlugins(registry);
  }

  // node_modules/@wordpress/data/build-module/default-registry.js
  var default_registry_default = createRegistry();

  // node_modules/@wordpress/data/build-module/components/registry-provider/context.js
  var Context = (0, import_react.createContext)(default_registry_default);
  var {
    Consumer: Consumer2,
    Provider: Provider2
  } = Context;
  var RegistryConsumer = Consumer2;
  var context_default = Provider2;

  // node_modules/@wordpress/data/build-module/components/registry-provider/use-registry.js
  function useRegistry() {
    return (0, import_react.useContext)(Context);
  }

  // node_modules/@wordpress/data/build-module/components/async-mode-provider/context.js
  var Context2 = (0, import_react.createContext)(false);
  var {
    Consumer: Consumer3,
    Provider: Provider3
  } = Context2;
  var context_default2 = Provider3;

  // node_modules/@wordpress/data/build-module/components/async-mode-provider/use-async-mode.js
  function useAsyncMode() {
    return (0, import_react.useContext)(Context2);
  }

  // node_modules/@wordpress/data/build-module/components/use-select/index.js
  var noop2 = () => {
  };
  var renderQueue = createQueue();
  function useSelect(mapSelect, deps) {
    const hasMappingFunction = "function" === typeof mapSelect;
    if (!hasMappingFunction) {
      deps = [];
    }
    const callbackMapper = (0, import_react.useCallback)(hasMappingFunction ? mapSelect : noop2, deps);
    const _mapSelect = hasMappingFunction ? callbackMapper : null;
    const registry = useRegistry();
    const isAsync = useAsyncMode();
    const latestRegistry = (0, import_react.useRef)(registry);
    const latestMapSelect = (0, import_react.useRef)();
    const latestIsAsync = (0, import_react.useRef)(isAsync);
    const latestMapOutput = (0, import_react.useRef)();
    const latestMapOutputError = (0, import_react.useRef)();
    const listeningStores = (0, import_react.useRef)([]);
    const wrapSelect = (0, import_react.useCallback)((callback) => registry.__unstableMarkListeningStores(() => callback(registry.select, registry), listeningStores), [registry]);
    const depsChangedFlag = (0, import_react.useMemo)(() => ({}), deps || []);
    let mapOutput;
    let selectorRan = false;
    if (_mapSelect) {
      mapOutput = latestMapOutput.current;
      const hasReplacedRegistry = latestRegistry.current !== registry;
      const hasReplacedMapSelect = latestMapSelect.current !== _mapSelect;
      const hasLeftAsyncMode = latestIsAsync.current && !isAsync;
      const lastMapSelectFailed = !!latestMapOutputError.current;
      if (hasReplacedRegistry || hasReplacedMapSelect || hasLeftAsyncMode || lastMapSelectFailed) {
        try {
          mapOutput = wrapSelect(_mapSelect);
          selectorRan = true;
        } catch (error2) {
          let errorMessage = `An error occurred while running 'mapSelect': ${error2.message}`;
          if (latestMapOutputError.current) {
            errorMessage += `
The error may be correlated with this previous error:
`;
            errorMessage += `${latestMapOutputError.current.stack}

`;
            errorMessage += "Original stack trace:";
          }
          console.error(errorMessage);
        }
      }
    }
    use_isomorphic_layout_effect_default(() => {
      if (!hasMappingFunction) {
        return;
      }
      latestRegistry.current = registry;
      latestMapSelect.current = _mapSelect;
      latestIsAsync.current = isAsync;
      if (selectorRan) {
        latestMapOutput.current = mapOutput;
      }
      latestMapOutputError.current = void 0;
    });
    const queueContext = useMemoOne(() => ({
      queue: true
    }), [registry]);
    const [, forceRender] = (0, import_react.useReducer)((s5) => s5 + 1, 0);
    const isMounted = (0, import_react.useRef)(false);
    use_isomorphic_layout_effect_default(() => {
      if (!hasMappingFunction) {
        return;
      }
      const onStoreChange = () => {
        try {
          const newMapOutput = wrapSelect(latestMapSelect.current);
          if (isShallowEqual(latestMapOutput.current, newMapOutput)) {
            return;
          }
          latestMapOutput.current = newMapOutput;
        } catch (error2) {
          latestMapOutputError.current = error2;
        }
        forceRender();
      };
      const onChange = () => {
        if (!isMounted.current) {
          return;
        }
        if (latestIsAsync.current) {
          renderQueue.add(queueContext, onStoreChange);
        } else {
          onStoreChange();
        }
      };
      onStoreChange();
      const unsubscribers = listeningStores.current.map((storeName) => registry.__unstableSubscribeStore(storeName, onChange));
      isMounted.current = true;
      return () => {
        unsubscribers.forEach((unsubscribe) => unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe());
        renderQueue.cancel(queueContext);
        isMounted.current = false;
      };
    }, [registry, wrapSelect, hasMappingFunction, depsChangedFlag]);
    (0, import_react.useDebugValue)(mapOutput);
    return hasMappingFunction ? mapOutput : registry.select(mapSelect);
  }

  // node_modules/@wordpress/data/build-module/components/with-select/index.js
  var withSelect = (mapSelectToProps) => createHigherOrderComponent((WrappedComponent) => pure_default((ownProps) => {
    const mapSelect = (select2, registry) => mapSelectToProps(select2, ownProps, registry);
    const mergeProps2 = useSelect(mapSelect);
    return (0, import_react.createElement)(WrappedComponent, _extends({}, ownProps, mergeProps2));
  }), "withSelect");
  var with_select_default = withSelect;

  // node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch.js
  var useDispatch = (storeNameOrDescriptor) => {
    const {
      dispatch: dispatch2
    } = useRegistry();
    return storeNameOrDescriptor === void 0 ? dispatch2 : dispatch2(storeNameOrDescriptor);
  };
  var use_dispatch_default = useDispatch;

  // node_modules/@wordpress/data/build-module/components/use-dispatch/use-dispatch-with-map.js
  var import_lodash6 = __toESM(require_lodash());
  var useDispatchWithMap = (dispatchMap, deps) => {
    const registry = useRegistry();
    const currentDispatchMap = (0, import_react.useRef)(dispatchMap);
    use_isomorphic_layout_effect_default(() => {
      currentDispatchMap.current = dispatchMap;
    });
    return (0, import_react.useMemo)(() => {
      const currentDispatchProps = currentDispatchMap.current(registry.dispatch, registry);
      return (0, import_lodash6.mapValues)(currentDispatchProps, (dispatcher, propName) => {
        if (typeof dispatcher !== "function") {
          console.warn(`Property ${propName} returned from dispatchMap in useDispatchWithMap must be a function.`);
        }
        return function() {
          return currentDispatchMap.current(registry.dispatch, registry)[propName](...arguments);
        };
      });
    }, [registry, ...deps]);
  };
  var use_dispatch_with_map_default = useDispatchWithMap;

  // node_modules/@wordpress/data/build-module/components/with-dispatch/index.js
  var withDispatch = (mapDispatchToProps) => createHigherOrderComponent((WrappedComponent) => (ownProps) => {
    const mapDispatch = (dispatch2, registry) => mapDispatchToProps(dispatch2, ownProps, registry);
    const dispatchProps = use_dispatch_with_map_default(mapDispatch, []);
    return (0, import_react.createElement)(WrappedComponent, _extends({}, ownProps, dispatchProps));
  }, "withDispatch");
  var with_dispatch_default = withDispatch;

  // node_modules/@wordpress/data/build-module/components/with-registry/index.js
  var withRegistry = createHigherOrderComponent((OriginalComponent) => (props) => (0, import_react.createElement)(RegistryConsumer, null, (registry) => (0, import_react.createElement)(OriginalComponent, _extends({}, props, {
    registry
  }))), "withRegistry");
  var with_registry_default = withRegistry;

  // node_modules/@wordpress/data/build-module/index.js
  var combineReducers2 = import_turbo_combine_reducers2.default;
  var select = default_registry_default.select;
  var resolveSelect = default_registry_default.resolveSelect;
  var suspendSelect = default_registry_default.suspendSelect;
  var dispatch = default_registry_default.dispatch;
  var subscribe2 = default_registry_default.subscribe;
  var registerGenericStore = default_registry_default.registerGenericStore;
  var registerStore = default_registry_default.registerStore;
  var use = default_registry_default.use;
  var register = default_registry_default.register;

  // node_modules/@wordpress/blocks/build-module/store/reducer.js
  var import_lodash8 = __toESM(require_lodash());

  // node_modules/@wordpress/blocks/build-module/api/utils.js
  var import_lodash7 = __toESM(require_lodash());

  // node_modules/colord/index.mjs
  var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
  var t = function(r5) {
    return "string" == typeof r5 ? r5.length > 0 : "number" == typeof r5;
  };
  var n = function(r5, t5, n5) {
    return void 0 === t5 && (t5 = 0), void 0 === n5 && (n5 = Math.pow(10, t5)), Math.round(n5 * r5) / n5 + 0;
  };
  var e = function(r5, t5, n5) {
    return void 0 === t5 && (t5 = 0), void 0 === n5 && (n5 = 1), r5 > n5 ? n5 : r5 > t5 ? r5 : t5;
  };
  var u = function(r5) {
    return (r5 = isFinite(r5) ? r5 % 360 : 0) > 0 ? r5 : r5 + 360;
  };
  var a = function(r5) {
    return { r: e(r5.r, 0, 255), g: e(r5.g, 0, 255), b: e(r5.b, 0, 255), a: e(r5.a) };
  };
  var o = function(r5) {
    return { r: n(r5.r), g: n(r5.g), b: n(r5.b), a: n(r5.a, 3) };
  };
  var i = /^#([0-9a-f]{3,8})$/i;
  var s = function(r5) {
    var t5 = r5.toString(16);
    return t5.length < 2 ? "0" + t5 : t5;
  };
  var h = function(r5) {
    var t5 = r5.r, n5 = r5.g, e4 = r5.b, u4 = r5.a, a6 = Math.max(t5, n5, e4), o6 = a6 - Math.min(t5, n5, e4), i5 = o6 ? a6 === t5 ? (n5 - e4) / o6 : a6 === n5 ? 2 + (e4 - t5) / o6 : 4 + (t5 - n5) / o6 : 0;
    return { h: 60 * (i5 < 0 ? i5 + 6 : i5), s: a6 ? o6 / a6 * 100 : 0, v: a6 / 255 * 100, a: u4 };
  };
  var b = function(r5) {
    var t5 = r5.h, n5 = r5.s, e4 = r5.v, u4 = r5.a;
    t5 = t5 / 360 * 6, n5 /= 100, e4 /= 100;
    var a6 = Math.floor(t5), o6 = e4 * (1 - n5), i5 = e4 * (1 - (t5 - a6) * n5), s5 = e4 * (1 - (1 - t5 + a6) * n5), h4 = a6 % 6;
    return { r: 255 * [e4, i5, o6, o6, s5, e4][h4], g: 255 * [s5, e4, e4, i5, o6, o6][h4], b: 255 * [o6, o6, s5, e4, e4, i5][h4], a: u4 };
  };
  var g = function(r5) {
    return { h: u(r5.h), s: e(r5.s, 0, 100), l: e(r5.l, 0, 100), a: e(r5.a) };
  };
  var d = function(r5) {
    return { h: n(r5.h), s: n(r5.s), l: n(r5.l), a: n(r5.a, 3) };
  };
  var f = function(r5) {
    return b((n5 = (t5 = r5).s, { h: t5.h, s: (n5 *= ((e4 = t5.l) < 50 ? e4 : 100 - e4) / 100) > 0 ? 2 * n5 / (e4 + n5) * 100 : 0, v: e4 + n5, a: t5.a }));
    var t5, n5, e4;
  };
  var c = function(r5) {
    return { h: (t5 = h(r5)).h, s: (u4 = (200 - (n5 = t5.s)) * (e4 = t5.v) / 100) > 0 && u4 < 200 ? n5 * e4 / 100 / (u4 <= 100 ? u4 : 200 - u4) * 100 : 0, l: u4 / 2, a: t5.a };
    var t5, n5, e4, u4;
  };
  var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
  var y = { string: [[function(r5) {
    var t5 = i.exec(r5);
    return t5 ? (r5 = t5[1]).length <= 4 ? { r: parseInt(r5[0] + r5[0], 16), g: parseInt(r5[1] + r5[1], 16), b: parseInt(r5[2] + r5[2], 16), a: 4 === r5.length ? n(parseInt(r5[3] + r5[3], 16) / 255, 2) : 1 } : 6 === r5.length || 8 === r5.length ? { r: parseInt(r5.substr(0, 2), 16), g: parseInt(r5.substr(2, 2), 16), b: parseInt(r5.substr(4, 2), 16), a: 8 === r5.length ? n(parseInt(r5.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
  }, "hex"], [function(r5) {
    var t5 = v.exec(r5) || m.exec(r5);
    return t5 ? t5[2] !== t5[4] || t5[4] !== t5[6] ? null : a({ r: Number(t5[1]) / (t5[2] ? 100 / 255 : 1), g: Number(t5[3]) / (t5[4] ? 100 / 255 : 1), b: Number(t5[5]) / (t5[6] ? 100 / 255 : 1), a: void 0 === t5[7] ? 1 : Number(t5[7]) / (t5[8] ? 100 : 1) }) : null;
  }, "rgb"], [function(t5) {
    var n5 = l.exec(t5) || p.exec(t5);
    if (!n5)
      return null;
    var e4, u4, a6 = g({ h: (e4 = n5[1], u4 = n5[2], void 0 === u4 && (u4 = "deg"), Number(e4) * (r[u4] || 1)), s: Number(n5[3]), l: Number(n5[4]), a: void 0 === n5[5] ? 1 : Number(n5[5]) / (n5[6] ? 100 : 1) });
    return f(a6);
  }, "hsl"]], object: [[function(r5) {
    var n5 = r5.r, e4 = r5.g, u4 = r5.b, o6 = r5.a, i5 = void 0 === o6 ? 1 : o6;
    return t(n5) && t(e4) && t(u4) ? a({ r: Number(n5), g: Number(e4), b: Number(u4), a: Number(i5) }) : null;
  }, "rgb"], [function(r5) {
    var n5 = r5.h, e4 = r5.s, u4 = r5.l, a6 = r5.a, o6 = void 0 === a6 ? 1 : a6;
    if (!t(n5) || !t(e4) || !t(u4))
      return null;
    var i5 = g({ h: Number(n5), s: Number(e4), l: Number(u4), a: Number(o6) });
    return f(i5);
  }, "hsl"], [function(r5) {
    var n5 = r5.h, a6 = r5.s, o6 = r5.v, i5 = r5.a, s5 = void 0 === i5 ? 1 : i5;
    if (!t(n5) || !t(a6) || !t(o6))
      return null;
    var h4 = function(r6) {
      return { h: u(r6.h), s: e(r6.s, 0, 100), v: e(r6.v, 0, 100), a: e(r6.a) };
    }({ h: Number(n5), s: Number(a6), v: Number(o6), a: Number(s5) });
    return b(h4);
  }, "hsv"]] };
  var N = function(r5, t5) {
    for (var n5 = 0; n5 < t5.length; n5++) {
      var e4 = t5[n5][0](r5);
      if (e4)
        return [e4, t5[n5][1]];
    }
    return [null, void 0];
  };
  var x = function(r5) {
    return "string" == typeof r5 ? N(r5.trim(), y.string) : "object" == typeof r5 && null !== r5 ? N(r5, y.object) : [null, void 0];
  };
  var M = function(r5, t5) {
    var n5 = c(r5);
    return { h: n5.h, s: e(n5.s + 100 * t5, 0, 100), l: n5.l, a: n5.a };
  };
  var H = function(r5) {
    return (299 * r5.r + 587 * r5.g + 114 * r5.b) / 1e3 / 255;
  };
  var $ = function(r5, t5) {
    var n5 = c(r5);
    return { h: n5.h, s: n5.s, l: e(n5.l + 100 * t5, 0, 100), a: n5.a };
  };
  var j = function() {
    function r5(r6) {
      this.parsed = x(r6)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
    }
    return r5.prototype.isValid = function() {
      return null !== this.parsed;
    }, r5.prototype.brightness = function() {
      return n(H(this.rgba), 2);
    }, r5.prototype.isDark = function() {
      return H(this.rgba) < 0.5;
    }, r5.prototype.isLight = function() {
      return H(this.rgba) >= 0.5;
    }, r5.prototype.toHex = function() {
      return r6 = o(this.rgba), t5 = r6.r, e4 = r6.g, u4 = r6.b, i5 = (a6 = r6.a) < 1 ? s(n(255 * a6)) : "", "#" + s(t5) + s(e4) + s(u4) + i5;
      var r6, t5, e4, u4, a6, i5;
    }, r5.prototype.toRgb = function() {
      return o(this.rgba);
    }, r5.prototype.toRgbString = function() {
      return r6 = o(this.rgba), t5 = r6.r, n5 = r6.g, e4 = r6.b, (u4 = r6.a) < 1 ? "rgba(" + t5 + ", " + n5 + ", " + e4 + ", " + u4 + ")" : "rgb(" + t5 + ", " + n5 + ", " + e4 + ")";
      var r6, t5, n5, e4, u4;
    }, r5.prototype.toHsl = function() {
      return d(c(this.rgba));
    }, r5.prototype.toHslString = function() {
      return r6 = d(c(this.rgba)), t5 = r6.h, n5 = r6.s, e4 = r6.l, (u4 = r6.a) < 1 ? "hsla(" + t5 + ", " + n5 + "%, " + e4 + "%, " + u4 + ")" : "hsl(" + t5 + ", " + n5 + "%, " + e4 + "%)";
      var r6, t5, n5, e4, u4;
    }, r5.prototype.toHsv = function() {
      return r6 = h(this.rgba), { h: n(r6.h), s: n(r6.s), v: n(r6.v), a: n(r6.a, 3) };
      var r6;
    }, r5.prototype.invert = function() {
      return w({ r: 255 - (r6 = this.rgba).r, g: 255 - r6.g, b: 255 - r6.b, a: r6.a });
      var r6;
    }, r5.prototype.saturate = function(r6) {
      return void 0 === r6 && (r6 = 0.1), w(M(this.rgba, r6));
    }, r5.prototype.desaturate = function(r6) {
      return void 0 === r6 && (r6 = 0.1), w(M(this.rgba, -r6));
    }, r5.prototype.grayscale = function() {
      return w(M(this.rgba, -1));
    }, r5.prototype.lighten = function(r6) {
      return void 0 === r6 && (r6 = 0.1), w($(this.rgba, r6));
    }, r5.prototype.darken = function(r6) {
      return void 0 === r6 && (r6 = 0.1), w($(this.rgba, -r6));
    }, r5.prototype.rotate = function(r6) {
      return void 0 === r6 && (r6 = 15), this.hue(this.hue() + r6);
    }, r5.prototype.alpha = function(r6) {
      return "number" == typeof r6 ? w({ r: (t5 = this.rgba).r, g: t5.g, b: t5.b, a: r6 }) : n(this.rgba.a, 3);
      var t5;
    }, r5.prototype.hue = function(r6) {
      var t5 = c(this.rgba);
      return "number" == typeof r6 ? w({ h: r6, s: t5.s, l: t5.l, a: t5.a }) : n(t5.h);
    }, r5.prototype.isEqual = function(r6) {
      return this.toHex() === w(r6).toHex();
    }, r5;
  }();
  var w = function(r5) {
    return r5 instanceof j ? r5 : new j(r5);
  };
  var S = [];
  var k = function(r5) {
    r5.forEach(function(r6) {
      S.indexOf(r6) < 0 && (r6(j, y), S.push(r6));
    });
  };

  // node_modules/colord/plugins/names.mjs
  function names_default(e4, f5) {
    var a6 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r5 = {};
    for (var d4 in a6)
      r5[a6[d4]] = d4;
    var l5 = {};
    e4.prototype.toName = function(f6) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var d5, i5, n5 = r5[this.toHex()];
      if (n5)
        return n5;
      if (null == f6 ? void 0 : f6.closest) {
        var o6 = this.toRgb(), t5 = 1 / 0, b6 = "black";
        if (!l5.length)
          for (var c6 in a6)
            l5[c6] = new e4(a6[c6]).toRgb();
        for (var g5 in a6) {
          var u4 = (d5 = o6, i5 = l5[g5], Math.pow(d5.r - i5.r, 2) + Math.pow(d5.g - i5.g, 2) + Math.pow(d5.b - i5.b, 2));
          u4 < t5 && (t5 = u4, b6 = g5);
        }
        return b6;
      }
    };
    f5.string.push([function(f6) {
      var r6 = f6.toLowerCase(), d5 = "transparent" === r6 ? "#0000" : a6[r6];
      return d5 ? new e4(d5).toRgb() : null;
    }, "name"]);
  }

  // node_modules/colord/plugins/a11y.mjs
  var o2 = function(o6) {
    var t5 = o6 / 255;
    return t5 < 0.04045 ? t5 / 12.92 : Math.pow((t5 + 0.055) / 1.055, 2.4);
  };
  var t2 = function(t5) {
    return 0.2126 * o2(t5.r) + 0.7152 * o2(t5.g) + 0.0722 * o2(t5.b);
  };
  function a11y_default(o6) {
    o6.prototype.luminance = function() {
      return o7 = t2(this.rgba), void 0 === (r5 = 2) && (r5 = 0), void 0 === n5 && (n5 = Math.pow(10, r5)), Math.round(n5 * o7) / n5 + 0;
      var o7, r5, n5;
    }, o6.prototype.contrast = function(r5) {
      void 0 === r5 && (r5 = "#FFF");
      var n5, a6, i5, e4, v5, u4, d4, c6 = r5 instanceof o6 ? r5 : new o6(r5);
      return e4 = this.rgba, v5 = c6.toRgb(), u4 = t2(e4), d4 = t2(v5), n5 = u4 > d4 ? (u4 + 0.05) / (d4 + 0.05) : (d4 + 0.05) / (u4 + 0.05), void 0 === (a6 = 2) && (a6 = 0), void 0 === i5 && (i5 = Math.pow(10, a6)), Math.floor(i5 * n5) / i5 + 0;
    }, o6.prototype.isReadable = function(o7, t5) {
      return void 0 === o7 && (o7 = "#FFF"), void 0 === t5 && (t5 = {}), this.contrast(o7) >= (e4 = void 0 === (i5 = (r5 = t5).size) ? "normal" : i5, "AAA" === (a6 = void 0 === (n5 = r5.level) ? "AA" : n5) && "normal" === e4 ? 7 : "AA" === a6 && "large" === e4 ? 3 : 4.5);
      var r5, n5, a6, i5, e4;
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/constants.js
  var BLOCK_ICON_DEFAULT = "block-default";
  var DEPRECATED_ENTRY_KEYS = ["attributes", "supports", "save", "migrate", "isEligible", "apiVersion"];
  var __EXPERIMENTAL_PATHS_WITH_MERGE = {
    "color.duotone": true,
    "color.gradients": true,
    "color.palette": true,
    "typography.fontFamilies": true,
    "typography.fontSizes": true,
    "spacing.spacingSizes": true
  };

  // node_modules/@wordpress/blocks/build-module/api/registration.js
  function getFreeformContentHandlerName() {
    return select(store).getFreeformFallbackBlockName();
  }
  function getGroupingBlockName() {
    return select(store).getGroupingBlockName();
  }
  function getUnregisteredTypeHandlerName() {
    return select(store).getUnregisteredFallbackBlockName();
  }
  function getDefaultBlockName() {
    return select(store).getDefaultBlockName();
  }
  function getBlockType(name) {
    var _select;
    return (_select = select(store)) === null || _select === void 0 ? void 0 : _select.getBlockType(name);
  }
  function getBlockTypes() {
    return select(store).getBlockTypes();
  }
  function getBlockSupport(nameOrType, feature, defaultSupports) {
    return select(store).getBlockSupport(nameOrType, feature, defaultSupports);
  }
  function hasBlockSupport(nameOrType, feature, defaultSupports) {
    return select(store).hasBlockSupport(nameOrType, feature, defaultSupports);
  }
  function isReusableBlock(blockOrType) {
    return (blockOrType === null || blockOrType === void 0 ? void 0 : blockOrType.name) === "core/block";
  }
  function isTemplatePart(blockOrType) {
    return blockOrType.name === "core/template-part";
  }
  var getBlockVariations = (blockName, scope) => {
    return select(store).getBlockVariations(blockName, scope);
  };

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default = validate;

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (i5 = 0; i5 < 256; ++i5) {
    byteToHex.push((i5 + 256).toString(16).substr(1));
  }
  var i5;
  function stringify(arr) {
    var offset4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset4 + 0]] + byteToHex[arr[offset4 + 1]] + byteToHex[arr[offset4 + 2]] + byteToHex[arr[offset4 + 3]] + "-" + byteToHex[arr[offset4 + 4]] + byteToHex[arr[offset4 + 5]] + "-" + byteToHex[arr[offset4 + 6]] + byteToHex[arr[offset4 + 7]] + "-" + byteToHex[arr[offset4 + 8]] + byteToHex[arr[offset4 + 9]] + "-" + byteToHex[arr[offset4 + 10]] + byteToHex[arr[offset4 + 11]] + byteToHex[arr[offset4 + 12]] + byteToHex[arr[offset4 + 13]] + byteToHex[arr[offset4 + 14]] + byteToHex[arr[offset4 + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var stringify_default = stringify;

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset4) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset4 = offset4 || 0;
      for (var i5 = 0; i5 < 16; ++i5) {
        buf[offset4 + i5] = rnds[i5];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default = v4;

  // node_modules/@wordpress/blocks/build-module/api/factory.js
  function createBlock(name) {
    let attributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let innerBlocks = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    const sanitizedAttributes = __experimentalSanitizeBlockAttributes(name, attributes);
    const clientId = v4_default();
    return {
      clientId,
      name,
      isValid: true,
      attributes: sanitizedAttributes,
      innerBlocks
    };
  }
  function createBlocksFromInnerBlocksTemplate() {
    let innerBlocksOrTemplate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return innerBlocksOrTemplate.map((innerBlock) => {
      const innerBlockTemplate = Array.isArray(innerBlock) ? innerBlock : [innerBlock.name, innerBlock.attributes, innerBlock.innerBlocks];
      const [name, attributes, innerBlocks = []] = innerBlockTemplate;
      return createBlock(name, attributes, createBlocksFromInnerBlocksTemplate(innerBlocks));
    });
  }
  function __experimentalCloneSanitizedBlock(block4) {
    let mergeAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let newInnerBlocks = arguments.length > 2 ? arguments[2] : void 0;
    const clientId = v4_default();
    const sanitizedAttributes = __experimentalSanitizeBlockAttributes(block4.name, {
      ...block4.attributes,
      ...mergeAttributes
    });
    return {
      ...block4,
      clientId,
      attributes: sanitizedAttributes,
      innerBlocks: newInnerBlocks || block4.innerBlocks.map((innerBlock) => __experimentalCloneSanitizedBlock(innerBlock))
    };
  }
  function cloneBlock(block4) {
    let mergeAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let newInnerBlocks = arguments.length > 2 ? arguments[2] : void 0;
    const clientId = v4_default();
    return {
      ...block4,
      clientId,
      attributes: {
        ...block4.attributes,
        ...mergeAttributes
      },
      innerBlocks: newInnerBlocks || block4.innerBlocks.map((innerBlock) => cloneBlock(innerBlock))
    };
  }
  var isPossibleTransformForSource = (transform, direction, blocks2) => {
    if (!blocks2.length) {
      return false;
    }
    const isMultiBlock = blocks2.length > 1;
    const firstBlockName = blocks2[0].name;
    const isValidForMultiBlocks = isWildcardBlockTransform(transform) || !isMultiBlock || transform.isMultiBlock;
    if (!isValidForMultiBlocks) {
      return false;
    }
    if (!isWildcardBlockTransform(transform) && !blocks2.every((block4) => block4.name === firstBlockName)) {
      return false;
    }
    const isBlockType = transform.type === "block";
    if (!isBlockType) {
      return false;
    }
    const sourceBlock = blocks2[0];
    const hasMatchingName = direction !== "from" || transform.blocks.indexOf(sourceBlock.name) !== -1 || isWildcardBlockTransform(transform);
    if (!hasMatchingName) {
      return false;
    }
    if (!isMultiBlock && direction === "from" && isContainerGroupBlock(sourceBlock.name) && isContainerGroupBlock(transform.blockName)) {
      return false;
    }
    if (!maybeCheckTransformIsMatch(transform, blocks2)) {
      return false;
    }
    if (transform.usingMobileTransformations && isWildcardBlockTransform(transform) && !isContainerGroupBlock(sourceBlock.name)) {
      return false;
    }
    return true;
  };
  var getBlockTypesForPossibleFromTransforms = (blocks2) => {
    if (!blocks2.length) {
      return [];
    }
    const allBlockTypes = getBlockTypes();
    const blockTypesWithPossibleFromTransforms = allBlockTypes.filter((blockType) => {
      const fromTransforms = getBlockTransforms("from", blockType.name);
      return !!findTransform(fromTransforms, (transform) => {
        return isPossibleTransformForSource(transform, "from", blocks2);
      });
    });
    return blockTypesWithPossibleFromTransforms;
  };
  var getBlockTypesForPossibleToTransforms = (blocks2) => {
    if (!blocks2.length) {
      return [];
    }
    const sourceBlock = blocks2[0];
    const blockType = getBlockType(sourceBlock.name);
    const transformsTo = blockType ? getBlockTransforms("to", blockType.name) : [];
    const possibleTransforms = transformsTo.filter((transform) => {
      return transform && isPossibleTransformForSource(transform, "to", blocks2);
    });
    const blockNames = possibleTransforms.map((transformation) => transformation.blocks).flat();
    return blockNames.map((name) => name === "*" ? name : getBlockType(name));
  };
  var isWildcardBlockTransform = (t5) => t5 && t5.type === "block" && Array.isArray(t5.blocks) && t5.blocks.includes("*");
  var isContainerGroupBlock = (name) => name === getGroupingBlockName();
  function getPossibleBlockTransformations(blocks2) {
    if (!blocks2.length) {
      return [];
    }
    const blockTypesForFromTransforms = getBlockTypesForPossibleFromTransforms(blocks2);
    const blockTypesForToTransforms = getBlockTypesForPossibleToTransforms(blocks2);
    return [.../* @__PURE__ */ new Set([...blockTypesForFromTransforms, ...blockTypesForToTransforms])];
  }
  function findTransform(transforms, predicate) {
    const hooks = createHooks_default();
    for (let i5 = 0; i5 < transforms.length; i5++) {
      const candidate = transforms[i5];
      if (predicate(candidate)) {
        hooks.addFilter("transform", "transform/" + i5.toString(), (result) => result ? result : candidate, candidate.priority);
      }
    }
    return hooks.applyFilters("transform", null);
  }
  function getBlockTransforms(direction, blockTypeOrName) {
    if (blockTypeOrName === void 0) {
      return getBlockTypes().map((_ref8) => {
        let {
          name
        } = _ref8;
        return getBlockTransforms(direction, name);
      }).flat();
    }
    const blockType = normalizeBlockType(blockTypeOrName);
    const {
      name: blockName,
      transforms
    } = blockType || {};
    if (!transforms || !Array.isArray(transforms[direction])) {
      return [];
    }
    const usingMobileTransformations = transforms.supportedMobileTransforms && Array.isArray(transforms.supportedMobileTransforms);
    const filteredTransforms = usingMobileTransformations ? transforms[direction].filter((t5) => {
      if (t5.type === "raw") {
        return true;
      }
      if (!t5.blocks || !t5.blocks.length) {
        return false;
      }
      if (isWildcardBlockTransform(t5)) {
        return true;
      }
      return t5.blocks.every((transformBlockName) => transforms.supportedMobileTransforms.includes(transformBlockName));
    }) : transforms[direction];
    return filteredTransforms.map((transform) => ({
      ...transform,
      blockName,
      usingMobileTransformations
    }));
  }
  function maybeCheckTransformIsMatch(transform, blocks2) {
    if (typeof transform.isMatch !== "function") {
      return true;
    }
    const sourceBlock = blocks2[0];
    const attributes = transform.isMultiBlock ? blocks2.map((block5) => block5.attributes) : sourceBlock.attributes;
    const block4 = transform.isMultiBlock ? blocks2 : sourceBlock;
    return transform.isMatch(attributes, block4);
  }
  function switchToBlockType(blocks2, name) {
    const blocksArray = Array.isArray(blocks2) ? blocks2 : [blocks2];
    const isMultiBlock = blocksArray.length > 1;
    const firstBlock = blocksArray[0];
    const sourceName = firstBlock.name;
    const transformationsFrom = getBlockTransforms("from", name);
    const transformationsTo = getBlockTransforms("to", sourceName);
    const transformation = findTransform(transformationsTo, (t5) => t5.type === "block" && t5.blocks.indexOf(name) !== -1 && (!isMultiBlock || t5.isMultiBlock) && maybeCheckTransformIsMatch(t5, blocksArray)) || findTransform(transformationsFrom, (t5) => t5.type === "block" && (isWildcardBlockTransform(t5) || t5.blocks.indexOf(sourceName) !== -1) && (!isMultiBlock || t5.isMultiBlock) && maybeCheckTransformIsMatch(t5, blocksArray));
    if (!transformation) {
      return null;
    }
    let transformationResults;
    if (transformation.isMultiBlock) {
      if ("__experimentalConvert" in transformation) {
        transformationResults = transformation.__experimentalConvert(blocksArray);
      } else {
        transformationResults = transformation.transform(blocksArray.map((currentBlock) => currentBlock.attributes), blocksArray.map((currentBlock) => currentBlock.innerBlocks));
      }
    } else if ("__experimentalConvert" in transformation) {
      transformationResults = transformation.__experimentalConvert(firstBlock);
    } else {
      transformationResults = transformation.transform(firstBlock.attributes, firstBlock.innerBlocks);
    }
    if (transformationResults === null || typeof transformationResults !== "object") {
      return null;
    }
    transformationResults = Array.isArray(transformationResults) ? transformationResults : [transformationResults];
    if (transformationResults.some((result) => !getBlockType(result.name))) {
      return null;
    }
    if (name === "*") {
      return transformationResults;
    }
    const hasSwitchedBlock = transformationResults.some((result) => result.name === name);
    if (!hasSwitchedBlock) {
      return null;
    }
    const ret = transformationResults.map((result, index2, results) => {
      return applyFilters("blocks.switchToBlockType.transformedBlock", result, blocks2, index2, results);
    });
    return ret;
  }
  var getBlockFromExample = (name, example) => {
    var _example$innerBlocks;
    return createBlock(name, example.attributes, ((_example$innerBlocks = example.innerBlocks) !== null && _example$innerBlocks !== void 0 ? _example$innerBlocks : []).map((innerBlock) => getBlockFromExample(innerBlock.name, innerBlock)));
  };

  // node_modules/@wordpress/blocks/build-module/api/utils.js
  k([names_default, a11y_default]);
  var ICON_COLORS = ["#191e23", "#f8f9f9"];
  function isUnmodifiedDefaultBlock(block4) {
    var _blockType$attributes;
    const defaultBlockName2 = getDefaultBlockName();
    if (block4.name !== defaultBlockName2) {
      return false;
    }
    if (!isUnmodifiedDefaultBlock.block || isUnmodifiedDefaultBlock.block.name !== defaultBlockName2) {
      isUnmodifiedDefaultBlock.block = createBlock(defaultBlockName2);
    }
    const newDefaultBlock = isUnmodifiedDefaultBlock.block;
    const blockType = getBlockType(defaultBlockName2);
    return Object.keys((_blockType$attributes = blockType === null || blockType === void 0 ? void 0 : blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}).every((key) => newDefaultBlock.attributes[key] === block4.attributes[key]);
  }
  function isValidIcon(icon) {
    return !!icon && (typeof icon === "string" || (0, import_react.isValidElement)(icon) || typeof icon === "function" || icon instanceof import_react.Component);
  }
  function normalizeIconObject(icon) {
    icon = icon || BLOCK_ICON_DEFAULT;
    if (isValidIcon(icon)) {
      return {
        src: icon
      };
    }
    if ("background" in icon) {
      const colordBgColor = w(icon.background);
      const getColorContrast = (iconColor) => colordBgColor.contrast(iconColor);
      const maxContrast = Math.max(...ICON_COLORS.map(getColorContrast));
      return {
        ...icon,
        foreground: icon.foreground ? icon.foreground : ICON_COLORS.find((iconColor) => getColorContrast(iconColor) === maxContrast),
        shadowColor: colordBgColor.alpha(0.3).toRgbString()
      };
    }
    return icon;
  }
  function normalizeBlockType(blockTypeOrName) {
    if (typeof blockTypeOrName === "string") {
      return getBlockType(blockTypeOrName);
    }
    return blockTypeOrName;
  }
  function getBlockLabel(blockType, attributes) {
    let context2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "visual";
    const {
      __experimentalLabel: getLabel,
      title
    } = blockType;
    const label = getLabel && getLabel(attributes, {
      context: context2
    });
    if (!label) {
      return title;
    }
    return stripHTML(label);
  }
  function getAccessibleBlockLabel(blockType, attributes, position) {
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "vertical";
    const title = blockType === null || blockType === void 0 ? void 0 : blockType.title;
    const label = blockType ? getBlockLabel(blockType, attributes, "accessibility") : "";
    const hasPosition = position !== void 0;
    const hasLabel = label && label !== title;
    if (hasPosition && direction === "vertical") {
      if (hasLabel) {
        return sprintf(
          __("%1$s Block. Row %2$d. %3$s"),
          title,
          position,
          label
        );
      }
      return sprintf(
        __("%1$s Block. Row %2$d"),
        title,
        position
      );
    } else if (hasPosition && direction === "horizontal") {
      if (hasLabel) {
        return sprintf(
          __("%1$s Block. Column %2$d. %3$s"),
          title,
          position,
          label
        );
      }
      return sprintf(
        __("%1$s Block. Column %2$d"),
        title,
        position
      );
    }
    if (hasLabel) {
      return sprintf(
        __("%1$s Block. %2$s"),
        title,
        label
      );
    }
    return sprintf(
      __("%s Block"),
      title
    );
  }
  function __experimentalSanitizeBlockAttributes(name, attributes) {
    const blockType = getBlockType(name);
    if (void 0 === blockType) {
      throw new Error(`Block type '${name}' is not registered.`);
    }
    return (0, import_lodash7.reduce)(blockType.attributes, (accumulator, schema, key) => {
      const value = attributes[key];
      if (void 0 !== value) {
        accumulator[key] = value;
      } else if (schema.hasOwnProperty("default")) {
        accumulator[key] = schema.default;
      }
      if (["node", "children"].indexOf(schema.source) !== -1) {
        if (typeof accumulator[key] === "string") {
          accumulator[key] = [accumulator[key]];
        } else if (!Array.isArray(accumulator[key])) {
          accumulator[key] = [];
        }
      }
      return accumulator;
    }, {});
  }
  function __experimentalGetBlockAttributesNamesByRole(name, role) {
    var _getBlockType;
    const attributes = (_getBlockType = getBlockType(name)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.attributes;
    if (!attributes)
      return [];
    const attributesNames = Object.keys(attributes);
    if (!role)
      return attributesNames;
    return attributesNames.filter((attributeName) => {
      var _attributes$attribute;
      return ((_attributes$attribute = attributes[attributeName]) === null || _attributes$attribute === void 0 ? void 0 : _attributes$attribute.__experimentalRole) === role;
    });
  }
  function omit(object, keys) {
    return Object.fromEntries(Object.entries(object).filter((_ref8) => {
      let [key] = _ref8;
      return !keys.includes(key);
    }));
  }

  // node_modules/@wordpress/blocks/build-module/store/reducer.js
  var DEFAULT_CATEGORIES = [{
    slug: "text",
    title: __("Text")
  }, {
    slug: "media",
    title: __("Media")
  }, {
    slug: "design",
    title: __("Design")
  }, {
    slug: "widgets",
    title: __("Widgets")
  }, {
    slug: "theme",
    title: __("Theme")
  }, {
    slug: "embed",
    title: __("Embeds")
  }, {
    slug: "reusable",
    title: __("Reusable blocks")
  }];
  function keyBlockTypesByName(types2) {
    return types2.reduce((newBlockTypes, block4) => ({
      ...newBlockTypes,
      [block4.name]: block4
    }), {});
  }
  function getUniqueItemsByName(items) {
    return items.reduce((acc, currentItem) => {
      if (!acc.some((item2) => item2.name === currentItem.name)) {
        acc.push(currentItem);
      }
      return acc;
    }, []);
  }
  function unprocessedBlockTypes() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "ADD_UNPROCESSED_BLOCK_TYPE":
        return {
          ...state,
          [action.blockType.name]: action.blockType
        };
      case "REMOVE_BLOCK_TYPES":
        return omit(state, action.names);
    }
    return state;
  }
  function blockTypes() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "ADD_BLOCK_TYPES":
        return {
          ...state,
          ...keyBlockTypesByName(action.blockTypes)
        };
      case "REMOVE_BLOCK_TYPES":
        return omit(state, action.names);
    }
    return state;
  }
  function blockStyles() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "ADD_BLOCK_TYPES":
        return {
          ...state,
          ...(0, import_lodash8.mapValues)(keyBlockTypesByName(action.blockTypes), (blockType) => getUniqueItemsByName([...(0, import_lodash8.get)(blockType, ["styles"], []).map((style) => ({
            ...style,
            source: "block"
          })), ...(0, import_lodash8.get)(state, [blockType.name], []).filter((_ref8) => {
            let {
              source
            } = _ref8;
            return "block" !== source;
          })]))
        };
      case "ADD_BLOCK_STYLES":
        return {
          ...state,
          [action.blockName]: getUniqueItemsByName([...(0, import_lodash8.get)(state, [action.blockName], []), ...action.styles])
        };
      case "REMOVE_BLOCK_STYLES":
        return {
          ...state,
          [action.blockName]: (0, import_lodash8.filter)((0, import_lodash8.get)(state, [action.blockName], []), (style) => action.styleNames.indexOf(style.name) === -1)
        };
    }
    return state;
  }
  function blockVariations() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "ADD_BLOCK_TYPES":
        return {
          ...state,
          ...(0, import_lodash8.mapValues)(keyBlockTypesByName(action.blockTypes), (blockType) => {
            return getUniqueItemsByName([...(0, import_lodash8.get)(blockType, ["variations"], []).map((variation) => ({
              ...variation,
              source: "block"
            })), ...(0, import_lodash8.get)(state, [blockType.name], []).filter((_ref22) => {
              let {
                source
              } = _ref22;
              return "block" !== source;
            })]);
          })
        };
      case "ADD_BLOCK_VARIATIONS":
        return {
          ...state,
          [action.blockName]: getUniqueItemsByName([...(0, import_lodash8.get)(state, [action.blockName], []), ...action.variations])
        };
      case "REMOVE_BLOCK_VARIATIONS":
        return {
          ...state,
          [action.blockName]: (0, import_lodash8.filter)((0, import_lodash8.get)(state, [action.blockName], []), (variation) => action.variationNames.indexOf(variation.name) === -1)
        };
    }
    return state;
  }
  function createBlockNameSetterReducer(setActionType) {
    return function() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let action = arguments.length > 1 ? arguments[1] : void 0;
      switch (action.type) {
        case "REMOVE_BLOCK_TYPES":
          if (action.names.indexOf(state) !== -1) {
            return null;
          }
          return state;
        case setActionType:
          return action.name || null;
      }
      return state;
    };
  }
  var defaultBlockName = createBlockNameSetterReducer("SET_DEFAULT_BLOCK_NAME");
  var freeformFallbackBlockName = createBlockNameSetterReducer("SET_FREEFORM_FALLBACK_BLOCK_NAME");
  var unregisteredFallbackBlockName = createBlockNameSetterReducer("SET_UNREGISTERED_FALLBACK_BLOCK_NAME");
  var groupingBlockName = createBlockNameSetterReducer("SET_GROUPING_BLOCK_NAME");
  function categories() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_CATEGORIES;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "SET_CATEGORIES":
        return action.categories || [];
      case "UPDATE_CATEGORY": {
        if (!action.category || (0, import_lodash8.isEmpty)(action.category)) {
          return state;
        }
        const categoryToChange = (0, import_lodash8.find)(state, ["slug", action.slug]);
        if (categoryToChange) {
          return (0, import_lodash8.map)(state, (category) => {
            if (category.slug === action.slug) {
              return {
                ...category,
                ...action.category
              };
            }
            return category;
          });
        }
      }
    }
    return state;
  }
  function collections() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "ADD_BLOCK_COLLECTION":
        return {
          ...state,
          [action.namespace]: {
            title: action.title,
            icon: action.icon
          }
        };
      case "REMOVE_BLOCK_COLLECTION":
        return omit(state, action.namespace);
    }
    return state;
  }
  var reducer_default2 = combineReducers2({
    unprocessedBlockTypes,
    blockTypes,
    blockStyles,
    blockVariations,
    defaultBlockName,
    freeformFallbackBlockName,
    unregisteredFallbackBlockName,
    groupingBlockName,
    categories,
    collections
  });

  // node_modules/@wordpress/blocks/build-module/store/selectors.js
  var selectors_exports2 = {};
  __export(selectors_exports2, {
    __experimentalGetUnprocessedBlockTypes: () => __experimentalGetUnprocessedBlockTypes,
    __experimentalHasContentRoleAttribute: () => __experimentalHasContentRoleAttribute,
    getActiveBlockVariation: () => getActiveBlockVariation,
    getBlockStyles: () => getBlockStyles,
    getBlockSupport: () => getBlockSupport2,
    getBlockType: () => getBlockType2,
    getBlockTypes: () => getBlockTypes2,
    getBlockVariations: () => getBlockVariations2,
    getCategories: () => getCategories,
    getChildBlockNames: () => getChildBlockNames,
    getCollections: () => getCollections,
    getDefaultBlockName: () => getDefaultBlockName2,
    getDefaultBlockVariation: () => getDefaultBlockVariation,
    getFreeformFallbackBlockName: () => getFreeformFallbackBlockName,
    getGroupingBlockName: () => getGroupingBlockName2,
    getUnregisteredFallbackBlockName: () => getUnregisteredFallbackBlockName,
    hasBlockSupport: () => hasBlockSupport2,
    hasChildBlocks: () => hasChildBlocks,
    hasChildBlocksWithInserterSupport: () => hasChildBlocksWithInserterSupport,
    isMatchingSearchTerm: () => isMatchingSearchTerm
  });

  // node_modules/rememo/rememo.js
  var LEAF_KEY = {};
  function arrayOf(value) {
    return [value];
  }
  function isObjectLike(value) {
    return !!value && "object" === typeof value;
  }
  function createCache() {
    var cache2 = {
      clear: function() {
        cache2.head = null;
      }
    };
    return cache2;
  }
  function isShallowEqual2(a6, b6, fromIndex) {
    var i5;
    if (a6.length !== b6.length) {
      return false;
    }
    for (i5 = fromIndex; i5 < a6.length; i5++) {
      if (a6[i5] !== b6[i5]) {
        return false;
      }
    }
    return true;
  }
  function rememo_default(selector4, getDependants) {
    var rootCache;
    var normalizedGetDependants = getDependants ? getDependants : arrayOf;
    function getCache(dependants) {
      var caches = rootCache, isUniqueByDependants = true, i5, dependant, map9, cache2;
      for (i5 = 0; i5 < dependants.length; i5++) {
        dependant = dependants[i5];
        if (!isObjectLike(dependant)) {
          isUniqueByDependants = false;
          break;
        }
        if (caches.has(dependant)) {
          caches = caches.get(dependant);
        } else {
          map9 = /* @__PURE__ */ new WeakMap();
          caches.set(dependant, map9);
          caches = map9;
        }
      }
      if (!caches.has(LEAF_KEY)) {
        cache2 = createCache();
        cache2.isUniqueByDependants = isUniqueByDependants;
        caches.set(LEAF_KEY, cache2);
      }
      return caches.get(LEAF_KEY);
    }
    function clear2() {
      rootCache = /* @__PURE__ */ new WeakMap();
    }
    function callSelector() {
      var len = arguments.length, cache2, node, i5, args, dependants;
      args = new Array(len);
      for (i5 = 0; i5 < len; i5++) {
        args[i5] = arguments[i5];
      }
      dependants = normalizedGetDependants.apply(null, args);
      cache2 = getCache(dependants);
      if (!cache2.isUniqueByDependants) {
        if (cache2.lastDependants && !isShallowEqual2(dependants, cache2.lastDependants, 0)) {
          cache2.clear();
        }
        cache2.lastDependants = dependants;
      }
      node = cache2.head;
      while (node) {
        if (!isShallowEqual2(node.args, args, 1)) {
          node = node.next;
          continue;
        }
        if (node !== cache2.head) {
          node.prev.next = node.next;
          if (node.next) {
            node.next.prev = node.prev;
          }
          node.next = cache2.head;
          node.prev = null;
          cache2.head.prev = node;
          cache2.head = node;
        }
        return node.val;
      }
      node = {
        val: selector4.apply(null, args)
      };
      args[0] = null;
      node.args = args;
      if (cache2.head) {
        cache2.head.prev = node;
        node.next = cache2.head;
      }
      cache2.head = node;
      return node.val;
    }
    callSelector.getDependants = normalizedGetDependants;
    callSelector.clear = clear2;
    clear2();
    return callSelector;
  }

  // node_modules/@wordpress/blocks/build-module/store/selectors.js
  var import_remove_accents = __toESM(require_remove_accents());
  var import_lodash9 = __toESM(require_lodash());
  var getNormalizedBlockType = (state, nameOrType) => "string" === typeof nameOrType ? getBlockType2(state, nameOrType) : nameOrType;
  function __experimentalGetUnprocessedBlockTypes(state) {
    return state.unprocessedBlockTypes;
  }
  var getBlockTypes2 = rememo_default((state) => Object.values(state.blockTypes), (state) => [state.blockTypes]);
  function getBlockType2(state, name) {
    return state.blockTypes[name];
  }
  function getBlockStyles(state, name) {
    return state.blockStyles[name];
  }
  var getBlockVariations2 = rememo_default((state, blockName, scope) => {
    const variations = state.blockVariations[blockName];
    if (!variations || !scope) {
      return variations;
    }
    return variations.filter((variation) => {
      return (variation.scope || ["block", "inserter"]).includes(scope);
    });
  }, (state, blockName) => [state.blockVariations[blockName]]);
  function getActiveBlockVariation(state, blockName, attributes, scope) {
    const variations = getBlockVariations2(state, blockName, scope);
    const match = variations === null || variations === void 0 ? void 0 : variations.find((variation) => {
      var _variation$isActive;
      if (Array.isArray(variation.isActive)) {
        const blockType = getBlockType2(state, blockName);
        const attributeKeys = Object.keys((blockType === null || blockType === void 0 ? void 0 : blockType.attributes) || {});
        const definedAttributes = variation.isActive.filter((attribute) => attributeKeys.includes(attribute));
        if (definedAttributes.length === 0) {
          return false;
        }
        return definedAttributes.every((attribute) => attributes[attribute] === variation.attributes[attribute]);
      }
      return (_variation$isActive = variation.isActive) === null || _variation$isActive === void 0 ? void 0 : _variation$isActive.call(variation, attributes, variation.attributes);
    });
    return match;
  }
  function getDefaultBlockVariation(state, blockName, scope) {
    const variations = getBlockVariations2(state, blockName, scope);
    const defaultVariation = [...variations].reverse().find((_ref8) => {
      let {
        isDefault
      } = _ref8;
      return !!isDefault;
    });
    return defaultVariation || variations[0];
  }
  function getCategories(state) {
    return state.categories;
  }
  function getCollections(state) {
    return state.collections;
  }
  function getDefaultBlockName2(state) {
    return state.defaultBlockName;
  }
  function getFreeformFallbackBlockName(state) {
    return state.freeformFallbackBlockName;
  }
  function getUnregisteredFallbackBlockName(state) {
    return state.unregisteredFallbackBlockName;
  }
  function getGroupingBlockName2(state) {
    return state.groupingBlockName;
  }
  var getChildBlockNames = rememo_default((state, blockName) => {
    return (0, import_lodash9.map)((0, import_lodash9.filter)(state.blockTypes, (blockType) => {
      var _blockType$parent;
      return (_blockType$parent = blockType.parent) === null || _blockType$parent === void 0 ? void 0 : _blockType$parent.includes(blockName);
    }), (_ref22) => {
      let {
        name
      } = _ref22;
      return name;
    });
  }, (state) => [state.blockTypes]);
  var getBlockSupport2 = (state, nameOrType, feature, defaultSupports) => {
    const blockType = getNormalizedBlockType(state, nameOrType);
    if (!(blockType !== null && blockType !== void 0 && blockType.supports)) {
      return defaultSupports;
    }
    return (0, import_lodash9.get)(blockType.supports, feature, defaultSupports);
  };
  function hasBlockSupport2(state, nameOrType, feature, defaultSupports) {
    return !!getBlockSupport2(state, nameOrType, feature, defaultSupports);
  }
  function isMatchingSearchTerm(state, nameOrType, searchTerm) {
    var _blockType$keywords;
    const blockType = getNormalizedBlockType(state, nameOrType);
    const getNormalizedSearchTerm = pipe_default([
      (term) => (0, import_remove_accents.default)(term !== null && term !== void 0 ? term : ""),
      (term) => term.toLowerCase(),
      (term) => term.trim()
    ]);
    const normalizedSearchTerm = getNormalizedSearchTerm(searchTerm);
    const isSearchMatch = pipe_default([getNormalizedSearchTerm, (normalizedCandidate) => normalizedCandidate.includes(normalizedSearchTerm)]);
    return isSearchMatch(blockType.title) || ((_blockType$keywords = blockType.keywords) === null || _blockType$keywords === void 0 ? void 0 : _blockType$keywords.some(isSearchMatch)) || isSearchMatch(blockType.category) || typeof blockType.description === "string" && isSearchMatch(blockType.description);
  }
  var hasChildBlocks = (state, blockName) => {
    return getChildBlockNames(state, blockName).length > 0;
  };
  var hasChildBlocksWithInserterSupport = (state, blockName) => {
    return getChildBlockNames(state, blockName).some((childBlockName) => {
      return hasBlockSupport2(state, childBlockName, "inserter", true);
    });
  };
  var __experimentalHasContentRoleAttribute = rememo_default((state, blockTypeName) => {
    const blockType = getBlockType2(state, blockTypeName);
    if (!blockType) {
      return false;
    }
    return Object.entries(blockType.attributes).some((_ref32) => {
      let [, {
        __experimentalRole
      }] = _ref32;
      return __experimentalRole === "content";
    });
  }, (state, blockTypeName) => {
    var _state$blockTypes$blo;
    return [(_state$blockTypes$blo = state.blockTypes[blockTypeName]) === null || _state$blockTypes$blo === void 0 ? void 0 : _state$blockTypes$blo.attributes];
  });

  // node_modules/@wordpress/blocks/build-module/store/actions.js
  var actions_exports2 = {};
  __export(actions_exports2, {
    __experimentalReapplyBlockTypeFilters: () => __experimentalReapplyBlockTypeFilters,
    __experimentalRegisterBlockType: () => __experimentalRegisterBlockType,
    addBlockCollection: () => addBlockCollection,
    addBlockStyles: () => addBlockStyles,
    addBlockTypes: () => addBlockTypes,
    addBlockVariations: () => addBlockVariations,
    removeBlockCollection: () => removeBlockCollection,
    removeBlockStyles: () => removeBlockStyles,
    removeBlockTypes: () => removeBlockTypes,
    removeBlockVariations: () => removeBlockVariations,
    setCategories: () => setCategories,
    setDefaultBlockName: () => setDefaultBlockName,
    setFreeformFallbackBlockName: () => setFreeformFallbackBlockName,
    setGroupingBlockName: () => setGroupingBlockName,
    setUnregisteredFallbackBlockName: () => setUnregisteredFallbackBlockName,
    updateCategory: () => updateCategory
  });
  var import_lodash10 = __toESM(require_lodash());
  var {
    error,
    warn
  } = window.console;
  var LEGACY_CATEGORY_MAPPING = {
    common: "text",
    formatting: "text",
    layout: "design"
  };
  function isFunction(maybeFunc) {
    return typeof maybeFunc === "function";
  }
  var processBlockType = (blockType, _ref8) => {
    let {
      select: select2
    } = _ref8;
    const {
      name
    } = blockType;
    const settings2 = applyFilters("blocks.registerBlockType", {
      ...blockType
    }, name, null);
    if (settings2.description && typeof settings2.description !== "string") {
      deprecated("Declaring non-string block descriptions", {
        since: "6.2"
      });
    }
    if (settings2.deprecated) {
      settings2.deprecated = settings2.deprecated.map((deprecation) => (0, import_lodash10.pick)(
        applyFilters(
          "blocks.registerBlockType",
          {
            ...omit(blockType, DEPRECATED_ENTRY_KEYS),
            ...deprecation
          },
          name,
          deprecation
        ),
        DEPRECATED_ENTRY_KEYS
      ));
    }
    if (!isPlainObject2(settings2)) {
      error("Block settings must be a valid object.");
      return;
    }
    if (!isFunction(settings2.save)) {
      error('The "save" property must be a valid function.');
      return;
    }
    if ("edit" in settings2 && !isFunction(settings2.edit)) {
      error('The "edit" property must be a valid function.');
      return;
    }
    if (LEGACY_CATEGORY_MAPPING.hasOwnProperty(settings2.category)) {
      settings2.category = LEGACY_CATEGORY_MAPPING[settings2.category];
    }
    if ("category" in settings2 && !select2.getCategories().some((_ref22) => {
      let {
        slug
      } = _ref22;
      return slug === settings2.category;
    })) {
      warn('The block "' + name + '" is registered with an invalid category "' + settings2.category + '".');
      delete settings2.category;
    }
    if (!("title" in settings2) || settings2.title === "") {
      error('The block "' + name + '" must have a title.');
      return;
    }
    if (typeof settings2.title !== "string") {
      error("Block titles must be strings.");
      return;
    }
    settings2.icon = normalizeIconObject(settings2.icon);
    if (!isValidIcon(settings2.icon.src)) {
      error("The icon passed is invalid. The icon should be a string, an element, a function, or an object following the specifications documented in https://developer.wordpress.org/block-editor/developers/block-api/block-registration/#icon-optional");
      return;
    }
    return settings2;
  };
  function addBlockTypes(blockTypes2) {
    return {
      type: "ADD_BLOCK_TYPES",
      blockTypes: Array.isArray(blockTypes2) ? blockTypes2 : [blockTypes2]
    };
  }
  var __experimentalRegisterBlockType = (blockType) => (_ref32) => {
    let {
      dispatch: dispatch2,
      select: select2
    } = _ref32;
    dispatch2({
      type: "ADD_UNPROCESSED_BLOCK_TYPE",
      blockType
    });
    const processedBlockType = processBlockType(blockType, {
      select: select2
    });
    if (!processedBlockType) {
      return;
    }
    dispatch2.addBlockTypes(processedBlockType);
  };
  var __experimentalReapplyBlockTypeFilters = () => (_ref42) => {
    let {
      dispatch: dispatch2,
      select: select2
    } = _ref42;
    const unprocessedBlockTypes2 = select2.__experimentalGetUnprocessedBlockTypes();
    const processedBlockTypes = Object.keys(unprocessedBlockTypes2).reduce((accumulator, blockName) => {
      const result = processBlockType(unprocessedBlockTypes2[blockName], {
        select: select2
      });
      if (result) {
        accumulator.push(result);
      }
      return accumulator;
    }, []);
    if (!processedBlockTypes.length) {
      return;
    }
    dispatch2.addBlockTypes(processedBlockTypes);
  };
  function removeBlockTypes(names2) {
    return {
      type: "REMOVE_BLOCK_TYPES",
      names: Array.isArray(names2) ? names2 : [names2]
    };
  }
  function addBlockStyles(blockName, styles) {
    return {
      type: "ADD_BLOCK_STYLES",
      styles: Array.isArray(styles) ? styles : [styles],
      blockName
    };
  }
  function removeBlockStyles(blockName, styleNames) {
    return {
      type: "REMOVE_BLOCK_STYLES",
      styleNames: Array.isArray(styleNames) ? styleNames : [styleNames],
      blockName
    };
  }
  function addBlockVariations(blockName, variations) {
    return {
      type: "ADD_BLOCK_VARIATIONS",
      variations: Array.isArray(variations) ? variations : [variations],
      blockName
    };
  }
  function removeBlockVariations(blockName, variationNames) {
    return {
      type: "REMOVE_BLOCK_VARIATIONS",
      variationNames: Array.isArray(variationNames) ? variationNames : [variationNames],
      blockName
    };
  }
  function setDefaultBlockName(name) {
    return {
      type: "SET_DEFAULT_BLOCK_NAME",
      name
    };
  }
  function setFreeformFallbackBlockName(name) {
    return {
      type: "SET_FREEFORM_FALLBACK_BLOCK_NAME",
      name
    };
  }
  function setUnregisteredFallbackBlockName(name) {
    return {
      type: "SET_UNREGISTERED_FALLBACK_BLOCK_NAME",
      name
    };
  }
  function setGroupingBlockName(name) {
    return {
      type: "SET_GROUPING_BLOCK_NAME",
      name
    };
  }
  function setCategories(categories2) {
    return {
      type: "SET_CATEGORIES",
      categories: categories2
    };
  }
  function updateCategory(slug, category) {
    return {
      type: "UPDATE_CATEGORY",
      slug,
      category
    };
  }
  function addBlockCollection(namespace, title, icon) {
    return {
      type: "ADD_BLOCK_COLLECTION",
      namespace,
      title,
      icon
    };
  }
  function removeBlockCollection(namespace) {
    return {
      type: "REMOVE_BLOCK_COLLECTION",
      namespace
    };
  }

  // node_modules/@wordpress/blocks/build-module/store/constants.js
  var STORE_NAME = "core/blocks";

  // node_modules/@wordpress/blocks/build-module/store/index.js
  var store = createReduxStore(STORE_NAME, {
    reducer: reducer_default2,
    selectors: selectors_exports2,
    actions: actions_exports2
  });
  register(store);

  // node_modules/@wordpress/block-serialization-default-parser/build-module/index.js
  var document2;
  var offset2;
  var output2;
  var stack2;
  var tokenizer2 = /<!--\s+(\/)?wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/g;
  function Block(blockName, attrs2, innerBlocks, innerHTML, innerContent) {
    return {
      blockName,
      attrs: attrs2,
      innerBlocks,
      innerHTML,
      innerContent
    };
  }
  function Freeform(innerHTML) {
    return Block(null, {}, [], innerHTML, [innerHTML]);
  }
  function Frame(block4, tokenStart, tokenLength, prevOffset, leadingHtmlStart) {
    return {
      block: block4,
      tokenStart,
      tokenLength,
      prevOffset: prevOffset || tokenStart + tokenLength,
      leadingHtmlStart
    };
  }
  var parse = (doc) => {
    document2 = doc;
    offset2 = 0;
    output2 = [];
    stack2 = [];
    tokenizer2.lastIndex = 0;
    do {
    } while (proceed2());
    return output2;
  };
  function proceed2() {
    const stackDepth = stack2.length;
    const next2 = nextToken2();
    const [tokenType, blockName, attrs2, startOffset, tokenLength] = next2;
    const leadingHtmlStart = startOffset > offset2 ? offset2 : null;
    switch (tokenType) {
      case "no-more-tokens":
        if (0 === stackDepth) {
          addFreeform();
          return false;
        }
        if (1 === stackDepth) {
          addBlockFromStack();
          return false;
        }
        while (0 < stack2.length) {
          addBlockFromStack();
        }
        return false;
      case "void-block":
        if (0 === stackDepth) {
          if (null !== leadingHtmlStart) {
            output2.push(Freeform(document2.substr(leadingHtmlStart, startOffset - leadingHtmlStart)));
          }
          output2.push(Block(blockName, attrs2, [], "", []));
          offset2 = startOffset + tokenLength;
          return true;
        }
        addInnerBlock(Block(blockName, attrs2, [], "", []), startOffset, tokenLength);
        offset2 = startOffset + tokenLength;
        return true;
      case "block-opener":
        stack2.push(Frame(Block(blockName, attrs2, [], "", []), startOffset, tokenLength, startOffset + tokenLength, leadingHtmlStart));
        offset2 = startOffset + tokenLength;
        return true;
      case "block-closer":
        if (0 === stackDepth) {
          addFreeform();
          return false;
        }
        if (1 === stackDepth) {
          addBlockFromStack(startOffset);
          offset2 = startOffset + tokenLength;
          return true;
        }
        const stackTop = stack2.pop();
        const html2 = document2.substr(stackTop.prevOffset, startOffset - stackTop.prevOffset);
        stackTop.block.innerHTML += html2;
        stackTop.block.innerContent.push(html2);
        stackTop.prevOffset = startOffset + tokenLength;
        addInnerBlock(stackTop.block, stackTop.tokenStart, stackTop.tokenLength, startOffset + tokenLength);
        offset2 = startOffset + tokenLength;
        return true;
      default:
        addFreeform();
        return false;
    }
  }
  function parseJSON(input) {
    try {
      return JSON.parse(input);
    } catch (e4) {
      return null;
    }
  }
  function nextToken2() {
    const matches2 = tokenizer2.exec(document2);
    if (null === matches2) {
      return ["no-more-tokens", "", null, 0, 0];
    }
    const startedAt = matches2.index;
    const [
      match,
      closerMatch,
      namespaceMatch,
      nameMatch,
      attrsMatch,
      ,
      voidMatch
    ] = matches2;
    const length = match.length;
    const isCloser = !!closerMatch;
    const isVoid = !!voidMatch;
    const namespace = namespaceMatch || "core/";
    const name = namespace + nameMatch;
    const hasAttrs = !!attrsMatch;
    const attrs2 = hasAttrs ? parseJSON(attrsMatch) : {};
    if (isCloser && (isVoid || hasAttrs)) {
    }
    if (isVoid) {
      return ["void-block", name, attrs2, startedAt, length];
    }
    if (isCloser) {
      return ["block-closer", name, null, startedAt, length];
    }
    return ["block-opener", name, attrs2, startedAt, length];
  }
  function addFreeform(rawLength) {
    const length = rawLength ? rawLength : document2.length - offset2;
    if (0 === length) {
      return;
    }
    output2.push(Freeform(document2.substr(offset2, length)));
  }
  function addInnerBlock(block4, tokenStart, tokenLength, lastOffset) {
    const parent = stack2[stack2.length - 1];
    parent.block.innerBlocks.push(block4);
    const html2 = document2.substr(parent.prevOffset, tokenStart - parent.prevOffset);
    if (html2) {
      parent.block.innerHTML += html2;
      parent.block.innerContent.push(html2);
    }
    parent.block.innerContent.push(null);
    parent.prevOffset = lastOffset ? lastOffset : tokenStart + tokenLength;
  }
  function addBlockFromStack(endOffset) {
    const {
      block: block4,
      leadingHtmlStart,
      prevOffset,
      tokenStart
    } = stack2.pop();
    const html2 = endOffset ? document2.substr(prevOffset, endOffset - prevOffset) : document2.substr(prevOffset);
    if (html2) {
      block4.innerHTML += html2;
      block4.innerContent.push(html2);
    }
    if (null !== leadingHtmlStart) {
      output2.push(Freeform(document2.substr(leadingHtmlStart, tokenStart - leadingHtmlStart)));
    }
    output2.push(block4);
  }

  // node_modules/@wordpress/autop/build-module/index.js
  var htmlSplitRegex = (() => {
    const comments = "!(?:-(?!->)[^\\-]*)*(?:-->)?";
    const cdata = "!\\[CDATA\\[[^\\]]*(?:](?!]>)[^\\]]*)*?(?:]]>)?";
    const escaped = "(?=!--|!\\[CDATA\\[)((?=!-)" + comments + "|" + cdata + ")";
    const regex = "(<(" + escaped + "|[^>]*>?))";
    return new RegExp(regex);
  })();
  function htmlSplit(input) {
    const parts = [];
    let workingInput = input;
    let match;
    while (match = workingInput.match(htmlSplitRegex)) {
      const index2 = match.index;
      parts.push(workingInput.slice(0, index2));
      parts.push(match[0]);
      workingInput = workingInput.slice(index2 + match[0].length);
    }
    if (workingInput.length) {
      parts.push(workingInput);
    }
    return parts;
  }
  function replaceInHtmlTags(haystack, replacePairs) {
    const textArr = htmlSplit(haystack);
    let changed = false;
    const needles = Object.keys(replacePairs);
    for (let i5 = 1; i5 < textArr.length; i5 += 2) {
      for (let j2 = 0; j2 < needles.length; j2++) {
        const needle = needles[j2];
        if (-1 !== textArr[i5].indexOf(needle)) {
          textArr[i5] = textArr[i5].replace(new RegExp(needle, "g"), replacePairs[needle]);
          changed = true;
          break;
        }
      }
    }
    if (changed) {
      haystack = textArr.join("");
    }
    return haystack;
  }
  function autop(text3) {
    let br = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const preTags = [];
    if (text3.trim() === "") {
      return "";
    }
    text3 = text3 + "\n";
    if (text3.indexOf("<pre") !== -1) {
      const textParts = text3.split("</pre>");
      const lastText = textParts.pop();
      text3 = "";
      for (let i5 = 0; i5 < textParts.length; i5++) {
        const textPart = textParts[i5];
        const start2 = textPart.indexOf("<pre");
        if (start2 === -1) {
          text3 += textPart;
          continue;
        }
        const name = "<pre wp-pre-tag-" + i5 + "></pre>";
        preTags.push([name, textPart.substr(start2) + "</pre>"]);
        text3 += textPart.substr(0, start2) + name;
      }
      text3 += lastText;
    }
    text3 = text3.replace(/<br\s*\/?>\s*<br\s*\/?>/g, "\n\n");
    const allBlocks = "(?:table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|form|map|area|blockquote|address|math|style|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary)";
    text3 = text3.replace(new RegExp("(<" + allBlocks + "[\\s/>])", "g"), "\n\n$1");
    text3 = text3.replace(new RegExp("(</" + allBlocks + ">)", "g"), "$1\n\n");
    text3 = text3.replace(/\r\n|\r/g, "\n");
    text3 = replaceInHtmlTags(text3, {
      "\n": " <!-- wpnl --> "
    });
    if (text3.indexOf("<option") !== -1) {
      text3 = text3.replace(/\s*<option/g, "<option");
      text3 = text3.replace(/<\/option>\s*/g, "</option>");
    }
    if (text3.indexOf("</object>") !== -1) {
      text3 = text3.replace(/(<object[^>]*>)\s*/g, "$1");
      text3 = text3.replace(/\s*<\/object>/g, "</object>");
      text3 = text3.replace(/\s*(<\/?(?:param|embed)[^>]*>)\s*/g, "$1");
    }
    if (text3.indexOf("<source") !== -1 || text3.indexOf("<track") !== -1) {
      text3 = text3.replace(/([<\[](?:audio|video)[^>\]]*[>\]])\s*/g, "$1");
      text3 = text3.replace(/\s*([<\[]\/(?:audio|video)[>\]])/g, "$1");
      text3 = text3.replace(/\s*(<(?:source|track)[^>]*>)\s*/g, "$1");
    }
    if (text3.indexOf("<figcaption") !== -1) {
      text3 = text3.replace(/\s*(<figcaption[^>]*>)/, "$1");
      text3 = text3.replace(/<\/figcaption>\s*/, "</figcaption>");
    }
    text3 = text3.replace(/\n\n+/g, "\n\n");
    const texts = text3.split(/\n\s*\n/).filter(Boolean);
    text3 = "";
    texts.forEach((textPiece) => {
      text3 += "<p>" + textPiece.replace(/^\n*|\n*$/g, "") + "</p>\n";
    });
    text3 = text3.replace(/<p>\s*<\/p>/g, "");
    text3 = text3.replace(/<p>([^<]+)<\/(div|address|form)>/g, "<p>$1</p></$2>");
    text3 = text3.replace(new RegExp("<p>\\s*(</?" + allBlocks + "[^>]*>)\\s*</p>", "g"), "$1");
    text3 = text3.replace(/<p>(<li.+?)<\/p>/g, "$1");
    text3 = text3.replace(/<p><blockquote([^>]*)>/gi, "<blockquote$1><p>");
    text3 = text3.replace(/<\/blockquote><\/p>/g, "</p></blockquote>");
    text3 = text3.replace(new RegExp("<p>\\s*(</?" + allBlocks + "[^>]*>)", "g"), "$1");
    text3 = text3.replace(new RegExp("(</?" + allBlocks + "[^>]*>)\\s*</p>", "g"), "$1");
    if (br) {
      text3 = text3.replace(/<(script|style).*?<\/\\1>/g, (match) => match[0].replace(/\n/g, "<WPPreserveNewline />"));
      text3 = text3.replace(/<br>|<br\/>/g, "<br />");
      text3 = text3.replace(/(<br \/>)?\s*\n/g, (a6, b6) => b6 ? a6 : "<br />\n");
      text3 = text3.replace(/<WPPreserveNewline \/>/g, "\n");
    }
    text3 = text3.replace(new RegExp("(</?" + allBlocks + "[^>]*>)\\s*<br />", "g"), "$1");
    text3 = text3.replace(/<br \/>(\s*<\/?(?:p|li|div|dl|dd|dt|th|pre|td|ul|ol)[^>]*>)/g, "$1");
    text3 = text3.replace(/\n<\/p>$/g, "</p>");
    preTags.forEach((preTag) => {
      const [name, original] = preTag;
      text3 = text3.replace(name, original);
    });
    if (-1 !== text3.indexOf("<!-- wpnl -->")) {
      text3 = text3.replace(/\s?<!-- wpnl -->\s?/g, "\n");
    }
    return text3;
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/serialize-raw-block.js
  function serializeRawBlock(rawBlock) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      isCommentDelimited = true
    } = options;
    const {
      blockName,
      attrs: attrs2 = {},
      innerBlocks = [],
      innerContent = []
    } = rawBlock;
    let childIndex = 0;
    const content = innerContent.map((item2) => item2 !== null ? item2 : serializeRawBlock(innerBlocks[childIndex++], options)).join("\n").replace(/\n+/g, "\n").trim();
    return isCommentDelimited ? getCommentDelimitedContent(blockName, attrs2, content) : content;
  }

  // node_modules/@wordpress/blocks/build-module/api/serializer.js
  function getBlockDefaultClassName(blockName) {
    const className = "wp-block-" + blockName.replace(/\//, "-").replace(/^core-/, "");
    return applyFilters("blocks.getBlockDefaultClassName", className, blockName);
  }
  function getBlockMenuDefaultClassName(blockName) {
    const className = "editor-block-list-item-" + blockName.replace(/\//, "-").replace(/^core-/, "");
    return applyFilters("blocks.getBlockMenuDefaultClassName", className, blockName);
  }
  var blockPropsProvider = {};
  var innerBlocksPropsProvider = {};
  function getBlockProps() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      blockType,
      attributes
    } = blockPropsProvider;
    return applyFilters("blocks.getSaveContent.extraProps", {
      ...props
    }, blockType, attributes);
  }
  function getInnerBlocksProps() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      innerBlocks
    } = innerBlocksPropsProvider;
    const html2 = serialize(innerBlocks, {
      isInnerBlocks: true
    });
    const children = (0, import_react.createElement)(RawHTML, null, html2);
    return {
      ...props,
      children
    };
  }
  function getSaveElement(blockTypeOrName, attributes) {
    let innerBlocks = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    const blockType = normalizeBlockType(blockTypeOrName);
    let {
      save
    } = blockType;
    if (save.prototype instanceof import_react.Component) {
      const instance = new save({
        attributes
      });
      save = instance.render.bind(instance);
    }
    blockPropsProvider.blockType = blockType;
    blockPropsProvider.attributes = attributes;
    innerBlocksPropsProvider.innerBlocks = innerBlocks;
    let element = save({
      attributes,
      innerBlocks
    });
    if (element !== null && typeof element === "object" && hasFilter("blocks.getSaveContent.extraProps") && !(blockType.apiVersion > 1)) {
      const props = applyFilters("blocks.getSaveContent.extraProps", {
        ...element.props
      }, blockType, attributes);
      if (!isShallowEqual(props, element.props)) {
        element = (0, import_react.cloneElement)(element, props);
      }
    }
    return applyFilters("blocks.getSaveElement", element, blockType, attributes);
  }
  function getSaveContent(blockTypeOrName, attributes, innerBlocks) {
    const blockType = normalizeBlockType(blockTypeOrName);
    return serialize_default(getSaveElement(blockType, attributes, innerBlocks));
  }
  function getCommentAttributes(blockType, attributes) {
    var _blockType$attributes;
    return Object.entries((_blockType$attributes = blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}).reduce((accumulator, _ref8) => {
      let [key, attributeSchema] = _ref8;
      const value = attributes[key];
      if (void 0 === value) {
        return accumulator;
      }
      if (attributeSchema.source !== void 0) {
        return accumulator;
      }
      if ("default" in attributeSchema && attributeSchema.default === value) {
        return accumulator;
      }
      accumulator[key] = value;
      return accumulator;
    }, {});
  }
  function serializeAttributes(attributes) {
    return JSON.stringify(attributes).replace(/--/g, "\\u002d\\u002d").replace(/</g, "\\u003c").replace(/>/g, "\\u003e").replace(/&/g, "\\u0026").replace(/\\"/g, "\\u0022");
  }
  function getBlockInnerHTML(block4) {
    let saveContent = block4.originalContent;
    if (block4.isValid || block4.innerBlocks.length) {
      try {
        saveContent = getSaveContent(block4.name, block4.attributes, block4.innerBlocks);
      } catch (error2) {
      }
    }
    return saveContent;
  }
  function getCommentDelimitedContent(rawBlockName, attributes, content) {
    const serializedAttributes = attributes && Object.entries(attributes).length ? serializeAttributes(attributes) + " " : "";
    const blockName = rawBlockName !== null && rawBlockName !== void 0 && rawBlockName.startsWith("core/") ? rawBlockName.slice(5) : rawBlockName;
    if (!content) {
      return `<!-- wp:${blockName} ${serializedAttributes}/-->`;
    }
    return `<!-- wp:${blockName} ${serializedAttributes}-->
` + content + `
<!-- /wp:${blockName} -->`;
  }
  function serializeBlock(block4) {
    let {
      isInnerBlocks = false
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!block4.isValid && block4.__unstableBlockSource) {
      return serializeRawBlock(block4.__unstableBlockSource);
    }
    const blockName = block4.name;
    const saveContent = getBlockInnerHTML(block4);
    if (blockName === getUnregisteredTypeHandlerName() || !isInnerBlocks && blockName === getFreeformContentHandlerName()) {
      return saveContent;
    }
    const blockType = getBlockType(blockName);
    if (!blockType) {
      return saveContent;
    }
    const saveAttributes = getCommentAttributes(blockType, block4.attributes);
    return getCommentDelimitedContent(blockName, saveAttributes, saveContent);
  }
  function serialize(blocks2, options) {
    const blocksArray = Array.isArray(blocks2) ? blocks2 : [blocks2];
    return blocksArray.map((block4) => serializeBlock(block4, options)).join("\n\n");
  }

  // node_modules/simple-html-tokenizer/dist/es6/index.js
  var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
  var CHARCODE = /^#([0-9]+)$/;
  var NAMED = /^([A-Za-z0-9]+)$/;
  var EntityParser = function() {
    function EntityParser2(named) {
      this.named = named;
    }
    EntityParser2.prototype.parse = function(entity) {
      if (!entity) {
        return;
      }
      var matches2 = entity.match(HEXCHARCODE);
      if (matches2) {
        return String.fromCharCode(parseInt(matches2[1], 16));
      }
      matches2 = entity.match(CHARCODE);
      if (matches2) {
        return String.fromCharCode(parseInt(matches2[1], 10));
      }
      matches2 = entity.match(NAMED);
      if (matches2) {
        return this.named[matches2[1]];
      }
    };
    return EntityParser2;
  }();
  var WSP = /[\t\n\f ]/;
  var ALPHA = /[A-Za-z]/;
  var CRLF = /\r\n?/g;
  function isSpace(char) {
    return WSP.test(char);
  }
  function isAlpha(char) {
    return ALPHA.test(char);
  }
  function preprocessInput(input) {
    return input.replace(CRLF, "\n");
  }
  var EventedTokenizer = function() {
    function EventedTokenizer2(delegate, entityParser, mode) {
      if (mode === void 0) {
        mode = "precompile";
      }
      this.delegate = delegate;
      this.entityParser = entityParser;
      this.mode = mode;
      this.state = "beforeData";
      this.line = -1;
      this.column = -1;
      this.input = "";
      this.index = -1;
      this.tagNameBuffer = "";
      this.states = {
        beforeData: function() {
          var char = this.peek();
          if (char === "<" && !this.isIgnoredEndTag()) {
            this.transitionTo("tagOpen");
            this.markTagStart();
            this.consume();
          } else {
            if (this.mode === "precompile" && char === "\n") {
              var tag = this.tagNameBuffer.toLowerCase();
              if (tag === "pre" || tag === "textarea") {
                this.consume();
              }
            }
            this.transitionTo("data");
            this.delegate.beginData();
          }
        },
        data: function() {
          var char = this.peek();
          var tag = this.tagNameBuffer;
          if (char === "<" && !this.isIgnoredEndTag()) {
            this.delegate.finishData();
            this.transitionTo("tagOpen");
            this.markTagStart();
            this.consume();
          } else if (char === "&" && tag !== "script" && tag !== "style") {
            this.consume();
            this.delegate.appendToData(this.consumeCharRef() || "&");
          } else {
            this.consume();
            this.delegate.appendToData(char);
          }
        },
        tagOpen: function() {
          var char = this.consume();
          if (char === "!") {
            this.transitionTo("markupDeclarationOpen");
          } else if (char === "/") {
            this.transitionTo("endTagOpen");
          } else if (char === "@" || char === ":" || isAlpha(char)) {
            this.transitionTo("tagName");
            this.tagNameBuffer = "";
            this.delegate.beginStartTag();
            this.appendToTagName(char);
          }
        },
        markupDeclarationOpen: function() {
          var char = this.consume();
          if (char === "-" && this.peek() === "-") {
            this.consume();
            this.transitionTo("commentStart");
            this.delegate.beginComment();
          } else {
            var maybeDoctype = char.toUpperCase() + this.input.substring(this.index, this.index + 6).toUpperCase();
            if (maybeDoctype === "DOCTYPE") {
              this.consume();
              this.consume();
              this.consume();
              this.consume();
              this.consume();
              this.consume();
              this.transitionTo("doctype");
              if (this.delegate.beginDoctype)
                this.delegate.beginDoctype();
            }
          }
        },
        doctype: function() {
          var char = this.consume();
          if (isSpace(char)) {
            this.transitionTo("beforeDoctypeName");
          }
        },
        beforeDoctypeName: function() {
          var char = this.consume();
          if (isSpace(char)) {
            return;
          } else {
            this.transitionTo("doctypeName");
            if (this.delegate.appendToDoctypeName)
              this.delegate.appendToDoctypeName(char.toLowerCase());
          }
        },
        doctypeName: function() {
          var char = this.consume();
          if (isSpace(char)) {
            this.transitionTo("afterDoctypeName");
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else {
            if (this.delegate.appendToDoctypeName)
              this.delegate.appendToDoctypeName(char.toLowerCase());
          }
        },
        afterDoctypeName: function() {
          var char = this.consume();
          if (isSpace(char)) {
            return;
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else {
            var nextSixChars = char.toUpperCase() + this.input.substring(this.index, this.index + 5).toUpperCase();
            var isPublic = nextSixChars.toUpperCase() === "PUBLIC";
            var isSystem = nextSixChars.toUpperCase() === "SYSTEM";
            if (isPublic || isSystem) {
              this.consume();
              this.consume();
              this.consume();
              this.consume();
              this.consume();
              this.consume();
            }
            if (isPublic) {
              this.transitionTo("afterDoctypePublicKeyword");
            } else if (isSystem) {
              this.transitionTo("afterDoctypeSystemKeyword");
            }
          }
        },
        afterDoctypePublicKeyword: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.transitionTo("beforeDoctypePublicIdentifier");
            this.consume();
          } else if (char === '"') {
            this.transitionTo("doctypePublicIdentifierDoubleQuoted");
            this.consume();
          } else if (char === "'") {
            this.transitionTo("doctypePublicIdentifierSingleQuoted");
            this.consume();
          } else if (char === ">") {
            this.consume();
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          }
        },
        doctypePublicIdentifierDoubleQuoted: function() {
          var char = this.consume();
          if (char === '"') {
            this.transitionTo("afterDoctypePublicIdentifier");
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else {
            if (this.delegate.appendToDoctypePublicIdentifier)
              this.delegate.appendToDoctypePublicIdentifier(char);
          }
        },
        doctypePublicIdentifierSingleQuoted: function() {
          var char = this.consume();
          if (char === "'") {
            this.transitionTo("afterDoctypePublicIdentifier");
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else {
            if (this.delegate.appendToDoctypePublicIdentifier)
              this.delegate.appendToDoctypePublicIdentifier(char);
          }
        },
        afterDoctypePublicIdentifier: function() {
          var char = this.consume();
          if (isSpace(char)) {
            this.transitionTo("betweenDoctypePublicAndSystemIdentifiers");
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else if (char === '"') {
            this.transitionTo("doctypeSystemIdentifierDoubleQuoted");
          } else if (char === "'") {
            this.transitionTo("doctypeSystemIdentifierSingleQuoted");
          }
        },
        betweenDoctypePublicAndSystemIdentifiers: function() {
          var char = this.consume();
          if (isSpace(char)) {
            return;
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else if (char === '"') {
            this.transitionTo("doctypeSystemIdentifierDoubleQuoted");
          } else if (char === "'") {
            this.transitionTo("doctypeSystemIdentifierSingleQuoted");
          }
        },
        doctypeSystemIdentifierDoubleQuoted: function() {
          var char = this.consume();
          if (char === '"') {
            this.transitionTo("afterDoctypeSystemIdentifier");
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else {
            if (this.delegate.appendToDoctypeSystemIdentifier)
              this.delegate.appendToDoctypeSystemIdentifier(char);
          }
        },
        doctypeSystemIdentifierSingleQuoted: function() {
          var char = this.consume();
          if (char === "'") {
            this.transitionTo("afterDoctypeSystemIdentifier");
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          } else {
            if (this.delegate.appendToDoctypeSystemIdentifier)
              this.delegate.appendToDoctypeSystemIdentifier(char);
          }
        },
        afterDoctypeSystemIdentifier: function() {
          var char = this.consume();
          if (isSpace(char)) {
            return;
          } else if (char === ">") {
            if (this.delegate.endDoctype)
              this.delegate.endDoctype();
            this.transitionTo("beforeData");
          }
        },
        commentStart: function() {
          var char = this.consume();
          if (char === "-") {
            this.transitionTo("commentStartDash");
          } else if (char === ">") {
            this.delegate.finishComment();
            this.transitionTo("beforeData");
          } else {
            this.delegate.appendToCommentData(char);
            this.transitionTo("comment");
          }
        },
        commentStartDash: function() {
          var char = this.consume();
          if (char === "-") {
            this.transitionTo("commentEnd");
          } else if (char === ">") {
            this.delegate.finishComment();
            this.transitionTo("beforeData");
          } else {
            this.delegate.appendToCommentData("-");
            this.transitionTo("comment");
          }
        },
        comment: function() {
          var char = this.consume();
          if (char === "-") {
            this.transitionTo("commentEndDash");
          } else {
            this.delegate.appendToCommentData(char);
          }
        },
        commentEndDash: function() {
          var char = this.consume();
          if (char === "-") {
            this.transitionTo("commentEnd");
          } else {
            this.delegate.appendToCommentData("-" + char);
            this.transitionTo("comment");
          }
        },
        commentEnd: function() {
          var char = this.consume();
          if (char === ">") {
            this.delegate.finishComment();
            this.transitionTo("beforeData");
          } else {
            this.delegate.appendToCommentData("--" + char);
            this.transitionTo("comment");
          }
        },
        tagName: function() {
          var char = this.consume();
          if (isSpace(char)) {
            this.transitionTo("beforeAttributeName");
          } else if (char === "/") {
            this.transitionTo("selfClosingStartTag");
          } else if (char === ">") {
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else {
            this.appendToTagName(char);
          }
        },
        endTagName: function() {
          var char = this.consume();
          if (isSpace(char)) {
            this.transitionTo("beforeAttributeName");
            this.tagNameBuffer = "";
          } else if (char === "/") {
            this.transitionTo("selfClosingStartTag");
            this.tagNameBuffer = "";
          } else if (char === ">") {
            this.delegate.finishTag();
            this.transitionTo("beforeData");
            this.tagNameBuffer = "";
          } else {
            this.appendToTagName(char);
          }
        },
        beforeAttributeName: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.consume();
            return;
          } else if (char === "/") {
            this.transitionTo("selfClosingStartTag");
            this.consume();
          } else if (char === ">") {
            this.consume();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else if (char === "=") {
            this.delegate.reportSyntaxError("attribute name cannot start with equals sign");
            this.transitionTo("attributeName");
            this.delegate.beginAttribute();
            this.consume();
            this.delegate.appendToAttributeName(char);
          } else {
            this.transitionTo("attributeName");
            this.delegate.beginAttribute();
          }
        },
        attributeName: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.transitionTo("afterAttributeName");
            this.consume();
          } else if (char === "/") {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.transitionTo("selfClosingStartTag");
          } else if (char === "=") {
            this.transitionTo("beforeAttributeValue");
            this.consume();
          } else if (char === ">") {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else if (char === '"' || char === "'" || char === "<") {
            this.delegate.reportSyntaxError(char + " is not a valid character within attribute names");
            this.consume();
            this.delegate.appendToAttributeName(char);
          } else {
            this.consume();
            this.delegate.appendToAttributeName(char);
          }
        },
        afterAttributeName: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.consume();
            return;
          } else if (char === "/") {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.transitionTo("selfClosingStartTag");
          } else if (char === "=") {
            this.consume();
            this.transitionTo("beforeAttributeValue");
          } else if (char === ">") {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.transitionTo("attributeName");
            this.delegate.beginAttribute();
            this.consume();
            this.delegate.appendToAttributeName(char);
          }
        },
        beforeAttributeValue: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.consume();
          } else if (char === '"') {
            this.transitionTo("attributeValueDoubleQuoted");
            this.delegate.beginAttributeValue(true);
            this.consume();
          } else if (char === "'") {
            this.transitionTo("attributeValueSingleQuoted");
            this.delegate.beginAttributeValue(true);
            this.consume();
          } else if (char === ">") {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else {
            this.transitionTo("attributeValueUnquoted");
            this.delegate.beginAttributeValue(false);
            this.consume();
            this.delegate.appendToAttributeValue(char);
          }
        },
        attributeValueDoubleQuoted: function() {
          var char = this.consume();
          if (char === '"') {
            this.delegate.finishAttributeValue();
            this.transitionTo("afterAttributeValueQuoted");
          } else if (char === "&") {
            this.delegate.appendToAttributeValue(this.consumeCharRef() || "&");
          } else {
            this.delegate.appendToAttributeValue(char);
          }
        },
        attributeValueSingleQuoted: function() {
          var char = this.consume();
          if (char === "'") {
            this.delegate.finishAttributeValue();
            this.transitionTo("afterAttributeValueQuoted");
          } else if (char === "&") {
            this.delegate.appendToAttributeValue(this.consumeCharRef() || "&");
          } else {
            this.delegate.appendToAttributeValue(char);
          }
        },
        attributeValueUnquoted: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.delegate.finishAttributeValue();
            this.consume();
            this.transitionTo("beforeAttributeName");
          } else if (char === "/") {
            this.delegate.finishAttributeValue();
            this.consume();
            this.transitionTo("selfClosingStartTag");
          } else if (char === "&") {
            this.consume();
            this.delegate.appendToAttributeValue(this.consumeCharRef() || "&");
          } else if (char === ">") {
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else {
            this.consume();
            this.delegate.appendToAttributeValue(char);
          }
        },
        afterAttributeValueQuoted: function() {
          var char = this.peek();
          if (isSpace(char)) {
            this.consume();
            this.transitionTo("beforeAttributeName");
          } else if (char === "/") {
            this.consume();
            this.transitionTo("selfClosingStartTag");
          } else if (char === ">") {
            this.consume();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else {
            this.transitionTo("beforeAttributeName");
          }
        },
        selfClosingStartTag: function() {
          var char = this.peek();
          if (char === ">") {
            this.consume();
            this.delegate.markTagAsSelfClosing();
            this.delegate.finishTag();
            this.transitionTo("beforeData");
          } else {
            this.transitionTo("beforeAttributeName");
          }
        },
        endTagOpen: function() {
          var char = this.consume();
          if (char === "@" || char === ":" || isAlpha(char)) {
            this.transitionTo("endTagName");
            this.tagNameBuffer = "";
            this.delegate.beginEndTag();
            this.appendToTagName(char);
          }
        }
      };
      this.reset();
    }
    EventedTokenizer2.prototype.reset = function() {
      this.transitionTo("beforeData");
      this.input = "";
      this.tagNameBuffer = "";
      this.index = 0;
      this.line = 1;
      this.column = 0;
      this.delegate.reset();
    };
    EventedTokenizer2.prototype.transitionTo = function(state) {
      this.state = state;
    };
    EventedTokenizer2.prototype.tokenize = function(input) {
      this.reset();
      this.tokenizePart(input);
      this.tokenizeEOF();
    };
    EventedTokenizer2.prototype.tokenizePart = function(input) {
      this.input += preprocessInput(input);
      while (this.index < this.input.length) {
        var handler = this.states[this.state];
        if (handler !== void 0) {
          handler.call(this);
        } else {
          throw new Error("unhandled state " + this.state);
        }
      }
    };
    EventedTokenizer2.prototype.tokenizeEOF = function() {
      this.flushData();
    };
    EventedTokenizer2.prototype.flushData = function() {
      if (this.state === "data") {
        this.delegate.finishData();
        this.transitionTo("beforeData");
      }
    };
    EventedTokenizer2.prototype.peek = function() {
      return this.input.charAt(this.index);
    };
    EventedTokenizer2.prototype.consume = function() {
      var char = this.peek();
      this.index++;
      if (char === "\n") {
        this.line++;
        this.column = 0;
      } else {
        this.column++;
      }
      return char;
    };
    EventedTokenizer2.prototype.consumeCharRef = function() {
      var endIndex = this.input.indexOf(";", this.index);
      if (endIndex === -1) {
        return;
      }
      var entity = this.input.slice(this.index, endIndex);
      var chars = this.entityParser.parse(entity);
      if (chars) {
        var count = entity.length;
        while (count) {
          this.consume();
          count--;
        }
        this.consume();
        return chars;
      }
    };
    EventedTokenizer2.prototype.markTagStart = function() {
      this.delegate.tagOpen();
    };
    EventedTokenizer2.prototype.appendToTagName = function(char) {
      this.tagNameBuffer += char;
      this.delegate.appendToTagName(char);
    };
    EventedTokenizer2.prototype.isIgnoredEndTag = function() {
      var tag = this.tagNameBuffer;
      return tag === "title" && this.input.substring(this.index, this.index + 8) !== "</title>" || tag === "style" && this.input.substring(this.index, this.index + 8) !== "</style>" || tag === "script" && this.input.substring(this.index, this.index + 9) !== "<\/script>";
    };
    return EventedTokenizer2;
  }();
  var Tokenizer = function() {
    function Tokenizer2(entityParser, options) {
      if (options === void 0) {
        options = {};
      }
      this.options = options;
      this.token = null;
      this.startLine = 1;
      this.startColumn = 0;
      this.tokens = [];
      this.tokenizer = new EventedTokenizer(this, entityParser, options.mode);
      this._currentAttribute = void 0;
    }
    Tokenizer2.prototype.tokenize = function(input) {
      this.tokens = [];
      this.tokenizer.tokenize(input);
      return this.tokens;
    };
    Tokenizer2.prototype.tokenizePart = function(input) {
      this.tokens = [];
      this.tokenizer.tokenizePart(input);
      return this.tokens;
    };
    Tokenizer2.prototype.tokenizeEOF = function() {
      this.tokens = [];
      this.tokenizer.tokenizeEOF();
      return this.tokens[0];
    };
    Tokenizer2.prototype.reset = function() {
      this.token = null;
      this.startLine = 1;
      this.startColumn = 0;
    };
    Tokenizer2.prototype.current = function() {
      var token = this.token;
      if (token === null) {
        throw new Error("token was unexpectedly null");
      }
      if (arguments.length === 0) {
        return token;
      }
      for (var i5 = 0; i5 < arguments.length; i5++) {
        if (token.type === arguments[i5]) {
          return token;
        }
      }
      throw new Error("token type was unexpectedly " + token.type);
    };
    Tokenizer2.prototype.push = function(token) {
      this.token = token;
      this.tokens.push(token);
    };
    Tokenizer2.prototype.currentAttribute = function() {
      return this._currentAttribute;
    };
    Tokenizer2.prototype.addLocInfo = function() {
      if (this.options.loc) {
        this.current().loc = {
          start: {
            line: this.startLine,
            column: this.startColumn
          },
          end: {
            line: this.tokenizer.line,
            column: this.tokenizer.column
          }
        };
      }
      this.startLine = this.tokenizer.line;
      this.startColumn = this.tokenizer.column;
    };
    Tokenizer2.prototype.beginDoctype = function() {
      this.push({
        type: "Doctype",
        name: ""
      });
    };
    Tokenizer2.prototype.appendToDoctypeName = function(char) {
      this.current("Doctype").name += char;
    };
    Tokenizer2.prototype.appendToDoctypePublicIdentifier = function(char) {
      var doctype = this.current("Doctype");
      if (doctype.publicIdentifier === void 0) {
        doctype.publicIdentifier = char;
      } else {
        doctype.publicIdentifier += char;
      }
    };
    Tokenizer2.prototype.appendToDoctypeSystemIdentifier = function(char) {
      var doctype = this.current("Doctype");
      if (doctype.systemIdentifier === void 0) {
        doctype.systemIdentifier = char;
      } else {
        doctype.systemIdentifier += char;
      }
    };
    Tokenizer2.prototype.endDoctype = function() {
      this.addLocInfo();
    };
    Tokenizer2.prototype.beginData = function() {
      this.push({
        type: "Chars",
        chars: ""
      });
    };
    Tokenizer2.prototype.appendToData = function(char) {
      this.current("Chars").chars += char;
    };
    Tokenizer2.prototype.finishData = function() {
      this.addLocInfo();
    };
    Tokenizer2.prototype.beginComment = function() {
      this.push({
        type: "Comment",
        chars: ""
      });
    };
    Tokenizer2.prototype.appendToCommentData = function(char) {
      this.current("Comment").chars += char;
    };
    Tokenizer2.prototype.finishComment = function() {
      this.addLocInfo();
    };
    Tokenizer2.prototype.tagOpen = function() {
    };
    Tokenizer2.prototype.beginStartTag = function() {
      this.push({
        type: "StartTag",
        tagName: "",
        attributes: [],
        selfClosing: false
      });
    };
    Tokenizer2.prototype.beginEndTag = function() {
      this.push({
        type: "EndTag",
        tagName: ""
      });
    };
    Tokenizer2.prototype.finishTag = function() {
      this.addLocInfo();
    };
    Tokenizer2.prototype.markTagAsSelfClosing = function() {
      this.current("StartTag").selfClosing = true;
    };
    Tokenizer2.prototype.appendToTagName = function(char) {
      this.current("StartTag", "EndTag").tagName += char;
    };
    Tokenizer2.prototype.beginAttribute = function() {
      this._currentAttribute = ["", "", false];
    };
    Tokenizer2.prototype.appendToAttributeName = function(char) {
      this.currentAttribute()[0] += char;
    };
    Tokenizer2.prototype.beginAttributeValue = function(isQuoted) {
      this.currentAttribute()[2] = isQuoted;
    };
    Tokenizer2.prototype.appendToAttributeValue = function(char) {
      this.currentAttribute()[1] += char;
    };
    Tokenizer2.prototype.finishAttributeValue = function() {
      this.current("StartTag").attributes.push(this._currentAttribute);
    };
    Tokenizer2.prototype.reportSyntaxError = function(message) {
      this.current().syntaxError = message;
    };
    return Tokenizer2;
  }();

  // node_modules/@wordpress/blocks/build-module/api/validation/index.js
  var import_lodash11 = __toESM(require_lodash());

  // node_modules/@wordpress/html-entities/build-module/index.js
  var _decodeTextArea;
  function decodeEntities(html2) {
    if ("string" !== typeof html2 || -1 === html2.indexOf("&")) {
      return html2;
    }
    if (void 0 === _decodeTextArea) {
      if (document.implementation && document.implementation.createHTMLDocument) {
        _decodeTextArea = document.implementation.createHTMLDocument("").createElement("textarea");
      } else {
        _decodeTextArea = document.createElement("textarea");
      }
    }
    _decodeTextArea.innerHTML = html2;
    const decoded = _decodeTextArea.textContent;
    _decodeTextArea.innerHTML = "";
    return decoded;
  }

  // node_modules/@wordpress/blocks/build-module/api/validation/logger.js
  function createLogger() {
    function createLogHandler(logger) {
      let log = function(message) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return logger("Block validation: " + message, ...args);
      };
      if (false) {
        log = function() {
          return logger(null.format(...arguments));
        };
      }
      return log;
    }
    return {
      error: createLogHandler(console.error),
      warning: createLogHandler(console.warn),
      getItems() {
        return [];
      }
    };
  }
  function createQueuedLogger() {
    const queue = [];
    const logger = createLogger();
    return {
      error() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        queue.push({
          log: logger.error,
          args
        });
      },
      warning() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        queue.push({
          log: logger.warning,
          args
        });
      },
      getItems() {
        return queue;
      }
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/validation/index.js
  var identity = (x4) => x4;
  var REGEXP_WHITESPACE = /[\t\n\r\v\f ]+/g;
  var REGEXP_ONLY_WHITESPACE = /^[\t\n\r\v\f ]*$/;
  var REGEXP_STYLE_URL_TYPE = /^url\s*\(['"\s]*(.*?)['"\s]*\)$/;
  var BOOLEAN_ATTRIBUTES2 = ["allowfullscreen", "allowpaymentrequest", "allowusermedia", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "download", "formnovalidate", "hidden", "ismap", "itemscope", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected", "typemustmatch"];
  var ENUMERATED_ATTRIBUTES2 = ["autocapitalize", "autocomplete", "charset", "contenteditable", "crossorigin", "decoding", "dir", "draggable", "enctype", "formenctype", "formmethod", "http-equiv", "inputmode", "kind", "method", "preload", "scope", "shape", "spellcheck", "translate", "type", "wrap"];
  var MEANINGFUL_ATTRIBUTES = [...BOOLEAN_ATTRIBUTES2, ...ENUMERATED_ATTRIBUTES2];
  var TEXT_NORMALIZATIONS = [identity, getTextWithCollapsedWhitespace];
  var REGEXP_NAMED_CHARACTER_REFERENCE = /^[\da-z]+$/i;
  var REGEXP_DECIMAL_CHARACTER_REFERENCE = /^#\d+$/;
  var REGEXP_HEXADECIMAL_CHARACTER_REFERENCE = /^#x[\da-f]+$/i;
  function isValidCharacterReference(text3) {
    return REGEXP_NAMED_CHARACTER_REFERENCE.test(text3) || REGEXP_DECIMAL_CHARACTER_REFERENCE.test(text3) || REGEXP_HEXADECIMAL_CHARACTER_REFERENCE.test(text3);
  }
  var DecodeEntityParser = class {
    parse(entity) {
      if (isValidCharacterReference(entity)) {
        return decodeEntities("&" + entity + ";");
      }
    }
  };
  function getTextPiecesSplitOnWhitespace(text3) {
    return text3.trim().split(REGEXP_WHITESPACE);
  }
  function getTextWithCollapsedWhitespace(text3) {
    return getTextPiecesSplitOnWhitespace(text3).join(" ");
  }
  function getMeaningfulAttributePairs(token) {
    return token.attributes.filter((pair) => {
      const [key, value] = pair;
      return value || key.indexOf("data-") === 0 || MEANINGFUL_ATTRIBUTES.includes(key);
    });
  }
  function isEquivalentTextTokens(actual, expected) {
    let logger = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createLogger();
    let actualChars = actual.chars;
    let expectedChars = expected.chars;
    for (let i5 = 0; i5 < TEXT_NORMALIZATIONS.length; i5++) {
      const normalize = TEXT_NORMALIZATIONS[i5];
      actualChars = normalize(actualChars);
      expectedChars = normalize(expectedChars);
      if (actualChars === expectedChars) {
        return true;
      }
    }
    logger.warning("Expected text `%s`, saw `%s`.", expected.chars, actual.chars);
    return false;
  }
  function getNormalizedLength(value) {
    if (0 === parseFloat(value)) {
      return "0";
    }
    if (value.indexOf(".") === 0) {
      return "0" + value;
    }
    return value;
  }
  function getNormalizedStyleValue(value) {
    const textPieces = getTextPiecesSplitOnWhitespace(value);
    const normalizedPieces = textPieces.map(getNormalizedLength);
    const result = normalizedPieces.join(" ");
    return result.replace(REGEXP_STYLE_URL_TYPE, "url($1)");
  }
  function getStyleProperties(text3) {
    const pairs = text3.replace(/;?\s*$/, "").split(";").map((style) => {
      const [key, ...valueParts] = style.split(":");
      const value = valueParts.join(":");
      return [key.trim(), getNormalizedStyleValue(value.trim())];
    });
    return Object.fromEntries(pairs);
  }
  var isEqualAttributesOfName = {
    class: (actual, expected) => {
      const [actualPieces, expectedPieces] = [actual, expected].map(getTextPiecesSplitOnWhitespace);
      const actualDiff = actualPieces.filter((c6) => !expectedPieces.includes(c6));
      const expectedDiff = expectedPieces.filter((c6) => !actualPieces.includes(c6));
      return actualDiff.length === 0 && expectedDiff.length === 0;
    },
    style: (actual, expected) => {
      return (0, import_lodash11.isEqual)(...[actual, expected].map(getStyleProperties));
    },
    ...Object.fromEntries(BOOLEAN_ATTRIBUTES2.map((attribute) => [attribute, () => true]))
  };
  function isEqualTagAttributePairs(actual, expected) {
    let logger = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createLogger();
    if (actual.length !== expected.length) {
      logger.warning("Expected attributes %o, instead saw %o.", expected, actual);
      return false;
    }
    const expectedAttributes = {};
    for (let i5 = 0; i5 < expected.length; i5++) {
      expectedAttributes[expected[i5][0].toLowerCase()] = expected[i5][1];
    }
    for (let i5 = 0; i5 < actual.length; i5++) {
      const [name, actualValue] = actual[i5];
      const nameLower = name.toLowerCase();
      if (!expectedAttributes.hasOwnProperty(nameLower)) {
        logger.warning("Encountered unexpected attribute `%s`.", name);
        return false;
      }
      const expectedValue = expectedAttributes[nameLower];
      const isEqualAttributes = isEqualAttributesOfName[nameLower];
      if (isEqualAttributes) {
        if (!isEqualAttributes(actualValue, expectedValue)) {
          logger.warning("Expected attribute `%s` of value `%s`, saw `%s`.", name, expectedValue, actualValue);
          return false;
        }
      } else if (actualValue !== expectedValue) {
        logger.warning("Expected attribute `%s` of value `%s`, saw `%s`.", name, expectedValue, actualValue);
        return false;
      }
    }
    return true;
  }
  var isEqualTokensOfType = {
    StartTag: function(actual, expected) {
      let logger = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createLogger();
      if (actual.tagName !== expected.tagName && actual.tagName.toLowerCase() !== expected.tagName.toLowerCase()) {
        logger.warning("Expected tag name `%s`, instead saw `%s`.", expected.tagName, actual.tagName);
        return false;
      }
      return isEqualTagAttributePairs(...[actual, expected].map(getMeaningfulAttributePairs), logger);
    },
    Chars: isEquivalentTextTokens,
    Comment: isEquivalentTextTokens
  };
  function getNextNonWhitespaceToken(tokens) {
    let token;
    while (token = tokens.shift()) {
      if (token.type !== "Chars") {
        return token;
      }
      if (!REGEXP_ONLY_WHITESPACE.test(token.chars)) {
        return token;
      }
    }
  }
  function getHTMLTokens(html2) {
    let logger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createLogger();
    try {
      return new Tokenizer(new DecodeEntityParser()).tokenize(html2);
    } catch (e4) {
      logger.warning("Malformed HTML detected: %s", html2);
    }
    return null;
  }
  function isClosedByToken(currentToken, nextToken3) {
    if (!currentToken.selfClosing) {
      return false;
    }
    if (nextToken3 && nextToken3.tagName === currentToken.tagName && nextToken3.type === "EndTag") {
      return true;
    }
    return false;
  }
  function isEquivalentHTML(actual, expected) {
    let logger = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createLogger();
    if (actual === expected) {
      return true;
    }
    const [actualTokens, expectedTokens] = [actual, expected].map((html2) => getHTMLTokens(html2, logger));
    if (!actualTokens || !expectedTokens) {
      return false;
    }
    let actualToken, expectedToken;
    while (actualToken = getNextNonWhitespaceToken(actualTokens)) {
      expectedToken = getNextNonWhitespaceToken(expectedTokens);
      if (!expectedToken) {
        logger.warning("Expected end of content, instead saw %o.", actualToken);
        return false;
      }
      if (actualToken.type !== expectedToken.type) {
        logger.warning("Expected token of type `%s` (%o), instead saw `%s` (%o).", expectedToken.type, expectedToken, actualToken.type, actualToken);
        return false;
      }
      const isEqualTokens = isEqualTokensOfType[actualToken.type];
      if (isEqualTokens && !isEqualTokens(actualToken, expectedToken, logger)) {
        return false;
      }
      if (isClosedByToken(actualToken, expectedTokens[0])) {
        getNextNonWhitespaceToken(expectedTokens);
      } else if (isClosedByToken(expectedToken, actualTokens[0])) {
        getNextNonWhitespaceToken(actualTokens);
      }
    }
    if (expectedToken = getNextNonWhitespaceToken(expectedTokens)) {
      logger.warning("Expected %o, instead saw end of content.", expectedToken);
      return false;
    }
    return true;
  }
  function validateBlock(block4) {
    let blockTypeOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : block4.name;
    const isFallbackBlock = block4.name === getFreeformContentHandlerName() || block4.name === getUnregisteredTypeHandlerName();
    if (isFallbackBlock) {
      return [true, []];
    }
    const logger = createQueuedLogger();
    const blockType = normalizeBlockType(blockTypeOrName);
    let generatedBlockContent;
    try {
      generatedBlockContent = getSaveContent(blockType, block4.attributes);
    } catch (error2) {
      logger.error("Block validation failed because an error occurred while generating block content:\n\n%s", error2.toString());
      return [false, logger.getItems()];
    }
    const isValid = isEquivalentHTML(block4.originalContent, generatedBlockContent, logger);
    if (!isValid) {
      logger.error("Block validation failed for `%s` (%o).\n\nContent generated by `save` function:\n\n%s\n\nContent retrieved from post body:\n\n%s", blockType.name, blockType, generatedBlockContent, block4.originalContent);
    }
    return [isValid, logger.getItems()];
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/convert-legacy-block.js
  function convertLegacyBlockNameAndAttributes(name, attributes) {
    const newAttributes = {
      ...attributes
    };
    if ("core/cover-image" === name) {
      name = "core/cover";
    }
    if ("core/text" === name || "core/cover-text" === name) {
      name = "core/paragraph";
    }
    if (name && name.indexOf("core/social-link-") === 0) {
      newAttributes.service = name.substring(17);
      name = "core/social-link";
    }
    if (name && name.indexOf("core-embed/") === 0) {
      const providerSlug = name.substring(11);
      const deprecated2 = {
        speaker: "speaker-deck",
        polldaddy: "crowdsignal"
      };
      newAttributes.providerNameSlug = providerSlug in deprecated2 ? deprecated2[providerSlug] : providerSlug;
      if (!["amazon-kindle", "wordpress"].includes(providerSlug)) {
        newAttributes.responsive = true;
      }
      name = "core/embed";
    }
    if (name === "core/post-comment-author") {
      name = "core/comment-author-name";
    }
    if (name === "core/post-comment-content") {
      name = "core/comment-content";
    }
    if (name === "core/post-comment-date") {
      name = "core/comment-date";
    }
    if (name === "core/comments-query-loop") {
      name = "core/comments";
      const {
        className = ""
      } = newAttributes;
      if (!className.includes("wp-block-comments-query-loop")) {
        newAttributes.className = ["wp-block-comments-query-loop", className].join(" ");
      }
    }
    if (name === "core/post-comments") {
      name = "core/comments";
      newAttributes.legacy = true;
    }
    return [name, newAttributes];
  }

  // node_modules/hpq/es/get-path.js
  function getPath(object, path) {
    var segments = path.split(".");
    var segment;
    while (segment = segments.shift()) {
      if (!(segment in object)) {
        return;
      }
      object = object[segment];
    }
    return object;
  }

  // node_modules/hpq/es/index.js
  var getDocument = function() {
    var doc;
    return function() {
      if (!doc) {
        doc = document.implementation.createHTMLDocument("");
      }
      return doc;
    };
  }();
  function parse2(source, matchers) {
    if (!matchers) {
      return;
    }
    if ("string" === typeof source) {
      var doc = getDocument();
      doc.body.innerHTML = source;
      source = doc.body;
    }
    if ("function" === typeof matchers) {
      return matchers(source);
    }
    if (Object !== matchers.constructor) {
      return;
    }
    return Object.keys(matchers).reduce(function(memo3, key) {
      memo3[key] = parse2(source, matchers[key]);
      return memo3;
    }, {});
  }
  function prop(selector4, name) {
    if (1 === arguments.length) {
      name = selector4;
      selector4 = void 0;
    }
    return function(node) {
      var match = node;
      if (selector4) {
        match = node.querySelector(selector4);
      }
      if (match) {
        return getPath(match, name);
      }
    };
  }
  function attr(selector4, name) {
    if (1 === arguments.length) {
      name = selector4;
      selector4 = void 0;
    }
    return function(node) {
      var attributes = prop(selector4, "attributes")(node);
      if (attributes && attributes.hasOwnProperty(name)) {
        return attributes[name].value;
      }
    };
  }
  function text(selector4) {
    return prop(selector4, "textContent");
  }
  function query(selector4, matchers) {
    return function(node) {
      var matches2 = node.querySelectorAll(selector4);
      return [].map.call(matches2, function(match) {
        return parse2(match, matchers);
      });
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/get-block-attributes.js
  var import_lodash12 = __toESM(require_lodash());
  var import_memize2 = __toESM(require_memize());

  // node_modules/@wordpress/blocks/build-module/api/children.js
  function fromDOM2(domNodes) {
    deprecated("wp.blocks.children.fromDOM", {
      since: "6.1",
      version: "6.3",
      alternative: "wp.richText.create",
      link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
    });
    const result = [];
    for (let i5 = 0; i5 < domNodes.length; i5++) {
      try {
        result.push(fromDOM(domNodes[i5]));
      } catch (error2) {
      }
    }
    return result;
  }
  function matcher(selector4) {
    deprecated("wp.blocks.children.matcher", {
      since: "6.1",
      version: "6.3",
      alternative: "html source",
      link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
    });
    return (domNode) => {
      let match = domNode;
      if (selector4) {
        match = domNode.querySelector(selector4);
      }
      if (match) {
        return fromDOM2(match.childNodes);
      }
      return [];
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/node.js
  function getNamedNodeMapAsObject(nodeMap) {
    const result = {};
    for (let i5 = 0; i5 < nodeMap.length; i5++) {
      const {
        name,
        value
      } = nodeMap[i5];
      result[name] = value;
    }
    return result;
  }
  function fromDOM(domNode) {
    deprecated("wp.blocks.node.fromDOM", {
      since: "6.1",
      version: "6.3",
      alternative: "wp.richText.create",
      link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
    });
    if (domNode.nodeType === domNode.TEXT_NODE) {
      return domNode.nodeValue;
    }
    if (domNode.nodeType !== domNode.ELEMENT_NODE) {
      throw new TypeError("A block node can only be created from a node of type text or element.");
    }
    return {
      type: domNode.nodeName.toLowerCase(),
      props: {
        ...getNamedNodeMapAsObject(domNode.attributes),
        children: fromDOM2(domNode.childNodes)
      }
    };
  }
  function matcher2(selector4) {
    deprecated("wp.blocks.node.matcher", {
      since: "6.1",
      version: "6.3",
      alternative: "html source",
      link: "https://developer.wordpress.org/block-editor/how-to-guides/block-tutorial/introducing-attributes-and-editable-fields/"
    });
    return (domNode) => {
      let match = domNode;
      if (selector4) {
        match = domNode.querySelector(selector4);
      }
      try {
        return fromDOM(match);
      } catch (error2) {
        return null;
      }
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/matchers.js
  function html(selector4, multilineTag) {
    return (domNode) => {
      let match = domNode;
      if (selector4) {
        match = domNode.querySelector(selector4);
      }
      if (!match) {
        return "";
      }
      if (multilineTag) {
        let value = "";
        const length = match.children.length;
        for (let index2 = 0; index2 < length; index2++) {
          const child = match.children[index2];
          if (child.nodeName.toLowerCase() !== multilineTag) {
            continue;
          }
          value += child.outerHTML;
        }
        return value;
      }
      return match.innerHTML;
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/get-block-attributes.js
  var toBooleanAttributeMatcher = (matcher3) => pipe_default([
    matcher3,
    (value) => value !== void 0
  ]);
  function isOfType(value, type) {
    switch (type) {
      case "string":
        return typeof value === "string";
      case "boolean":
        return typeof value === "boolean";
      case "object":
        return !!value && value.constructor === Object;
      case "null":
        return value === null;
      case "array":
        return Array.isArray(value);
      case "integer":
      case "number":
        return typeof value === "number";
    }
    return true;
  }
  function isOfTypes(value, types2) {
    return types2.some((type) => isOfType(value, type));
  }
  function getBlockAttribute(attributeKey, attributeSchema, innerHTML, commentAttributes) {
    let value;
    switch (attributeSchema.source) {
      case void 0:
        value = commentAttributes ? commentAttributes[attributeKey] : void 0;
        break;
      case "attribute":
      case "property":
      case "html":
      case "text":
      case "children":
      case "node":
      case "query":
      case "tag":
        value = parseWithAttributeSchema(innerHTML, attributeSchema);
        break;
    }
    if (!isValidByType(value, attributeSchema.type) || !isValidByEnum(value, attributeSchema.enum)) {
      value = void 0;
    }
    if (value === void 0) {
      value = attributeSchema.default;
    }
    return value;
  }
  function isValidByType(value, type) {
    return type === void 0 || isOfTypes(value, Array.isArray(type) ? type : [type]);
  }
  function isValidByEnum(value, enumSet) {
    return !Array.isArray(enumSet) || enumSet.includes(value);
  }
  var matcherFromSource = (0, import_memize2.default)((sourceConfig) => {
    switch (sourceConfig.source) {
      case "attribute":
        let matcher3 = attr(sourceConfig.selector, sourceConfig.attribute);
        if (sourceConfig.type === "boolean") {
          matcher3 = toBooleanAttributeMatcher(matcher3);
        }
        return matcher3;
      case "html":
        return html(sourceConfig.selector, sourceConfig.multiline);
      case "text":
        return text(sourceConfig.selector);
      case "children":
        return matcher(sourceConfig.selector);
      case "node":
        return matcher2(sourceConfig.selector);
      case "query":
        const subMatchers = (0, import_lodash12.mapValues)(sourceConfig.query, matcherFromSource);
        return query(sourceConfig.selector, subMatchers);
      case "tag":
        return pipe_default([prop(sourceConfig.selector, "nodeName"), (nodeName) => nodeName ? nodeName.toLowerCase() : void 0]);
      default:
        console.error(`Unknown source type "${sourceConfig.source}"`);
    }
  });
  function parseHtml(innerHTML) {
    return parse2(innerHTML, (h4) => h4);
  }
  function parseWithAttributeSchema(innerHTML, attributeSchema) {
    return matcherFromSource(attributeSchema)(parseHtml(innerHTML));
  }
  function getBlockAttributes(blockTypeOrName, innerHTML) {
    let attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const doc = parseHtml(innerHTML);
    const blockType = normalizeBlockType(blockTypeOrName);
    const blockAttributes = (0, import_lodash12.mapValues)(blockType.attributes, (schema, key) => getBlockAttribute(key, schema, doc, attributes));
    return applyFilters("blocks.getBlockAttributes", blockAttributes, blockType, innerHTML, attributes);
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/fix-custom-classname.js
  var CLASS_ATTR_SCHEMA = {
    type: "string",
    source: "attribute",
    selector: "[data-custom-class-name] > *",
    attribute: "class"
  };
  function getHTMLRootElementClasses(innerHTML) {
    const parsed = parseWithAttributeSchema(`<div data-custom-class-name>${innerHTML}</div>`, CLASS_ATTR_SCHEMA);
    return parsed ? parsed.trim().split(/\s+/) : [];
  }
  function fixCustomClassname(blockAttributes, blockType, innerHTML) {
    if (hasBlockSupport(blockType, "customClassName", true)) {
      const {
        className: omittedClassName,
        ...attributesSansClassName
      } = blockAttributes;
      const serialized = getSaveContent(blockType, attributesSansClassName);
      const defaultClasses = getHTMLRootElementClasses(serialized);
      const actualClasses = getHTMLRootElementClasses(innerHTML);
      const customClasses = actualClasses.filter((className) => !defaultClasses.includes(className));
      if (customClasses.length) {
        blockAttributes.className = customClasses.join(" ");
      } else if (serialized) {
        delete blockAttributes.className;
      }
    }
    return blockAttributes;
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/apply-built-in-validation-fixes.js
  function applyBuiltInValidationFixes(block4, blockType) {
    const updatedBlockAttributes = fixCustomClassname(block4.attributes, blockType, block4.originalContent);
    return {
      ...block4,
      attributes: updatedBlockAttributes
    };
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/apply-block-deprecated-versions.js
  function stubFalse() {
    return false;
  }
  function applyBlockDeprecatedVersions(block4, rawBlock, blockType) {
    const parsedAttributes = rawBlock.attrs;
    const {
      deprecated: deprecatedDefinitions
    } = blockType;
    if (!deprecatedDefinitions || !deprecatedDefinitions.length) {
      return block4;
    }
    for (let i5 = 0; i5 < deprecatedDefinitions.length; i5++) {
      const {
        isEligible = stubFalse
      } = deprecatedDefinitions[i5];
      if (block4.isValid && !isEligible(parsedAttributes, block4.innerBlocks)) {
        continue;
      }
      const deprecatedBlockType = Object.assign(omit(blockType, DEPRECATED_ENTRY_KEYS), deprecatedDefinitions[i5]);
      let migratedBlock = {
        ...block4,
        attributes: getBlockAttributes(deprecatedBlockType, block4.originalContent, parsedAttributes)
      };
      let [isValid] = validateBlock(migratedBlock, deprecatedBlockType);
      if (!isValid) {
        migratedBlock = applyBuiltInValidationFixes(migratedBlock, deprecatedBlockType);
        [isValid] = validateBlock(migratedBlock, deprecatedBlockType);
      }
      if (!isValid) {
        continue;
      }
      let migratedInnerBlocks = migratedBlock.innerBlocks;
      let migratedAttributes = migratedBlock.attributes;
      const {
        migrate
      } = deprecatedBlockType;
      if (migrate) {
        let migrated = migrate(migratedAttributes, block4.innerBlocks);
        if (!Array.isArray(migrated)) {
          migrated = [migrated];
        }
        [migratedAttributes = parsedAttributes, migratedInnerBlocks = block4.innerBlocks] = migrated;
      }
      block4 = {
        ...block4,
        attributes: migratedAttributes,
        innerBlocks: migratedInnerBlocks,
        isValid: true,
        validationIssues: []
      };
    }
    return block4;
  }

  // node_modules/@wordpress/blocks/build-module/api/parser/index.js
  function convertLegacyBlocks(rawBlock) {
    const [correctName, correctedAttributes] = convertLegacyBlockNameAndAttributes(rawBlock.blockName, rawBlock.attrs);
    return {
      ...rawBlock,
      blockName: correctName,
      attrs: correctedAttributes
    };
  }
  function normalizeRawBlock(rawBlock, options) {
    const fallbackBlockName = getFreeformContentHandlerName();
    const rawBlockName = rawBlock.blockName || getFreeformContentHandlerName();
    const rawAttributes = rawBlock.attrs || {};
    const rawInnerBlocks = rawBlock.innerBlocks || [];
    let rawInnerHTML = rawBlock.innerHTML.trim();
    if (rawBlockName === fallbackBlockName && !(options !== null && options !== void 0 && options.__unstableSkipAutop)) {
      rawInnerHTML = autop(rawInnerHTML).trim();
    }
    return {
      ...rawBlock,
      blockName: rawBlockName,
      attrs: rawAttributes,
      innerHTML: rawInnerHTML,
      innerBlocks: rawInnerBlocks
    };
  }
  function createMissingBlockType(rawBlock) {
    const unregisteredFallbackBlock = getUnregisteredTypeHandlerName() || getFreeformContentHandlerName();
    const originalUndelimitedContent = serializeRawBlock(rawBlock, {
      isCommentDelimited: false
    });
    const originalContent = serializeRawBlock(rawBlock, {
      isCommentDelimited: true
    });
    return {
      blockName: unregisteredFallbackBlock,
      attrs: {
        originalName: rawBlock.blockName,
        originalContent,
        originalUndelimitedContent
      },
      innerHTML: rawBlock.blockName ? originalContent : rawBlock.innerHTML,
      innerBlocks: rawBlock.innerBlocks,
      innerContent: rawBlock.innerContent
    };
  }
  function applyBlockValidation(unvalidatedBlock, blockType) {
    const [isValid] = validateBlock(unvalidatedBlock, blockType);
    if (isValid) {
      return {
        ...unvalidatedBlock,
        isValid,
        validationIssues: []
      };
    }
    const fixedBlock = applyBuiltInValidationFixes(unvalidatedBlock, blockType);
    const [isFixedValid, validationIssues] = validateBlock(unvalidatedBlock, blockType);
    return {
      ...fixedBlock,
      isValid: isFixedValid,
      validationIssues
    };
  }
  function parseRawBlock(rawBlock, options) {
    let normalizedBlock = normalizeRawBlock(rawBlock, options);
    normalizedBlock = convertLegacyBlocks(normalizedBlock);
    let blockType = getBlockType(normalizedBlock.blockName);
    if (!blockType) {
      normalizedBlock = createMissingBlockType(normalizedBlock);
      blockType = getBlockType(normalizedBlock.blockName);
    }
    const isFallbackBlock = normalizedBlock.blockName === getFreeformContentHandlerName() || normalizedBlock.blockName === getUnregisteredTypeHandlerName();
    if (!blockType || !normalizedBlock.innerHTML && isFallbackBlock) {
      return;
    }
    const parsedInnerBlocks = normalizedBlock.innerBlocks.map((innerBlock) => parseRawBlock(innerBlock, options)).filter((innerBlock) => !!innerBlock);
    const parsedBlock = createBlock(normalizedBlock.blockName, getBlockAttributes(blockType, normalizedBlock.innerHTML, normalizedBlock.attrs), parsedInnerBlocks);
    parsedBlock.originalContent = normalizedBlock.innerHTML;
    const validatedBlock = applyBlockValidation(parsedBlock, blockType);
    const {
      validationIssues
    } = validatedBlock;
    const updatedBlock = applyBlockDeprecatedVersions(validatedBlock, normalizedBlock, blockType);
    if (!updatedBlock.isValid) {
      updatedBlock.__unstableBlockSource = rawBlock;
    }
    if (!validatedBlock.isValid && updatedBlock.isValid && !(options !== null && options !== void 0 && options.__unstableSkipMigrationLogs)) {
      console.groupCollapsed("Updated Block: %s", blockType.name);
      console.info("Block successfully updated for `%s` (%o).\n\nNew content generated by `save` function:\n\n%s\n\nContent retrieved from post body:\n\n%s", blockType.name, blockType, getSaveContent(blockType, updatedBlock.attributes), updatedBlock.originalContent);
      console.groupEnd();
    } else if (!validatedBlock.isValid && !updatedBlock.isValid) {
      validationIssues.forEach((_ref8) => {
        let {
          log,
          args
        } = _ref8;
        return log(...args);
      });
    }
    return updatedBlock;
  }
  function parse3(content, options) {
    return parse(content).reduce((accumulator, rawBlock) => {
      const block4 = parseRawBlock(rawBlock, options);
      if (block4) {
        accumulator.push(block4);
      }
      return accumulator;
    }, []);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/get-raw-transforms.js
  function getRawTransforms() {
    return getBlockTransforms("from").filter((_ref8) => {
      let {
        type
      } = _ref8;
      return type === "raw";
    }).map((transform) => {
      return transform.isMatch ? transform : {
        ...transform,
        isMatch: (node) => transform.selector && node.matches(transform.selector)
      };
    });
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/html-to-blocks.js
  function htmlToBlocks(html2, handler) {
    const doc = document.implementation.createHTMLDocument("");
    doc.body.innerHTML = html2;
    return Array.from(doc.body.children).flatMap((node) => {
      const rawTransform = findTransform(getRawTransforms(), (_ref8) => {
        let {
          isMatch
        } = _ref8;
        return isMatch(node);
      });
      if (!rawTransform) {
        return createBlock(
          "core/html",
          getBlockAttributes("core/html", node.outerHTML)
        );
      }
      const {
        transform,
        blockName
      } = rawTransform;
      if (transform) {
        return transform(node, handler);
      }
      return createBlock(blockName, getBlockAttributes(blockName, node.outerHTML));
    });
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/normalise-blocks.js
  function normaliseBlocks(HTML) {
    const decuDoc = document.implementation.createHTMLDocument("");
    const accuDoc = document.implementation.createHTMLDocument("");
    const decu = decuDoc.body;
    const accu = accuDoc.body;
    decu.innerHTML = HTML;
    while (decu.firstChild) {
      const node = decu.firstChild;
      if (node.nodeType === node.TEXT_NODE) {
        if (isEmpty(node)) {
          decu.removeChild(node);
        } else {
          if (!accu.lastChild || accu.lastChild.nodeName !== "P") {
            accu.appendChild(accuDoc.createElement("P"));
          }
          accu.lastChild.appendChild(node);
        }
      } else if (node.nodeType === node.ELEMENT_NODE) {
        if (node.nodeName === "BR") {
          if (node.nextSibling && node.nextSibling.nodeName === "BR") {
            accu.appendChild(accuDoc.createElement("P"));
            decu.removeChild(node.nextSibling);
          }
          if (accu.lastChild && accu.lastChild.nodeName === "P" && accu.lastChild.hasChildNodes()) {
            accu.lastChild.appendChild(node);
          } else {
            decu.removeChild(node);
          }
        } else if (node.nodeName === "P") {
          if (isEmpty(node)) {
            decu.removeChild(node);
          } else {
            accu.appendChild(node);
          }
        } else if (isPhrasingContent(node)) {
          if (!accu.lastChild || accu.lastChild.nodeName !== "P") {
            accu.appendChild(accuDoc.createElement("P"));
          }
          accu.lastChild.appendChild(node);
        } else {
          accu.appendChild(node);
        }
      } else {
        decu.removeChild(node);
      }
    }
    return accu.innerHTML;
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/special-comment-converter.js
  function specialCommentConverter(node, doc) {
    if (node.nodeType !== node.COMMENT_NODE) {
      return;
    }
    if (node.nodeValue === "nextpage") {
      replace2(node, createNextpage(doc));
      return;
    }
    if (node.nodeValue.indexOf("more") === 0) {
      moreCommentConverter(node, doc);
    }
  }
  function moreCommentConverter(node, doc) {
    const customText = node.nodeValue.slice(4).trim();
    let sibling = node;
    let noTeaser = false;
    while (sibling = sibling.nextSibling) {
      if (sibling.nodeType === sibling.COMMENT_NODE && sibling.nodeValue === "noteaser") {
        noTeaser = true;
        remove(sibling);
        break;
      }
    }
    const moreBlock = createMore(customText, noTeaser, doc);
    if (!node.parentNode || node.parentNode.nodeName !== "P" || node.parentNode.childNodes.length === 1) {
      replace2(node, moreBlock);
    } else {
      const childNodes = Array.from(node.parentNode.childNodes);
      const nodeIndex = childNodes.indexOf(node);
      const wrapperNode = node.parentNode.parentNode || doc.body;
      const paragraphBuilder = (acc, child) => {
        if (!acc) {
          acc = doc.createElement("p");
        }
        acc.appendChild(child);
        return acc;
      };
      [childNodes.slice(0, nodeIndex).reduce(paragraphBuilder, null), moreBlock, childNodes.slice(nodeIndex + 1).reduce(paragraphBuilder, null)].forEach((element) => element && wrapperNode.insertBefore(element, node.parentNode));
      remove(node.parentNode);
    }
  }
  function createMore(customText, noTeaser, doc) {
    const node = doc.createElement("wp-block");
    node.dataset.block = "core/more";
    if (customText) {
      node.dataset.customText = customText;
    }
    if (noTeaser) {
      node.dataset.noTeaser = "";
    }
    return node;
  }
  function createNextpage(doc) {
    const node = doc.createElement("wp-block");
    node.dataset.block = "core/nextpage";
    return node;
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/list-reducer.js
  function isList(node) {
    return node.nodeName === "OL" || node.nodeName === "UL";
  }
  function shallowTextContent(element) {
    return Array.from(element.childNodes).map((_ref8) => {
      let {
        nodeValue = ""
      } = _ref8;
      return nodeValue;
    }).join("");
  }
  function listReducer(node) {
    if (!isList(node)) {
      return;
    }
    const list = node;
    const prevElement = node.previousElementSibling;
    if (prevElement && prevElement.nodeName === node.nodeName && list.children.length === 1) {
      while (list.firstChild) {
        prevElement.appendChild(list.firstChild);
      }
      list.parentNode.removeChild(list);
    }
    const parentElement = node.parentNode;
    if (parentElement && parentElement.nodeName === "LI" && parentElement.children.length === 1 && !/\S/.test(shallowTextContent(parentElement))) {
      const parentListItem = parentElement;
      const prevListItem = parentListItem.previousElementSibling;
      const parentList = parentListItem.parentNode;
      if (prevListItem) {
        prevListItem.appendChild(list);
        parentList.removeChild(parentListItem);
      } else {
        parentList.parentNode.insertBefore(list, parentList);
        parentList.parentNode.removeChild(parentList);
      }
    }
    if (parentElement && isList(parentElement)) {
      const prevListItem = node.previousElementSibling;
      if (prevListItem) {
        prevListItem.appendChild(node);
      } else {
        unwrap(node);
      }
    }
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/blockquote-normaliser.js
  function blockquoteNormaliser(node) {
    if (node.nodeName !== "BLOCKQUOTE") {
      return;
    }
    node.innerHTML = normaliseBlocks(node.innerHTML);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/figure-content-reducer.js
  function isFigureContent(node, schema) {
    var _schema$figure$childr, _schema$figure;
    const tag = node.nodeName.toLowerCase();
    if (tag === "figcaption" || isTextContent(node)) {
      return false;
    }
    return tag in ((_schema$figure$childr = schema === null || schema === void 0 ? void 0 : (_schema$figure = schema.figure) === null || _schema$figure === void 0 ? void 0 : _schema$figure.children) !== null && _schema$figure$childr !== void 0 ? _schema$figure$childr : {});
  }
  function canHaveAnchor(node, schema) {
    var _schema$figure$childr2, _schema$figure2, _schema$figure2$child, _schema$figure2$child2;
    const tag = node.nodeName.toLowerCase();
    return tag in ((_schema$figure$childr2 = schema === null || schema === void 0 ? void 0 : (_schema$figure2 = schema.figure) === null || _schema$figure2 === void 0 ? void 0 : (_schema$figure2$child = _schema$figure2.children) === null || _schema$figure2$child === void 0 ? void 0 : (_schema$figure2$child2 = _schema$figure2$child.a) === null || _schema$figure2$child2 === void 0 ? void 0 : _schema$figure2$child2.children) !== null && _schema$figure$childr2 !== void 0 ? _schema$figure$childr2 : {});
  }
  function wrapFigureContent(element) {
    let beforeElement = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element;
    const figure = element.ownerDocument.createElement("figure");
    beforeElement.parentNode.insertBefore(figure, beforeElement);
    figure.appendChild(element);
  }
  function figureContentReducer(node, doc, schema) {
    if (!isFigureContent(node, schema)) {
      return;
    }
    let nodeToInsert = node;
    const parentNode = node.parentNode;
    if (canHaveAnchor(node, schema) && parentNode.nodeName === "A" && parentNode.childNodes.length === 1) {
      nodeToInsert = node.parentNode;
    }
    const wrapper = nodeToInsert.closest("p,div");
    if (wrapper) {
      if (!node.classList) {
        wrapFigureContent(nodeToInsert, wrapper);
      } else if (node.classList.contains("alignright") || node.classList.contains("alignleft") || node.classList.contains("aligncenter") || !wrapper.textContent.trim()) {
        wrapFigureContent(nodeToInsert, wrapper);
      }
    } else if (nodeToInsert.parentNode.nodeName === "BODY") {
      wrapFigureContent(nodeToInsert);
    }
  }

  // node_modules/@wordpress/shortcode/build-module/index.js
  var import_memize3 = __toESM(require_memize());
  function next(tag, text3) {
    let index2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const re = regexp(tag);
    re.lastIndex = index2;
    const match = re.exec(text3);
    if (!match) {
      return;
    }
    if ("[" === match[1] && "]" === match[7]) {
      return next(tag, text3, re.lastIndex);
    }
    const result = {
      index: match.index,
      content: match[0],
      shortcode: fromMatch(match)
    };
    if (match[1]) {
      result.content = result.content.slice(1);
      result.index++;
    }
    if (match[7]) {
      result.content = result.content.slice(0, -1);
    }
    return result;
  }
  function replace3(tag, text3, callback) {
    return text3.replace(regexp(tag), function(match, left, $3, attrs2, slash, content, closing, right) {
      if (left === "[" && right === "]") {
        return match;
      }
      const result = callback(fromMatch(arguments));
      return result || result === "" ? left + result + right : match;
    });
  }
  function string(options) {
    return new shortcode(options).string();
  }
  function regexp(tag) {
    return new RegExp("\\[(\\[?)(" + tag + ")(?![\\w-])([^\\]\\/]*(?:\\/(?!\\])[^\\]\\/]*)*?)(?:(\\/)\\]|\\](?:([^\\[]*(?:\\[(?!\\/\\2\\])[^\\[]*)*)(\\[\\/\\2\\]))?)(\\]?)", "g");
  }
  var attrs = (0, import_memize3.default)((text3) => {
    const named = {};
    const numeric = [];
    const pattern = /([\w-]+)\s*=\s*"([^"]*)"(?:\s|$)|([\w-]+)\s*=\s*'([^']*)'(?:\s|$)|([\w-]+)\s*=\s*([^\s'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|'([^']*)'(?:\s|$)|(\S+)(?:\s|$)/g;
    text3 = text3.replace(/[\u00a0\u200b]/g, " ");
    let match;
    while (match = pattern.exec(text3)) {
      if (match[1]) {
        named[match[1].toLowerCase()] = match[2];
      } else if (match[3]) {
        named[match[3].toLowerCase()] = match[4];
      } else if (match[5]) {
        named[match[5].toLowerCase()] = match[6];
      } else if (match[7]) {
        numeric.push(match[7]);
      } else if (match[8]) {
        numeric.push(match[8]);
      } else if (match[9]) {
        numeric.push(match[9]);
      }
    }
    return {
      named,
      numeric
    };
  });
  function fromMatch(match) {
    let type;
    if (match[4]) {
      type = "self-closing";
    } else if (match[6]) {
      type = "closed";
    } else {
      type = "single";
    }
    return new shortcode({
      tag: match[2],
      attrs: match[3],
      type,
      content: match[5]
    });
  }
  var shortcode = Object.assign(function(options) {
    const {
      tag,
      attrs: attributes,
      type,
      content
    } = options || {};
    Object.assign(this, {
      tag,
      type,
      content
    });
    this.attrs = {
      named: {},
      numeric: []
    };
    if (!attributes) {
      return;
    }
    const attributeTypes = ["named", "numeric"];
    if (typeof attributes === "string") {
      this.attrs = attrs(attributes);
    } else if (attributes.length === attributeTypes.length && attributeTypes.every((t5, key) => t5 === attributes[key])) {
      this.attrs = attributes;
    } else {
      Object.entries(attributes).forEach((_ref8) => {
        let [key, value] = _ref8;
        this.set(key, value);
      });
    }
  }, {
    next,
    replace: replace3,
    string,
    regexp,
    attrs,
    fromMatch
  });
  Object.assign(shortcode.prototype, {
    get(attr2) {
      return this.attrs[typeof attr2 === "number" ? "numeric" : "named"][attr2];
    },
    set(attr2, value) {
      this.attrs[typeof attr2 === "number" ? "numeric" : "named"][attr2] = value;
      return this;
    },
    string() {
      let text3 = "[" + this.tag;
      this.attrs.numeric.forEach((value) => {
        if (/\s/.test(value)) {
          text3 += ' "' + value + '"';
        } else {
          text3 += " " + value;
        }
      });
      Object.entries(this.attrs.named).forEach((_ref22) => {
        let [name, value] = _ref22;
        text3 += " " + name + '="' + value + '"';
      });
      if ("single" === this.type) {
        return text3 + "]";
      } else if ("self-closing" === this.type) {
        return text3 + " /]";
      }
      text3 += "]";
      if (this.content) {
        text3 += this.content;
      }
      return text3 + "[/" + this.tag + "]";
    }
  });

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/shortcode-converter.js
  var castArray = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  function segmentHTMLToShortcodeBlock(HTML) {
    let lastIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let excludedBlockNames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    const transformsFrom = getBlockTransforms("from");
    const transformation = findTransform(transformsFrom, (transform) => excludedBlockNames.indexOf(transform.blockName) === -1 && transform.type === "shortcode" && castArray(transform.tag).some((tag) => regexp(tag).test(HTML)));
    if (!transformation) {
      return [HTML];
    }
    const transformTags = castArray(transformation.tag);
    const transformTag = transformTags.find((tag) => regexp(tag).test(HTML));
    let match;
    const previousIndex = lastIndex;
    if (match = next(transformTag, HTML, lastIndex)) {
      var _match$shortcode$cont;
      lastIndex = match.index + match.content.length;
      const beforeHTML = HTML.substr(0, match.index);
      const afterHTML = HTML.substr(lastIndex);
      if (!((_match$shortcode$cont = match.shortcode.content) !== null && _match$shortcode$cont !== void 0 && _match$shortcode$cont.includes("<")) && !(/(\n|<p>)\s*$/.test(beforeHTML) && /^\s*(\n|<\/p>)/.test(afterHTML))) {
        return segmentHTMLToShortcodeBlock(HTML, lastIndex);
      }
      if (transformation.isMatch && !transformation.isMatch(match.shortcode.attrs)) {
        return segmentHTMLToShortcodeBlock(HTML, previousIndex, [...excludedBlockNames, transformation.blockName]);
      }
      let blocks2 = [];
      if (typeof transformation.transform === "function") {
        blocks2 = [].concat(transformation.transform(match.shortcode.attrs, match));
        blocks2 = blocks2.map((block4) => {
          block4.originalContent = match.shortcode.content;
          return applyBuiltInValidationFixes(block4, getBlockType(block4.name));
        });
      } else {
        const attributes = Object.fromEntries(Object.entries(transformation.attributes).filter((_ref8) => {
          let [, schema] = _ref8;
          return schema.shortcode;
        }).map((_ref22) => {
          let [key, schema] = _ref22;
          return [key, schema.shortcode(match.shortcode.attrs, match)];
        }));
        const blockType = getBlockType(transformation.blockName);
        if (!blockType) {
          return [HTML];
        }
        const transformationBlockType = {
          ...blockType,
          attributes: transformation.attributes
        };
        let block4 = createBlock(transformation.blockName, getBlockAttributes(transformationBlockType, match.shortcode.content, attributes));
        block4.originalContent = match.shortcode.content;
        block4 = applyBuiltInValidationFixes(block4, transformationBlockType);
        blocks2 = [block4];
      }
      return [...segmentHTMLToShortcodeBlock(beforeHTML), ...blocks2, ...segmentHTMLToShortcodeBlock(afterHTML)];
    }
    return [HTML];
  }
  var shortcode_converter_default = segmentHTMLToShortcodeBlock;

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/utils.js
  var import_lodash13 = __toESM(require_lodash());
  function getBlockContentSchemaFromTransforms(transforms, context2) {
    const phrasingContentSchema2 = getPhrasingContentSchema(context2);
    const schemaArgs = {
      phrasingContentSchema: phrasingContentSchema2,
      isPaste: context2 === "paste"
    };
    const schemas = transforms.map((_ref8) => {
      let {
        isMatch,
        blockName,
        schema
      } = _ref8;
      const hasAnchorSupport = hasBlockSupport(blockName, "anchor");
      schema = typeof schema === "function" ? schema(schemaArgs) : schema;
      if (!hasAnchorSupport && !isMatch) {
        return schema;
      }
      return (0, import_lodash13.mapValues)(schema, (value) => {
        let attributes = value.attributes || [];
        if (hasAnchorSupport) {
          attributes = [...attributes, "id"];
        }
        return {
          ...value,
          attributes,
          isMatch: isMatch ? isMatch : void 0
        };
      });
    });
    return (0, import_lodash13.mergeWith)({}, ...schemas, (objValue, srcValue, key) => {
      switch (key) {
        case "children": {
          if (objValue === "*" || srcValue === "*") {
            return "*";
          }
          return {
            ...objValue,
            ...srcValue
          };
        }
        case "attributes":
        case "require": {
          return [...objValue || [], ...srcValue || []];
        }
        case "isMatch": {
          if (!objValue || !srcValue) {
            return void 0;
          }
          return function() {
            return objValue(...arguments) || srcValue(...arguments);
          };
        }
      }
    });
  }
  function getBlockContentSchema(context2) {
    return getBlockContentSchemaFromTransforms(getRawTransforms(), context2);
  }
  function isPlain(HTML) {
    return !/<(?!br[ />])/i.test(HTML);
  }
  function deepFilterNodeList(nodeList, filters2, doc, schema) {
    Array.from(nodeList).forEach((node) => {
      deepFilterNodeList(node.childNodes, filters2, doc, schema);
      filters2.forEach((item2) => {
        if (!doc.contains(node)) {
          return;
        }
        item2(node, doc, schema);
      });
    });
  }
  function deepFilterHTML(HTML) {
    let filters2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let schema = arguments.length > 2 ? arguments[2] : void 0;
    const doc = document.implementation.createHTMLDocument("");
    doc.body.innerHTML = HTML;
    deepFilterNodeList(doc.body.childNodes, filters2, doc, schema);
    return doc.body.innerHTML;
  }
  function getSibling(node, which) {
    const sibling = node[`${which}Sibling`];
    if (sibling && isPhrasingContent(sibling)) {
      return sibling;
    }
    const {
      parentNode
    } = node;
    if (!parentNode || !isPhrasingContent(parentNode)) {
      return;
    }
    return getSibling(parentNode, which);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/comment-remover.js
  function commentRemover(node) {
    if (node.nodeType === node.COMMENT_NODE) {
      remove(node);
    }
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/is-inline-content.js
  function isInline(node, contextTag) {
    if (isTextContent(node)) {
      return true;
    }
    if (!contextTag) {
      return false;
    }
    const tag = node.nodeName.toLowerCase();
    const inlineAllowedTagGroups = [["ul", "li", "ol"], ["h1", "h2", "h3", "h4", "h5", "h6"]];
    return inlineAllowedTagGroups.some((tagGroup) => [tag, contextTag].filter((t5) => !tagGroup.includes(t5)).length === 0);
  }
  function deepCheck(nodes, contextTag) {
    return nodes.every((node) => isInline(node, contextTag) && deepCheck(Array.from(node.children), contextTag));
  }
  function isDoubleBR(node) {
    return node.nodeName === "BR" && node.previousSibling && node.previousSibling.nodeName === "BR";
  }
  function isInlineContent(HTML, contextTag) {
    const doc = document.implementation.createHTMLDocument("");
    doc.body.innerHTML = HTML;
    const nodes = Array.from(doc.body.children);
    return !nodes.some(isDoubleBR) && deepCheck(nodes, contextTag);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/phrasing-content-reducer.js
  function phrasingContentReducer(node, doc) {
    if (node.nodeName === "SPAN" && node.style) {
      const {
        fontWeight: fontWeight2,
        fontStyle: fontStyle2,
        textDecorationLine,
        textDecoration: textDecoration2,
        verticalAlign
      } = node.style;
      if (fontWeight2 === "bold" || fontWeight2 === "700") {
        wrap(doc.createElement("strong"), node);
      }
      if (fontStyle2 === "italic") {
        wrap(doc.createElement("em"), node);
      }
      if (textDecorationLine === "line-through" || textDecoration2.includes("line-through")) {
        wrap(doc.createElement("s"), node);
      }
      if (verticalAlign === "super") {
        wrap(doc.createElement("sup"), node);
      } else if (verticalAlign === "sub") {
        wrap(doc.createElement("sub"), node);
      }
    } else if (node.nodeName === "B") {
      node = replaceTag(node, "strong");
    } else if (node.nodeName === "I") {
      node = replaceTag(node, "em");
    } else if (node.nodeName === "A") {
      if (node.target && node.target.toLowerCase() === "_blank") {
        node.rel = "noreferrer noopener";
      } else {
        node.removeAttribute("target");
        node.removeAttribute("rel");
      }
      if (node.name && !node.id) {
        node.id = node.name;
      }
      if (node.id && !node.ownerDocument.querySelector(`[href="#${node.id}"]`)) {
        node.removeAttribute("id");
      }
    }
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/head-remover.js
  function headRemover(node) {
    if (node.nodeName !== "SCRIPT" && node.nodeName !== "NOSCRIPT" && node.nodeName !== "TEMPLATE" && node.nodeName !== "STYLE") {
      return;
    }
    node.parentNode.removeChild(node);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/ms-list-converter.js
  var {
    parseInt: parseInt2
  } = window;
  function isList2(node) {
    return node.nodeName === "OL" || node.nodeName === "UL";
  }
  function msListConverter(node, doc) {
    if (node.nodeName !== "P") {
      return;
    }
    const style = node.getAttribute("style");
    if (!style) {
      return;
    }
    if (style.indexOf("mso-list") === -1) {
      return;
    }
    const matches2 = /mso-list\s*:[^;]+level([0-9]+)/i.exec(style);
    if (!matches2) {
      return;
    }
    let level = parseInt2(matches2[1], 10) - 1 || 0;
    const prevNode = node.previousElementSibling;
    if (!prevNode || !isList2(prevNode)) {
      const type = node.textContent.trim().slice(0, 1);
      const isNumeric = /[1iIaA]/.test(type);
      const newListNode = doc.createElement(isNumeric ? "ol" : "ul");
      if (isNumeric) {
        newListNode.setAttribute("type", type);
      }
      node.parentNode.insertBefore(newListNode, node);
    }
    const listNode = node.previousElementSibling;
    const listType = listNode.nodeName;
    const listItem = doc.createElement("li");
    let receivingNode = listNode;
    node.removeChild(node.firstChild);
    while (node.firstChild) {
      listItem.appendChild(node.firstChild);
    }
    while (level--) {
      receivingNode = receivingNode.lastChild || receivingNode;
      if (isList2(receivingNode)) {
        receivingNode = receivingNode.lastChild || receivingNode;
      }
    }
    if (!isList2(receivingNode)) {
      receivingNode = receivingNode.appendChild(doc.createElement(listType));
    }
    receivingNode.appendChild(listItem);
    node.parentNode.removeChild(node);
  }

  // node_modules/@wordpress/blob/build-module/index.js
  var {
    createObjectURL,
    revokeObjectURL
  } = window.URL;
  var cache = {};
  function createBlobURL(file) {
    const url = createObjectURL(file);
    cache[url] = file;
    return url;
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/image-corrector.js
  var {
    atob,
    File
  } = window;
  function imageCorrector(node) {
    if (node.nodeName !== "IMG") {
      return;
    }
    if (node.src.indexOf("file:") === 0) {
      node.src = "";
    }
    if (node.src.indexOf("data:") === 0) {
      const [properties, data] = node.src.split(",");
      const [type] = properties.slice(5).split(";");
      if (!data || !type) {
        node.src = "";
        return;
      }
      let decoded;
      try {
        decoded = atob(data);
      } catch (e4) {
        node.src = "";
        return;
      }
      const uint8Array = new Uint8Array(decoded.length);
      for (let i5 = 0; i5 < uint8Array.length; i5++) {
        uint8Array[i5] = decoded.charCodeAt(i5);
      }
      const name = type.replace("/", ".");
      const file = new File([uint8Array], name, {
        type
      });
      node.src = createBlobURL(file);
    }
    if (node.height === 1 || node.width === 1) {
      node.parentNode.removeChild(node);
    }
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/div-normaliser.js
  function divNormaliser(node) {
    if (node.nodeName !== "DIV") {
      return;
    }
    node.innerHTML = normaliseBlocks(node.innerHTML);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/markdown-converter.js
  var import_showdown = __toESM(require_showdown());
  var converter = new import_showdown.default.Converter({
    noHeaderId: true,
    tables: true,
    literalMidWordUnderscores: true,
    omitExtraWLInCodeBlocks: true,
    simpleLineBreaks: true,
    strikethrough: true
  });
  function slackMarkdownVariantCorrector(text3) {
    return text3.replace(/((?:^|\n)```)([^\n`]+)(```(?:$|\n))/, (match, p1, p22, p32) => `${p1}
${p22}
${p32}`);
  }
  function bulletsToAsterisks(text3) {
    return text3.replace(/(^|\n)( +)/g, "$1*$2");
  }
  function markdownConverter(text3) {
    return converter.makeHtml(slackMarkdownVariantCorrector(bulletsToAsterisks(text3)));
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/iframe-remover.js
  function iframeRemover(node) {
    if (node.nodeName === "IFRAME") {
      const text3 = node.ownerDocument.createTextNode(node.src);
      node.parentNode.replaceChild(text3, node);
    }
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/google-docs-uid-remover.js
  function googleDocsUIdRemover(node) {
    if (!node.id || node.id.indexOf("docs-internal-guid-") !== 0) {
      return;
    }
    unwrap(node);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/html-formatting-remover.js
  function isFormattingSpace(character) {
    return character === " " || character === "\r" || character === "\n" || character === "	";
  }
  function htmlFormattingRemover(node) {
    if (node.nodeType !== node.TEXT_NODE) {
      return;
    }
    let parent = node;
    while (parent = parent.parentNode) {
      if (parent.nodeType === parent.ELEMENT_NODE && parent.nodeName === "PRE") {
        return;
      }
    }
    let newData = node.data.replace(/[ \r\n\t]+/g, " ");
    if (newData[0] === " ") {
      const previousSibling = getSibling(node, "previous");
      if (!previousSibling || previousSibling.nodeName === "BR" || previousSibling.textContent.slice(-1) === " ") {
        newData = newData.slice(1);
      }
    }
    if (newData[newData.length - 1] === " ") {
      const nextSibling = getSibling(node, "next");
      if (!nextSibling || nextSibling.nodeName === "BR" || nextSibling.nodeType === nextSibling.TEXT_NODE && isFormattingSpace(nextSibling.textContent[0])) {
        newData = newData.slice(0, -1);
      }
    }
    if (!newData) {
      node.parentNode.removeChild(node);
    } else {
      node.data = newData;
    }
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/br-remover.js
  function brRemover(node) {
    if (node.nodeName !== "BR") {
      return;
    }
    if (getSibling(node, "next")) {
      return;
    }
    node.parentNode.removeChild(node);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/empty-paragraph-remover.js
  function emptyParagraphRemover(node) {
    if (node.nodeName !== "P") {
      return;
    }
    if (node.hasChildNodes()) {
      return;
    }
    node.parentNode.removeChild(node);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/slack-paragraph-corrector.js
  function slackParagraphCorrector(node) {
    if (node.nodeName !== "SPAN") {
      return;
    }
    if (node.getAttribute("data-stringify-type") !== "paragraph-break") {
      return;
    }
    const {
      parentNode
    } = node;
    parentNode.insertBefore(node.ownerDocument.createElement("br"), node);
    parentNode.insertBefore(node.ownerDocument.createElement("br"), node);
    parentNode.removeChild(node);
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/paste-handler.js
  var {
    console: console2
  } = window;
  function filterInlineHTML(HTML, preserveWhiteSpace) {
    HTML = deepFilterHTML(HTML, [googleDocsUIdRemover, phrasingContentReducer, commentRemover]);
    HTML = removeInvalidHTML(HTML, getPhrasingContentSchema("paste"), {
      inline: true
    });
    if (!preserveWhiteSpace) {
      HTML = deepFilterHTML(HTML, [htmlFormattingRemover, brRemover]);
    }
    console2.log("Processed inline HTML:\n\n", HTML);
    return HTML;
  }
  function pasteHandler(_ref8) {
    let {
      HTML = "",
      plainText = "",
      mode = "AUTO",
      tagName,
      preserveWhiteSpace
    } = _ref8;
    HTML = HTML.replace(/<meta[^>]+>/g, "");
    HTML = HTML.replace(/^\s*<html[^>]*>\s*<body[^>]*>(?:\s*<!--\s*StartFragment\s*-->)?/i, "");
    HTML = HTML.replace(/(?:<!--\s*EndFragment\s*-->\s*)?<\/body>\s*<\/html>\s*$/i, "");
    if (mode !== "INLINE") {
      const content = HTML ? HTML : plainText;
      if (content.indexOf("<!-- wp:") !== -1) {
        return parse3(content);
      }
    }
    if (String.prototype.normalize) {
      HTML = HTML.normalize();
    }
    if (plainText && (!HTML || isPlain(HTML))) {
      HTML = plainText;
      if (!/^\s+$/.test(plainText)) {
        HTML = markdownConverter(HTML);
      }
      if (mode === "AUTO" && plainText.indexOf("\n") === -1 && plainText.indexOf("<p>") !== 0 && HTML.indexOf("<p>") === 0) {
        mode = "INLINE";
      }
    }
    if (mode === "INLINE") {
      return filterInlineHTML(HTML, preserveWhiteSpace);
    }
    HTML = deepFilterHTML(HTML, [slackParagraphCorrector]);
    const pieces = shortcode_converter_default(HTML);
    const hasShortcodes = pieces.length > 1;
    if (mode === "AUTO" && !hasShortcodes && isInlineContent(HTML, tagName)) {
      return filterInlineHTML(HTML, preserveWhiteSpace);
    }
    const phrasingContentSchema2 = getPhrasingContentSchema("paste");
    const blockContentSchema = getBlockContentSchema("paste");
    const blocks2 = pieces.map((piece) => {
      if (typeof piece !== "string") {
        return piece;
      }
      const filters2 = [googleDocsUIdRemover, msListConverter, headRemover, listReducer, imageCorrector, phrasingContentReducer, specialCommentConverter, commentRemover, iframeRemover, figureContentReducer, blockquoteNormaliser, divNormaliser];
      const schema = {
        ...blockContentSchema,
        ...phrasingContentSchema2
      };
      piece = deepFilterHTML(piece, filters2, blockContentSchema);
      piece = removeInvalidHTML(piece, schema);
      piece = normaliseBlocks(piece);
      piece = deepFilterHTML(piece, [htmlFormattingRemover, brRemover, emptyParagraphRemover], blockContentSchema);
      console2.log("Processed HTML piece:\n\n", piece);
      return htmlToBlocks(piece, pasteHandler);
    }).flat().filter(Boolean);
    if (mode === "AUTO" && blocks2.length === 1 && hasBlockSupport(blocks2[0].name, "__unstablePasteTextInline", false)) {
      const trimRegex = /^[\n]+|[\n]+$/g;
      const trimmedPlainText = plainText.replace(trimRegex, "");
      if (trimmedPlainText !== "" && trimmedPlainText.indexOf("\n") === -1) {
        return removeInvalidHTML(getBlockInnerHTML(blocks2[0]), phrasingContentSchema2).replace(trimRegex, "");
      }
    }
    return blocks2;
  }

  // node_modules/@wordpress/blocks/build-module/api/raw-handling/index.js
  function rawHandler(_ref8) {
    let {
      HTML = ""
    } = _ref8;
    if (HTML.indexOf("<!-- wp:") !== -1) {
      return parse3(HTML);
    }
    const pieces = shortcode_converter_default(HTML);
    const blockContentSchema = getBlockContentSchema();
    return pieces.map((piece) => {
      if (typeof piece !== "string") {
        return piece;
      }
      const filters2 = [
        listReducer,
        specialCommentConverter,
        figureContentReducer,
        blockquoteNormaliser
      ];
      piece = deepFilterHTML(piece, filters2, blockContentSchema);
      piece = normaliseBlocks(piece);
      return htmlToBlocks(piece, rawHandler);
    }).flat().filter(Boolean);
  }

  // node_modules/@wordpress/blocks/build-module/api/templates.js
  function doBlocksMatchTemplate() {
    let blocks2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let template2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return blocks2.length === template2.length && template2.every((_ref8, index2) => {
      let [name, , innerBlocksTemplate] = _ref8;
      const block4 = blocks2[index2];
      return name === block4.name && doBlocksMatchTemplate(block4.innerBlocks, innerBlocksTemplate);
    });
  }
  function synchronizeBlocksWithTemplate() {
    let blocks2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let template2 = arguments.length > 1 ? arguments[1] : void 0;
    if (!template2) {
      return blocks2;
    }
    return template2.map((_ref22, index2) => {
      var _blockType$attributes;
      let [name, attributes, innerBlocksTemplate] = _ref22;
      const block4 = blocks2[index2];
      if (block4 && block4.name === name) {
        const innerBlocks = synchronizeBlocksWithTemplate(block4.innerBlocks, innerBlocksTemplate);
        return {
          ...block4,
          innerBlocks
        };
      }
      const blockType = getBlockType(name);
      const isHTMLAttribute = (attributeDefinition) => (attributeDefinition === null || attributeDefinition === void 0 ? void 0 : attributeDefinition.source) === "html";
      const isQueryAttribute = (attributeDefinition) => (attributeDefinition === null || attributeDefinition === void 0 ? void 0 : attributeDefinition.source) === "query";
      const normalizeAttributes = (schema, values) => {
        if (!values) {
          return {};
        }
        return Object.fromEntries(Object.entries(values).map((_ref32) => {
          let [key, value] = _ref32;
          return [key, normalizeAttribute(schema[key], value)];
        }));
      };
      const normalizeAttribute = (definition, value) => {
        if (isHTMLAttribute(definition) && Array.isArray(value)) {
          return serialize_default(value);
        }
        if (isQueryAttribute(definition) && value) {
          return value.map((subValues) => {
            return normalizeAttributes(definition.query, subValues);
          });
        }
        return value;
      };
      const normalizedAttributes = normalizeAttributes((_blockType$attributes = blockType === null || blockType === void 0 ? void 0 : blockType.attributes) !== null && _blockType$attributes !== void 0 ? _blockType$attributes : {}, attributes);
      let [blockName, blockAttributes] = convertLegacyBlockNameAndAttributes(name, normalizedAttributes);
      if (void 0 === getBlockType(blockName)) {
        blockAttributes = {
          originalName: name,
          originalContent: "",
          originalUndelimitedContent: ""
        };
        blockName = "core/missing";
      }
      return createBlock(blockName, blockAttributes, synchronizeBlocksWithTemplate([], innerBlocksTemplate));
    });
  }

  // node_modules/@wordpress/block-editor/build-module/components/use-setting/index.js
  var import_lodash21 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js
  var import_classnames21 = __toESM(require_classnames());
  var import_lodash18 = __toESM(require_lodash());

  // node_modules/@wordpress/primitives/build-module/svg/index.js
  var import_classnames = __toESM(require_classnames());
  var Path = (props) => (0, import_react.createElement)("path", props);
  var SVG = (_ref8) => {
    let {
      className,
      isPressed,
      ...props
    } = _ref8;
    const appliedProps = {
      ...props,
      className: (0, import_classnames.default)(className, {
        "is-pressed": isPressed
      }) || void 0,
      "aria-hidden": true,
      focusable: false
    };
    return (0, import_react.createElement)("svg", appliedProps);
  };

  // node_modules/reakit/es/_rollupPluginBabelHelpers-1f0bf8c2.js
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread22(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5] != null ? arguments[i5] : {};
      if (i5 % 2) {
        ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i5;
    for (i5 = 0; i5 < sourceKeys.length; i5++) {
      key = sourceKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _unsupportedIterableToArray(o6, minLen) {
    if (!o6)
      return;
    if (typeof o6 === "string")
      return _arrayLikeToArray(o6, minLen);
    var n5 = Object.prototype.toString.call(o6).slice(8, -1);
    if (n5 === "Object" && o6.constructor)
      n5 = o6.constructor.name;
    if (n5 === "Map" || n5 === "Set")
      return Array.from(o6);
    if (n5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5))
      return _arrayLikeToArray(o6, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++)
      arr2[i5] = arr[i5];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o6, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o6[Symbol.iterator] == null) {
      if (Array.isArray(o6) || (it = _unsupportedIterableToArray(o6)) || allowArrayLike && o6 && typeof o6.length === "number") {
        if (it)
          o6 = it;
        var i5 = 0;
        return function() {
          if (i5 >= o6.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o6[i5++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    it = o6[Symbol.iterator]();
    return it.next.bind(it);
  }

  // node_modules/reakit-system/es/createComponent.js
  var import_react8 = __toESM(require_react());

  // node_modules/reakit-system/es/SystemContext.js
  var import_react6 = __toESM(require_react());
  var SystemContext = /* @__PURE__ */ (0, import_react6.createContext)({});

  // node_modules/reakit-system/es/_rollupPluginBabelHelpers-0c84a174.js
  function _defineProperty3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread23(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5] != null ? arguments[i5] : {};
      if (i5 % 2) {
        ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i5;
    for (i5 = 0; i5 < sourceKeys.length; i5++) {
      key = sourceKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _unsupportedIterableToArray2(o6, minLen) {
    if (!o6)
      return;
    if (typeof o6 === "string")
      return _arrayLikeToArray2(o6, minLen);
    var n5 = Object.prototype.toString.call(o6).slice(8, -1);
    if (n5 === "Object" && o6.constructor)
      n5 = o6.constructor.name;
    if (n5 === "Map" || n5 === "Set")
      return Array.from(o6);
    if (n5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5))
      return _arrayLikeToArray2(o6, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++)
      arr2[i5] = arr[i5];
    return arr2;
  }
  function _createForOfIteratorHelperLoose2(o6, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o6[Symbol.iterator] == null) {
      if (Array.isArray(o6) || (it = _unsupportedIterableToArray2(o6)) || allowArrayLike && o6 && typeof o6.length === "number") {
        if (it)
          o6 = it;
        var i5 = 0;
        return function() {
          if (i5 >= o6.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o6[i5++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    it = o6[Symbol.iterator]();
    return it.next.bind(it);
  }

  // node_modules/reakit-system/es/useCreateElement.js
  var import_react7 = __toESM(require_react());
  function isRenderProp(children) {
    return typeof children === "function";
  }
  var useCreateElement = function useCreateElement2(type, props, children) {
    if (children === void 0) {
      children = props.children;
    }
    var context2 = (0, import_react7.useContext)(SystemContext);
    if (context2.useCreateElement) {
      return context2.useCreateElement(type, props, children);
    }
    if (typeof type === "string" && isRenderProp(children)) {
      var _ = props.children, rest = _objectWithoutPropertiesLoose2(props, ["children"]);
      return children(rest);
    }
    return /* @__PURE__ */ (0, import_react7.createElement)(type, props, children);
  };

  // node_modules/reakit-utils/es/_rollupPluginBabelHelpers-1f0bf8c2.js
  function _defineProperty4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread24(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5] != null ? arguments[i5] : {};
      if (i5 % 2) {
        ownKeys4(Object(source), true).forEach(function(key) {
          _defineProperty4(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys4(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i5;
    for (i5 = 0; i5 < sourceKeys.length; i5++) {
      key = sourceKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _unsupportedIterableToArray3(o6, minLen) {
    if (!o6)
      return;
    if (typeof o6 === "string")
      return _arrayLikeToArray3(o6, minLen);
    var n5 = Object.prototype.toString.call(o6).slice(8, -1);
    if (n5 === "Object" && o6.constructor)
      n5 = o6.constructor.name;
    if (n5 === "Map" || n5 === "Set")
      return Array.from(o6);
    if (n5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5))
      return _arrayLikeToArray3(o6, minLen);
  }
  function _arrayLikeToArray3(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++)
      arr2[i5] = arr[i5];
    return arr2;
  }
  function _createForOfIteratorHelperLoose3(o6, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o6[Symbol.iterator] == null) {
      if (Array.isArray(o6) || (it = _unsupportedIterableToArray3(o6)) || allowArrayLike && o6 && typeof o6.length === "number") {
        if (it)
          o6 = it;
        var i5 = 0;
        return function() {
          if (i5 >= o6.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o6[i5++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    it = o6[Symbol.iterator]();
    return it.next.bind(it);
  }

  // node_modules/reakit-utils/es/isObject.js
  function isObject3(arg) {
    return typeof arg === "object" && arg != null;
  }

  // node_modules/reakit-utils/es/isPlainObject.js
  function isPlainObject3(arg) {
    var _proto$constructor;
    if (!isObject3(arg))
      return false;
    var proto = Object.getPrototypeOf(arg);
    if (proto == null)
      return true;
    return ((_proto$constructor = proto.constructor) === null || _proto$constructor === void 0 ? void 0 : _proto$constructor.toString()) === Object.toString();
  }

  // node_modules/reakit-utils/es/splitProps.js
  function __deprecatedSplitProps(props, keys) {
    var propsKeys = Object.keys(props);
    var picked = {};
    var omitted = {};
    for (var _i = 0, _propsKeys = propsKeys; _i < _propsKeys.length; _i++) {
      var key = _propsKeys[_i];
      if (keys.indexOf(key) >= 0) {
        picked[key] = props[key];
      } else {
        omitted[key] = props[key];
      }
    }
    return [picked, omitted];
  }
  function splitProps(props, keys) {
    if (keys === void 0) {
      keys = [];
    }
    if (!isPlainObject3(props.state)) {
      return __deprecatedSplitProps(props, keys);
    }
    var _deprecatedSplitProp = __deprecatedSplitProps(props, [].concat(keys, ["state"])), picked = _deprecatedSplitProp[0], omitted = _deprecatedSplitProp[1];
    var state = picked.state, restPicked = _objectWithoutPropertiesLoose3(picked, ["state"]);
    return [_objectSpread24(_objectSpread24({}, state), restPicked), omitted];
  }

  // node_modules/reakit-utils/es/shallowEqual.js
  function shallowEqual(objA, objB) {
    if (objA === objB)
      return true;
    if (!objA)
      return false;
    if (!objB)
      return false;
    if (typeof objA !== "object")
      return false;
    if (typeof objB !== "object")
      return false;
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);
    var length = aKeys.length;
    if (bKeys.length !== length)
      return false;
    for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
      var key = _aKeys[_i];
      if (objA[key] !== objB[key]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/reakit-utils/es/normalizePropsAreEqual.js
  function normalizePropsAreEqual(propsAreEqual4) {
    if (propsAreEqual4.name === "normalizePropsAreEqualInner") {
      return propsAreEqual4;
    }
    return function normalizePropsAreEqualInner(prev, next2) {
      if (!isPlainObject3(prev.state) || !isPlainObject3(next2.state)) {
        return propsAreEqual4(prev, next2);
      }
      return propsAreEqual4(_objectSpread24(_objectSpread24({}, prev.state), prev), _objectSpread24(_objectSpread24({}, next2.state), next2));
    };
  }

  // node_modules/reakit-system/es/createComponent.js
  function forwardRef2(component) {
    return /* @__PURE__ */ (0, import_react8.forwardRef)(component);
  }
  function memo2(component, propsAreEqual4) {
    return /* @__PURE__ */ (0, import_react8.memo)(component, propsAreEqual4);
  }
  function createComponent(_ref8) {
    var type = _ref8.as, useHook = _ref8.useHook, shouldMemo = _ref8.memo, _ref$propsAreEqual = _ref8.propsAreEqual, propsAreEqual4 = _ref$propsAreEqual === void 0 ? useHook === null || useHook === void 0 ? void 0 : useHook.unstable_propsAreEqual : _ref$propsAreEqual, _ref$keys = _ref8.keys, keys = _ref$keys === void 0 ? (useHook === null || useHook === void 0 ? void 0 : useHook.__keys) || [] : _ref$keys, _ref$useCreateElement = _ref8.useCreateElement, useCreateElement$14 = _ref$useCreateElement === void 0 ? useCreateElement : _ref$useCreateElement;
    var Comp = function Comp2(_ref22, ref2) {
      var _ref2$as = _ref22.as, as = _ref2$as === void 0 ? type : _ref2$as, props = _objectWithoutPropertiesLoose2(_ref22, ["as"]);
      if (useHook) {
        var _as$render;
        var _splitProps = splitProps(props, keys), _options = _splitProps[0], htmlProps = _splitProps[1];
        var _useHook = useHook(_options, _objectSpread23({
          ref: ref2
        }, htmlProps)), wrapElement = _useHook.wrapElement, elementProps = _objectWithoutPropertiesLoose2(_useHook, ["wrapElement"]);
        var asKeys = ((_as$render = as.render) === null || _as$render === void 0 ? void 0 : _as$render.__keys) || as.__keys;
        var asOptions = asKeys && splitProps(props, asKeys)[0];
        var allProps = asOptions ? _objectSpread23(_objectSpread23({}, elementProps), asOptions) : elementProps;
        var _element = useCreateElement$14(as, allProps);
        if (wrapElement) {
          return wrapElement(_element);
        }
        return _element;
      }
      return useCreateElement$14(as, _objectSpread23({
        ref: ref2
      }, props));
    };
    if (useHook) {
      Comp.displayName = useHook.name.replace(/^(unstable_)?use/, "");
    }
    Comp = forwardRef2(Comp);
    if (shouldMemo) {
      Comp = memo2(Comp, propsAreEqual4 && normalizePropsAreEqual(propsAreEqual4));
    }
    Comp.__keys = keys;
    Comp.unstable_propsAreEqual = normalizePropsAreEqual(propsAreEqual4 || shallowEqual);
    return Comp;
  }

  // node_modules/reakit-system/es/createHook.js
  var import_react12 = __toESM(require_react());

  // node_modules/reakit-system/es/useToken.js
  var import_react9 = __toESM(require_react());
  function useToken(token, defaultValue) {
    (0, import_react9.useDebugValue)(token);
    var context2 = (0, import_react9.useContext)(SystemContext);
    return context2[token] != null ? context2[token] : defaultValue;
  }

  // node_modules/reakit-system/es/useProps.js
  var import_react10 = __toESM(require_react());
  function useProps(name, options, htmlProps) {
    if (options === void 0) {
      options = {};
    }
    if (htmlProps === void 0) {
      htmlProps = {};
    }
    var hookName = "use" + name + "Props";
    (0, import_react10.useDebugValue)(hookName);
    var useHook = useToken(hookName);
    if (useHook) {
      return useHook(options, htmlProps);
    }
    return htmlProps;
  }

  // node_modules/reakit-system/es/useOptions.js
  var import_react11 = __toESM(require_react());
  function useOptions(name, options, htmlProps) {
    if (options === void 0) {
      options = {};
    }
    if (htmlProps === void 0) {
      htmlProps = {};
    }
    var hookName = "use" + name + "Options";
    (0, import_react11.useDebugValue)(hookName);
    var useHook = useToken(hookName);
    if (useHook) {
      return _objectSpread23(_objectSpread23({}, options), useHook(options, htmlProps));
    }
    return options;
  }

  // node_modules/reakit-utils/es/toArray.js
  function toArray(arg) {
    if (Array.isArray(arg)) {
      return arg;
    }
    return typeof arg !== "undefined" ? [arg] : [];
  }

  // node_modules/reakit-system/es/createHook.js
  function createHook(options) {
    var _options$useState, _composedHooks$;
    var composedHooks = toArray(options.compose);
    var __useOptions = function __useOptions2(hookOptions, htmlProps) {
      if (options.useOptions) {
        hookOptions = options.useOptions(hookOptions, htmlProps);
      }
      if (options.name) {
        hookOptions = useOptions(options.name, hookOptions, htmlProps);
      }
      if (options.compose) {
        for (var _iterator = _createForOfIteratorHelperLoose2(composedHooks), _step; !(_step = _iterator()).done; ) {
          var hook = _step.value;
          hookOptions = hook.__useOptions(hookOptions, htmlProps);
        }
      }
      return hookOptions;
    };
    var useHook = function useHook2(hookOptions, htmlProps, unstable_ignoreUseOptions) {
      if (hookOptions === void 0) {
        hookOptions = {};
      }
      if (htmlProps === void 0) {
        htmlProps = {};
      }
      if (unstable_ignoreUseOptions === void 0) {
        unstable_ignoreUseOptions = false;
      }
      if (!unstable_ignoreUseOptions) {
        hookOptions = __useOptions(hookOptions, htmlProps);
      }
      if (options.useProps) {
        htmlProps = options.useProps(hookOptions, htmlProps);
      }
      if (options.name) {
        htmlProps = useProps(options.name, hookOptions, htmlProps);
      }
      if (options.compose) {
        if (options.useComposeOptions) {
          hookOptions = options.useComposeOptions(hookOptions, htmlProps);
        }
        if (options.useComposeProps) {
          htmlProps = options.useComposeProps(hookOptions, htmlProps);
        } else {
          for (var _iterator2 = _createForOfIteratorHelperLoose2(composedHooks), _step2; !(_step2 = _iterator2()).done; ) {
            var hook = _step2.value;
            htmlProps = hook(hookOptions, htmlProps, true);
          }
        }
      }
      var finalHTMLProps = {};
      var definedHTMLProps = htmlProps || {};
      for (var prop2 in definedHTMLProps) {
        if (definedHTMLProps[prop2] !== void 0) {
          finalHTMLProps[prop2] = definedHTMLProps[prop2];
        }
      }
      return finalHTMLProps;
    };
    useHook.__useOptions = __useOptions;
    var composedKeys = composedHooks.reduce(function(keys, hook) {
      keys.push.apply(keys, hook.__keys || []);
      return keys;
    }, []);
    useHook.__keys = [].concat(composedKeys, ((_options$useState = options.useState) === null || _options$useState === void 0 ? void 0 : _options$useState.__keys) || [], options.keys || []);
    useHook.unstable_propsAreEqual = options.propsAreEqual || ((_composedHooks$ = composedHooks[0]) === null || _composedHooks$ === void 0 ? void 0 : _composedHooks$.unstable_propsAreEqual) || shallowEqual;
    if (options.name) {
      Object.defineProperty(useHook, "name", {
        value: "use" + options.name
      });
    }
    return useHook;
  }

  // node_modules/reakit/es/index.js
  var import_react34 = __toESM(require_react());

  // node_modules/reakit-utils/es/useForkRef.js
  var import_react13 = __toESM(require_react());
  function setRef(ref2, value) {
    if (value === void 0) {
      value = null;
    }
    if (!ref2)
      return;
    if (typeof ref2 === "function") {
      ref2(value);
    } else {
      ref2.current = value;
    }
  }
  function useForkRef(refA, refB) {
    return (0, import_react13.useMemo)(function() {
      if (refA == null && refB == null) {
        return null;
      }
      return function(value) {
        setRef(refA, value);
        setRef(refB, value);
      };
    }, [refA, refB]);
  }

  // node_modules/reakit-utils/es/isButton.js
  var buttonInputTypes = ["button", "color", "file", "image", "reset", "submit"];
  function isButton(element) {
    if (element.tagName === "BUTTON")
      return true;
    if (element.tagName === "INPUT") {
      var input = element;
      return buttonInputTypes.indexOf(input.type) !== -1;
    }
    return false;
  }

  // node_modules/reakit-utils/es/flatten.js
  function flatten(array) {
    var flat = [];
    for (var _iterator = _createForOfIteratorHelperLoose3(array), _step; !(_step = _iterator()).done; ) {
      var maybeArray = _step.value;
      if (Array.isArray(maybeArray)) {
        flat.push.apply(flat, flatten(maybeArray));
      } else {
        flat.push(maybeArray);
      }
    }
    return flat;
  }

  // node_modules/reakit-warning/es/warning.js
  function warning2(condition) {
    if (true) {
      var _console;
      if (!condition)
        return;
      for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        messages[_key - 1] = arguments[_key];
      }
      var warns = flatten(messages.map(function(message) {
        return [message, "\n"];
      }));
      (_console = console).warn.apply(_console, warns.slice(0, -1));
      try {
        throw Error(warns.join(""));
      } catch (x4) {
      }
    }
  }

  // node_modules/reakit-warning/es/index.js
  var import_react15 = __toESM(require_react());

  // node_modules/reakit-warning/es/useWarning.js
  var import_react14 = __toESM(require_react());
  function isRefObject(ref2) {
    return isObject3(ref2) && "current" in ref2;
  }
  function useWarning(condition) {
    for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      messages[_key - 1] = arguments[_key];
    }
    if (true) {
      (0, import_react14.useEffect)(function() {
        true ? warning2.apply(void 0, [condition].concat(messages.map(function(message) {
          return isRefObject(message) ? message.current : message;
        }))) : void 0;
      }, [condition]);
    }
  }

  // node_modules/reakit-utils/es/useLiveRef.js
  var import_react17 = __toESM(require_react());

  // node_modules/reakit-utils/es/getDocument.js
  function getDocument2(element) {
    return element ? element.ownerDocument || element : document;
  }

  // node_modules/reakit-utils/es/getWindow.js
  var _window;
  try {
    _window = window;
  } catch (e4) {
  }
  function getWindow(element) {
    if (!element) {
      return _window;
    }
    return getDocument2(element).defaultView || _window;
  }

  // node_modules/reakit-utils/es/canUseDOM.js
  function checkIsBrowser() {
    var _window2 = getWindow();
    return Boolean(typeof _window2 !== "undefined" && _window2.document && _window2.document.createElement);
  }
  var canUseDOM = checkIsBrowser();

  // node_modules/reakit-utils/es/useIsomorphicEffect.js
  var import_react16 = __toESM(require_react());
  var useIsomorphicEffect = !canUseDOM ? import_react16.useEffect : import_react16.useLayoutEffect;

  // node_modules/reakit-utils/es/useLiveRef.js
  function useLiveRef(value) {
    var ref2 = (0, import_react17.useRef)(value);
    useIsomorphicEffect(function() {
      ref2.current = value;
    });
    return ref2;
  }

  // node_modules/reakit-utils/es/isSelfTarget.js
  function isSelfTarget(event) {
    return event.target === event.currentTarget;
  }

  // node_modules/reakit-utils/es/getActiveElement.js
  function getActiveElement(element) {
    var _getDocument = getDocument2(element), activeElement = _getDocument.activeElement;
    if (!(activeElement !== null && activeElement !== void 0 && activeElement.nodeName)) {
      return null;
    }
    return activeElement;
  }

  // node_modules/reakit-utils/es/contains.js
  function contains(parent, child) {
    return parent === child || parent.contains(child);
  }

  // node_modules/reakit-utils/es/hasFocusWithin.js
  function hasFocusWithin(element) {
    var activeElement = getActiveElement(element);
    if (!activeElement)
      return false;
    if (contains(element, activeElement))
      return true;
    var activeDescendant = activeElement.getAttribute("aria-activedescendant");
    if (!activeDescendant)
      return false;
    if (activeDescendant === element.id)
      return true;
    return !!element.querySelector("#" + activeDescendant);
  }

  // node_modules/reakit-utils/es/isPortalEvent.js
  function isPortalEvent(event) {
    return !contains(event.currentTarget, event.target);
  }

  // node_modules/reakit-utils/es/dom.js
  function isUA(string2) {
    if (!canUseDOM)
      return false;
    return window.navigator.userAgent.indexOf(string2) !== -1;
  }

  // node_modules/reakit-utils/es/matches.js
  function matches(element, selectors) {
    if ("matches" in element) {
      return element.matches(selectors);
    }
    if ("msMatchesSelector" in element) {
      return element.msMatchesSelector(selectors);
    }
    return element.webkitMatchesSelector(selectors);
  }

  // node_modules/reakit-utils/es/tabbable.js
  var selector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
  function isVisible2(element) {
    var htmlElement = element;
    return htmlElement.offsetWidth > 0 || htmlElement.offsetHeight > 0 || element.getClientRects().length > 0;
  }
  function isFocusable(element) {
    return matches(element, selector) && isVisible2(element);
  }

  // node_modules/reakit/es/Role/Role.js
  var ROLE_KEYS = ["unstable_system"];
  var useRole = createHook({
    name: "Role",
    keys: ROLE_KEYS,
    propsAreEqual: function propsAreEqual(prev, next2) {
      var prevSystem = prev.unstable_system, prevProps = _objectWithoutPropertiesLoose(prev, ["unstable_system"]);
      var nextSystem = next2.unstable_system, nextProps = _objectWithoutPropertiesLoose(next2, ["unstable_system"]);
      if (prevSystem !== nextSystem && !shallowEqual(prevSystem, nextSystem)) {
        return false;
      }
      return shallowEqual(prevProps, nextProps);
    }
  });
  var Role = createComponent({
    as: "div",
    useHook: useRole
  });

  // node_modules/reakit/es/Tabbable/Tabbable.js
  var import_react18 = __toESM(require_react());
  var TABBABLE_KEYS = ["disabled", "focusable"];
  var isSafariOrFirefoxOnMac = isUA("Mac") && !isUA("Chrome") && (isUA("Safari") || isUA("Firefox"));
  function focusIfNeeded(element) {
    if (!hasFocusWithin(element) && isFocusable(element)) {
      element.focus();
    }
  }
  function isNativeTabbable(element) {
    return ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"].includes(element.tagName);
  }
  function supportsDisabledAttribute(element) {
    return ["BUTTON", "INPUT", "SELECT", "TEXTAREA"].includes(element.tagName);
  }
  function getTabIndex2(trulyDisabled, nativeTabbable, supportsDisabled, htmlTabIndex) {
    if (trulyDisabled) {
      if (nativeTabbable && !supportsDisabled) {
        return -1;
      }
      return void 0;
    }
    if (nativeTabbable) {
      return htmlTabIndex;
    }
    return htmlTabIndex || 0;
  }
  function useDisableEvent(htmlEventRef, disabled) {
    return (0, import_react18.useCallback)(function(event) {
      var _htmlEventRef$current;
      (_htmlEventRef$current = htmlEventRef.current) === null || _htmlEventRef$current === void 0 ? void 0 : _htmlEventRef$current.call(htmlEventRef, event);
      if (event.defaultPrevented)
        return;
      if (disabled) {
        event.stopPropagation();
        event.preventDefault();
      }
    }, [htmlEventRef, disabled]);
  }
  var useTabbable = createHook({
    name: "Tabbable",
    compose: useRole,
    keys: TABBABLE_KEYS,
    useOptions: function useOptions2(options, _ref8) {
      var disabled = _ref8.disabled;
      return _objectSpread22({
        disabled
      }, options);
    },
    useProps: function useProps2(options, _ref22) {
      var htmlRef = _ref22.ref, htmlTabIndex = _ref22.tabIndex, htmlOnClickCapture = _ref22.onClickCapture, htmlOnMouseDownCapture = _ref22.onMouseDownCapture, htmlOnMouseDown = _ref22.onMouseDown, htmlOnKeyPressCapture = _ref22.onKeyPressCapture, htmlStyle = _ref22.style, htmlProps = _objectWithoutPropertiesLoose(_ref22, ["ref", "tabIndex", "onClickCapture", "onMouseDownCapture", "onMouseDown", "onKeyPressCapture", "style"]);
      var ref2 = (0, import_react18.useRef)(null);
      var onClickCaptureRef = useLiveRef(htmlOnClickCapture);
      var onMouseDownCaptureRef = useLiveRef(htmlOnMouseDownCapture);
      var onMouseDownRef = useLiveRef(htmlOnMouseDown);
      var onKeyPressCaptureRef = useLiveRef(htmlOnKeyPressCapture);
      var trulyDisabled = !!options.disabled && !options.focusable;
      var _React$useState = (0, import_react18.useState)(true), nativeTabbable = _React$useState[0], setNativeTabbable = _React$useState[1];
      var _React$useState2 = (0, import_react18.useState)(true), supportsDisabled = _React$useState2[0], setSupportsDisabled = _React$useState2[1];
      var style = options.disabled ? _objectSpread22({
        pointerEvents: "none"
      }, htmlStyle) : htmlStyle;
      useIsomorphicEffect(function() {
        var tabbable = ref2.current;
        if (!tabbable) {
          true ? warning2(true, "Can't determine if the element is a native tabbable element because `ref` wasn't passed to the component.", "See https://reakit.io/docs/tabbable") : void 0;
          return;
        }
        if (!isNativeTabbable(tabbable)) {
          setNativeTabbable(false);
        }
        if (!supportsDisabledAttribute(tabbable)) {
          setSupportsDisabled(false);
        }
      }, []);
      var onClickCapture = useDisableEvent(onClickCaptureRef, options.disabled);
      var onMouseDownCapture = useDisableEvent(onMouseDownCaptureRef, options.disabled);
      var onKeyPressCapture = useDisableEvent(onKeyPressCaptureRef, options.disabled);
      var onMouseDown = (0, import_react18.useCallback)(function(event) {
        var _onMouseDownRef$curre;
        (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
        var element = event.currentTarget;
        if (event.defaultPrevented)
          return;
        if (!isSafariOrFirefoxOnMac)
          return;
        if (isPortalEvent(event))
          return;
        if (!isButton(element))
          return;
        var raf2 = requestAnimationFrame(function() {
          element.removeEventListener("mouseup", focusImmediately, true);
          focusIfNeeded(element);
        });
        var focusImmediately = function focusImmediately2() {
          cancelAnimationFrame(raf2);
          focusIfNeeded(element);
        };
        element.addEventListener("mouseup", focusImmediately, {
          once: true,
          capture: true
        });
      }, []);
      return _objectSpread22({
        ref: useForkRef(ref2, htmlRef),
        style,
        tabIndex: getTabIndex2(trulyDisabled, nativeTabbable, supportsDisabled, htmlTabIndex),
        disabled: trulyDisabled && supportsDisabled ? true : void 0,
        "aria-disabled": options.disabled ? true : void 0,
        onClickCapture,
        onMouseDownCapture,
        onMouseDown,
        onKeyPressCapture
      }, htmlProps);
    }
  });
  var Tabbable = createComponent({
    as: "div",
    useHook: useTabbable
  });

  // node_modules/reakit/es/Clickable/Clickable.js
  var import_react19 = __toESM(require_react());
  var CLICKABLE_KEYS = ["unstable_clickOnEnter", "unstable_clickOnSpace"];
  function isNativeClick(event) {
    var element = event.currentTarget;
    if (!event.isTrusted)
      return false;
    return isButton(element) || element.tagName === "INPUT" || element.tagName === "TEXTAREA" || element.tagName === "A" || element.tagName === "SELECT";
  }
  var useClickable = createHook({
    name: "Clickable",
    compose: useTabbable,
    keys: CLICKABLE_KEYS,
    useOptions: function useOptions3(_ref8) {
      var _ref$unstable_clickOn = _ref8.unstable_clickOnEnter, unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? true : _ref$unstable_clickOn, _ref$unstable_clickOn2 = _ref8.unstable_clickOnSpace, unstable_clickOnSpace = _ref$unstable_clickOn2 === void 0 ? true : _ref$unstable_clickOn2, options = _objectWithoutPropertiesLoose(_ref8, ["unstable_clickOnEnter", "unstable_clickOnSpace"]);
      return _objectSpread22({
        unstable_clickOnEnter,
        unstable_clickOnSpace
      }, options);
    },
    useProps: function useProps3(options, _ref22) {
      var htmlOnKeyDown = _ref22.onKeyDown, htmlOnKeyUp = _ref22.onKeyUp, htmlProps = _objectWithoutPropertiesLoose(_ref22, ["onKeyDown", "onKeyUp"]);
      var _React$useState = (0, import_react19.useState)(false), active = _React$useState[0], setActive = _React$useState[1];
      var onKeyDownRef = useLiveRef(htmlOnKeyDown);
      var onKeyUpRef = useLiveRef(htmlOnKeyUp);
      var onKeyDown = (0, import_react19.useCallback)(function(event) {
        var _onKeyDownRef$current;
        (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
        if (event.defaultPrevented)
          return;
        if (options.disabled)
          return;
        if (event.metaKey)
          return;
        if (!isSelfTarget(event))
          return;
        var isEnter = options.unstable_clickOnEnter && event.key === "Enter";
        var isSpace2 = options.unstable_clickOnSpace && event.key === " ";
        if (isEnter || isSpace2) {
          if (isNativeClick(event))
            return;
          event.preventDefault();
          if (isEnter) {
            event.currentTarget.click();
          } else if (isSpace2) {
            setActive(true);
          }
        }
      }, [options.disabled, options.unstable_clickOnEnter, options.unstable_clickOnSpace]);
      var onKeyUp = (0, import_react19.useCallback)(function(event) {
        var _onKeyUpRef$current;
        (_onKeyUpRef$current = onKeyUpRef.current) === null || _onKeyUpRef$current === void 0 ? void 0 : _onKeyUpRef$current.call(onKeyUpRef, event);
        if (event.defaultPrevented)
          return;
        if (options.disabled)
          return;
        if (event.metaKey)
          return;
        var isSpace2 = options.unstable_clickOnSpace && event.key === " ";
        if (active && isSpace2) {
          setActive(false);
          event.currentTarget.click();
        }
      }, [options.disabled, options.unstable_clickOnSpace, active]);
      return _objectSpread22({
        "data-active": active || void 0,
        onKeyDown,
        onKeyUp
      }, htmlProps);
    }
  });
  var Clickable = createComponent({
    as: "button",
    memo: true,
    useHook: useClickable
  });

  // node_modules/reakit-utils/es/createEvent.js
  function createEvent(element, type, eventInit) {
    if (typeof Event === "function") {
      return new Event(type, eventInit);
    }
    var event = getDocument2(element).createEvent("Event");
    event.initEvent(type, eventInit === null || eventInit === void 0 ? void 0 : eventInit.bubbles, eventInit === null || eventInit === void 0 ? void 0 : eventInit.cancelable);
    return event;
  }

  // node_modules/reakit-utils/es/useSealedState.js
  var import_react20 = __toESM(require_react());
  function useSealedState(initialState) {
    var _React$useState = (0, import_react20.useState)(initialState), sealed = _React$useState[0];
    return sealed;
  }

  // node_modules/reakit-utils/es/fireBlurEvent.js
  function createFocusEvent(element, type, eventInit) {
    if (eventInit === void 0) {
      eventInit = {};
    }
    if (typeof FocusEvent === "function") {
      return new FocusEvent(type, eventInit);
    }
    return createEvent(element, type, eventInit);
  }
  function fireBlurEvent(element, eventInit) {
    var event = createFocusEvent(element, "blur", eventInit);
    var defaultAllowed = element.dispatchEvent(event);
    var bubbleInit = _objectSpread24(_objectSpread24({}, eventInit), {}, {
      bubbles: true
    });
    element.dispatchEvent(createFocusEvent(element, "focusout", bubbleInit));
    return defaultAllowed;
  }

  // node_modules/reakit-utils/es/fireKeyboardEvent.js
  function createKeyboardEvent(element, type, eventInit) {
    if (eventInit === void 0) {
      eventInit = {};
    }
    if (typeof KeyboardEvent === "function") {
      return new KeyboardEvent(type, eventInit);
    }
    var event = getDocument2(element).createEvent("KeyboardEvent");
    event.initKeyboardEvent(type, eventInit.bubbles, eventInit.cancelable, getWindow(element), eventInit.key, eventInit.location, eventInit.ctrlKey, eventInit.altKey, eventInit.shiftKey, eventInit.metaKey);
    return event;
  }
  function fireKeyboardEvent(element, type, eventInit) {
    return element.dispatchEvent(createKeyboardEvent(element, type, eventInit));
  }

  // node_modules/reakit-utils/es/getNextActiveElementOnBlur.js
  var isIE11 = canUseDOM && "msCrypto" in window;
  function getNextActiveElementOnBlur(event) {
    if (isIE11) {
      var activeElement = getActiveElement(event.currentTarget);
      return activeElement;
    }
    return event.relatedTarget;
  }

  // node_modules/reakit/es/reverse-30eaa122.js
  function groupItems(items) {
    var groups2 = [[]];
    var _loop = function _loop2() {
      var item2 = _step.value;
      var group2 = groups2.find(function(g5) {
        return !g5[0] || g5[0].groupId === item2.groupId;
      });
      if (group2) {
        group2.push(item2);
      } else {
        groups2.push([item2]);
      }
    };
    for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done; ) {
      _loop();
    }
    return groups2;
  }
  function flatten2(grid) {
    var flattened = [];
    for (var _iterator = _createForOfIteratorHelperLoose(grid), _step; !(_step = _iterator()).done; ) {
      var row2 = _step.value;
      flattened.push.apply(flattened, row2);
    }
    return flattened;
  }
  function reverse(array) {
    return array.slice().reverse();
  }

  // node_modules/reakit/es/getCurrentId-5aa9849e.js
  function findFirstEnabledItem(items, excludeId) {
    if (excludeId) {
      return items.find(function(item2) {
        return !item2.disabled && item2.id !== excludeId;
      });
    }
    return items.find(function(item2) {
      return !item2.disabled;
    });
  }
  function getCurrentId(options, passedId) {
    var _findFirstEnabledItem;
    if (passedId || passedId === null) {
      return passedId;
    }
    if (options.currentId || options.currentId === null) {
      return options.currentId;
    }
    return (_findFirstEnabledItem = findFirstEnabledItem(options.items || [])) === null || _findFirstEnabledItem === void 0 ? void 0 : _findFirstEnabledItem.id;
  }

  // node_modules/reakit/es/findEnabledItemById-8ddca752.js
  function findEnabledItemById(items, id2) {
    if (!id2)
      return void 0;
    return items === null || items === void 0 ? void 0 : items.find(function(item2) {
      return item2.id === id2 && !item2.disabled;
    });
  }

  // node_modules/reakit/es/__keys-6742f591.js
  var COMPOSITE_STATE_KEYS = ["baseId", "unstable_idCountRef", "setBaseId", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget"];
  var COMPOSITE_KEYS = COMPOSITE_STATE_KEYS;
  var COMPOSITE_GROUP_KEYS = COMPOSITE_KEYS;
  var COMPOSITE_ITEM_KEYS = COMPOSITE_GROUP_KEYS;

  // node_modules/reakit/es/userFocus-e16425e3.js
  function userFocus(element) {
    element.userFocus = true;
    element.focus();
    element.userFocus = false;
  }
  function hasUserFocus(element) {
    return !!element.userFocus;
  }
  function setUserFocus(element, value) {
    element.userFocus = value;
  }

  // node_modules/reakit/es/Composite/Composite.js
  var import_react21 = __toESM(require_react());
  var isIE112 = canUseDOM && "msCrypto" in window;
  function canProxyKeyboardEvent(event) {
    if (!isSelfTarget(event))
      return false;
    if (event.metaKey)
      return false;
    if (event.key === "Tab")
      return false;
    return true;
  }
  function useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {
    var eventHandlerRef = useLiveRef(htmlEventHandler);
    return (0, import_react21.useCallback)(function(event) {
      var _eventHandlerRef$curr;
      (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);
      if (event.defaultPrevented)
        return;
      if (virtual && canProxyKeyboardEvent(event)) {
        var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;
        if (currentElement) {
          if (!fireKeyboardEvent(currentElement, event.type, event)) {
            event.preventDefault();
          }
          if (event.currentTarget.contains(currentElement)) {
            event.stopPropagation();
          }
        }
      }
    }, [virtual, currentItem]);
  }
  function useActiveElementRef(elementRef) {
    var activeElementRef = (0, import_react21.useRef)(null);
    (0, import_react21.useEffect)(function() {
      var document3 = getDocument2(elementRef.current);
      var onFocus = function onFocus2(event) {
        var target = event.target;
        activeElementRef.current = target;
      };
      document3.addEventListener("focus", onFocus, true);
      return function() {
        document3.removeEventListener("focus", onFocus, true);
      };
    }, []);
    return activeElementRef;
  }
  function findFirstEnabledItemInTheLastRow(items) {
    return findFirstEnabledItem(flatten2(reverse(groupItems(items))));
  }
  function isItem(items, element) {
    return items === null || items === void 0 ? void 0 : items.some(function(item2) {
      return !!element && item2.ref.current === element;
    });
  }
  function useScheduleUserFocus(currentItem) {
    var currentItemRef = useLiveRef(currentItem);
    var _React$useReducer = (0, import_react21.useReducer)(function(n5) {
      return n5 + 1;
    }, 0), scheduled = _React$useReducer[0], schedule2 = _React$useReducer[1];
    (0, import_react21.useEffect)(function() {
      var _currentItemRef$curre;
      var currentElement = (_currentItemRef$curre = currentItemRef.current) === null || _currentItemRef$curre === void 0 ? void 0 : _currentItemRef$curre.ref.current;
      if (scheduled && currentElement) {
        userFocus(currentElement);
      }
    }, [scheduled]);
    return schedule2;
  }
  var useComposite = createHook({
    name: "Composite",
    compose: [useTabbable],
    keys: COMPOSITE_KEYS,
    useOptions: function useOptions4(options) {
      return _objectSpread22(_objectSpread22({}, options), {}, {
        currentId: getCurrentId(options)
      });
    },
    useProps: function useProps4(options, _ref8) {
      var htmlRef = _ref8.ref, htmlOnFocusCapture = _ref8.onFocusCapture, htmlOnFocus = _ref8.onFocus, htmlOnBlurCapture = _ref8.onBlurCapture, htmlOnKeyDown = _ref8.onKeyDown, htmlOnKeyDownCapture = _ref8.onKeyDownCapture, htmlOnKeyUpCapture = _ref8.onKeyUpCapture, htmlProps = _objectWithoutPropertiesLoose(_ref8, ["ref", "onFocusCapture", "onFocus", "onBlurCapture", "onKeyDown", "onKeyDownCapture", "onKeyUpCapture"]);
      var ref2 = (0, import_react21.useRef)(null);
      var currentItem = findEnabledItemById(options.items, options.currentId);
      var previousElementRef = (0, import_react21.useRef)(null);
      var onFocusCaptureRef = useLiveRef(htmlOnFocusCapture);
      var onFocusRef = useLiveRef(htmlOnFocus);
      var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);
      var onKeyDownRef = useLiveRef(htmlOnKeyDown);
      var scheduleUserFocus = useScheduleUserFocus(currentItem);
      var activeElementRef = isIE112 ? useActiveElementRef(ref2) : void 0;
      (0, import_react21.useEffect)(function() {
        var element = ref2.current;
        if (options.unstable_moves && !currentItem) {
          true ? warning2(!element, "Can't focus composite component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
          element === null || element === void 0 ? void 0 : element.focus();
        }
      }, [options.unstable_moves, currentItem]);
      var onKeyDownCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDownCapture);
      var onKeyUpCapture = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUpCapture);
      var onFocusCapture = (0, import_react21.useCallback)(function(event) {
        var _onFocusCaptureRef$cu;
        (_onFocusCaptureRef$cu = onFocusCaptureRef.current) === null || _onFocusCaptureRef$cu === void 0 ? void 0 : _onFocusCaptureRef$cu.call(onFocusCaptureRef, event);
        if (event.defaultPrevented)
          return;
        if (!options.unstable_virtual)
          return;
        var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;
        var previousActiveElementWasItem = isItem(options.items, previousActiveElement);
        if (isSelfTarget(event) && previousActiveElementWasItem) {
          event.stopPropagation();
          previousElementRef.current = previousActiveElement;
        }
      }, [options.unstable_virtual, options.items]);
      var onFocus = (0, import_react21.useCallback)(function(event) {
        var _onFocusRef$current;
        (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
        if (event.defaultPrevented)
          return;
        if (options.unstable_virtual) {
          if (isSelfTarget(event)) {
            scheduleUserFocus();
          }
        } else if (isSelfTarget(event)) {
          var _options$setCurrentId;
          (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);
        }
      }, [options.unstable_virtual, options.setCurrentId]);
      var onBlurCapture = (0, import_react21.useCallback)(function(event) {
        var _onBlurCaptureRef$cur;
        (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);
        if (event.defaultPrevented)
          return;
        if (!options.unstable_virtual)
          return;
        var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null;
        var nextActiveElement = getNextActiveElementOnBlur(event);
        var nextActiveElementIsItem = isItem(options.items, nextActiveElement);
        if (isSelfTarget(event) && nextActiveElementIsItem) {
          if (nextActiveElement === currentElement) {
            if (previousElementRef.current && previousElementRef.current !== nextActiveElement) {
              fireBlurEvent(previousElementRef.current, event);
            }
          } else if (currentElement) {
            fireBlurEvent(currentElement, event);
          }
          event.stopPropagation();
        } else {
          var targetIsItem = isItem(options.items, event.target);
          if (!targetIsItem && currentElement) {
            fireBlurEvent(currentElement, event);
          }
        }
      }, [options.unstable_virtual, options.items, currentItem]);
      var onKeyDown = (0, import_react21.useCallback)(function(event) {
        var _onKeyDownRef$current, _options$groups;
        (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
        if (event.defaultPrevented)
          return;
        if (options.currentId !== null)
          return;
        if (!isSelfTarget(event))
          return;
        var isVertical = options.orientation !== "horizontal";
        var isHorizontal = options.orientation !== "vertical";
        var isGrid = !!((_options$groups = options.groups) !== null && _options$groups !== void 0 && _options$groups.length);
        var up = function up2() {
          if (isGrid) {
            var item2 = findFirstEnabledItemInTheLastRow(options.items);
            if (item2 !== null && item2 !== void 0 && item2.id) {
              var _options$move;
              (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item2.id);
            }
          } else {
            var _options$last;
            (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
          }
        };
        var keyMap = {
          ArrowUp: (isGrid || isVertical) && up,
          ArrowRight: (isGrid || isHorizontal) && options.first,
          ArrowDown: (isGrid || isVertical) && options.first,
          ArrowLeft: (isGrid || isHorizontal) && options.last,
          Home: options.first,
          End: options.last,
          PageUp: options.first,
          PageDown: options.last
        };
        var action = keyMap[event.key];
        if (action) {
          event.preventDefault();
          action();
        }
      }, [options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);
      return _objectSpread22({
        ref: useForkRef(ref2, htmlRef),
        id: options.baseId,
        onFocus,
        onFocusCapture,
        onBlurCapture,
        onKeyDownCapture,
        onKeyDown,
        onKeyUpCapture,
        "aria-activedescendant": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || void 0 : void 0
      }, htmlProps);
    },
    useComposeProps: function useComposeProps(options, htmlProps) {
      htmlProps = useRole(options, htmlProps, true);
      var tabbableHTMLProps = useTabbable(options, htmlProps, true);
      if (options.unstable_virtual || options.currentId === null) {
        return _objectSpread22({
          tabIndex: 0
        }, tabbableHTMLProps);
      }
      return _objectSpread22(_objectSpread22({}, htmlProps), {}, {
        ref: tabbableHTMLProps.ref
      });
    }
  });
  var Composite = createComponent({
    as: "div",
    useHook: useComposite,
    useCreateElement: function useCreateElement$1(type, props, children) {
      true ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/composite") : void 0;
      return useCreateElement(type, props, children);
    }
  });

  // node_modules/reakit-utils/es/isTextField.js
  function isTextField2(element) {
    try {
      var isTextInput = element instanceof HTMLInputElement && element.selectionStart !== null;
      var isTextArea = element.tagName === "TEXTAREA";
      var isContentEditable = element.contentEditable === "true";
      return isTextInput || isTextArea || isContentEditable || false;
    } catch (error2) {
      return false;
    }
  }

  // node_modules/reakit-utils/es/hasFocus.js
  function hasFocus(element) {
    var activeElement = getActiveElement(element);
    if (!activeElement)
      return false;
    if (activeElement === element)
      return true;
    var activeDescendant = activeElement.getAttribute("aria-activedescendant");
    if (!activeDescendant)
      return false;
    return activeDescendant === element.id;
  }

  // node_modules/reakit-utils/es/ensureFocus.js
  function ensureFocus(element, _temp) {
    var _ref8 = _temp === void 0 ? {} : _temp, preventScroll = _ref8.preventScroll, _ref$isActive = _ref8.isActive, isActive = _ref$isActive === void 0 ? hasFocus : _ref$isActive;
    if (isActive(element))
      return -1;
    element.focus({
      preventScroll
    });
    if (isActive(element))
      return -1;
    return requestAnimationFrame(function() {
      element.focus({
        preventScroll
      });
    });
  }

  // node_modules/reakit/es/Id/IdProvider.js
  var import_react22 = __toESM(require_react());
  var defaultPrefix = "id";
  function generateRandomString(prefix2) {
    if (prefix2 === void 0) {
      prefix2 = defaultPrefix;
    }
    return (prefix2 ? prefix2 + "-" : "") + Math.random().toString(32).substr(2, 6);
  }
  var unstable_IdContext = /* @__PURE__ */ (0, import_react22.createContext)(generateRandomString);

  // node_modules/reakit/es/Id/Id.js
  var import_react23 = __toESM(require_react());
  var ID_STATE_KEYS = ["baseId", "unstable_idCountRef", "setBaseId"];
  var ID_KEYS = [].concat(ID_STATE_KEYS, ["id"]);
  var unstable_useId = createHook({
    keys: ID_KEYS,
    useOptions: function useOptions5(options, htmlProps) {
      var generateId = (0, import_react23.useContext)(unstable_IdContext);
      var _React$useState = (0, import_react23.useState)(function() {
        if (options.unstable_idCountRef) {
          options.unstable_idCountRef.current += 1;
          return "-" + options.unstable_idCountRef.current;
        }
        if (options.baseId) {
          return "-" + generateId("");
        }
        return "";
      }), suffix = _React$useState[0];
      var baseId = (0, import_react23.useMemo)(function() {
        return options.baseId || generateId();
      }, [options.baseId, generateId]);
      var id2 = htmlProps.id || options.id || "" + baseId + suffix;
      return _objectSpread22(_objectSpread22({}, options), {}, {
        id: id2
      });
    },
    useProps: function useProps5(options, htmlProps) {
      return _objectSpread22({
        id: options.id
      }, htmlProps);
    }
  });
  var unstable_Id = createComponent({
    as: "div",
    useHook: unstable_useId
  });

  // node_modules/reakit-utils/es/fireEvent.js
  function fireEvent(element, type, eventInit) {
    return element.dispatchEvent(createEvent(element, type, eventInit));
  }

  // node_modules/reakit/es/setTextFieldValue-0a221f4e.js
  function setTextFieldValue(element, value) {
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
      var _Object$getOwnPropert;
      var proto = Object.getPrototypeOf(element);
      var setValue = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(proto, "value")) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.set;
      if (setValue) {
        setValue.call(element, value);
        fireEvent(element, "input", {
          bubbles: true
        });
      }
    }
  }

  // node_modules/reakit/es/Composite/CompositeItem.js
  var import_react24 = __toESM(require_react());
  function getWidget(itemElement) {
    return itemElement.querySelector("[data-composite-item-widget]");
  }
  function useItem(options) {
    return (0, import_react24.useMemo)(function() {
      var _options$items;
      return (_options$items = options.items) === null || _options$items === void 0 ? void 0 : _options$items.find(function(item2) {
        return options.id && item2.id === options.id;
      });
    }, [options.items, options.id]);
  }
  function targetIsAnotherItem(event, items) {
    if (isSelfTarget(event))
      return false;
    for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done; ) {
      var item2 = _step.value;
      if (item2.ref.current === event.target) {
        return true;
      }
    }
    return false;
  }
  var useCompositeItem = createHook({
    name: "CompositeItem",
    compose: [useClickable, unstable_useId],
    keys: COMPOSITE_ITEM_KEYS,
    propsAreEqual: function propsAreEqual2(prev, next2) {
      if (!next2.id || prev.id !== next2.id) {
        return useClickable.unstable_propsAreEqual(prev, next2);
      }
      var prevCurrentId = prev.currentId, prevMoves = prev.unstable_moves, prevProps = _objectWithoutPropertiesLoose(prev, ["currentId", "unstable_moves"]);
      var nextCurrentId = next2.currentId, nextMoves = next2.unstable_moves, nextProps = _objectWithoutPropertiesLoose(next2, ["currentId", "unstable_moves"]);
      if (nextCurrentId !== prevCurrentId) {
        if (next2.id === nextCurrentId || next2.id === prevCurrentId) {
          return false;
        }
      } else if (prevMoves !== nextMoves) {
        return false;
      }
      return useClickable.unstable_propsAreEqual(prevProps, nextProps);
    },
    useOptions: function useOptions6(options) {
      return _objectSpread22(_objectSpread22({}, options), {}, {
        id: options.id,
        currentId: getCurrentId(options),
        unstable_clickOnSpace: options.unstable_hasActiveWidget ? false : options.unstable_clickOnSpace
      });
    },
    useProps: function useProps6(options, _ref8) {
      var _options$items2;
      var htmlRef = _ref8.ref, _ref$tabIndex = _ref8.tabIndex, htmlTabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, htmlOnMouseDown = _ref8.onMouseDown, htmlOnFocus = _ref8.onFocus, htmlOnBlurCapture = _ref8.onBlurCapture, htmlOnKeyDown = _ref8.onKeyDown, htmlOnClick = _ref8.onClick, htmlProps = _objectWithoutPropertiesLoose(_ref8, ["ref", "tabIndex", "onMouseDown", "onFocus", "onBlurCapture", "onKeyDown", "onClick"]);
      var ref2 = (0, import_react24.useRef)(null);
      var id2 = options.id;
      var trulyDisabled = options.disabled && !options.focusable;
      var isCurrentItem = options.currentId === id2;
      var isCurrentItemRef = useLiveRef(isCurrentItem);
      var hasFocusedComposite = (0, import_react24.useRef)(false);
      var item2 = useItem(options);
      var onMouseDownRef = useLiveRef(htmlOnMouseDown);
      var onFocusRef = useLiveRef(htmlOnFocus);
      var onBlurCaptureRef = useLiveRef(htmlOnBlurCapture);
      var onKeyDownRef = useLiveRef(htmlOnKeyDown);
      var onClickRef = useLiveRef(htmlOnClick);
      var shouldTabIndex = !options.unstable_virtual && !options.unstable_hasActiveWidget && isCurrentItem || !((_options$items2 = options.items) !== null && _options$items2 !== void 0 && _options$items2.length);
      (0, import_react24.useEffect)(function() {
        var _options$registerItem;
        if (!id2)
          return void 0;
        (_options$registerItem = options.registerItem) === null || _options$registerItem === void 0 ? void 0 : _options$registerItem.call(options, {
          id: id2,
          ref: ref2,
          disabled: !!trulyDisabled
        });
        return function() {
          var _options$unregisterIt;
          (_options$unregisterIt = options.unregisterItem) === null || _options$unregisterIt === void 0 ? void 0 : _options$unregisterIt.call(options, id2);
        };
      }, [id2, trulyDisabled, options.registerItem, options.unregisterItem]);
      (0, import_react24.useEffect)(function() {
        var element = ref2.current;
        if (!element) {
          true ? warning2(true, "Can't focus composite item component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
          return;
        }
        if (options.unstable_moves && isCurrentItemRef.current) {
          userFocus(element);
        }
      }, [options.unstable_moves]);
      var onMouseDown = (0, import_react24.useCallback)(function(event) {
        var _onMouseDownRef$curre;
        (_onMouseDownRef$curre = onMouseDownRef.current) === null || _onMouseDownRef$curre === void 0 ? void 0 : _onMouseDownRef$curre.call(onMouseDownRef, event);
        setUserFocus(event.currentTarget, true);
      }, []);
      var onFocus = (0, import_react24.useCallback)(function(event) {
        var _onFocusRef$current, _options$setCurrentId;
        var shouldFocusComposite = hasUserFocus(event.currentTarget);
        setUserFocus(event.currentTarget, false);
        (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
        if (event.defaultPrevented)
          return;
        if (isPortalEvent(event))
          return;
        if (!id2)
          return;
        if (targetIsAnotherItem(event, options.items))
          return;
        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, id2);
        if (shouldFocusComposite && options.unstable_virtual && options.baseId && isSelfTarget(event)) {
          var target = event.target;
          var composite = getDocument2(target).getElementById(options.baseId);
          if (composite) {
            hasFocusedComposite.current = true;
            ensureFocus(composite);
          }
        }
      }, [id2, options.items, options.setCurrentId, options.unstable_virtual, options.baseId]);
      var onBlurCapture = (0, import_react24.useCallback)(function(event) {
        var _onBlurCaptureRef$cur;
        (_onBlurCaptureRef$cur = onBlurCaptureRef.current) === null || _onBlurCaptureRef$cur === void 0 ? void 0 : _onBlurCaptureRef$cur.call(onBlurCaptureRef, event);
        if (event.defaultPrevented)
          return;
        if (options.unstable_virtual && hasFocusedComposite.current) {
          hasFocusedComposite.current = false;
          event.preventDefault();
          event.stopPropagation();
        }
      }, [options.unstable_virtual]);
      var onKeyDown = (0, import_react24.useCallback)(function(event) {
        var _onKeyDownRef$current;
        if (!isSelfTarget(event))
          return;
        var isVertical = options.orientation !== "horizontal";
        var isHorizontal = options.orientation !== "vertical";
        var isGrid = !!(item2 !== null && item2 !== void 0 && item2.groupId);
        var keyMap = {
          ArrowUp: (isGrid || isVertical) && options.up,
          ArrowRight: (isGrid || isHorizontal) && options.next,
          ArrowDown: (isGrid || isVertical) && options.down,
          ArrowLeft: (isGrid || isHorizontal) && options.previous,
          Home: function Home() {
            if (!isGrid || event.ctrlKey) {
              var _options$first;
              (_options$first = options.first) === null || _options$first === void 0 ? void 0 : _options$first.call(options);
            } else {
              var _options$previous;
              (_options$previous = options.previous) === null || _options$previous === void 0 ? void 0 : _options$previous.call(options, true);
            }
          },
          End: function End() {
            if (!isGrid || event.ctrlKey) {
              var _options$last;
              (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
            } else {
              var _options$next;
              (_options$next = options.next) === null || _options$next === void 0 ? void 0 : _options$next.call(options, true);
            }
          },
          PageUp: function PageUp() {
            if (isGrid) {
              var _options$up;
              (_options$up = options.up) === null || _options$up === void 0 ? void 0 : _options$up.call(options, true);
            } else {
              var _options$first2;
              (_options$first2 = options.first) === null || _options$first2 === void 0 ? void 0 : _options$first2.call(options);
            }
          },
          PageDown: function PageDown() {
            if (isGrid) {
              var _options$down;
              (_options$down = options.down) === null || _options$down === void 0 ? void 0 : _options$down.call(options, true);
            } else {
              var _options$last2;
              (_options$last2 = options.last) === null || _options$last2 === void 0 ? void 0 : _options$last2.call(options);
            }
          }
        };
        var action = keyMap[event.key];
        if (action) {
          event.preventDefault();
          action();
          return;
        }
        (_onKeyDownRef$current = onKeyDownRef.current) === null || _onKeyDownRef$current === void 0 ? void 0 : _onKeyDownRef$current.call(onKeyDownRef, event);
        if (event.defaultPrevented)
          return;
        if (event.key.length === 1 && event.key !== " ") {
          var widget = getWidget(event.currentTarget);
          if (widget && isTextField2(widget)) {
            widget.focus();
            setTextFieldValue(widget, "");
          }
        } else if (event.key === "Delete" || event.key === "Backspace") {
          var _widget = getWidget(event.currentTarget);
          if (_widget && isTextField2(_widget)) {
            event.preventDefault();
            setTextFieldValue(_widget, "");
          }
        }
      }, [options.orientation, item2, options.up, options.next, options.down, options.previous, options.first, options.last]);
      var onClick = (0, import_react24.useCallback)(function(event) {
        var _onClickRef$current;
        (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
        if (event.defaultPrevented)
          return;
        var element = event.currentTarget;
        var widget = getWidget(element);
        if (widget && !hasFocusWithin(widget)) {
          widget.focus();
        }
      }, []);
      return _objectSpread22({
        ref: useForkRef(ref2, htmlRef),
        id: id2,
        tabIndex: shouldTabIndex ? htmlTabIndex : -1,
        "aria-selected": options.unstable_virtual && isCurrentItem ? true : void 0,
        onMouseDown,
        onFocus,
        onBlurCapture,
        onKeyDown,
        onClick
      }, htmlProps);
    }
  });
  var CompositeItem = createComponent({
    as: "button",
    memo: true,
    useHook: useCompositeItem
  });

  // node_modules/reakit/es/Group/Group.js
  var GROUP_KEYS = [];
  var useGroup = createHook({
    name: "Group",
    compose: useRole,
    keys: GROUP_KEYS,
    useProps: function useProps7(_, htmlProps) {
      return _objectSpread22({
        role: "group"
      }, htmlProps);
    }
  });
  var Group = createComponent({
    as: "div",
    useHook: useGroup
  });

  // node_modules/reakit/es/Composite/CompositeGroup.js
  var import_react25 = __toESM(require_react());
  var useCompositeGroup = createHook({
    name: "CompositeGroup",
    compose: [useGroup, unstable_useId],
    keys: COMPOSITE_GROUP_KEYS,
    propsAreEqual: function propsAreEqual3(prev, next2) {
      if (!next2.id || prev.id !== next2.id) {
        return useGroup.unstable_propsAreEqual(prev, next2);
      }
      var prevCurrentId = prev.currentId, prevMoves = prev.unstable_moves, prevProps = _objectWithoutPropertiesLoose(prev, ["currentId", "unstable_moves"]);
      var nextCurrentId = next2.currentId, nextMoves = next2.unstable_moves, nextProps = _objectWithoutPropertiesLoose(next2, ["currentId", "unstable_moves"]);
      if (prev.items && next2.items) {
        var prevCurrentItem = findEnabledItemById(prev.items, prevCurrentId);
        var nextCurrentItem = findEnabledItemById(next2.items, nextCurrentId);
        var prevGroupId = prevCurrentItem === null || prevCurrentItem === void 0 ? void 0 : prevCurrentItem.groupId;
        var nextGroupId = nextCurrentItem === null || nextCurrentItem === void 0 ? void 0 : nextCurrentItem.groupId;
        if (next2.id === nextGroupId || next2.id === prevGroupId) {
          return false;
        }
      }
      return useGroup.unstable_propsAreEqual(prevProps, nextProps);
    },
    useProps: function useProps8(options, _ref8) {
      var htmlRef = _ref8.ref, htmlProps = _objectWithoutPropertiesLoose(_ref8, ["ref"]);
      var ref2 = (0, import_react25.useRef)(null);
      var id2 = options.id;
      useIsomorphicEffect(function() {
        var _options$registerGrou;
        if (!id2)
          return void 0;
        (_options$registerGrou = options.registerGroup) === null || _options$registerGrou === void 0 ? void 0 : _options$registerGrou.call(options, {
          id: id2,
          ref: ref2
        });
        return function() {
          var _options$unregisterGr;
          (_options$unregisterGr = options.unregisterGroup) === null || _options$unregisterGr === void 0 ? void 0 : _options$unregisterGr.call(options, id2);
        };
      }, [id2, options.registerGroup, options.unregisterGroup]);
      return _objectSpread22({
        ref: useForkRef(ref2, htmlRef)
      }, htmlProps);
    }
  });
  var CompositeGroup = createComponent({
    as: "div",
    useHook: useCompositeGroup
  });

  // node_modules/reakit-utils/es/applyState.js
  function isUpdater(argument) {
    return typeof argument === "function";
  }
  function applyState(argument, currentValue) {
    if (isUpdater(argument)) {
      return argument(currentValue);
    }
    return argument;
  }

  // node_modules/reakit/es/Id/IdState.js
  var import_react26 = __toESM(require_react());
  function unstable_useIdState(initialState) {
    if (initialState === void 0) {
      initialState = {};
    }
    var _useSealedState = useSealedState(initialState), initialBaseId = _useSealedState.baseId;
    var generateId = (0, import_react26.useContext)(unstable_IdContext);
    var idCountRef = (0, import_react26.useRef)(0);
    var _React$useState = (0, import_react26.useState)(function() {
      return initialBaseId || generateId();
    }), baseId = _React$useState[0], setBaseId = _React$useState[1];
    return {
      baseId,
      setBaseId,
      unstable_idCountRef: idCountRef
    };
  }

  // node_modules/reakit/es/Composite/CompositeState.js
  var import_react27 = __toESM(require_react());
  function isElementPreceding(element1, element2) {
    return Boolean(element2.compareDocumentPosition(element1) & Node.DOCUMENT_POSITION_PRECEDING);
  }
  function findDOMIndex(items, item2) {
    return items.findIndex(function(currentItem) {
      if (!currentItem.ref.current || !item2.ref.current) {
        return false;
      }
      return isElementPreceding(item2.ref.current, currentItem.ref.current);
    });
  }
  function getMaxLength(rows) {
    var maxLength = 0;
    for (var _iterator = _createForOfIteratorHelperLoose(rows), _step; !(_step = _iterator()).done; ) {
      var length = _step.value.length;
      if (length > maxLength) {
        maxLength = length;
      }
    }
    return maxLength;
  }
  function verticalizeItems(items) {
    var groups2 = groupItems(items);
    var maxLength = getMaxLength(groups2);
    var verticalized = [];
    for (var i5 = 0; i5 < maxLength; i5 += 1) {
      for (var _iterator = _createForOfIteratorHelperLoose(groups2), _step; !(_step = _iterator()).done; ) {
        var group2 = _step.value;
        if (group2[i5]) {
          verticalized.push(_objectSpread22(_objectSpread22({}, group2[i5]), {}, {
            groupId: group2[i5].groupId ? "" + i5 : void 0
          }));
        }
      }
    }
    return verticalized;
  }
  function createEmptyItem(groupId) {
    return {
      id: "__EMPTY_ITEM__",
      disabled: true,
      ref: {
        current: null
      },
      groupId
    };
  }
  function fillGroups(groups2, currentId, shift) {
    var maxLength = getMaxLength(groups2);
    for (var _iterator = _createForOfIteratorHelperLoose(groups2), _step; !(_step = _iterator()).done; ) {
      var group2 = _step.value;
      for (var i5 = 0; i5 < maxLength; i5 += 1) {
        var item2 = group2[i5];
        if (!item2 || shift && item2.disabled) {
          var isFrist = i5 === 0;
          var previousItem = isFrist && shift ? findFirstEnabledItem(group2) : group2[i5 - 1];
          group2[i5] = previousItem && currentId !== (previousItem === null || previousItem === void 0 ? void 0 : previousItem.id) && shift ? previousItem : createEmptyItem(previousItem === null || previousItem === void 0 ? void 0 : previousItem.groupId);
        }
      }
    }
    return groups2;
  }
  var nullItem = {
    id: null,
    ref: {
      current: null
    }
  };
  function placeItemsAfter(items, id2, shouldInsertNullItem) {
    var index2 = items.findIndex(function(item2) {
      return item2.id === id2;
    });
    return [].concat(items.slice(index2 + 1), shouldInsertNullItem ? [nullItem] : [], items.slice(0, index2));
  }
  function getItemsInGroup(items, groupId) {
    return items.filter(function(item2) {
      return item2.groupId === groupId;
    });
  }
  var map3 = {
    horizontal: "vertical",
    vertical: "horizontal"
  };
  function getOppositeOrientation(orientation) {
    return orientation && map3[orientation];
  }
  function addItemAtIndex(array, item2, index2) {
    if (!(index2 in array)) {
      return [].concat(array, [item2]);
    }
    return [].concat(array.slice(0, index2), [item2], array.slice(index2));
  }
  function sortBasedOnDOMPosition(items) {
    var pairs = items.map(function(item2, index2) {
      return [index2, item2];
    });
    var isOrderDifferent = false;
    pairs.sort(function(_ref8, _ref22) {
      var indexA = _ref8[0], a6 = _ref8[1];
      var indexB = _ref22[0], b6 = _ref22[1];
      var elementA = a6.ref.current;
      var elementB = b6.ref.current;
      if (!elementA || !elementB)
        return 0;
      if (isElementPreceding(elementA, elementB)) {
        if (indexA > indexB) {
          isOrderDifferent = true;
        }
        return -1;
      }
      if (indexA < indexB) {
        isOrderDifferent = true;
      }
      return 1;
    });
    if (isOrderDifferent) {
      return pairs.map(function(_ref32) {
        var _ = _ref32[0], item2 = _ref32[1];
        return item2;
      });
    }
    return items;
  }
  function setItemsBasedOnDOMPosition(items, setItems) {
    var sortedItems = sortBasedOnDOMPosition(items);
    if (items !== sortedItems) {
      setItems(sortedItems);
    }
  }
  function getCommonParent(items) {
    var _firstItem$ref$curren;
    var firstItem = items[0], nextItems = items.slice(1);
    var parentElement = firstItem === null || firstItem === void 0 ? void 0 : (_firstItem$ref$curren = firstItem.ref.current) === null || _firstItem$ref$curren === void 0 ? void 0 : _firstItem$ref$curren.parentElement;
    var _loop = function _loop2() {
      var parent = parentElement;
      if (nextItems.every(function(item2) {
        return parent.contains(item2.ref.current);
      })) {
        return {
          v: parentElement
        };
      }
      parentElement = parentElement.parentElement;
    };
    while (parentElement) {
      var _ret = _loop();
      if (typeof _ret === "object")
        return _ret.v;
    }
    return getDocument2(parentElement).body;
  }
  function useIntersectionObserver(items, setItems) {
    var previousItems = (0, import_react27.useRef)([]);
    (0, import_react27.useEffect)(function() {
      var callback = function callback2() {
        var hasPreviousItems = !!previousItems.current.length;
        if (hasPreviousItems) {
          setItemsBasedOnDOMPosition(items, setItems);
        }
        previousItems.current = items;
      };
      var root = getCommonParent(items);
      var observer = new IntersectionObserver(callback, {
        root
      });
      for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done; ) {
        var item2 = _step.value;
        if (item2.ref.current) {
          observer.observe(item2.ref.current);
        }
      }
      return function() {
        observer.disconnect();
      };
    }, [items]);
  }
  function useTimeoutObserver(items, setItems) {
    (0, import_react27.useEffect)(function() {
      var callback = function callback2() {
        return setItemsBasedOnDOMPosition(items, setItems);
      };
      var timeout = setTimeout(callback, 250);
      return function() {
        return clearTimeout(timeout);
      };
    });
  }
  function useSortBasedOnDOMPosition(items, setItems) {
    if (typeof IntersectionObserver === "function") {
      useIntersectionObserver(items, setItems);
    } else {
      useTimeoutObserver(items, setItems);
    }
  }
  function reducer(state, action) {
    var virtual = state.unstable_virtual, rtl2 = state.rtl, orientation = state.orientation, items = state.items, groups2 = state.groups, currentId = state.currentId, loop2 = state.loop, wrap3 = state.wrap, pastIds = state.pastIds, shift = state.shift, moves = state.unstable_moves, includesBaseElement = state.unstable_includesBaseElement, initialVirtual = state.initialVirtual, initialRTL = state.initialRTL, initialOrientation = state.initialOrientation, initialCurrentId = state.initialCurrentId, initialLoop = state.initialLoop, initialWrap = state.initialWrap, initialShift = state.initialShift, hasSetCurrentId = state.hasSetCurrentId;
    switch (action.type) {
      case "registerGroup": {
        var _group = action.group;
        if (groups2.length === 0) {
          return _objectSpread22(_objectSpread22({}, state), {}, {
            groups: [_group]
          });
        }
        var index2 = findDOMIndex(groups2, _group);
        return _objectSpread22(_objectSpread22({}, state), {}, {
          groups: addItemAtIndex(groups2, _group, index2)
        });
      }
      case "unregisterGroup": {
        var _id = action.id;
        var nextGroups = groups2.filter(function(group2) {
          return group2.id !== _id;
        });
        if (nextGroups.length === groups2.length) {
          return state;
        }
        return _objectSpread22(_objectSpread22({}, state), {}, {
          groups: nextGroups
        });
      }
      case "registerItem": {
        var _item = action.item;
        var _group2 = groups2.find(function(r5) {
          var _r$ref$current;
          return (_r$ref$current = r5.ref.current) === null || _r$ref$current === void 0 ? void 0 : _r$ref$current.contains(_item.ref.current);
        });
        var nextItem = _objectSpread22({
          groupId: _group2 === null || _group2 === void 0 ? void 0 : _group2.id
        }, _item);
        var _index = findDOMIndex(items, nextItem);
        var nextState = _objectSpread22(_objectSpread22({}, state), {}, {
          items: addItemAtIndex(items, nextItem, _index)
        });
        if (!hasSetCurrentId && !moves && initialCurrentId === void 0) {
          var _findFirstEnabledItem;
          return _objectSpread22(_objectSpread22({}, nextState), {}, {
            currentId: (_findFirstEnabledItem = findFirstEnabledItem(nextState.items)) === null || _findFirstEnabledItem === void 0 ? void 0 : _findFirstEnabledItem.id
          });
        }
        return nextState;
      }
      case "unregisterItem": {
        var _id2 = action.id;
        var nextItems = items.filter(function(item2) {
          return item2.id !== _id2;
        });
        if (nextItems.length === items.length) {
          return state;
        }
        var nextPastIds = pastIds.filter(function(pastId) {
          return pastId !== _id2;
        });
        var _nextState = _objectSpread22(_objectSpread22({}, state), {}, {
          pastIds: nextPastIds,
          items: nextItems
        });
        if (currentId && currentId === _id2) {
          var nextId2 = includesBaseElement ? null : getCurrentId(_objectSpread22(_objectSpread22({}, _nextState), {}, {
            currentId: nextPastIds[0]
          }));
          return _objectSpread22(_objectSpread22({}, _nextState), {}, {
            currentId: nextId2
          });
        }
        return _nextState;
      }
      case "move": {
        var _id3 = action.id;
        if (_id3 === void 0) {
          return state;
        }
        var filteredPastIds = pastIds.filter(function(pastId) {
          return pastId !== currentId && pastId !== _id3;
        });
        var _nextPastIds = currentId ? [currentId].concat(filteredPastIds) : filteredPastIds;
        var _nextState2 = _objectSpread22(_objectSpread22({}, state), {}, {
          pastIds: _nextPastIds
        });
        if (_id3 === null) {
          return _objectSpread22(_objectSpread22({}, _nextState2), {}, {
            unstable_moves: moves + 1,
            currentId: getCurrentId(_nextState2, _id3)
          });
        }
        var _item2 = findEnabledItemById(items, _id3);
        return _objectSpread22(_objectSpread22({}, _nextState2), {}, {
          unstable_moves: _item2 ? moves + 1 : moves,
          currentId: getCurrentId(_nextState2, _item2 === null || _item2 === void 0 ? void 0 : _item2.id)
        });
      }
      case "next": {
        if (currentId == null) {
          return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
            type: "first"
          }));
        }
        var isHorizontal = orientation !== "vertical";
        var isRTL3 = rtl2 && isHorizontal;
        var allItems = isRTL3 ? reverse(items) : items;
        var currentItem = allItems.find(function(item2) {
          return item2.id === currentId;
        });
        if (!currentItem) {
          return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
            type: "first"
          }));
        }
        var isGrid = !!currentItem.groupId;
        var currentIndex = allItems.indexOf(currentItem);
        var _nextItems = allItems.slice(currentIndex + 1);
        var nextItemsInGroup = getItemsInGroup(_nextItems, currentItem.groupId);
        if (action.allTheWay) {
          var _nextItem2 = findFirstEnabledItem(isRTL3 ? getItemsInGroup(allItems, currentItem.groupId) : reverse(nextItemsInGroup));
          return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
            type: "move",
            id: _nextItem2 === null || _nextItem2 === void 0 ? void 0 : _nextItem2.id
          }));
        }
        var oppositeOrientation = getOppositeOrientation(
          isGrid ? orientation || "horizontal" : orientation
        );
        var canLoop = loop2 && loop2 !== oppositeOrientation;
        var canWrap = isGrid && wrap3 && wrap3 !== oppositeOrientation;
        var hasNullItem = action.hasNullItem || !isGrid && canLoop && includesBaseElement;
        if (canLoop) {
          var loopItems = canWrap && !hasNullItem ? allItems : getItemsInGroup(allItems, currentItem.groupId);
          var sortedItems = placeItemsAfter(loopItems, currentId, hasNullItem);
          var _nextItem3 = findFirstEnabledItem(sortedItems, currentId);
          return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
            type: "move",
            id: _nextItem3 === null || _nextItem3 === void 0 ? void 0 : _nextItem3.id
          }));
        }
        if (canWrap) {
          var _nextItem4 = findFirstEnabledItem(
            hasNullItem ? nextItemsInGroup : _nextItems,
            currentId
          );
          var _nextId = hasNullItem ? (_nextItem4 === null || _nextItem4 === void 0 ? void 0 : _nextItem4.id) || null : _nextItem4 === null || _nextItem4 === void 0 ? void 0 : _nextItem4.id;
          return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
            type: "move",
            id: _nextId
          }));
        }
        var _nextItem = findFirstEnabledItem(nextItemsInGroup, currentId);
        if (!_nextItem && hasNullItem) {
          return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
            type: "move",
            id: null
          }));
        }
        return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
          type: "move",
          id: _nextItem === null || _nextItem === void 0 ? void 0 : _nextItem.id
        }));
      }
      case "previous": {
        var _isGrid = !!groups2.length;
        var _hasNullItem = !_isGrid && includesBaseElement;
        var _nextState3 = reducer(_objectSpread22(_objectSpread22({}, state), {}, {
          items: reverse(items)
        }), _objectSpread22(_objectSpread22({}, action), {}, {
          type: "next",
          hasNullItem: _hasNullItem
        }));
        return _objectSpread22(_objectSpread22({}, _nextState3), {}, {
          items
        });
      }
      case "down": {
        var shouldShift = shift && !action.allTheWay;
        var verticalItems = verticalizeItems(flatten2(fillGroups(groupItems(items), currentId, shouldShift)));
        var _canLoop = loop2 && loop2 !== "horizontal";
        var _hasNullItem2 = _canLoop && includesBaseElement;
        var _nextState4 = reducer(_objectSpread22(_objectSpread22({}, state), {}, {
          orientation: "vertical",
          items: verticalItems
        }), _objectSpread22(_objectSpread22({}, action), {}, {
          type: "next",
          hasNullItem: _hasNullItem2
        }));
        return _objectSpread22(_objectSpread22({}, _nextState4), {}, {
          orientation,
          items
        });
      }
      case "up": {
        var _shouldShift = shift && !action.allTheWay;
        var _verticalItems = verticalizeItems(reverse(flatten2(fillGroups(groupItems(items), currentId, _shouldShift))));
        var _hasNullItem3 = includesBaseElement;
        var _nextState5 = reducer(_objectSpread22(_objectSpread22({}, state), {}, {
          orientation: "vertical",
          items: _verticalItems
        }), _objectSpread22(_objectSpread22({}, action), {}, {
          type: "next",
          hasNullItem: _hasNullItem3
        }));
        return _objectSpread22(_objectSpread22({}, _nextState5), {}, {
          orientation,
          items
        });
      }
      case "first": {
        var firstItem = findFirstEnabledItem(items);
        return reducer(state, _objectSpread22(_objectSpread22({}, action), {}, {
          type: "move",
          id: firstItem === null || firstItem === void 0 ? void 0 : firstItem.id
        }));
      }
      case "last": {
        var _nextState6 = reducer(_objectSpread22(_objectSpread22({}, state), {}, {
          items: reverse(items)
        }), _objectSpread22(_objectSpread22({}, action), {}, {
          type: "first"
        }));
        return _objectSpread22(_objectSpread22({}, _nextState6), {}, {
          items
        });
      }
      case "sort": {
        return _objectSpread22(_objectSpread22({}, state), {}, {
          items: sortBasedOnDOMPosition(items),
          groups: sortBasedOnDOMPosition(groups2)
        });
      }
      case "setVirtual":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          unstable_virtual: applyState(action.virtual, virtual)
        });
      case "setRTL":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          rtl: applyState(action.rtl, rtl2)
        });
      case "setOrientation":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          orientation: applyState(action.orientation, orientation)
        });
      case "setCurrentId": {
        var nextCurrentId = getCurrentId(_objectSpread22(_objectSpread22({}, state), {}, {
          currentId: applyState(action.currentId, currentId)
        }));
        return _objectSpread22(_objectSpread22({}, state), {}, {
          currentId: nextCurrentId,
          hasSetCurrentId: true
        });
      }
      case "setLoop":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          loop: applyState(action.loop, loop2)
        });
      case "setWrap":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          wrap: applyState(action.wrap, wrap3)
        });
      case "setShift":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          shift: applyState(action.shift, shift)
        });
      case "setIncludesBaseElement": {
        return _objectSpread22(_objectSpread22({}, state), {}, {
          unstable_includesBaseElement: applyState(action.includesBaseElement, includesBaseElement)
        });
      }
      case "reset":
        return _objectSpread22(_objectSpread22({}, state), {}, {
          unstable_virtual: initialVirtual,
          rtl: initialRTL,
          orientation: initialOrientation,
          currentId: getCurrentId(_objectSpread22(_objectSpread22({}, state), {}, {
            currentId: initialCurrentId
          })),
          loop: initialLoop,
          wrap: initialWrap,
          shift: initialShift,
          unstable_moves: 0,
          pastIds: []
        });
      case "setItems": {
        return _objectSpread22(_objectSpread22({}, state), {}, {
          items: action.items
        });
      }
      default:
        throw new Error();
    }
  }
  function useAction(fn) {
    return (0, import_react27.useCallback)(fn, []);
  }
  function useIsUnmountedRef() {
    var isUnmountedRef = (0, import_react27.useRef)(false);
    useIsomorphicEffect(function() {
      return function() {
        isUnmountedRef.current = true;
      };
    }, []);
    return isUnmountedRef;
  }
  function useCompositeState(initialState) {
    if (initialState === void 0) {
      initialState = {};
    }
    var _useSealedState = useSealedState(initialState), _useSealedState$unsta = _useSealedState.unstable_virtual, virtual = _useSealedState$unsta === void 0 ? false : _useSealedState$unsta, _useSealedState$rtl = _useSealedState.rtl, rtl2 = _useSealedState$rtl === void 0 ? false : _useSealedState$rtl, orientation = _useSealedState.orientation, currentId = _useSealedState.currentId, _useSealedState$loop = _useSealedState.loop, loop2 = _useSealedState$loop === void 0 ? false : _useSealedState$loop, _useSealedState$wrap = _useSealedState.wrap, wrap3 = _useSealedState$wrap === void 0 ? false : _useSealedState$wrap, _useSealedState$shift = _useSealedState.shift, shift = _useSealedState$shift === void 0 ? false : _useSealedState$shift, unstable_includesBaseElement = _useSealedState.unstable_includesBaseElement, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["unstable_virtual", "rtl", "orientation", "currentId", "loop", "wrap", "shift", "unstable_includesBaseElement"]);
    var idState = unstable_useIdState(sealed);
    var _React$useReducer = (0, import_react27.useReducer)(reducer, {
      unstable_virtual: virtual,
      rtl: rtl2,
      orientation,
      items: [],
      groups: [],
      currentId,
      loop: loop2,
      wrap: wrap3,
      shift,
      unstable_moves: 0,
      pastIds: [],
      unstable_includesBaseElement: unstable_includesBaseElement != null ? unstable_includesBaseElement : currentId === null,
      initialVirtual: virtual,
      initialRTL: rtl2,
      initialOrientation: orientation,
      initialCurrentId: currentId,
      initialLoop: loop2,
      initialWrap: wrap3,
      initialShift: shift
    }), _React$useReducer$ = _React$useReducer[0], pastIds = _React$useReducer$.pastIds, initialVirtual = _React$useReducer$.initialVirtual, initialRTL = _React$useReducer$.initialRTL, initialOrientation = _React$useReducer$.initialOrientation, initialCurrentId = _React$useReducer$.initialCurrentId, initialLoop = _React$useReducer$.initialLoop, initialWrap = _React$useReducer$.initialWrap, initialShift = _React$useReducer$.initialShift, hasSetCurrentId = _React$useReducer$.hasSetCurrentId, state = _objectWithoutPropertiesLoose(_React$useReducer$, ["pastIds", "initialVirtual", "initialRTL", "initialOrientation", "initialCurrentId", "initialLoop", "initialWrap", "initialShift", "hasSetCurrentId"]), dispatch2 = _React$useReducer[1];
    var _React$useState = (0, import_react27.useState)(false), hasActiveWidget = _React$useState[0], setHasActiveWidget = _React$useState[1];
    var isUnmountedRef = useIsUnmountedRef();
    var setItems = (0, import_react27.useCallback)(function(items) {
      return dispatch2({
        type: "setItems",
        items
      });
    }, []);
    useSortBasedOnDOMPosition(state.items, setItems);
    return _objectSpread22(_objectSpread22(_objectSpread22({}, idState), state), {}, {
      unstable_hasActiveWidget: hasActiveWidget,
      unstable_setHasActiveWidget: setHasActiveWidget,
      registerItem: useAction(function(item2) {
        if (isUnmountedRef.current)
          return;
        dispatch2({
          type: "registerItem",
          item: item2
        });
      }),
      unregisterItem: useAction(function(id2) {
        if (isUnmountedRef.current)
          return;
        dispatch2({
          type: "unregisterItem",
          id: id2
        });
      }),
      registerGroup: useAction(function(group2) {
        if (isUnmountedRef.current)
          return;
        dispatch2({
          type: "registerGroup",
          group: group2
        });
      }),
      unregisterGroup: useAction(function(id2) {
        if (isUnmountedRef.current)
          return;
        dispatch2({
          type: "unregisterGroup",
          id: id2
        });
      }),
      move: useAction(function(id2) {
        return dispatch2({
          type: "move",
          id: id2
        });
      }),
      next: useAction(function(allTheWay) {
        return dispatch2({
          type: "next",
          allTheWay
        });
      }),
      previous: useAction(function(allTheWay) {
        return dispatch2({
          type: "previous",
          allTheWay
        });
      }),
      up: useAction(function(allTheWay) {
        return dispatch2({
          type: "up",
          allTheWay
        });
      }),
      down: useAction(function(allTheWay) {
        return dispatch2({
          type: "down",
          allTheWay
        });
      }),
      first: useAction(function() {
        return dispatch2({
          type: "first"
        });
      }),
      last: useAction(function() {
        return dispatch2({
          type: "last"
        });
      }),
      sort: useAction(function() {
        return dispatch2({
          type: "sort"
        });
      }),
      unstable_setVirtual: useAction(function(value) {
        return dispatch2({
          type: "setVirtual",
          virtual: value
        });
      }),
      setRTL: useAction(function(value) {
        return dispatch2({
          type: "setRTL",
          rtl: value
        });
      }),
      setOrientation: useAction(function(value) {
        return dispatch2({
          type: "setOrientation",
          orientation: value
        });
      }),
      setCurrentId: useAction(function(value) {
        return dispatch2({
          type: "setCurrentId",
          currentId: value
        });
      }),
      setLoop: useAction(function(value) {
        return dispatch2({
          type: "setLoop",
          loop: value
        });
      }),
      setWrap: useAction(function(value) {
        return dispatch2({
          type: "setWrap",
          wrap: value
        });
      }),
      setShift: useAction(function(value) {
        return dispatch2({
          type: "setShift",
          shift: value
        });
      }),
      unstable_setIncludesBaseElement: useAction(function(value) {
        return dispatch2({
          type: "setIncludesBaseElement",
          includesBaseElement: value
        });
      }),
      reset: useAction(function() {
        return dispatch2({
          type: "reset"
        });
      })
    });
  }

  // node_modules/reakit/es/index.js
  var import_react_dom2 = __toESM(require_react_dom());

  // node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js
  var hasPassiveEvents = false;
  if (typeof window !== "undefined") {
    passiveTestOptions = {
      get passive() {
        hasPassiveEvents = true;
        return void 0;
      }
    };
    window.addEventListener("testPassive", null, passiveTestOptions);
    window.removeEventListener("testPassive", null, passiveTestOptions);
  }
  var passiveTestOptions;
  var isIosDevice = typeof window !== "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);

  // node_modules/reakit/es/__keys-d251e56b.js
  var RADIO_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "state", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget", "setState"];
  var RADIO_KEYS = [].concat(RADIO_STATE_KEYS, ["value", "checked", "unstable_checkOnFocus"]);
  var RADIO_GROUP_KEYS = RADIO_STATE_KEYS;

  // node_modules/reakit/es/Radio/Radio.js
  var import_react28 = __toESM(require_react());
  function getChecked(options) {
    if (typeof options.checked !== "undefined") {
      return options.checked;
    }
    return typeof options.value !== "undefined" && options.state === options.value;
  }
  function useInitialChecked(options) {
    var _React$useState = (0, import_react28.useState)(function() {
      return getChecked(options);
    }), initialChecked = _React$useState[0];
    var _React$useState2 = (0, import_react28.useState)(options.currentId), initialCurrentId = _React$useState2[0];
    var id2 = options.id, setCurrentId = options.setCurrentId;
    (0, import_react28.useEffect)(function() {
      if (initialChecked && id2 && initialCurrentId !== id2) {
        setCurrentId === null || setCurrentId === void 0 ? void 0 : setCurrentId(id2);
      }
    }, [initialChecked, id2, setCurrentId, initialCurrentId]);
  }
  function fireChange(element, onChange) {
    var event = createEvent(element, "change");
    Object.defineProperties(event, {
      type: {
        value: "change"
      },
      target: {
        value: element
      },
      currentTarget: {
        value: element
      }
    });
    onChange === null || onChange === void 0 ? void 0 : onChange(event);
  }
  var useRadio = createHook({
    name: "Radio",
    compose: useCompositeItem,
    keys: RADIO_KEYS,
    useOptions: function useOptions7(_ref8, _ref22) {
      var _options$value;
      var value = _ref22.value, checked = _ref22.checked;
      var _ref$unstable_clickOn = _ref8.unstable_clickOnEnter, unstable_clickOnEnter = _ref$unstable_clickOn === void 0 ? false : _ref$unstable_clickOn, _ref$unstable_checkOn = _ref8.unstable_checkOnFocus, unstable_checkOnFocus = _ref$unstable_checkOn === void 0 ? true : _ref$unstable_checkOn, options = _objectWithoutPropertiesLoose(_ref8, ["unstable_clickOnEnter", "unstable_checkOnFocus"]);
      return _objectSpread22(_objectSpread22({
        checked,
        unstable_clickOnEnter,
        unstable_checkOnFocus
      }, options), {}, {
        value: (_options$value = options.value) != null ? _options$value : value
      });
    },
    useProps: function useProps9(options, _ref32) {
      var htmlRef = _ref32.ref, htmlOnChange = _ref32.onChange, htmlOnClick = _ref32.onClick, htmlProps = _objectWithoutPropertiesLoose(_ref32, ["ref", "onChange", "onClick"]);
      var ref2 = (0, import_react28.useRef)(null);
      var _React$useState3 = (0, import_react28.useState)(true), isNativeRadio = _React$useState3[0], setIsNativeRadio = _React$useState3[1];
      var checked = getChecked(options);
      var isCurrentItemRef = useLiveRef(options.currentId === options.id);
      var onChangeRef = useLiveRef(htmlOnChange);
      var onClickRef = useLiveRef(htmlOnClick);
      useInitialChecked(options);
      (0, import_react28.useEffect)(function() {
        var element = ref2.current;
        if (!element) {
          true ? warning2(true, "Can't determine whether the element is a native radio because `ref` wasn't passed to the component", "See https://reakit.io/docs/radio") : void 0;
          return;
        }
        if (element.tagName !== "INPUT" || element.type !== "radio") {
          setIsNativeRadio(false);
        }
      }, []);
      var onChange = (0, import_react28.useCallback)(function(event) {
        var _onChangeRef$current, _options$setState;
        (_onChangeRef$current = onChangeRef.current) === null || _onChangeRef$current === void 0 ? void 0 : _onChangeRef$current.call(onChangeRef, event);
        if (event.defaultPrevented)
          return;
        if (options.disabled)
          return;
        (_options$setState = options.setState) === null || _options$setState === void 0 ? void 0 : _options$setState.call(options, options.value);
      }, [options.disabled, options.setState, options.value]);
      var onClick = (0, import_react28.useCallback)(function(event) {
        var _onClickRef$current;
        (_onClickRef$current = onClickRef.current) === null || _onClickRef$current === void 0 ? void 0 : _onClickRef$current.call(onClickRef, event);
        if (event.defaultPrevented)
          return;
        if (isNativeRadio)
          return;
        fireChange(event.currentTarget, onChange);
      }, [onChange, isNativeRadio]);
      (0, import_react28.useEffect)(function() {
        var element = ref2.current;
        if (!element)
          return;
        if (options.unstable_moves && isCurrentItemRef.current && options.unstable_checkOnFocus) {
          fireChange(element, onChange);
        }
      }, [options.unstable_moves, options.unstable_checkOnFocus, onChange]);
      return _objectSpread22({
        ref: useForkRef(ref2, htmlRef),
        role: !isNativeRadio ? "radio" : void 0,
        type: isNativeRadio ? "radio" : void 0,
        value: isNativeRadio ? options.value : void 0,
        name: isNativeRadio ? options.baseId : void 0,
        "aria-checked": checked,
        checked,
        onChange,
        onClick
      }, htmlProps);
    }
  });
  var Radio = createComponent({
    as: "input",
    memo: true,
    useHook: useRadio
  });

  // node_modules/reakit/es/Radio/RadioGroup.js
  var import_react29 = __toESM(require_react());
  var useRadioGroup = createHook({
    name: "RadioGroup",
    compose: useComposite,
    keys: RADIO_GROUP_KEYS,
    useProps: function useProps10(_, htmlProps) {
      return _objectSpread22({
        role: "radiogroup"
      }, htmlProps);
    }
  });
  var RadioGroup = createComponent({
    as: "div",
    useHook: useRadioGroup,
    useCreateElement: function useCreateElement$12(type, props, children) {
      true ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/radio") : void 0;
      return useCreateElement(type, props, children);
    }
  });

  // node_modules/reakit/es/Radio/RadioState.js
  var import_react30 = __toESM(require_react());
  function useRadioState(initialState) {
    if (initialState === void 0) {
      initialState = {};
    }
    var _useSealedState = useSealedState(initialState), initialValue = _useSealedState.state, _useSealedState$loop = _useSealedState.loop, loop2 = _useSealedState$loop === void 0 ? true : _useSealedState$loop, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["state", "loop"]);
    var _React$useState = (0, import_react30.useState)(initialValue), state = _React$useState[0], setState = _React$useState[1];
    var composite = useCompositeState(_objectSpread22(_objectSpread22({}, sealed), {}, {
      loop: loop2
    }));
    return _objectSpread22(_objectSpread22({}, composite), {}, {
      state,
      setState
    });
  }

  // node_modules/reakit/es/__keys-ae468c11.js
  var TOOLBAR_STATE_KEYS = ["baseId", "unstable_idCountRef", "unstable_virtual", "rtl", "orientation", "items", "groups", "currentId", "loop", "wrap", "shift", "unstable_moves", "unstable_hasActiveWidget", "unstable_includesBaseElement", "setBaseId", "registerItem", "unregisterItem", "registerGroup", "unregisterGroup", "move", "next", "previous", "up", "down", "first", "last", "sort", "unstable_setVirtual", "setRTL", "setOrientation", "setCurrentId", "setLoop", "setWrap", "setShift", "reset", "unstable_setIncludesBaseElement", "unstable_setHasActiveWidget"];
  var TOOLBAR_KEYS = TOOLBAR_STATE_KEYS;
  var TOOLBAR_ITEM_KEYS = TOOLBAR_KEYS;

  // node_modules/reakit/es/Toolbar/Toolbar.js
  var import_react31 = __toESM(require_react());
  var useToolbar = createHook({
    name: "Toolbar",
    compose: useComposite,
    keys: TOOLBAR_KEYS,
    useProps: function useProps11(options, htmlProps) {
      return _objectSpread22({
        role: "toolbar",
        "aria-orientation": options.orientation
      }, htmlProps);
    }
  });
  var Toolbar = createComponent({
    as: "div",
    useHook: useToolbar,
    useCreateElement: function useCreateElement$13(type, props, children) {
      true ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/toolbar") : void 0;
      return useCreateElement(type, props, children);
    }
  });

  // node_modules/reakit/es/Toolbar/ToolbarItem.js
  var import_react32 = __toESM(require_react());
  var useToolbarItem = createHook({
    name: "ToolbarItem",
    compose: useCompositeItem,
    keys: TOOLBAR_ITEM_KEYS
  });
  var ToolbarItem = createComponent({
    as: "button",
    memo: true,
    useHook: useToolbarItem
  });

  // node_modules/reakit/es/Toolbar/ToolbarState.js
  var import_react33 = __toESM(require_react());
  function useToolbarState(initialState) {
    if (initialState === void 0) {
      initialState = {};
    }
    var _useSealedState = useSealedState(initialState), _useSealedState$orien = _useSealedState.orientation, orientation = _useSealedState$orien === void 0 ? "horizontal" : _useSealedState$orien, sealed = _objectWithoutPropertiesLoose(_useSealedState, ["orientation"]);
    return useCompositeState(_objectSpread22({
      orientation
    }, sealed));
  }

  // node_modules/@wordpress/components/build-module/popover/index.js
  var import_classnames3 = __toESM(require_classnames());

  // node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
  function t3(t5) {
    return t5.split("-")[0];
  }
  function e2(t5) {
    return t5.split("-")[1];
  }
  function n2(e4) {
    return ["top", "bottom"].includes(t3(e4)) ? "x" : "y";
  }
  function r2(t5) {
    return "y" === t5 ? "height" : "width";
  }
  function i2(i5, o6, a6) {
    let { reference: l5, floating: s5 } = i5;
    const c6 = l5.x + l5.width / 2 - s5.width / 2, f5 = l5.y + l5.height / 2 - s5.height / 2, u4 = n2(o6), m4 = r2(u4), g5 = l5[m4] / 2 - s5[m4] / 2, d4 = "x" === u4;
    let p5;
    switch (t3(o6)) {
      case "top":
        p5 = { x: c6, y: l5.y - s5.height };
        break;
      case "bottom":
        p5 = { x: c6, y: l5.y + l5.height };
        break;
      case "right":
        p5 = { x: l5.x + l5.width, y: f5 };
        break;
      case "left":
        p5 = { x: l5.x - s5.width, y: f5 };
        break;
      default:
        p5 = { x: l5.x, y: l5.y };
    }
    switch (e2(o6)) {
      case "start":
        p5[u4] -= g5 * (a6 && d4 ? -1 : 1);
        break;
      case "end":
        p5[u4] += g5 * (a6 && d4 ? -1 : 1);
    }
    return p5;
  }
  var o3 = async (t5, e4, n5) => {
    const { placement: r5 = "bottom", strategy: o6 = "absolute", middleware: a6 = [], platform: l5 } = n5, s5 = await (null == l5.isRTL ? void 0 : l5.isRTL(e4));
    let c6 = await l5.getElementRects({ reference: t5, floating: e4, strategy: o6 }), { x: f5, y: u4 } = i2(c6, r5, s5), m4 = r5, g5 = {}, d4 = 0;
    for (let n6 = 0; n6 < a6.length; n6++) {
      const { name: p5, fn: h4 } = a6[n6], { x: y5, y: x4, data: w4, reset: v5 } = await h4({ x: f5, y: u4, initialPlacement: r5, placement: m4, strategy: o6, middlewareData: g5, rects: c6, platform: l5, elements: { reference: t5, floating: e4 } });
      f5 = null != y5 ? y5 : f5, u4 = null != x4 ? x4 : u4, g5 = { ...g5, [p5]: { ...g5[p5], ...w4 } }, v5 && d4 <= 50 && (d4++, "object" == typeof v5 && (v5.placement && (m4 = v5.placement), v5.rects && (c6 = true === v5.rects ? await l5.getElementRects({ reference: t5, floating: e4, strategy: o6 }) : v5.rects), { x: f5, y: u4 } = i2(c6, m4, s5)), n6 = -1);
    }
    return { x: f5, y: u4, placement: m4, strategy: o6, middlewareData: g5 };
  };
  function a2(t5) {
    return "number" != typeof t5 ? function(t6) {
      return { top: 0, right: 0, bottom: 0, left: 0, ...t6 };
    }(t5) : { top: t5, right: t5, bottom: t5, left: t5 };
  }
  function l2(t5) {
    return { ...t5, top: t5.y, left: t5.x, right: t5.x + t5.width, bottom: t5.y + t5.height };
  }
  async function s2(t5, e4) {
    var n5;
    void 0 === e4 && (e4 = {});
    const { x: r5, y: i5, platform: o6, rects: s5, elements: c6, strategy: f5 } = t5, { boundary: u4 = "clippingAncestors", rootBoundary: m4 = "viewport", elementContext: g5 = "floating", altBoundary: d4 = false, padding: p5 = 0 } = e4, h4 = a2(p5), y5 = c6[d4 ? "floating" === g5 ? "reference" : "floating" : g5], x4 = l2(await o6.getClippingRect({ element: null == (n5 = await (null == o6.isElement ? void 0 : o6.isElement(y5))) || n5 ? y5 : y5.contextElement || await (null == o6.getDocumentElement ? void 0 : o6.getDocumentElement(c6.floating)), boundary: u4, rootBoundary: m4, strategy: f5 })), w4 = l2(o6.convertOffsetParentRelativeRectToViewportRelativeRect ? await o6.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: "floating" === g5 ? { ...s5.floating, x: r5, y: i5 } : s5.reference, offsetParent: await (null == o6.getOffsetParent ? void 0 : o6.getOffsetParent(c6.floating)), strategy: f5 }) : s5[g5]);
    return { top: x4.top - w4.top + h4.top, bottom: w4.bottom - x4.bottom + h4.bottom, left: x4.left - w4.left + h4.left, right: w4.right - x4.right + h4.right };
  }
  var c2 = Math.min;
  var f2 = Math.max;
  function u2(t5, e4, n5) {
    return f2(t5, c2(e4, n5));
  }
  var m2 = (t5) => ({ name: "arrow", options: t5, async fn(i5) {
    const { element: o6, padding: l5 = 0 } = null != t5 ? t5 : {}, { x: s5, y: c6, placement: f5, rects: m4, platform: g5 } = i5;
    if (null == o6)
      return {};
    const d4 = a2(l5), p5 = { x: s5, y: c6 }, h4 = n2(f5), y5 = e2(f5), x4 = r2(h4), w4 = await g5.getDimensions(o6), v5 = "y" === h4 ? "top" : "left", b6 = "y" === h4 ? "bottom" : "right", R2 = m4.reference[x4] + m4.reference[h4] - p5[h4] - m4.floating[x4], A2 = p5[h4] - m4.reference[h4], P2 = await (null == g5.getOffsetParent ? void 0 : g5.getOffsetParent(o6));
    let T3 = P2 ? "y" === h4 ? P2.clientHeight || 0 : P2.clientWidth || 0 : 0;
    0 === T3 && (T3 = m4.floating[x4]);
    const O2 = R2 / 2 - A2 / 2, L3 = d4[v5], D3 = T3 - w4[x4] - d4[b6], k3 = T3 / 2 - w4[x4] / 2 + O2, E3 = u2(L3, k3, D3), C2 = ("start" === y5 ? d4[v5] : d4[b6]) > 0 && k3 !== E3 && m4.reference[x4] <= m4.floating[x4];
    return { [h4]: p5[h4] - (C2 ? k3 < L3 ? L3 - k3 : D3 - k3 : 0), data: { [h4]: E3, centerOffset: k3 - E3 } };
  } });
  var g2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function d2(t5) {
    return t5.replace(/left|right|bottom|top/g, (t6) => g2[t6]);
  }
  function p2(t5, i5, o6) {
    void 0 === o6 && (o6 = false);
    const a6 = e2(t5), l5 = n2(t5), s5 = r2(l5);
    let c6 = "x" === l5 ? a6 === (o6 ? "end" : "start") ? "right" : "left" : "start" === a6 ? "bottom" : "top";
    return i5.reference[s5] > i5.floating[s5] && (c6 = d2(c6)), { main: c6, cross: d2(c6) };
  }
  var h2 = { start: "end", end: "start" };
  function y2(t5) {
    return t5.replace(/start|end/g, (t6) => h2[t6]);
  }
  var x2 = ["top", "right", "bottom", "left"];
  var w2 = x2.reduce((t5, e4) => t5.concat(e4, e4 + "-start", e4 + "-end"), []);
  var b2 = function(e4) {
    return void 0 === e4 && (e4 = {}), { name: "flip", options: e4, async fn(n5) {
      var r5;
      const { placement: i5, middlewareData: o6, rects: a6, initialPlacement: l5, platform: c6, elements: f5 } = n5, { mainAxis: u4 = true, crossAxis: m4 = true, fallbackPlacements: g5, fallbackStrategy: h4 = "bestFit", flipAlignment: x4 = true, ...w4 } = e4, v5 = t3(i5), b6 = g5 || (v5 === l5 || !x4 ? [d2(l5)] : function(t5) {
        const e5 = d2(t5);
        return [y2(t5), e5, y2(e5)];
      }(l5)), R2 = [l5, ...b6], A2 = await s2(n5, w4), P2 = [];
      let T3 = (null == (r5 = o6.flip) ? void 0 : r5.overflows) || [];
      if (u4 && P2.push(A2[v5]), m4) {
        const { main: t5, cross: e5 } = p2(i5, a6, await (null == c6.isRTL ? void 0 : c6.isRTL(f5.floating)));
        P2.push(A2[t5], A2[e5]);
      }
      if (T3 = [...T3, { placement: i5, overflows: P2 }], !P2.every((t5) => t5 <= 0)) {
        var O2, L3;
        const t5 = (null != (O2 = null == (L3 = o6.flip) ? void 0 : L3.index) ? O2 : 0) + 1, e5 = R2[t5];
        if (e5)
          return { data: { index: t5, overflows: T3 }, reset: { placement: e5 } };
        let n6 = "bottom";
        switch (h4) {
          case "bestFit": {
            var D3;
            const t6 = null == (D3 = T3.map((t7) => [t7, t7.overflows.filter((t8) => t8 > 0).reduce((t8, e6) => t8 + e6, 0)]).sort((t7, e6) => t7[1] - e6[1])[0]) ? void 0 : D3[0].placement;
            t6 && (n6 = t6);
            break;
          }
          case "initialPlacement":
            n6 = l5;
        }
        if (i5 !== n6)
          return { reset: { placement: n6 } };
      }
      return {};
    } };
  };
  var T = function(r5) {
    return void 0 === r5 && (r5 = 0), { name: "offset", options: r5, async fn(i5) {
      const { x: o6, y: a6 } = i5, l5 = await async function(r6, i6) {
        const { placement: o7, platform: a7, elements: l6 } = r6, s5 = await (null == a7.isRTL ? void 0 : a7.isRTL(l6.floating)), c6 = t3(o7), f5 = e2(o7), u4 = "x" === n2(o7), m4 = ["left", "top"].includes(c6) ? -1 : 1, g5 = s5 && u4 ? -1 : 1, d4 = "function" == typeof i6 ? i6(r6) : i6;
        let { mainAxis: p5, crossAxis: h4, alignmentAxis: y5 } = "number" == typeof d4 ? { mainAxis: d4, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d4 };
        return f5 && "number" == typeof y5 && (h4 = "end" === f5 ? -1 * y5 : y5), u4 ? { x: h4 * g5, y: p5 * m4 } : { x: p5 * m4, y: h4 * g5 };
      }(i5, r5);
      return { x: o6 + l5.x, y: a6 + l5.y, data: l5 };
    } };
  };
  function O(t5) {
    return "x" === t5 ? "y" : "x";
  }
  var L = function(e4) {
    return void 0 === e4 && (e4 = {}), { name: "shift", options: e4, async fn(r5) {
      const { x: i5, y: o6, placement: a6 } = r5, { mainAxis: l5 = true, crossAxis: c6 = false, limiter: f5 = { fn: (t5) => {
        let { x: e5, y: n5 } = t5;
        return { x: e5, y: n5 };
      } }, ...m4 } = e4, g5 = { x: i5, y: o6 }, d4 = await s2(r5, m4), p5 = n2(t3(a6)), h4 = O(p5);
      let y5 = g5[p5], x4 = g5[h4];
      if (l5) {
        const t5 = "y" === p5 ? "bottom" : "right";
        y5 = u2(y5 + d4["y" === p5 ? "top" : "left"], y5, y5 - d4[t5]);
      }
      if (c6) {
        const t5 = "y" === h4 ? "bottom" : "right";
        x4 = u2(x4 + d4["y" === h4 ? "top" : "left"], x4, x4 - d4[t5]);
      }
      const w4 = f5.fn({ ...r5, [p5]: y5, [h4]: x4 });
      return { ...w4, data: { x: w4.x - i5, y: w4.y - o6 } };
    } };
  };
  var k2 = function(n5) {
    return void 0 === n5 && (n5 = {}), { name: "size", options: n5, async fn(r5) {
      const { placement: i5, rects: o6, platform: a6, elements: l5 } = r5, { apply: c6 = () => {
      }, ...u4 } = n5, m4 = await s2(r5, u4), g5 = t3(i5), d4 = e2(i5);
      let p5, h4;
      "top" === g5 || "bottom" === g5 ? (p5 = g5, h4 = d4 === (await (null == a6.isRTL ? void 0 : a6.isRTL(l5.floating)) ? "start" : "end") ? "left" : "right") : (h4 = g5, p5 = "end" === d4 ? "top" : "bottom");
      const y5 = f2(m4.left, 0), x4 = f2(m4.right, 0), w4 = f2(m4.top, 0), v5 = f2(m4.bottom, 0), b6 = { availableHeight: o6.floating.height - (["left", "right"].includes(i5) ? 2 * (0 !== w4 || 0 !== v5 ? w4 + v5 : f2(m4.top, m4.bottom)) : m4[p5]), availableWidth: o6.floating.width - (["top", "bottom"].includes(i5) ? 2 * (0 !== y5 || 0 !== x4 ? y5 + x4 : f2(m4.left, m4.right)) : m4[h4]) };
      await c6({ ...r5, ...b6 });
      const R2 = await a6.getDimensions(l5.floating);
      return o6.floating.width !== R2.width || o6.floating.height !== R2.height ? { reset: { rects: true } } : {};
    } };
  };

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
  function n3(t5) {
    return t5 && t5.document && t5.location && t5.alert && t5.setInterval;
  }
  function o4(t5) {
    if (null == t5)
      return window;
    if (!n3(t5)) {
      const e4 = t5.ownerDocument;
      return e4 && e4.defaultView || window;
    }
    return t5;
  }
  function i3(t5) {
    return o4(t5).getComputedStyle(t5);
  }
  function r3(t5) {
    return n3(t5) ? "" : t5 ? (t5.nodeName || "").toLowerCase() : "";
  }
  function l3() {
    const t5 = navigator.userAgentData;
    return null != t5 && t5.brands ? t5.brands.map((t6) => t6.brand + "/" + t6.version).join(" ") : navigator.userAgent;
  }
  function c3(t5) {
    return t5 instanceof o4(t5).HTMLElement;
  }
  function s3(t5) {
    return t5 instanceof o4(t5).Element;
  }
  function f3(t5) {
    if ("undefined" == typeof ShadowRoot)
      return false;
    return t5 instanceof o4(t5).ShadowRoot || t5 instanceof ShadowRoot;
  }
  function u3(t5) {
    const { overflow: e4, overflowX: n5, overflowY: o6, display: r5 } = i3(t5);
    return /auto|scroll|overlay|hidden/.test(e4 + o6 + n5) && !["inline", "contents"].includes(r5);
  }
  function d3(t5) {
    return ["table", "td", "th"].includes(r3(t5));
  }
  function h3(t5) {
    const e4 = /firefox/i.test(l3()), n5 = i3(t5);
    return "none" !== n5.transform || "none" !== n5.perspective || e4 && "filter" === n5.willChange || e4 && !!n5.filter && "none" !== n5.filter || ["transform", "perspective"].some((t6) => n5.willChange.includes(t6)) || ["paint", "layout", "strict", "content"].some((t6) => {
      const e5 = n5.contain;
      return null != e5 && e5.includes(t6);
    });
  }
  function a3() {
    return !/^((?!chrome|android).)*safari/i.test(l3());
  }
  function g3(t5) {
    return ["html", "body", "#document"].includes(r3(t5));
  }
  var m3 = Math.min;
  var p3 = Math.max;
  var w3 = Math.round;
  function v3(t5, e4, n5) {
    var i5, r5, l5, f5;
    void 0 === e4 && (e4 = false), void 0 === n5 && (n5 = false);
    const u4 = t5.getBoundingClientRect();
    let d4 = 1, h4 = 1;
    e4 && c3(t5) && (d4 = t5.offsetWidth > 0 && w3(u4.width) / t5.offsetWidth || 1, h4 = t5.offsetHeight > 0 && w3(u4.height) / t5.offsetHeight || 1);
    const g5 = s3(t5) ? o4(t5) : window, m4 = !a3() && n5, p5 = (u4.left + (m4 && null != (i5 = null == (r5 = g5.visualViewport) ? void 0 : r5.offsetLeft) ? i5 : 0)) / d4, v5 = (u4.top + (m4 && null != (l5 = null == (f5 = g5.visualViewport) ? void 0 : f5.offsetTop) ? l5 : 0)) / h4, y5 = u4.width / d4, x4 = u4.height / h4;
    return { width: y5, height: x4, top: v5, right: p5 + y5, bottom: v5 + x4, left: p5, x: p5, y: v5 };
  }
  function y3(t5) {
    return (e4 = t5, (e4 instanceof o4(e4).Node ? t5.ownerDocument : t5.document) || window.document).documentElement;
    var e4;
  }
  function x3(t5) {
    return s3(t5) ? { scrollLeft: t5.scrollLeft, scrollTop: t5.scrollTop } : { scrollLeft: t5.pageXOffset, scrollTop: t5.pageYOffset };
  }
  function b3(t5) {
    return v3(y3(t5)).left + x3(t5).scrollLeft;
  }
  function L2(t5, e4, n5) {
    const o6 = c3(e4), i5 = y3(e4), l5 = v3(t5, o6 && function(t6) {
      const e5 = v3(t6);
      return w3(e5.width) !== t6.offsetWidth || w3(e5.height) !== t6.offsetHeight;
    }(e4), "fixed" === n5);
    let s5 = { scrollLeft: 0, scrollTop: 0 };
    const f5 = { x: 0, y: 0 };
    if (o6 || !o6 && "fixed" !== n5)
      if (("body" !== r3(e4) || u3(i5)) && (s5 = x3(e4)), c3(e4)) {
        const t6 = v3(e4, true);
        f5.x = t6.x + e4.clientLeft, f5.y = t6.y + e4.clientTop;
      } else
        i5 && (f5.x = b3(i5));
    return { x: l5.left + s5.scrollLeft - f5.x, y: l5.top + s5.scrollTop - f5.y, width: l5.width, height: l5.height };
  }
  function R(t5) {
    return "html" === r3(t5) ? t5 : t5.assignedSlot || t5.parentNode || (f3(t5) ? t5.host : null) || y3(t5);
  }
  function E2(t5) {
    return c3(t5) && "fixed" !== i3(t5).position ? t5.offsetParent : null;
  }
  function T2(t5) {
    const e4 = o4(t5);
    let n5 = E2(t5);
    for (; n5 && d3(n5) && "static" === i3(n5).position; )
      n5 = E2(n5);
    return n5 && ("html" === r3(n5) || "body" === r3(n5) && "static" === i3(n5).position && !h3(n5)) ? e4 : n5 || function(t6) {
      let e5 = R(t6);
      for (f3(e5) && (e5 = e5.host); c3(e5) && !g3(e5); ) {
        if (h3(e5))
          return e5;
        {
          const t7 = e5.parentNode;
          e5 = f3(t7) ? t7.host : t7;
        }
      }
      return null;
    }(t5) || e4;
  }
  function W(t5) {
    if (c3(t5))
      return { width: t5.offsetWidth, height: t5.offsetHeight };
    const e4 = v3(t5);
    return { width: e4.width, height: e4.height };
  }
  function H2(t5) {
    const e4 = R(t5);
    return g3(e4) ? t5.ownerDocument.body : c3(e4) && u3(e4) ? e4 : H2(e4);
  }
  function C(t5, e4) {
    var n5;
    void 0 === e4 && (e4 = []);
    const i5 = H2(t5), r5 = i5 === (null == (n5 = t5.ownerDocument) ? void 0 : n5.body), l5 = o4(i5), c6 = r5 ? [l5].concat(l5.visualViewport || [], u3(i5) ? i5 : []) : i5, s5 = e4.concat(c6);
    return r5 ? s5 : s5.concat(C(c6));
  }
  function D2(e4, n5, r5) {
    return "viewport" === n5 ? l2(function(t5, e5) {
      const n6 = o4(t5), i5 = y3(t5), r6 = n6.visualViewport;
      let l5 = i5.clientWidth, c6 = i5.clientHeight, s5 = 0, f5 = 0;
      if (r6) {
        l5 = r6.width, c6 = r6.height;
        const t6 = a3();
        (t6 || !t6 && "fixed" === e5) && (s5 = r6.offsetLeft, f5 = r6.offsetTop);
      }
      return { width: l5, height: c6, x: s5, y: f5 };
    }(e4, r5)) : s3(n5) ? function(t5, e5) {
      const n6 = v3(t5, false, "fixed" === e5), o6 = n6.top + t5.clientTop, i5 = n6.left + t5.clientLeft;
      return { top: o6, left: i5, x: i5, y: o6, right: i5 + t5.clientWidth, bottom: o6 + t5.clientHeight, width: t5.clientWidth, height: t5.clientHeight };
    }(n5, r5) : l2(function(t5) {
      var e5;
      const n6 = y3(t5), o6 = x3(t5), r6 = null == (e5 = t5.ownerDocument) ? void 0 : e5.body, l5 = p3(n6.scrollWidth, n6.clientWidth, r6 ? r6.scrollWidth : 0, r6 ? r6.clientWidth : 0), c6 = p3(n6.scrollHeight, n6.clientHeight, r6 ? r6.scrollHeight : 0, r6 ? r6.clientHeight : 0);
      let s5 = -o6.scrollLeft + b3(t5);
      const f5 = -o6.scrollTop;
      return "rtl" === i3(r6 || n6).direction && (s5 += p3(n6.clientWidth, r6 ? r6.clientWidth : 0) - l5), { width: l5, height: c6, x: s5, y: f5 };
    }(y3(e4)));
  }
  function N2(t5) {
    const e4 = C(t5), n5 = function(t6, e5) {
      let n6 = t6;
      for (; n6 && !g3(n6) && !e5.includes(n6) && (!s3(n6) || !["absolute", "fixed"].includes(i3(n6).position)); ) {
        const t7 = R(n6);
        n6 = f3(t7) ? t7.host : t7;
      }
      return n6;
    }(t5, e4);
    let o6 = null;
    if (n5 && c3(n5)) {
      const t6 = T2(n5);
      u3(n5) ? o6 = n5 : c3(t6) && (o6 = t6);
    }
    return s3(o6) ? e4.filter((t6) => o6 && s3(t6) && function(t7, e5) {
      const n6 = null == e5.getRootNode ? void 0 : e5.getRootNode();
      if (t7.contains(e5))
        return true;
      if (n6 && f3(n6)) {
        let n7 = e5;
        do {
          if (n7 && t7 === n7)
            return true;
          n7 = n7.parentNode || n7.host;
        } while (n7);
      }
      return false;
    }(t6, o6) && "body" !== r3(t6)) : [];
  }
  var S2 = { getClippingRect: function(t5) {
    let { element: e4, boundary: n5, rootBoundary: o6, strategy: i5 } = t5;
    const r5 = [..."clippingAncestors" === n5 ? N2(e4) : [].concat(n5), o6], l5 = r5[0], c6 = r5.reduce((t6, n6) => {
      const o7 = D2(e4, n6, i5);
      return t6.top = p3(o7.top, t6.top), t6.right = m3(o7.right, t6.right), t6.bottom = m3(o7.bottom, t6.bottom), t6.left = p3(o7.left, t6.left), t6;
    }, D2(e4, l5, i5));
    return { width: c6.right - c6.left, height: c6.bottom - c6.top, x: c6.left, y: c6.top };
  }, convertOffsetParentRelativeRectToViewportRelativeRect: function(t5) {
    let { rect: e4, offsetParent: n5, strategy: o6 } = t5;
    const i5 = c3(n5), l5 = y3(n5);
    if (n5 === l5)
      return e4;
    let s5 = { scrollLeft: 0, scrollTop: 0 };
    const f5 = { x: 0, y: 0 };
    if ((i5 || !i5 && "fixed" !== o6) && (("body" !== r3(n5) || u3(l5)) && (s5 = x3(n5)), c3(n5))) {
      const t6 = v3(n5, true);
      f5.x = t6.x + n5.clientLeft, f5.y = t6.y + n5.clientTop;
    }
    return { ...e4, x: e4.x - s5.scrollLeft + f5.x, y: e4.y - s5.scrollTop + f5.y };
  }, isElement: s3, getDimensions: W, getOffsetParent: T2, getDocumentElement: y3, getElementRects: (t5) => {
    let { reference: e4, floating: n5, strategy: o6 } = t5;
    return { reference: L2(e4, T2(n5), o6), floating: { ...W(n5), x: 0, y: 0 } };
  }, getClientRects: (t5) => Array.from(t5.getClientRects()), isRTL: (t5) => "rtl" === i3(t5).direction };
  function z(t5, e4, n5, o6) {
    void 0 === o6 && (o6 = {});
    const { ancestorScroll: i5 = true, ancestorResize: r5 = true, elementResize: l5 = true, animationFrame: c6 = false } = o6, f5 = i5 && !c6, u4 = f5 || r5 ? [...s3(t5) ? C(t5) : t5.contextElement ? C(t5.contextElement) : [], ...C(e4)] : [];
    u4.forEach((t6) => {
      f5 && t6.addEventListener("scroll", n5, { passive: true }), r5 && t6.addEventListener("resize", n5);
    });
    let d4, h4 = null;
    if (l5) {
      let o7 = true;
      h4 = new ResizeObserver(() => {
        o7 || n5(), o7 = false;
      }), s3(t5) && !c6 && h4.observe(t5), s3(t5) || !t5.contextElement || c6 || h4.observe(t5.contextElement), h4.observe(e4);
    }
    let a6 = c6 ? v3(t5) : null;
    return c6 && function e5() {
      const o7 = v3(t5);
      !a6 || o7.x === a6.x && o7.y === a6.y && o7.width === a6.width && o7.height === a6.height || n5();
      a6 = o7, d4 = requestAnimationFrame(e5);
    }(), n5(), () => {
      var t6;
      u4.forEach((t7) => {
        f5 && t7.removeEventListener("scroll", n5), r5 && t7.removeEventListener("resize", n5);
      }), null == (t6 = h4) || t6.disconnect(), h4 = null, c6 && cancelAnimationFrame(d4);
    };
  }
  var A = (t5, n5, o6) => o3(t5, n5, { platform: S2, ...o6 });

  // node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
  var React2 = __toESM(require_react(), 1);
  var import_react35 = __toESM(require_react(), 1);
  var ReactDOM = __toESM(require_react_dom(), 1);
  var index = typeof document !== "undefined" ? import_react35.useLayoutEffect : import_react35.useEffect;
  function deepEqual(a6, b6) {
    if (a6 === b6) {
      return true;
    }
    if (typeof a6 !== typeof b6) {
      return false;
    }
    if (typeof a6 === "function" && a6.toString() === b6.toString()) {
      return true;
    }
    let length, i5, keys;
    if (a6 && b6 && typeof a6 == "object") {
      if (Array.isArray(a6)) {
        length = a6.length;
        if (length != b6.length)
          return false;
        for (i5 = length; i5-- !== 0; ) {
          if (!deepEqual(a6[i5], b6[i5])) {
            return false;
          }
        }
        return true;
      }
      keys = Object.keys(a6);
      length = keys.length;
      if (length !== Object.keys(b6).length) {
        return false;
      }
      for (i5 = length; i5-- !== 0; ) {
        if (!Object.prototype.hasOwnProperty.call(b6, keys[i5])) {
          return false;
        }
      }
      for (i5 = length; i5-- !== 0; ) {
        const key = keys[i5];
        if (key === "_owner" && a6.$$typeof) {
          continue;
        }
        if (!deepEqual(a6[key], b6[key])) {
          return false;
        }
      }
      return true;
    }
    return a6 !== a6 && b6 !== b6;
  }
  function useLatestRef(value) {
    const ref2 = React2.useRef(value);
    index(() => {
      ref2.current = value;
    });
    return ref2;
  }
  function useFloating(_temp) {
    let {
      middleware,
      placement = "bottom",
      strategy = "absolute",
      whileElementsMounted
    } = _temp === void 0 ? {} : _temp;
    const [data, setData] = React2.useState({
      x: null,
      y: null,
      strategy,
      placement,
      middlewareData: {}
    });
    const [latestMiddleware, setLatestMiddleware] = React2.useState(middleware);
    if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref8) => {
      let {
        name,
        options
      } = _ref8;
      return {
        name,
        options
      };
    }), middleware == null ? void 0 : middleware.map((_ref22) => {
      let {
        name,
        options
      } = _ref22;
      return {
        name,
        options
      };
    }))) {
      setLatestMiddleware(middleware);
    }
    const reference = React2.useRef(null);
    const floating = React2.useRef(null);
    const cleanupRef = React2.useRef(null);
    const dataRef = React2.useRef(data);
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const update3 = React2.useCallback(() => {
      if (!reference.current || !floating.current) {
        return;
      }
      A(reference.current, floating.current, {
        middleware: latestMiddleware,
        placement,
        strategy
      }).then((data2) => {
        if (isMountedRef.current && !deepEqual(dataRef.current, data2)) {
          dataRef.current = data2;
          ReactDOM.flushSync(() => {
            setData(data2);
          });
        }
      });
    }, [latestMiddleware, placement, strategy]);
    index(() => {
      if (isMountedRef.current) {
        update3();
      }
    }, [update3]);
    const isMountedRef = React2.useRef(false);
    index(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    const runElementMountCallback = React2.useCallback(() => {
      if (typeof cleanupRef.current === "function") {
        cleanupRef.current();
        cleanupRef.current = null;
      }
      if (reference.current && floating.current) {
        if (whileElementsMountedRef.current) {
          const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update3);
          cleanupRef.current = cleanupFn;
        } else {
          update3();
        }
      }
    }, [update3, whileElementsMountedRef]);
    const setReference = React2.useCallback((node) => {
      reference.current = node;
      runElementMountCallback();
    }, [runElementMountCallback]);
    const setFloating = React2.useCallback((node) => {
      floating.current = node;
      runElementMountCallback();
    }, [runElementMountCallback]);
    const refs = React2.useMemo(() => ({
      reference,
      floating
    }), []);
    return React2.useMemo(() => ({
      ...data,
      update: update3,
      refs,
      reference: setReference,
      floating: setFloating
    }), [data, update3, refs, setReference, setFloating]);
  }
  var arrow = (options) => {
    const {
      element,
      padding: padding2
    } = options;
    function isRef(value) {
      return Object.prototype.hasOwnProperty.call(value, "current");
    }
    return {
      name: "arrow",
      options,
      fn(args) {
        if (isRef(element)) {
          if (element.current != null) {
            return m2({
              element: element.current,
              padding: padding2
            }).fn(args);
          }
          return {};
        } else if (element) {
          return m2({
            element,
            padding: padding2
          }).fn(args);
        }
        return {};
      }
    };
  };

  // node_modules/framer-motion/dist/es/motion/index.mjs
  var React4 = __toESM(require_react(), 1);
  var import_react51 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/motion/features/use-features.mjs
  var React3 = __toESM(require_react(), 1);
  var import_react37 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/process.mjs
  var defaultEnvironment = "production";
  var env = typeof process === "undefined" || process.env === void 0 ? defaultEnvironment : "development";

  // node_modules/framer-motion/dist/es/motion/features/definitions.mjs
  var createDefinition = function(propNames) {
    return {
      isEnabled: function(props) {
        return propNames.some(function(name) {
          return !!props[name];
        });
      }
    };
  };
  var featureDefinitions = {
    measureLayout: createDefinition(["layout", "layoutId", "drag"]),
    animation: createDefinition([
      "animate",
      "exit",
      "variants",
      "whileHover",
      "whileTap",
      "whileFocus",
      "whileDrag",
      "whileInView"
    ]),
    exit: createDefinition(["exit"]),
    drag: createDefinition(["drag", "dragControls"]),
    focus: createDefinition(["whileFocus"]),
    hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
    tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
    pan: createDefinition([
      "onPan",
      "onPanStart",
      "onPanSessionStart",
      "onPanEnd"
    ]),
    inView: createDefinition([
      "whileInView",
      "onViewportEnter",
      "onViewportLeave"
    ])
  };
  function loadFeatures(features) {
    for (var key in features) {
      if (features[key] === null)
        continue;
      if (key === "projectionNodeConstructor") {
        featureDefinitions.projectionNodeConstructor = features[key];
      } else {
        featureDefinitions[key].Component = features[key];
      }
    }
  }

  // node_modules/hey-listen/dist/hey-listen.es.js
  var warning3 = function() {
  };
  var invariant = function() {
  };
  if (true) {
    warning3 = function(check2, message) {
      if (!check2 && typeof console !== "undefined") {
        console.warn(message);
      }
    };
    invariant = function(check2, message) {
      if (!check2) {
        throw new Error(message);
      }
    };
  }

  // node_modules/framer-motion/dist/es/context/LazyContext.mjs
  var import_react36 = __toESM(require_react(), 1);
  var LazyContext = (0, import_react36.createContext)({ strict: false });

  // node_modules/framer-motion/dist/es/motion/features/use-features.mjs
  var featureNames = Object.keys(featureDefinitions);
  var numFeatures = featureNames.length;
  function useFeatures(props, visualElement2, preloadedFeatures) {
    var features = [];
    var lazyContext = (0, import_react37.useContext)(LazyContext);
    if (!visualElement2)
      return null;
    if (env !== "production" && preloadedFeatures && lazyContext.strict) {
      invariant(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
    }
    for (var i5 = 0; i5 < numFeatures; i5++) {
      var name_1 = featureNames[i5];
      var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component2 = _a.Component;
      if (isEnabled(props) && Component2) {
        features.push(React3.createElement(Component2, __assign({ key: name_1 }, props, { visualElement: visualElement2 })));
      }
    }
    return features;
  }

  // node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
  var import_react38 = __toESM(require_react(), 1);
  var MotionConfigContext = (0, import_react38.createContext)({
    transformPagePoint: function(p5) {
      return p5;
    },
    isStatic: false,
    reducedMotion: "never"
  });

  // node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
  var import_react39 = __toESM(require_react(), 1);
  var MotionContext = (0, import_react39.createContext)({});
  function useVisualElementContext() {
    return (0, import_react39.useContext)(MotionContext).visualElement;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var import_react43 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/PresenceContext.mjs
  var import_react40 = __toESM(require_react(), 1);
  var PresenceContext = (0, import_react40.createContext)(null);

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var import_react41 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-browser.mjs
  var isBrowser = typeof document !== "undefined";

  // node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var useIsomorphicLayoutEffect2 = isBrowser ? import_react41.useLayoutEffect : import_react41.useEffect;

  // node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs
  var import_react42 = __toESM(require_react(), 1);
  var prefersReducedMotion = { current: null };
  var hasDetected = false;
  function initPrefersReducedMotion() {
    hasDetected = true;
    if (!isBrowser)
      return;
    if (window.matchMedia) {
      var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
      var setReducedMotionPreferences = function() {
        return prefersReducedMotion.current = motionMediaQuery_1.matches;
      };
      motionMediaQuery_1.addListener(setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }
  function useReducedMotion2() {
    !hasDetected && initPrefersReducedMotion();
    var _a = __read((0, import_react42.useState)(prefersReducedMotion.current), 1), shouldReduceMotion = _a[0];
    return shouldReduceMotion;
  }
  function useReducedMotionConfig() {
    var reducedMotionPreference = useReducedMotion2();
    var reducedMotion = (0, import_react42.useContext)(MotionConfigContext).reducedMotion;
    if (reducedMotion === "never") {
      return false;
    } else if (reducedMotion === "always") {
      return true;
    } else {
      return reducedMotionPreference;
    }
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  function useVisualElement(Component2, visualState, props, createVisualElement) {
    var lazyContext = (0, import_react43.useContext)(LazyContext);
    var parent = useVisualElementContext();
    var presenceContext = (0, import_react43.useContext)(PresenceContext);
    var shouldReduceMotion = useReducedMotionConfig();
    var visualElementRef = (0, import_react43.useRef)(void 0);
    if (!createVisualElement)
      createVisualElement = lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component2, {
        visualState,
        parent,
        props,
        presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
        blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
        shouldReduceMotion
      });
    }
    var visualElement2 = visualElementRef.current;
    useIsomorphicLayoutEffect2(function() {
      visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
    });
    (0, import_react43.useEffect)(function() {
      var _a;
      (_a = visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();
    });
    useIsomorphicLayoutEffect2(function() {
      return function() {
        return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();
      };
    }, []);
    return visualElement2;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  var import_react44 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
  function isRefObject2(ref2) {
    return typeof ref2 === "object" && Object.prototype.hasOwnProperty.call(ref2, "current");
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  function useMotionRef(visualState, visualElement2, externalRef) {
    return (0, import_react44.useCallback)(
      function(instance) {
        var _a;
        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));
        if (visualElement2) {
          instance ? visualElement2.mount(instance) : visualElement2.unmount();
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject2(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      [visualElement2]
    );
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  var import_react45 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/utils/variants.mjs
  function isVariantLabels(v5) {
    return Array.isArray(v5);
  }
  function isVariantLabel(v5) {
    return typeof v5 === "string" || isVariantLabels(v5);
  }
  function getCurrent(visualElement2) {
    var current = {};
    visualElement2.forEachValue(function(value, key) {
      return current[key] = value.get();
    });
    return current;
  }
  function getVelocity(visualElement2) {
    var velocity = {};
    visualElement2.forEachValue(function(value, key) {
      return velocity[key] = value.getVelocity();
    });
    return velocity;
  }
  function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
    var _a;
    if (currentValues === void 0) {
      currentValues = {};
    }
    if (currentVelocity === void 0) {
      currentVelocity = {};
    }
    if (typeof definition === "function") {
      definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
    }
    if (typeof definition === "string") {
      definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
    }
    if (typeof definition === "function") {
      definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
    }
    return definition;
  }
  function resolveVariant(visualElement2, definition, custom) {
    var props = visualElement2.getProps();
    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
  }
  function checkIfControllingVariants(props) {
    var _a;
    return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
  }
  function checkIfVariantNode(props) {
    return Boolean(checkIfControllingVariants(props) || props.variants);
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
  function getCurrentTreeVariants(props, context2) {
    if (checkIfControllingVariants(props)) {
      var initial = props.initial, animate3 = props.animate;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate3) ? animate3 : void 0
      };
    }
    return props.inherit !== false ? context2 : {};
  }

  // node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  function useCreateMotionContext(props) {
    var _a = getCurrentTreeVariants(props, (0, import_react45.useContext)(MotionContext)), initial = _a.initial, animate3 = _a.animate;
    return (0, import_react45.useMemo)(function() {
      return { initial, animate: animate3 };
    }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate3)]);
  }
  function variantLabelsAsDependency(prop2) {
    return Array.isArray(prop2) ? prop2.join(" ") : prop2;
  }

  // node_modules/framer-motion/dist/es/utils/use-constant.mjs
  var import_react46 = __toESM(require_react(), 1);
  function useConstant(init) {
    var ref2 = (0, import_react46.useRef)(null);
    if (ref2.current === null) {
      ref2.current = init();
    }
    return ref2.current;
  }

  // node_modules/framer-motion/dist/es/projection/node/state.mjs
  var globalProjectionState = {
    hasAnimatedSinceResize: true,
    hasEverUpdated: false
  };

  // node_modules/framer-motion/dist/es/projection/node/id.mjs
  var id = 1;
  function useProjectionId() {
    return useConstant(function() {
      if (globalProjectionState.hasEverUpdated) {
        return id++;
      }
    });
  }

  // node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
  var import_react47 = __toESM(require_react(), 1);
  var LayoutGroupContext = (0, import_react47.createContext)({});

  // node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
  var import_react49 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
  var import_react48 = __toESM(require_react(), 1);
  var SwitchLayoutGroupContext = (0, import_react48.createContext)({});

  // node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
  function useProjection(projectionId, _a, visualElement2, ProjectionNodeConstructor) {
    var _b;
    var layoutId = _a.layoutId, layout = _a.layout, drag2 = _a.drag, dragConstraints = _a.dragConstraints, layoutScroll = _a.layoutScroll;
    var initialPromotionConfig = (0, import_react49.useContext)(SwitchLayoutGroupContext);
    if (!ProjectionNodeConstructor || !visualElement2 || (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.projection)) {
      return;
    }
    visualElement2.projection = new ProjectionNodeConstructor(projectionId, visualElement2.getLatestValues(), (_b = visualElement2.parent) === null || _b === void 0 ? void 0 : _b.projection);
    visualElement2.projection.setOptions({
      layoutId,
      layout,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject2(dragConstraints),
      visualElement: visualElement2,
      scheduleRender: function() {
        return visualElement2.scheduleRender();
      },
      animationType: typeof layout === "string" ? layout : "both",
      initialPromotionConfig,
      layoutScroll
    });
  }

  // node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs
  var import_react50 = __toESM(require_react(), 1);
  var VisualElementHandler = function(_super) {
    __extends(VisualElementHandler2, _super);
    function VisualElementHandler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VisualElementHandler2.prototype.getSnapshotBeforeUpdate = function() {
      this.updateProps();
      return null;
    };
    VisualElementHandler2.prototype.componentDidUpdate = function() {
    };
    VisualElementHandler2.prototype.updateProps = function() {
      var _a = this.props, visualElement2 = _a.visualElement, props = _a.props;
      if (visualElement2)
        visualElement2.setProps(props);
    };
    VisualElementHandler2.prototype.render = function() {
      return this.props.children;
    };
    return VisualElementHandler2;
  }(import_react50.default.Component);

  // node_modules/framer-motion/dist/es/motion/index.mjs
  function createMotionComponent(_a) {
    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component2 = _a.Component;
    preloadedFeatures && loadFeatures(preloadedFeatures);
    function MotionComponent(props, externalRef) {
      var layoutId = useLayoutId(props);
      props = __assign(__assign({}, props), { layoutId });
      var config2 = (0, import_react51.useContext)(MotionConfigContext);
      var features = null;
      var context2 = useCreateMotionContext(props);
      var projectionId = config2.isStatic ? void 0 : useProjectionId();
      var visualState = useVisualState(props, config2.isStatic);
      if (!config2.isStatic && isBrowser) {
        context2.visualElement = useVisualElement(Component2, visualState, __assign(__assign({}, config2), props), createVisualElement);
        useProjection(projectionId, props, context2.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);
        features = useFeatures(props, context2.visualElement, preloadedFeatures);
      }
      return React4.createElement(
        VisualElementHandler,
        { visualElement: context2.visualElement, props: __assign(__assign({}, config2), props) },
        features,
        React4.createElement(MotionContext.Provider, { value: context2 }, useRender(Component2, props, projectionId, useMotionRef(visualState, context2.visualElement, externalRef), visualState, config2.isStatic, context2.visualElement))
      );
    }
    return (0, import_react51.forwardRef)(MotionComponent);
  }
  function useLayoutId(_a) {
    var _b;
    var layoutId = _a.layoutId;
    var layoutGroupId = (_b = (0, import_react51.useContext)(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }

  // node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
  function createMotionProxy(createConfig) {
    function custom(Component2, customMotionComponentConfig) {
      if (customMotionComponentConfig === void 0) {
        customMotionComponentConfig = {};
      }
      return createMotionComponent(createConfig(Component2, customMotionComponentConfig));
    }
    if (typeof Proxy === "undefined") {
      return custom;
    }
    var componentCache = /* @__PURE__ */ new Map();
    return new Proxy(custom, {
      get: function(_target, key) {
        if (!componentCache.has(key)) {
          componentCache.set(key, custom(key));
        }
        return componentCache.get(key);
      }
    });
  }

  // node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
  var lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "svg",
    "switch",
    "symbol",
    "text",
    "tspan",
    "use",
    "view"
  ];

  // node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
  function isSVGComponent(Component2) {
    if (typeof Component2 !== "string" || Component2.includes("-")) {
      return false;
    } else if (lowercaseSVGElements.indexOf(Component2) > -1 || /[A-Z]/.test(Component2)) {
      return true;
    }
    return false;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  var import_react54 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  var import_react52 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
  var scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    Object.assign(scaleCorrectors, correctors);
  }

  // node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
  var transformAxes = ["", "X", "Y", "Z"];
  var order = ["translate", "scale", "rotate", "skew"];
  var transformProps = ["transformPerspective", "x", "y", "z"];
  order.forEach(function(operationKey) {
    return transformAxes.forEach(function(axesKey) {
      return transformProps.push(operationKey + axesKey);
    });
  });
  function sortTransformProps(a6, b6) {
    return transformProps.indexOf(a6) - transformProps.indexOf(b6);
  }
  var transformPropSet = new Set(transformProps);
  function isTransformProp(key) {
    return transformPropSet.has(key);
  }
  var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
  function isTransformOriginProp(key) {
    return transformOriginProps.has(key);
  }

  // node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
  function isForcedMotionValue(key, _a) {
    var layout = _a.layout, layoutId = _a.layoutId;
    return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }

  // node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
  var isMotionValue = function(value) {
    return Boolean(value !== null && typeof value === "object" && value.getVelocity);
  };

  // node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
  var translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
    var transform = _a.transform, transformKeys2 = _a.transformKeys;
    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
    var transformString = "";
    transformKeys2.sort(sortTransformProps);
    var transformHasZ = false;
    var numTransformKeys = transformKeys2.length;
    for (var i5 = 0; i5 < numTransformKeys; i5++) {
      var key = transformKeys2[i5];
      transformString += "".concat(translateAlias[key] || key, "(").concat(transform[key], ") ");
      if (key === "z")
        transformHasZ = true;
    }
    if (!transformHasZ && enableHardwareAcceleration) {
      transformString += "translateZ(0)";
    } else {
      transformString = transformString.trim();
    }
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (allowTransformNone && transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }
  function buildTransformOrigin(_a) {
    var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
    return "".concat(originX, " ").concat(originY, " ").concat(originZ);
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
  function isCSSVariable(key) {
    return key.startsWith("--");
  }

  // node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
  var getValueAsType = function(value, type) {
    return type && typeof value === "number" ? type.transform(value) : value;
  };

  // node_modules/style-value-types/dist/es/utils.mjs
  var clamp = (min, max) => (v5) => Math.max(Math.min(v5, max), min);
  var sanitize = (v5) => v5 % 1 ? Number(v5.toFixed(5)) : v5;
  var floatRegex = /(-)?([\d]*\.?[\d])+/g;
  var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
  var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
  function isString(v5) {
    return typeof v5 === "string";
  }

  // node_modules/style-value-types/dist/es/numbers/index.mjs
  var number = {
    test: (v5) => typeof v5 === "number",
    parse: parseFloat,
    transform: (v5) => v5
  };
  var alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });
  var scale = Object.assign(Object.assign({}, number), { default: 1 });

  // node_modules/style-value-types/dist/es/numbers/units.mjs
  var createUnitType = (unit) => ({
    test: (v5) => isString(v5) && v5.endsWith(unit) && v5.split(" ").length === 1,
    parse: parseFloat,
    transform: (v5) => `${v5}${unit}`
  });
  var degrees = createUnitType("deg");
  var percent = createUnitType("%");
  var px = createUnitType("px");
  var vh = createUnitType("vh");
  var vw = createUnitType("vw");
  var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v5) => percent.parse(v5) / 100, transform: (v5) => percent.transform(v5 * 100) });

  // node_modules/style-value-types/dist/es/color/utils.mjs
  var isColorString = (type, testProp) => (v5) => {
    return Boolean(isString(v5) && singleColorRegex.test(v5) && v5.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v5, testProp));
  };
  var splitColor = (aName, bName, cName) => (v5) => {
    if (!isString(v5))
      return v5;
    const [a6, b6, c6, alpha2] = v5.match(floatRegex);
    return {
      [aName]: parseFloat(a6),
      [bName]: parseFloat(b6),
      [cName]: parseFloat(c6),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };

  // node_modules/style-value-types/dist/es/color/hsla.mjs
  var hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };

  // node_modules/style-value-types/dist/es/color/rgba.mjs
  var clampRgbUnit = clamp(0, 255);
  var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v5) => Math.round(clampRgbUnit(v5)) });
  var rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };

  // node_modules/style-value-types/dist/es/color/hex.mjs
  function parseHex(v5) {
    let r5 = "";
    let g5 = "";
    let b6 = "";
    let a6 = "";
    if (v5.length > 5) {
      r5 = v5.substr(1, 2);
      g5 = v5.substr(3, 2);
      b6 = v5.substr(5, 2);
      a6 = v5.substr(7, 2);
    } else {
      r5 = v5.substr(1, 1);
      g5 = v5.substr(2, 1);
      b6 = v5.substr(3, 1);
      a6 = v5.substr(4, 1);
      r5 += r5;
      g5 += g5;
      b6 += b6;
      a6 += a6;
    }
    return {
      red: parseInt(r5, 16),
      green: parseInt(g5, 16),
      blue: parseInt(b6, 16),
      alpha: a6 ? parseInt(a6, 16) / 255 : 1
    };
  }
  var hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };

  // node_modules/style-value-types/dist/es/color/index.mjs
  var color = {
    test: (v5) => rgba.test(v5) || hex.test(v5) || hsla.test(v5),
    parse: (v5) => {
      if (rgba.test(v5)) {
        return rgba.parse(v5);
      } else if (hsla.test(v5)) {
        return hsla.parse(v5);
      } else {
        return hex.parse(v5);
      }
    },
    transform: (v5) => {
      return isString(v5) ? v5 : v5.hasOwnProperty("red") ? rgba.transform(v5) : hsla.transform(v5);
    }
  };

  // node_modules/style-value-types/dist/es/complex/index.mjs
  var colorToken = "${c}";
  var numberToken = "${n}";
  function test(v5) {
    var _a, _b, _c, _d;
    return isNaN(v5) && isString(v5) && ((_b = (_a = v5.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v5.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;
  }
  function analyse(v5) {
    if (typeof v5 === "number")
      v5 = `${v5}`;
    const values = [];
    let numColors = 0;
    const colors2 = v5.match(colorRegex);
    if (colors2) {
      numColors = colors2.length;
      v5 = v5.replace(colorRegex, colorToken);
      values.push(...colors2.map(color.parse));
    }
    const numbers = v5.match(floatRegex);
    if (numbers) {
      v5 = v5.replace(floatRegex, numberToken);
      values.push(...numbers.map(number.parse));
    }
    return { values, numColors, tokenised: v5 };
  }
  function parse4(v5) {
    return analyse(v5).values;
  }
  function createTransformer(v5) {
    const { values, numColors, tokenised } = analyse(v5);
    const numValues = values.length;
    return (v6) => {
      let output3 = tokenised;
      for (let i5 = 0; i5 < numValues; i5++) {
        output3 = output3.replace(i5 < numColors ? colorToken : numberToken, i5 < numColors ? color.transform(v6[i5]) : sanitize(v6[i5]));
      }
      return output3;
    };
  }
  var convertNumbersToZero = (v5) => typeof v5 === "number" ? 0 : v5;
  function getAnimatableNone(v5) {
    const parsed = parse4(v5);
    const transformer = createTransformer(v5);
    return transformer(parsed.map(convertNumbersToZero));
  }
  var complex = { test, parse: parse4, createTransformer, getAnimatableNone };

  // node_modules/style-value-types/dist/es/complex/filter.mjs
  var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v5) {
    let [name, value] = v5.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v5;
    const [number2] = value.match(floatRegex) || [];
    if (!number2)
      return v5;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number2 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  var functionRegex = /([a-z-]*)\(.*?\)/g;
  var filter3 = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v5) => {
    const functions = v5.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v5;
  } });

  // node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
  var int = __assign(__assign({}, number), { transform: Math.round });

  // node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
  var numberValueTypes = {
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    size: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
    zIndex: int,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };

  // node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
  function buildHTMLStyles(state, latestValues, options, transformTemplate) {
    var _a;
    var style = state.style, vars = state.vars, transform = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
    transformKeys2.length = 0;
    var hasTransform2 = false;
    var hasTransformOrigin = false;
    var transformIsNone = true;
    for (var key in latestValues) {
      var value = latestValues[key];
      if (isCSSVariable(key)) {
        vars[key] = value;
        continue;
      }
      var valueType = numberValueTypes[key];
      var valueAsType = getValueAsType(value, valueType);
      if (isTransformProp(key)) {
        hasTransform2 = true;
        transform[key] = valueAsType;
        transformKeys2.push(key);
        if (!transformIsNone)
          continue;
        if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
          transformIsNone = false;
      } else if (isTransformOriginProp(key)) {
        transformOrigin[key] = valueAsType;
        hasTransformOrigin = true;
      } else {
        style[key] = valueAsType;
      }
    }
    if (hasTransform2) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    } else if (transformTemplate) {
      style.transform = transformTemplate({}, "");
    } else if (!latestValues.transform && style.transform) {
      style.transform = "none";
    }
    if (hasTransformOrigin) {
      style.transformOrigin = buildTransformOrigin(transformOrigin);
    }
  }

  // node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
  var createHtmlRenderState = function() {
    return {
      style: {},
      transform: {},
      transformKeys: [],
      transformOrigin: {},
      vars: {}
    };
  };

  // node_modules/framer-motion/dist/es/render/html/use-props.mjs
  function copyRawValuesOnly(target, source, props) {
    for (var key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues(_a, visualState, isStatic) {
    var transformTemplate = _a.transformTemplate;
    return (0, import_react52.useMemo)(function() {
      var state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
      var vars = state.vars, style = state.style;
      return __assign(__assign({}, vars), style);
    }, [visualState]);
  }
  function useStyle(props, visualState, isStatic) {
    var styleProp = props.style || {};
    var style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
    if (props.transformValues) {
      style = props.transformValues(style);
    }
    return style;
  }
  function useHTMLProps(props, visualState, isStatic) {
    var htmlProps = {};
    var style = useStyle(props, visualState, isStatic);
    if (Boolean(props.drag) && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
    }
    htmlProps.style = style;
    return htmlProps;
  }

  // node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
  var validMotionProps = /* @__PURE__ */ new Set([
    "initial",
    "animate",
    "exit",
    "style",
    "variants",
    "transition",
    "transformTemplate",
    "transformValues",
    "custom",
    "inherit",
    "layout",
    "layoutId",
    "layoutDependency",
    "onLayoutAnimationStart",
    "onLayoutAnimationComplete",
    "onLayoutMeasure",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "drag",
    "dragControls",
    "dragListener",
    "dragConstraints",
    "dragDirectionLock",
    "dragSnapToOrigin",
    "_dragX",
    "_dragY",
    "dragElastic",
    "dragMomentum",
    "dragPropagation",
    "dragTransition",
    "whileDrag",
    "onPan",
    "onPanStart",
    "onPanEnd",
    "onPanSessionStart",
    "onTap",
    "onTapStart",
    "onTapCancel",
    "onHoverStart",
    "onHoverEnd",
    "whileFocus",
    "whileTap",
    "whileHover",
    "whileInView",
    "onViewportEnter",
    "onViewportLeave",
    "viewport",
    "layoutScroll"
  ]);
  function isValidMotionProp(key) {
    return validMotionProps.has(key);
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
  var shouldForward = function(key) {
    return !isValidMotionProp(key);
  };
  function loadExternalIsValidProp(isValidProp) {
    if (!isValidProp)
      return;
    shouldForward = function(key) {
      return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
    };
  }
  try {
    loadExternalIsValidProp(require_is_prop_valid_browser_cjs().default);
  } catch (_a) {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    var filteredProps = {};
    for (var key in props) {
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  var import_react53 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
  function calcOrigin(origin, offset4, size) {
    return typeof origin === "string" ? origin : px.transform(offset4 + size * origin);
  }
  function calcSVGTransformOrigin(dimensions, originX, originY) {
    var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
    var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
    return "".concat(pxOriginX, " ").concat(pxOriginY);
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
  var dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  var camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs2, length, spacing, offset4, useDashCase) {
    if (spacing === void 0) {
      spacing = 1;
    }
    if (offset4 === void 0) {
      offset4 = 0;
    }
    if (useDashCase === void 0) {
      useDashCase = true;
    }
    attrs2.pathLength = 1;
    var keys = useDashCase ? dashKeys : camelKeys;
    attrs2[keys.offset] = px.transform(-offset4);
    var pathLength = px.transform(length);
    var pathSpacing = px.transform(spacing);
    attrs2[keys.array] = "".concat(pathLength, " ").concat(pathSpacing);
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
  function buildSVGAttrs(state, _a, options, transformTemplate) {
    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
    buildHTMLStyles(state, latest, options, transformTemplate);
    state.attrs = state.style;
    state.style = {};
    var attrs2 = state.attrs, style = state.style, dimensions = state.dimensions;
    if (attrs2.transform) {
      if (dimensions)
        style.transform = attrs2.transform;
      delete attrs2.transform;
    }
    if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
      style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
    }
    if (attrX !== void 0)
      attrs2.x = attrX;
    if (attrY !== void 0)
      attrs2.y = attrY;
    if (pathLength !== void 0) {
      buildSVGPath(attrs2, pathLength, pathSpacing, pathOffset, false);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
  var createSvgRenderState = function() {
    return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });
  };

  // node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  function useSVGProps(props, visualState) {
    var visualProps = (0, import_react53.useMemo)(function() {
      var state = createSvgRenderState();
      buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
      return __assign(__assign({}, state.attrs), { style: __assign({}, state.style) });
    }, [visualState]);
    if (props.style) {
      var rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);
    }
    return visualProps;
  }

  // node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  function createUseRender(forwardMotionProps) {
    if (forwardMotionProps === void 0) {
      forwardMotionProps = false;
    }
    var useRender = function(Component2, props, projectionId, ref2, _a, isStatic) {
      var latestValues = _a.latestValues;
      var useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
      var visualProps = useVisualProps(props, latestValues, isStatic);
      var filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
      var elementProps = __assign(__assign(__assign({}, filteredProps), visualProps), { ref: ref2 });
      if (projectionId) {
        elementProps["data-projection-id"] = projectionId;
      }
      return (0, import_react54.createElement)(Component2, elementProps);
    };
    return useRender;
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
  var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
  var REPLACE_TEMPLATE = "$1-$2";
  var camelToDash = function(str) {
    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
  };

  // node_modules/framer-motion/dist/es/render/html/utils/render.mjs
  function renderHTML(element, _a, styleProp, projection) {
    var style = _a.style, vars = _a.vars;
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    for (var key in vars) {
      element.style.setProperty(key, vars[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
  var camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength"
  ]);

  // node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (var key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }

  // node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps(props) {
    var style = props.style;
    var newValues = {};
    for (var key in style) {
      if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps2(props) {
    var newValues = scrapeMotionValuesFromProps(props);
    for (var key in props) {
      if (isMotionValue(props[key])) {
        var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  var import_react55 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
  function isAnimationControls(v5) {
    return typeof v5 === "object" && typeof v5.start === "function";
  }

  // node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
  var isKeyframesTarget = function(v5) {
    return Array.isArray(v5);
  };

  // node_modules/framer-motion/dist/es/utils/resolve-value.mjs
  var isCustomValue = function(v5) {
    return Boolean(v5 && typeof v5 === "object" && v5.mix && v5.toValue);
  };
  var resolveFinalValueInKeyframes = function(v5) {
    return isKeyframesTarget(v5) ? v5[v5.length - 1] || 0 : v5;
  };

  // node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
  function resolveMotionValue(value) {
    var unwrappedValue = isMotionValue(value) ? value.get() : value;
    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
  }

  // node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  function makeState(_a, props, context2, presenceContext) {
    var scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;
    var state = {
      latestValues: makeLatestValues(props, context2, presenceContext, scrapeMotionValuesFromProps3),
      renderState: createRenderState()
    };
    if (onMount) {
      state.mount = function(instance) {
        return onMount(props, instance, state);
      };
    }
    return state;
  }
  var makeUseVisualState = function(config2) {
    return function(props, isStatic) {
      var context2 = (0, import_react55.useContext)(MotionContext);
      var presenceContext = (0, import_react55.useContext)(PresenceContext);
      return isStatic ? makeState(config2, props, context2, presenceContext) : useConstant(function() {
        return makeState(config2, props, context2, presenceContext);
      });
    };
  };
  function makeLatestValues(props, context2, presenceContext, scrapeMotionValues) {
    var values = {};
    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
    var motionValues = scrapeMotionValues(props);
    for (var key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    var initial = props.initial, animate3 = props.animate;
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    if (context2 && isVariantNode && !isControllingVariants && props.inherit !== false) {
      initial !== null && initial !== void 0 ? initial : initial = context2.initial;
      animate3 !== null && animate3 !== void 0 ? animate3 : animate3 = context2.animate;
    }
    var initialAnimationIsBlocked = blockInitialAnimation || initial === false;
    var variantToSet = initialAnimationIsBlocked ? animate3 : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      list.forEach(function(definition) {
        var resolved = resolveVariantFromProps(props, definition);
        if (!resolved)
          return;
        var transitionEnd = resolved.transitionEnd;
        resolved.transition;
        var target = __rest(resolved, ["transitionEnd", "transition"]);
        for (var key2 in target) {
          var valueTarget = target[key2];
          if (Array.isArray(valueTarget)) {
            var index2 = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values[key2] = valueTarget;
          }
        }
        for (var key2 in transitionEnd)
          values[key2] = transitionEnd[key2];
      });
    }
    return values;
  }

  // node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
  var svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
      createRenderState: createSvgRenderState,
      onMount: function(props, instance, _a) {
        var renderState = _a.renderState, latestValues = _a.latestValues;
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e4) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
        renderSVG(instance, renderState);
      }
    })
  };

  // node_modules/framer-motion/dist/es/render/html/config-motion.mjs
  var htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createHtmlRenderState
    })
  };

  // node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
  function createDomMotionConfig(Component2, _a, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;
    var baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;
    return __assign(__assign({}, baseConfig), { preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement, projectionNodeConstructor, Component: Component2 });
  }

  // node_modules/framer-motion/dist/es/render/utils/types.mjs
  var AnimationType;
  (function(AnimationType2) {
    AnimationType2["Animate"] = "animate";
    AnimationType2["Hover"] = "whileHover";
    AnimationType2["Tap"] = "whileTap";
    AnimationType2["Drag"] = "whileDrag";
    AnimationType2["Focus"] = "whileFocus";
    AnimationType2["InView"] = "whileInView";
    AnimationType2["Exit"] = "exit";
  })(AnimationType || (AnimationType = {}));

  // node_modules/framer-motion/dist/es/events/use-dom-event.mjs
  var import_react56 = __toESM(require_react(), 1);
  function addDomEvent(target, eventName, handler, options) {
    if (options === void 0) {
      options = { passive: true };
    }
    target.addEventListener(eventName, handler, options);
    return function() {
      return target.removeEventListener(eventName, handler);
    };
  }
  function useDomEvent(ref2, eventName, handler, options) {
    (0, import_react56.useEffect)(function() {
      var element = ref2.current;
      if (handler && element) {
        return addDomEvent(element, eventName, handler, options);
      }
    }, [ref2, eventName, handler, options]);
  }

  // node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs
  function useFocusGesture(_a) {
    var whileFocus = _a.whileFocus, visualElement2 = _a.visualElement;
    var onFocus = function() {
      var _a2;
      (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, true);
    };
    var onBlur = function() {
      var _a2;
      (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, false);
    };
    useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
    useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
  }

  // node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs
  function isMouseEvent(event) {
    if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
      return !!(event.pointerType === "mouse");
    }
    return event instanceof MouseEvent;
  }
  function isTouchEvent(event) {
    var hasTouches = !!event.touches;
    return hasTouches;
  }

  // node_modules/framer-motion/dist/es/events/event-info.mjs
  function filterPrimaryPointer(eventHandler) {
    return function(event) {
      var isMouseEvent2 = event instanceof MouseEvent;
      var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
      if (isPrimaryPointer) {
        eventHandler(event);
      }
    };
  }
  var defaultPagePoint = { pageX: 0, pageY: 0 };
  function pointFromTouch(e4, pointType) {
    if (pointType === void 0) {
      pointType = "page";
    }
    var primaryTouch = e4.touches[0] || e4.changedTouches[0];
    var point = primaryTouch || defaultPagePoint;
    return {
      x: point[pointType + "X"],
      y: point[pointType + "Y"]
    };
  }
  function pointFromMouse(point, pointType) {
    if (pointType === void 0) {
      pointType = "page";
    }
    return {
      x: point[pointType + "X"],
      y: point[pointType + "Y"]
    };
  }
  function extractEventInfo(event, pointType) {
    if (pointType === void 0) {
      pointType = "page";
    }
    return {
      point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
    };
  }
  var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
    if (shouldFilterPrimaryPointer === void 0) {
      shouldFilterPrimaryPointer = false;
    }
    var listener2 = function(event) {
      return handler(event, extractEventInfo(event));
    };
    return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener2) : listener2;
  };

  // node_modules/framer-motion/dist/es/events/utils.mjs
  var supportsPointerEvents = function() {
    return isBrowser && window.onpointerdown === null;
  };
  var supportsTouchEvents = function() {
    return isBrowser && window.ontouchstart === null;
  };
  var supportsMouseEvents = function() {
    return isBrowser && window.onmousedown === null;
  };

  // node_modules/framer-motion/dist/es/events/use-pointer-event.mjs
  var mouseEventNames = {
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointercancel: "mousecancel",
    pointerover: "mouseover",
    pointerout: "mouseout",
    pointerenter: "mouseenter",
    pointerleave: "mouseleave"
  };
  var touchEventNames = {
    pointerdown: "touchstart",
    pointermove: "touchmove",
    pointerup: "touchend",
    pointercancel: "touchcancel"
  };
  function getPointerEventName(name) {
    if (supportsPointerEvents()) {
      return name;
    } else if (supportsTouchEvents()) {
      return touchEventNames[name];
    } else if (supportsMouseEvents()) {
      return mouseEventNames[name];
    }
    return name;
  }
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
  }
  function usePointerEvent(ref2, eventName, handler, options) {
    return useDomEvent(ref2, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
  }

  // node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
  function createLock(name) {
    var lock2 = null;
    return function() {
      var openLock = function() {
        lock2 = null;
      };
      if (lock2 === null) {
        lock2 = name;
        return openLock;
      }
      return false;
    };
  }
  var globalHorizontalLock = createLock("dragHorizontal");
  var globalVerticalLock = createLock("dragVertical");
  function getGlobalLock(drag2) {
    var lock2 = false;
    if (drag2 === "y") {
      lock2 = globalVerticalLock();
    } else if (drag2 === "x") {
      lock2 = globalHorizontalLock();
    } else {
      var openHorizontal_1 = globalHorizontalLock();
      var openVertical_1 = globalVerticalLock();
      if (openHorizontal_1 && openVertical_1) {
        lock2 = function() {
          openHorizontal_1();
          openVertical_1();
        };
      } else {
        if (openHorizontal_1)
          openHorizontal_1();
        if (openVertical_1)
          openVertical_1();
      }
    }
    return lock2;
  }
  function isDragActive() {
    var openGestureLock = getGlobalLock(true);
    if (!openGestureLock)
      return true;
    openGestureLock();
    return false;
  }

  // node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs
  function createHoverEvent(visualElement2, isActive, callback) {
    return function(event, info) {
      var _a;
      if (!isMouseEvent(event) || isDragActive())
        return;
      (_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);
      callback === null || callback === void 0 ? void 0 : callback(event, info);
    };
  }
  function useHoverGesture(_a) {
    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement2 = _a.visualElement;
    usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0, { passive: !onHoverStart });
    usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0, { passive: !onHoverEnd });
  }

  // node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
  var import_react58 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
  var isNodeOrChild = function(parent, child) {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };

  // node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
  var import_react57 = __toESM(require_react(), 1);
  function useUnmountEffect(callback) {
    return (0, import_react57.useEffect)(function() {
      return function() {
        return callback();
      };
    }, []);
  }

  // node_modules/popmotion/dist/es/utils/clamp.mjs
  var clamp2 = (min, max, v5) => Math.min(Math.max(v5, min), max);

  // node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
  var safeMin = 1e-3;
  var minDuration = 0.01;
  var maxDuration = 10;
  var minDamping = 0.05;
  var maxDamping = 1;
  function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
    let envelope;
    let derivative;
    warning3(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);
    duration = clamp2(minDuration, maxDuration, duration / 1e3);
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a6 = exponentialDecay - velocity;
        const b6 = calcAngularFreq(undampedFreq2, dampingRatio);
        const c6 = Math.exp(-delta);
        return safeMin - a6 / b6 * c6;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d4 = delta * velocity + velocity;
        const e4 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f5 = Math.exp(-delta);
        const g5 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d4 - e4) * f5) / g5;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a6 = Math.exp(-undampedFreq2 * duration);
        const b6 = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a6 * b6;
      };
      derivative = (undampedFreq2) => {
        const a6 = Math.exp(-undampedFreq2 * duration);
        const b6 = (velocity - undampedFreq2) * (duration * duration);
        return a6 * b6;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = duration * 1e3;
    if (isNaN(undampedFreq)) {
      return {
        stiffness: 100,
        damping: 10,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  var rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i5 = 1; i5 < rootIterations; i5++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }

  // node_modules/popmotion/dist/es/animations/generators/spring.mjs
  var durationKeys = ["duration", "bounce"];
  var physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      const derived = findSpring(options);
      springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
      springOptions.isResolvedFromDuration = true;
    }
    return springOptions;
  }
  function spring(_a) {
    var { from = 0, to: to2 = 1, restSpeed = 2, restDelta } = _a, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
    const state = { done: false, value: from };
    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
    let resolveSpring = zero;
    let resolveVelocity = zero;
    function createSpring2() {
      const initialVelocity = velocity ? -(velocity / 1e3) : 0;
      const initialDelta = to2 - from;
      const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
      const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
      if (restDelta === void 0) {
        restDelta = Math.min(Math.abs(to2 - from) / 100, 0.4);
      }
      if (dampingRatio < 1) {
        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
        resolveSpring = (t5) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t5);
          return to2 - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t5) + initialDelta * Math.cos(angularFreq * t5));
        };
        resolveVelocity = (t5) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t5);
          return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t5) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t5)) - envelope * (Math.cos(angularFreq * t5) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t5));
        };
      } else if (dampingRatio === 1) {
        resolveSpring = (t5) => to2 - Math.exp(-undampedAngularFreq * t5) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t5);
      } else {
        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
        resolveSpring = (t5) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t5);
          const freqForT = Math.min(dampedAngularFreq * t5, 300);
          return to2 - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
        };
      }
    }
    createSpring2();
    return {
      next: (t5) => {
        const current = resolveSpring(t5);
        if (!isResolvedFromDuration) {
          const currentVelocity = resolveVelocity(t5) * 1e3;
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(to2 - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t5 >= duration;
        }
        state.value = state.done ? to2 : current;
        return state;
      },
      flipTarget: () => {
        velocity = -velocity;
        [from, to2] = [to2, from];
        createSpring2();
      }
    };
  }
  spring.needsInterpolation = (a6, b6) => typeof a6 === "string" || typeof b6 === "string";
  var zero = (_t) => 0;

  // node_modules/popmotion/dist/es/utils/progress.mjs
  var progress = (from, to2, value) => {
    const toFromDifference = to2 - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  };

  // node_modules/popmotion/dist/es/utils/mix.mjs
  var mix = (from, to2, progress2) => -progress2 * from + progress2 * to2 + from;

  // node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs
  function hueToRgb(p5, q, t5) {
    if (t5 < 0)
      t5 += 1;
    if (t5 > 1)
      t5 -= 1;
    if (t5 < 1 / 6)
      return p5 + (q - p5) * 6 * t5;
    if (t5 < 1 / 2)
      return q;
    if (t5 < 2 / 3)
      return p5 + (q - p5) * (2 / 3 - t5) * 6;
    return p5;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p5 = 2 * lightness - q;
      red = hueToRgb(p5, q, hue + 1 / 3);
      green = hueToRgb(p5, q, hue);
      blue = hueToRgb(p5, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }

  // node_modules/popmotion/dist/es/utils/mix-color.mjs
  var mixLinearColor = (from, to2, v5) => {
    const fromExpo = from * from;
    const toExpo = to2 * to2;
    return Math.sqrt(Math.max(0, v5 * (toExpo - fromExpo) + fromExpo));
  };
  var colorTypes = [hex, rgba, hsla];
  var getColorType = (v5) => colorTypes.find((type) => type.test(v5));
  var notAnimatable = (color4) => `'${color4}' is not an animatable color. Use the equivalent color code instead.`;
  var mixColor = (from, to2) => {
    let fromColorType = getColorType(from);
    let toColorType = getColorType(to2);
    invariant(!!fromColorType, notAnimatable(from));
    invariant(!!toColorType, notAnimatable(to2));
    let fromColor = fromColorType.parse(from);
    let toColor = toColorType.parse(to2);
    if (fromColorType === hsla) {
      fromColor = hslaToRgba(fromColor);
      fromColorType = rgba;
    }
    if (toColorType === hsla) {
      toColor = hslaToRgba(toColor);
      toColorType = rgba;
    }
    const blended = Object.assign({}, fromColor);
    return (v5) => {
      for (const key in blended) {
        if (key !== "alpha") {
          blended[key] = mixLinearColor(fromColor[key], toColor[key], v5);
        }
      }
      blended.alpha = mix(fromColor.alpha, toColor.alpha, v5);
      return fromColorType.transform(blended);
    };
  };

  // node_modules/popmotion/dist/es/utils/inc.mjs
  var isNum = (v5) => typeof v5 === "number";

  // node_modules/popmotion/dist/es/utils/pipe.mjs
  var combineFunctions = (a6, b6) => (v5) => b6(a6(v5));
  var pipe2 = (...transformers) => transformers.reduce(combineFunctions);

  // node_modules/popmotion/dist/es/utils/mix-complex.mjs
  function getMixer(origin, target) {
    if (isNum(origin)) {
      return (v5) => mix(origin, target, v5);
    } else if (color.test(origin)) {
      return mixColor(origin, target);
    } else {
      return mixComplex(origin, target);
    }
  }
  var mixArray = (from, to2) => {
    const output3 = [...from];
    const numValues = output3.length;
    const blendValue = from.map((fromThis, i5) => getMixer(fromThis, to2[i5]));
    return (v5) => {
      for (let i5 = 0; i5 < numValues; i5++) {
        output3[i5] = blendValue[i5](v5);
      }
      return output3;
    };
  };
  var mixObject = (origin, target) => {
    const output3 = Object.assign(Object.assign({}, origin), target);
    const blendValue = {};
    for (const key in output3) {
      if (origin[key] !== void 0 && target[key] !== void 0) {
        blendValue[key] = getMixer(origin[key], target[key]);
      }
    }
    return (v5) => {
      for (const key in blendValue) {
        output3[key] = blendValue[key](v5);
      }
      return output3;
    };
  };
  function analyse2(value) {
    const parsed = complex.parse(value);
    const numValues = parsed.length;
    let numNumbers = 0;
    let numRGB = 0;
    let numHSL = 0;
    for (let i5 = 0; i5 < numValues; i5++) {
      if (numNumbers || typeof parsed[i5] === "number") {
        numNumbers++;
      } else {
        if (parsed[i5].hue !== void 0) {
          numHSL++;
        } else {
          numRGB++;
        }
      }
    }
    return { parsed, numNumbers, numRGB, numHSL };
  }
  var mixComplex = (origin, target) => {
    const template2 = complex.createTransformer(target);
    const originStats = analyse2(origin);
    const targetStats = analyse2(target);
    const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
    if (canInterpolate) {
      return pipe2(mixArray(originStats.parsed, targetStats.parsed), template2);
    } else {
      warning3(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
      return (p5) => `${p5 > 0 ? target : origin}`;
    }
  };

  // node_modules/popmotion/dist/es/utils/interpolate.mjs
  var mixNumber = (from, to2) => (p5) => mix(from, to2, p5);
  function detectMixerFactory(v5) {
    if (typeof v5 === "number") {
      return mixNumber;
    } else if (typeof v5 === "string") {
      if (color.test(v5)) {
        return mixColor;
      } else {
        return mixComplex;
      }
    } else if (Array.isArray(v5)) {
      return mixArray;
    } else if (typeof v5 === "object") {
      return mixObject;
    }
  }
  function createMixers(output3, ease, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || detectMixerFactory(output3[0]);
    const numMixers = output3.length - 1;
    for (let i5 = 0; i5 < numMixers; i5++) {
      let mixer = mixerFactory(output3[i5], output3[i5 + 1]);
      if (ease) {
        const easingFunction = Array.isArray(ease) ? ease[i5] : ease;
        mixer = pipe2(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function fastInterpolate([from, to2], [mixer]) {
    return (v5) => mixer(progress(from, to2, v5));
  }
  function slowInterpolate(input, mixers) {
    const inputLength = input.length;
    const lastInputIndex = inputLength - 1;
    return (v5) => {
      let mixerIndex = 0;
      let foundMixerIndex = false;
      if (v5 <= input[0]) {
        foundMixerIndex = true;
      } else if (v5 >= input[lastInputIndex]) {
        mixerIndex = lastInputIndex - 1;
        foundMixerIndex = true;
      }
      if (!foundMixerIndex) {
        let i5 = 1;
        for (; i5 < inputLength; i5++) {
          if (input[i5] > v5 || i5 === lastInputIndex) {
            break;
          }
        }
        mixerIndex = i5 - 1;
      }
      const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v5);
      return mixers[mixerIndex](progressInRange);
    };
  }
  function interpolate(input, output3, { clamp: isClamp = true, ease, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output3.length, "Both input and output ranges must be the same length");
    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
    if (input[0] > input[inputLength - 1]) {
      input = [].concat(input);
      output3 = [].concat(output3);
      input.reverse();
      output3.reverse();
    }
    const mixers = createMixers(output3, ease, mixer);
    const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
    return isClamp ? (v5) => interpolator(clamp2(input[0], input[inputLength - 1], v5)) : interpolator;
  }

  // node_modules/popmotion/dist/es/easing/utils.mjs
  var reverseEasing = (easing) => (p5) => 1 - easing(1 - p5);
  var mirrorEasing = (easing) => (p5) => p5 <= 0.5 ? easing(2 * p5) / 2 : (2 - easing(2 * (1 - p5))) / 2;
  var createExpoIn = (power) => (p5) => Math.pow(p5, power);
  var createBackIn = (power) => (p5) => p5 * p5 * ((power + 1) * p5 - power);
  var createAnticipate = (power) => {
    const backEasing = createBackIn(power);
    return (p5) => (p5 *= 2) < 1 ? 0.5 * backEasing(p5) : 0.5 * (2 - Math.pow(2, -10 * (p5 - 1)));
  };

  // node_modules/popmotion/dist/es/easing/index.mjs
  var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
  var BOUNCE_FIRST_THRESHOLD = 4 / 11;
  var BOUNCE_SECOND_THRESHOLD = 8 / 11;
  var BOUNCE_THIRD_THRESHOLD = 9 / 10;
  var linear = (p5) => p5;
  var easeIn = createExpoIn(2);
  var easeOut = reverseEasing(easeIn);
  var easeInOut = mirrorEasing(easeIn);
  var circIn = (p5) => 1 - Math.sin(Math.acos(p5));
  var circOut = reverseEasing(circIn);
  var circInOut = mirrorEasing(circOut);
  var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
  var backOut = reverseEasing(backIn);
  var backInOut = mirrorEasing(backIn);
  var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
  var ca = 4356 / 361;
  var cb = 35442 / 1805;
  var cc = 16061 / 1805;
  var bounceOut = (p5) => {
    if (p5 === 1 || p5 === 0)
      return p5;
    const p22 = p5 * p5;
    return p5 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p5 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p5 + 3.4 : p5 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p5 + cc : 10.8 * p5 * p5 - 20.52 * p5 + 10.72;
  };
  var bounceIn = reverseEasing(bounceOut);
  var bounceInOut = (p5) => p5 < 0.5 ? 0.5 * (1 - bounceOut(1 - p5 * 2)) : 0.5 * bounceOut(p5 * 2 - 1) + 0.5;

  // node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function defaultOffset(values) {
    const numValues = values.length;
    return values.map((_value, i5) => i5 !== 0 ? i5 / (numValues - 1) : 0);
  }
  function convertOffsetToTimes(offset4, duration) {
    return offset4.map((o6) => o6 * duration);
  }
  function keyframes({ from = 0, to: to2 = 1, ease, offset: offset4, duration = 300 }) {
    const state = { done: false, value: from };
    const values = Array.isArray(to2) ? to2 : [from, to2];
    const times = convertOffsetToTimes(offset4 && offset4.length === values.length ? offset4 : defaultOffset(values), duration);
    function createInterpolator2() {
      return interpolate(times, values, {
        ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
      });
    }
    let interpolator = createInterpolator2();
    return {
      next: (t5) => {
        state.value = interpolator(t5);
        state.done = t5 >= duration;
        return state;
      },
      flipTarget: () => {
        values.reverse();
        interpolator = createInterpolator2();
      }
    };
  }

  // node_modules/popmotion/dist/es/animations/generators/decay.mjs
  function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
    const state = { done: false, value: from };
    let amplitude = power * velocity;
    const ideal = from + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - from;
    return {
      next: (t5) => {
        const delta = -amplitude * Math.exp(-t5 / timeConstant);
        state.done = !(delta > restDelta || delta < -restDelta);
        state.value = state.done ? target : target + delta;
        return state;
      },
      flipTarget: () => {
      }
    };
  }

  // node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
  var types = { keyframes, spring, decay };
  function detectAnimationFromOptions(config2) {
    if (Array.isArray(config2.to)) {
      return keyframes;
    } else if (types[config2.type]) {
      return types[config2.type];
    }
    const keys = new Set(Object.keys(config2));
    if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
      return keyframes;
    } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
      return spring;
    }
    return keyframes;
  }

  // node_modules/framesync/dist/es/on-next-frame.mjs
  var defaultTimestep = 1 / 60 * 1e3;
  var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
  var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

  // node_modules/framesync/dist/es/create-render-step.mjs
  function createRenderStep(runNextFrame2) {
    let toRun = [];
    let toRunNextFrame = [];
    let numToRun = 0;
    let isProcessing2 = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    const step = {
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing2;
        const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (buffer.indexOf(callback) === -1) {
          buffer.push(callback);
          if (addToCurrentFrame && isProcessing2)
            numToRun = toRun.length;
        }
        return callback;
      },
      cancel: (callback) => {
        const index2 = toRunNextFrame.indexOf(callback);
        if (index2 !== -1)
          toRunNextFrame.splice(index2, 1);
        toKeepAlive.delete(callback);
      },
      process: (frameData) => {
        if (isProcessing2) {
          flushNextFrame = true;
          return;
        }
        isProcessing2 = true;
        [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
        toRunNextFrame.length = 0;
        numToRun = toRun.length;
        if (numToRun) {
          for (let i5 = 0; i5 < numToRun; i5++) {
            const callback = toRun[i5];
            callback(frameData);
            if (toKeepAlive.has(callback)) {
              step.schedule(callback);
              runNextFrame2();
            }
          }
        }
        isProcessing2 = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData);
        }
      }
    };
    return step;
  }

  // node_modules/framesync/dist/es/index.mjs
  var maxElapsed = 40;
  var useDefaultElapsed = true;
  var runNextFrame = false;
  var isProcessing = false;
  var frame = {
    delta: 0,
    timestamp: 0
  };
  var stepsOrder = [
    "read",
    "update",
    "preRender",
    "render",
    "postRender"
  ];
  var steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(() => runNextFrame = true);
    return acc;
  }, {});
  var sync = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        startLoop();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  var cancelSync = stepsOrder.reduce((acc, key) => {
    acc[key] = steps[key].cancel;
    return acc;
  }, {});
  var flushSync2 = stepsOrder.reduce((acc, key) => {
    acc[key] = () => steps[key].process(frame);
    return acc;
  }, {});
  var processStep = (stepId) => steps[stepId].process(frame);
  var processFrame = (timestamp) => {
    runNextFrame = false;
    frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
    frame.timestamp = timestamp;
    isProcessing = true;
    stepsOrder.forEach(processStep);
    isProcessing = false;
    if (runNextFrame) {
      useDefaultElapsed = false;
      onNextFrame(processFrame);
    }
  };
  var startLoop = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!isProcessing)
      onNextFrame(processFrame);
  };
  var getFrameData = () => frame;
  var es_default = sync;

  // node_modules/popmotion/dist/es/animations/utils/elapsed.mjs
  function loopElapsed(elapsed, duration, delay = 0) {
    return elapsed - duration - delay;
  }
  function reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {
    return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
  }
  function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
  }

  // node_modules/popmotion/dist/es/animations/index.mjs
  var framesync = (update3) => {
    const passTimestamp = ({ delta }) => update3(delta);
    return {
      start: () => es_default.update(passTimestamp, true),
      stop: () => cancelSync.update(passTimestamp)
    };
  };
  function animate(_a) {
    var _b, _c;
    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
    let { to: to2 } = options;
    let driverControls;
    let repeatCount = 0;
    let computedDuration = options.duration;
    let latest;
    let isComplete = false;
    let isForwardPlayback = true;
    let interpolateFromNumber;
    const animator = detectAnimationFromOptions(options);
    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to2)) {
      interpolateFromNumber = interpolate([0, 100], [from, to2], {
        clamp: false
      });
      from = 0;
      to2 = 100;
    }
    const animation = animator(Object.assign(Object.assign({}, options), { from, to: to2 }));
    function repeat() {
      repeatCount++;
      if (repeatType === "reverse") {
        isForwardPlayback = repeatCount % 2 === 0;
        elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
      } else {
        elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
        if (repeatType === "mirror")
          animation.flipTarget();
      }
      isComplete = false;
      onRepeat && onRepeat();
    }
    function complete() {
      driverControls.stop();
      onComplete && onComplete();
    }
    function update3(delta) {
      if (!isForwardPlayback)
        delta = -delta;
      elapsed += delta;
      if (!isComplete) {
        const state = animation.next(Math.max(0, elapsed));
        latest = state.value;
        if (interpolateFromNumber)
          latest = interpolateFromNumber(latest);
        isComplete = isForwardPlayback ? state.done : elapsed <= 0;
      }
      onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
      if (isComplete) {
        if (repeatCount === 0)
          computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
        if (repeatCount < repeatMax) {
          hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
        } else {
          complete();
        }
      }
    }
    function play() {
      onPlay === null || onPlay === void 0 ? void 0 : onPlay();
      driverControls = driver(update3);
      driverControls.start();
    }
    autoplay && play();
    return {
      stop: () => {
        onStop === null || onStop === void 0 ? void 0 : onStop();
        driverControls.stop();
      }
    };
  }

  // node_modules/popmotion/dist/es/utils/velocity-per-second.mjs
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }

  // node_modules/popmotion/dist/es/animations/inertia.mjs
  function inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
    let currentAnimation;
    function isOutOfBounds(v5) {
      return min !== void 0 && v5 < min || max !== void 0 && v5 > max;
    }
    function boundaryNearest(v5) {
      if (min === void 0)
        return max;
      if (max === void 0)
        return min;
      return Math.abs(min - v5) < Math.abs(max - v5) ? min : max;
    }
    function startAnimation2(options) {
      currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
      currentAnimation = animate(Object.assign(Object.assign({}, options), {
        driver,
        onUpdate: (v5) => {
          var _a;
          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v5);
          (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v5);
        },
        onComplete,
        onStop
      }));
    }
    function startSpring(options) {
      startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
    }
    if (isOutOfBounds(from)) {
      startSpring({ from, velocity, to: boundaryNearest(from) });
    } else {
      let target = power * velocity + from;
      if (typeof modifyTarget !== "undefined")
        target = modifyTarget(target);
      const boundary = boundaryNearest(target);
      const heading = boundary === min ? -1 : 1;
      let prev;
      let current;
      const checkBoundary = (v5) => {
        prev = current;
        current = v5;
        velocity = velocityPerSecond(v5 - prev, getFrameData().delta);
        if (heading === 1 && v5 > boundary || heading === -1 && v5 < boundary) {
          startSpring({ from: v5, to: boundary, velocity });
        }
      };
      startAnimation2({
        type: "decay",
        from,
        velocity,
        timeConstant,
        power,
        restDelta,
        modifyTarget,
        onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
      });
    }
    return {
      stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
    };
  }

  // node_modules/popmotion/dist/es/utils/is-point.mjs
  var isPoint = (point) => point.hasOwnProperty("x") && point.hasOwnProperty("y");

  // node_modules/popmotion/dist/es/utils/is-point-3d.mjs
  var isPoint3D = (point) => isPoint(point) && point.hasOwnProperty("z");

  // node_modules/popmotion/dist/es/utils/distance.mjs
  var distance1D = (a6, b6) => Math.abs(a6 - b6);
  function distance(a6, b6) {
    if (isNum(a6) && isNum(b6)) {
      return distance1D(a6, b6);
    } else if (isPoint(a6) && isPoint(b6)) {
      const xDelta = distance1D(a6.x, b6.x);
      const yDelta = distance1D(a6.y, b6.y);
      const zDelta = isPoint3D(a6) && isPoint3D(b6) ? distance1D(a6.z, b6.z) : 0;
      return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
    }
  }

  // node_modules/popmotion/dist/es/easing/cubic-bezier.mjs
  var a4 = (a1, a22) => 1 - 3 * a22 + 3 * a1;
  var b4 = (a1, a22) => 3 * a22 - 6 * a1;
  var c4 = (a1) => 3 * a1;
  var calcBezier = (t5, a1, a22) => ((a4(a1, a22) * t5 + b4(a1, a22)) * t5 + c4(a1)) * t5;
  var getSlope = (t5, a1, a22) => 3 * a4(a1, a22) * t5 * t5 + 2 * b4(a1, a22) * t5 + c4(a1);
  var subdivisionPrecision = 1e-7;
  var subdivisionMaxIterations = 10;
  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    let currentX;
    let currentT;
    let i5 = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i5 < subdivisionMaxIterations);
    return currentT;
  }
  var newtonIterations = 8;
  var newtonMinSlope = 1e-3;
  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (let i5 = 0; i5 < newtonIterations; ++i5) {
      const currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0) {
        return aGuessT;
      }
      const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }
  var kSplineTableSize = 11;
  var kSampleStepSize = 1 / (kSplineTableSize - 1);
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return linear;
    const sampleValues = new Float32Array(kSplineTableSize);
    for (let i5 = 0; i5 < kSplineTableSize; ++i5) {
      sampleValues[i5] = calcBezier(i5 * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
      let intervalStart = 0;
      let currentSample = 1;
      const lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;
      const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      const guessForT = intervalStart + dist * kSampleStepSize;
      const initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= newtonMinSlope) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }
    return (t5) => t5 === 0 || t5 === 1 ? t5 : calcBezier(getTForX(t5), mY1, mY2);
  }

  // node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
  function useTapGesture(_a) {
    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement2 = _a.visualElement;
    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
    var isPressing = (0, import_react58.useRef)(false);
    var cancelPointerEndListeners = (0, import_react58.useRef)(null);
    var eventOptions = {
      passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
    };
    function removePointerEndListener() {
      var _a2;
      (_a2 = cancelPointerEndListeners.current) === null || _a2 === void 0 ? void 0 : _a2.call(cancelPointerEndListeners);
      cancelPointerEndListeners.current = null;
    }
    function checkPointerEnd() {
      var _a2;
      removePointerEndListener();
      isPressing.current = false;
      (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, false);
      return !isDragActive();
    }
    function onPointerUp(event, info) {
      if (!checkPointerEnd())
        return;
      !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
    }
    function onPointerCancel(event, info) {
      if (!checkPointerEnd())
        return;
      onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
    }
    function onPointerDown(event, info) {
      var _a2;
      removePointerEndListener();
      if (isPressing.current)
        return;
      isPressing.current = true;
      cancelPointerEndListeners.current = pipe2(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
      (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, true);
      onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
    }
    usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0, eventOptions);
    useUnmountEffect(removePointerEndListener);
  }

  // node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
  var import_react59 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/warn-once.mjs
  var warned = /* @__PURE__ */ new Set();
  function warnOnce(condition, message, element) {
    if (condition || warned.has(message))
      return;
    console.warn(message);
    if (element)
      console.warn(element);
    warned.add(message);
  }

  // node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
  var observerCallbacks = /* @__PURE__ */ new WeakMap();
  var observers = /* @__PURE__ */ new WeakMap();
  var fireObserverCallback = function(entry) {
    var _a;
    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);
  };
  var fireAllObserverCallbacks = function(entries) {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver(_a) {
    var root = _a.root, options = __rest(_a, ["root"]);
    var lookupRoot = root || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    var rootObservers = observers.get(lookupRoot);
    var key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root }, options));
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    var rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return function() {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }

  // node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
  function useViewport(_a) {
    var visualElement2 = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;
    var state = (0, import_react59.useRef)({
      hasEnteredView: false,
      isInView: false
    });
    var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
    if (viewport.once && state.current.hasEnteredView)
      shouldObserve = false;
    var useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver2;
    useObserver(shouldObserve, state.current, visualElement2, viewport);
  }
  var thresholdNames = {
    some: 0,
    all: 1
  };
  function useIntersectionObserver2(shouldObserve, state, visualElement2, _a) {
    var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? "some" : _b, once2 = _a.once;
    (0, import_react59.useEffect)(function() {
      if (!shouldObserve)
        return;
      var options = {
        root: root === null || root === void 0 ? void 0 : root.current,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      var intersectionCallback = function(entry) {
        var _a2;
        var isIntersecting = entry.isIntersecting;
        if (state.isInView === isIntersecting)
          return;
        state.isInView = isIntersecting;
        if (once2 && !isIntersecting && state.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          state.hasEnteredView = true;
        }
        (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.InView, isIntersecting);
        var props = visualElement2.getProps();
        var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
        callback === null || callback === void 0 ? void 0 : callback(entry);
      };
      return observeIntersection(visualElement2.getInstance(), options, intersectionCallback);
    }, [shouldObserve, root, rootMargin, amount]);
  }
  function useMissingIntersectionObserver(shouldObserve, state, visualElement2, _a) {
    var _b = _a.fallback, fallback = _b === void 0 ? true : _b;
    (0, import_react59.useEffect)(function() {
      if (!shouldObserve || !fallback)
        return;
      if (env !== "production") {
        warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
      }
      requestAnimationFrame(function() {
        var _a2;
        state.hasEnteredView = true;
        var onViewportEnter = visualElement2.getProps().onViewportEnter;
        onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);
        (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.InView, true);
      });
    }, [shouldObserve]);
  }

  // node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs
  var makeRenderlessComponent = function(hook) {
    return function(props) {
      hook(props);
      return null;
    };
  };

  // node_modules/framer-motion/dist/es/motion/features/gestures.mjs
  var gestureAnimations = {
    inView: makeRenderlessComponent(useViewport),
    tap: makeRenderlessComponent(useTapGesture),
    focus: makeRenderlessComponent(useFocusGesture),
    hover: makeRenderlessComponent(useHoverGesture)
  };

  // node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var import_react61 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  var import_react60 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/utils/use-id.mjs
  var counter = 0;
  var incrementId = function() {
    return counter++;
  };
  var useId = function() {
    return useConstant(incrementId);
  };

  // node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  function usePresence() {
    var context2 = (0, import_react60.useContext)(PresenceContext);
    if (context2 === null)
      return [true, null];
    var isPresent = context2.isPresent, onExitComplete = context2.onExitComplete, register2 = context2.register;
    var id2 = useId();
    (0, import_react60.useEffect)(function() {
      return register2(id2);
    }, []);
    var safeToRemove = function() {
      return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id2);
    };
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }

  // node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
  function shallowCompare(next2, prev) {
    if (!Array.isArray(prev))
      return false;
    var prevLength = prev.length;
    if (prevLength !== next2.length)
      return false;
    for (var i5 = 0; i5 < prevLength; i5++) {
      if (prev[i5] !== next2[i5])
        return false;
    }
    return true;
  }

  // node_modules/framer-motion/dist/es/utils/time-conversion.mjs
  var secondsToMilliseconds = function(seconds) {
    return seconds * 1e3;
  };

  // node_modules/framer-motion/dist/es/animation/utils/easing.mjs
  var easingLookup = {
    linear,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate,
    bounceIn,
    bounceInOut,
    bounceOut
  };
  var easingDefinitionToFunction = function(definition) {
    if (Array.isArray(definition)) {
      invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
      var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x22 = _a[2], y22 = _a[3];
      return cubicBezier(x1, y1, x22, y22);
    } else if (typeof definition === "string") {
      invariant(easingLookup[definition] !== void 0, "Invalid easing type '".concat(definition, "'"));
      return easingLookup[definition];
    }
    return definition;
  };
  var isEasingArray = function(ease) {
    return Array.isArray(ease) && typeof ease[0] !== "number";
  };

  // node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
  var isAnimatable = function(key, value) {
    if (key === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && complex.test(value) && !value.startsWith("url(")) {
      return true;
    }
    return false;
  };

  // node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
  var underDampedSpring = function() {
    return {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
  };
  var criticallyDampedSpring = function(to2) {
    return {
      type: "spring",
      stiffness: 550,
      damping: to2 === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    };
  };
  var linearTween = function() {
    return {
      type: "keyframes",
      ease: "linear",
      duration: 0.3
    };
  };
  var keyframes2 = function(values) {
    return {
      type: "keyframes",
      duration: 0.8,
      values
    };
  };
  var defaultTransitions = {
    x: underDampedSpring,
    y: underDampedSpring,
    z: underDampedSpring,
    rotate: underDampedSpring,
    rotateX: underDampedSpring,
    rotateY: underDampedSpring,
    rotateZ: underDampedSpring,
    scaleX: criticallyDampedSpring,
    scaleY: criticallyDampedSpring,
    scale: criticallyDampedSpring,
    opacity: linearTween,
    backgroundColor: linearTween,
    color: linearTween,
    default: criticallyDampedSpring
  };
  var getDefaultTransition = function(valueKey, to2) {
    var transitionFactory;
    if (isKeyframesTarget(to2)) {
      transitionFactory = keyframes2;
    } else {
      transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
    }
    return __assign({ to: to2 }, transitionFactory(to2));
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
  var defaultValueTypes = __assign(__assign({}, numberValueTypes), {
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter: filter3,
    WebkitFilter: filter3
  });
  var getDefaultValueType = function(key) {
    return defaultValueTypes[key];
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
  function getAnimatableNone2(key, value) {
    var _a;
    var defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter3)
      defaultValueType = complex;
    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
  }

  // node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
  var instantAnimationState = {
    current: false
  };

  // node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
  function isTransitionDefined(_a) {
    _a.when;
    _a.delay;
    _a.delayChildren;
    _a.staggerChildren;
    _a.staggerDirection;
    _a.repeat;
    _a.repeatType;
    _a.repeatDelay;
    _a.from;
    var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
    return !!Object.keys(transition).length;
  }
  var legacyRepeatWarning = false;
  function convertTransitionToAnimationOptions(_a) {
    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop2 = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);
    var options = __assign({}, transition);
    if (times)
      options["offset"] = times;
    if (transition.duration)
      options["duration"] = secondsToMilliseconds(transition.duration);
    if (transition.repeatDelay)
      options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
    if (ease) {
      options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
    }
    if (transition.type === "tween")
      options.type = "keyframes";
    if (yoyo || loop2 || flip) {
      warning3(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
      legacyRepeatWarning = true;
      if (yoyo) {
        options.repeatType = "reverse";
      } else if (loop2) {
        options.repeatType = "loop";
      } else if (flip) {
        options.repeatType = "mirror";
      }
      options.repeat = loop2 || yoyo || flip || transition.repeat;
    }
    if (transition.type !== "spring")
      options.type = "keyframes";
    return options;
  }
  function getDelayFromTransition(transition, key) {
    var _a, _b;
    var valueTransition = getValueTransition(transition, key) || {};
    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;
  }
  function hydrateKeyframes(options) {
    if (Array.isArray(options.to) && options.to[0] === null) {
      options.to = __spreadArray([], __read(options.to), false);
      options.to[0] = options.from;
    }
    return options;
  }
  function getPopmotionAnimationOptions(transition, options, key) {
    var _a;
    if (Array.isArray(options.to)) {
      (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
    }
    hydrateKeyframes(options);
    if (!isTransitionDefined(transition)) {
      transition = __assign(__assign({}, transition), getDefaultTransition(key, options.to));
    }
    return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition));
  }
  function getAnimation(key, value, target, transition, onComplete) {
    var _a;
    var valueTransition = getValueTransition(transition, key);
    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
    var isTargetAnimatable = isAnimatable(key, target);
    if (origin === "none" && isTargetAnimatable && typeof target === "string") {
      origin = getAnimatableNone2(key, target);
    } else if (isZero(origin) && typeof target === "string") {
      origin = getZeroUnit(target);
    } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
      target = getZeroUnit(origin);
    }
    var isOriginAnimatable = isAnimatable(key, origin);
    warning3(isOriginAnimatable === isTargetAnimatable, "You are trying to animate ".concat(key, ' from "').concat(origin, '" to "').concat(target, '". ').concat(origin, " is not an animatable value - to enable this animation set ").concat(origin, " to a value animatable to ").concat(target, " via the `style` property."));
    function start2() {
      var options = {
        from: origin,
        to: target,
        velocity: value.getVelocity(),
        onComplete,
        onUpdate: function(v5) {
          return value.set(v5);
        }
      };
      return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign(__assign({}, options), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v5) {
        var _a2;
        options.onUpdate(v5);
        (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v5);
      }, onComplete: function() {
        var _a2;
        options.onComplete();
        (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
      } }));
    }
    function set() {
      var _a2, _b;
      var finalTarget = resolveFinalValueInKeyframes(target);
      value.set(finalTarget);
      onComplete();
      (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, finalTarget);
      (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);
      return { stop: function() {
      } };
    }
    return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start2;
  }
  function isZero(value) {
    return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
  }
  function getZeroUnit(potentialUnitType) {
    return typeof potentialUnitType === "number" ? 0 : getAnimatableNone2("", potentialUnitType);
  }
  function getValueTransition(transition, key) {
    return transition[key] || transition["default"] || transition;
  }
  function startAnimation(key, value, target, transition) {
    if (transition === void 0) {
      transition = {};
    }
    if (instantAnimationState.current) {
      transition = { type: false };
    }
    return value.start(function(onComplete) {
      var delayTimer;
      var controls;
      var animation = getAnimation(key, value, target, transition, onComplete);
      var delay = getDelayFromTransition(transition, key);
      var start2 = function() {
        return controls = animation();
      };
      if (delay) {
        delayTimer = window.setTimeout(start2, secondsToMilliseconds(delay));
      } else {
        start2();
      }
      return function() {
        clearTimeout(delayTimer);
        controls === null || controls === void 0 ? void 0 : controls.stop();
      };
    });
  }

  // node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
  var isNumericalString = function(v5) {
    return /^\-?\d*\.?\d+$/.test(v5);
  };

  // node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
  var isZeroValueString = function(v5) {
    return /^0[^.\s]+$/.test(v5);
  };

  // node_modules/framer-motion/dist/es/utils/array.mjs
  function addUniqueItem(arr, item2) {
    arr.indexOf(item2) === -1 && arr.push(item2);
  }
  function removeItem(arr, item2) {
    var index2 = arr.indexOf(item2);
    index2 > -1 && arr.splice(index2, 1);
  }

  // node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
  var SubscriptionManager = function() {
    function SubscriptionManager2() {
      this.subscriptions = [];
    }
    SubscriptionManager2.prototype.add = function(handler) {
      var _this = this;
      addUniqueItem(this.subscriptions, handler);
      return function() {
        return removeItem(_this.subscriptions, handler);
      };
    };
    SubscriptionManager2.prototype.notify = function(a6, b6, c6) {
      var numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a6, b6, c6);
      } else {
        for (var i5 = 0; i5 < numSubscriptions; i5++) {
          var handler = this.subscriptions[i5];
          handler && handler(a6, b6, c6);
        }
      }
    };
    SubscriptionManager2.prototype.getSize = function() {
      return this.subscriptions.length;
    };
    SubscriptionManager2.prototype.clear = function() {
      this.subscriptions.length = 0;
    };
    return SubscriptionManager2;
  }();

  // node_modules/framer-motion/dist/es/value/index.mjs
  var isFloat = function(value) {
    return !isNaN(parseFloat(value));
  };
  var MotionValue = function() {
    function MotionValue2(init) {
      var _this = this;
      this.version = "6.5.1";
      this.timeDelta = 0;
      this.lastUpdated = 0;
      this.updateSubscribers = new SubscriptionManager();
      this.velocityUpdateSubscribers = new SubscriptionManager();
      this.renderSubscribers = new SubscriptionManager();
      this.canTrackVelocity = false;
      this.updateAndNotify = function(v5, render2) {
        if (render2 === void 0) {
          render2 = true;
        }
        _this.prev = _this.current;
        _this.current = v5;
        var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;
        if (_this.lastUpdated !== timestamp) {
          _this.timeDelta = delta;
          _this.lastUpdated = timestamp;
          es_default.postRender(_this.scheduleVelocityCheck);
        }
        if (_this.prev !== _this.current) {
          _this.updateSubscribers.notify(_this.current);
        }
        if (_this.velocityUpdateSubscribers.getSize()) {
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
        if (render2) {
          _this.renderSubscribers.notify(_this.current);
        }
      };
      this.scheduleVelocityCheck = function() {
        return es_default.postRender(_this.velocityCheck);
      };
      this.velocityCheck = function(_a) {
        var timestamp = _a.timestamp;
        if (timestamp !== _this.lastUpdated) {
          _this.prev = _this.current;
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
      };
      this.hasAnimated = false;
      this.prev = this.current = init;
      this.canTrackVelocity = isFloat(this.current);
    }
    MotionValue2.prototype.onChange = function(subscription) {
      return this.updateSubscribers.add(subscription);
    };
    MotionValue2.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
    };
    MotionValue2.prototype.onRenderRequest = function(subscription) {
      subscription(this.get());
      return this.renderSubscribers.add(subscription);
    };
    MotionValue2.prototype.attach = function(passiveEffect) {
      this.passiveEffect = passiveEffect;
    };
    MotionValue2.prototype.set = function(v5, render2) {
      if (render2 === void 0) {
        render2 = true;
      }
      if (!render2 || !this.passiveEffect) {
        this.updateAndNotify(v5, render2);
      } else {
        this.passiveEffect(v5, this.updateAndNotify);
      }
    };
    MotionValue2.prototype.get = function() {
      return this.current;
    };
    MotionValue2.prototype.getPrevious = function() {
      return this.prev;
    };
    MotionValue2.prototype.getVelocity = function() {
      return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
    };
    MotionValue2.prototype.start = function(animation) {
      var _this = this;
      this.stop();
      return new Promise(function(resolve) {
        _this.hasAnimated = true;
        _this.stopAnimation = animation(resolve);
      }).then(function() {
        return _this.clearAnimation();
      });
    };
    MotionValue2.prototype.stop = function() {
      if (this.stopAnimation)
        this.stopAnimation();
      this.clearAnimation();
    };
    MotionValue2.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    };
    MotionValue2.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    };
    MotionValue2.prototype.destroy = function() {
      this.updateSubscribers.clear();
      this.renderSubscribers.clear();
      this.stop();
    };
    return MotionValue2;
  }();
  function motionValue(init) {
    return new MotionValue(init);
  }

  // node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
  var testValueType = function(v5) {
    return function(type) {
      return type.test(v5);
    };
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
  var auto = {
    test: function(v5) {
      return v5 === "auto";
    },
    parse: function(v5) {
      return v5;
    }
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
  var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  var findDimensionValueType = function(v5) {
    return dimensionValueTypes.find(testValueType(v5));
  };

  // node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
  var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes), false), [color, complex], false);
  var findValueType = function(v5) {
    return valueTypes.find(testValueType(v5));
  };

  // node_modules/framer-motion/dist/es/render/utils/setters.mjs
  function setMotionValue(visualElement2, key, value) {
    if (visualElement2.hasValue(key)) {
      visualElement2.getValue(key).set(value);
    } else {
      visualElement2.addValue(key, motionValue(value));
    }
  }
  function setTarget(visualElement2, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
    _a.transition;
    var target = __rest(_a, ["transitionEnd", "transition"]);
    target = __assign(__assign({}, target), transitionEnd);
    for (var key in target) {
      var value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement2, key, value);
    }
  }
  function checkTargetForNewValues(visualElement2, target, origin) {
    var _a, _b, _c;
    var _d;
    var newValueKeys = Object.keys(target).filter(function(key2) {
      return !visualElement2.hasValue(key2);
    });
    var numNewValues = newValueKeys.length;
    if (!numNewValues)
      return;
    for (var i5 = 0; i5 < numNewValues; i5++) {
      var key = newValueKeys[i5];
      var targetValue = target[key];
      var value = null;
      if (Array.isArray(targetValue)) {
        value = targetValue[0];
      }
      if (value === null) {
        value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
      }
      if (value === void 0 || value === null)
        continue;
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(targetValue)) {
        value = getAnimatableNone2(key, targetValue);
      }
      visualElement2.addValue(key, motionValue(value));
      (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
      visualElement2.setBaseTarget(key, value);
    }
  }
  function getOriginFromTransition(key, transition) {
    if (!transition)
      return;
    var valueTransition = transition[key] || transition["default"] || transition;
    return valueTransition.from;
  }
  function getOrigin(target, transition, visualElement2) {
    var _a, _b;
    var origin = {};
    for (var key in target) {
      origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
    }
    return origin;
  }

  // node_modules/framer-motion/dist/es/render/utils/animation.mjs
  function animateVisualElement(visualElement2, definition, options) {
    if (options === void 0) {
      options = {};
    }
    visualElement2.notifyAnimationStart(definition);
    var animation;
    if (Array.isArray(definition)) {
      var animations2 = definition.map(function(variant) {
        return animateVariant(visualElement2, variant, options);
      });
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement2, definition, options);
    } else {
      var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
      animation = animateTarget(visualElement2, resolvedDefinition, options);
    }
    return animation.then(function() {
      return visualElement2.notifyAnimationComplete(definition);
    });
  }
  function animateVariant(visualElement2, variant, options) {
    var _a;
    if (options === void 0) {
      options = {};
    }
    var resolved = resolveVariant(visualElement2, variant, options.custom);
    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    var getAnimation2 = resolved ? function() {
      return animateTarget(visualElement2, resolved, options);
    } : function() {
      return Promise.resolve();
    };
    var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
      if (forwardDelay === void 0) {
        forwardDelay = 0;
      }
      var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
      return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
    } : function() {
      return Promise.resolve();
    };
    var when = transition.when;
    if (when) {
      var _c = __read(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last = _c[1];
      return first().then(last);
    } else {
      return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
    }
  }
  function animateTarget(visualElement2, definition, _a) {
    var _b;
    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
    var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);
    if (transitionOverride)
      transition = transitionOverride;
    var animations2 = [];
    var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
    for (var key in target) {
      var value = visualElement2.getValue(key);
      var valueTarget = target[key];
      if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      var valueTransition = __assign({ delay }, transition);
      if (visualElement2.shouldReduceMotion && isTransformProp(key)) {
        valueTransition = __assign(__assign({}, valueTransition), { type: false, delay: 0 });
      }
      var animation = startAnimation(key, value, valueTarget, valueTransition);
      animations2.push(animation);
    }
    return Promise.all(animations2).then(function() {
      transitionEnd && setTarget(visualElement2, transitionEnd);
    });
  }
  function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
    if (delayChildren === void 0) {
      delayChildren = 0;
    }
    if (staggerChildren === void 0) {
      staggerChildren = 0;
    }
    if (staggerDirection === void 0) {
      staggerDirection = 1;
    }
    var animations2 = [];
    var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
    var generateStaggerDuration = staggerDirection === 1 ? function(i5) {
      if (i5 === void 0) {
        i5 = 0;
      }
      return i5 * staggerChildren;
    } : function(i5) {
      if (i5 === void 0) {
        i5 = 0;
      }
      return maxStaggerDuration - i5 * staggerChildren;
    };
    Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i5) {
      animations2.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i5) })).then(function() {
        return child.notifyAnimationComplete(variant);
      }));
    });
    return Promise.all(animations2);
  }
  function sortByTreeOrder(a6, b6) {
    return a6.sortNodePosition(b6);
  }
  function shouldBlockAnimation(_a, key) {
    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }

  // node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
  var variantPriorityOrder = [
    AnimationType.Animate,
    AnimationType.InView,
    AnimationType.Focus,
    AnimationType.Hover,
    AnimationType.Tap,
    AnimationType.Drag,
    AnimationType.Exit
  ];
  var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder), false).reverse();
  var numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement2) {
    return function(animations2) {
      return Promise.all(animations2.map(function(_a) {
        var animation = _a.animation, options = _a.options;
        return animateVisualElement(visualElement2, animation, options);
      }));
    };
  }
  function createAnimationState(visualElement2) {
    var animate3 = animateList(visualElement2);
    var state = createState();
    var allAnimatedKeys = {};
    var isInitialRender = true;
    var buildResolvedTypeValues = function(acc, definition) {
      var resolved = resolveVariant(visualElement2, definition);
      if (resolved) {
        resolved.transition;
        var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
        acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
      }
      return acc;
    };
    function isAnimated2(key) {
      return allAnimatedKeys[key] !== void 0;
    }
    function setAnimateFunction(makeAnimator) {
      animate3 = makeAnimator(visualElement2);
    }
    function animateChanges(options, changedActiveType) {
      var _a;
      var props = visualElement2.getProps();
      var context2 = visualElement2.getVariantContext(true) || {};
      var animations2 = [];
      var removedKeys = /* @__PURE__ */ new Set();
      var encounteredKeys = {};
      var removedVariantIndex = Infinity;
      var _loop_1 = function(i6) {
        var type = reversePriorityOrder[i6];
        var typeState = state[type];
        var prop2 = (_a = props[type]) !== null && _a !== void 0 ? _a : context2[type];
        var propIsVariant = isVariantLabel(prop2);
        var activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i6;
        var isInherited = prop2 === context2[type] && prop2 !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = __assign({}, encounteredKeys);
        if (!typeState.isActive && activeDelta === null || !prop2 && !typeState.prevProp || isAnimationControls(prop2) || typeof prop2 === "boolean") {
          return "continue";
        }
        var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop2);
        var shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i6 > removedVariantIndex && propIsVariant;
        var definitionList = Array.isArray(prop2) ? prop2 : [prop2];
        var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
        if (activeDelta === false)
          resolvedValues = {};
        var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
        var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);
        var markToAnimate = function(key2) {
          shouldAnimateType = true;
          removedKeys.delete(key2);
          typeState.needsAnimating[key2] = true;
        };
        for (var key in allKeys) {
          var next2 = resolvedValues[key];
          var prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          if (next2 !== prev) {
            if (isKeyframesTarget(next2) && isKeyframesTarget(prev)) {
              if (!shallowCompare(next2, prev) || variantDidChange) {
                markToAnimate(key);
              } else {
                typeState.protectedKeys[key] = true;
              }
            } else if (next2 !== void 0) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next2 !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop2;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
        }
        if (isInitialRender && visualElement2.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        if (shouldAnimateType && !isInherited) {
          animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
            return {
              animation,
              options: __assign({ type }, options)
            };
          })), false));
        }
      };
      for (var i5 = 0; i5 < numAnimationTypes; i5++) {
        _loop_1(i5);
      }
      allAnimatedKeys = __assign({}, encounteredKeys);
      if (removedKeys.size) {
        var fallbackAnimation_1 = {};
        removedKeys.forEach(function(key) {
          var fallbackTarget = visualElement2.getBaseTarget(key);
          if (fallbackTarget !== void 0) {
            fallbackAnimation_1[key] = fallbackTarget;
          }
        });
        animations2.push({ animation: fallbackAnimation_1 });
      }
      var shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate3(animations2) : Promise.resolve();
    }
    function setActive(type, isActive, options) {
      var _a;
      if (state[type].isActive === isActive)
        return Promise.resolve();
      (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
        var _a2;
        return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
      });
      state[type].isActive = isActive;
      var animations2 = animateChanges(options, type);
      for (var key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      isAnimated: isAnimated2,
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: function() {
        return state;
      }
    };
  }
  function checkVariantsDidChange(prev, next2) {
    if (typeof next2 === "string") {
      return next2 !== prev;
    } else if (isVariantLabels(next2)) {
      return !shallowCompare(next2, prev);
    }
    return false;
  }
  function createTypeState(isActive) {
    if (isActive === void 0) {
      isActive = false;
    }
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    var _a;
    return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.InView] = createTypeState(), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;
  }

  // node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var animations = {
    animation: makeRenderlessComponent(function(_a) {
      var visualElement2 = _a.visualElement, animate3 = _a.animate;
      visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
      if (isAnimationControls(animate3)) {
        (0, import_react61.useEffect)(function() {
          return animate3.subscribe(visualElement2);
        }, [animate3]);
      }
    }),
    exit: makeRenderlessComponent(function(props) {
      var custom = props.custom, visualElement2 = props.visualElement;
      var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];
      var presenceContext = (0, import_react61.useContext)(PresenceContext);
      (0, import_react61.useEffect)(function() {
        var _a2, _b;
        visualElement2.isPresent = isPresent;
        var animation = (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });
        !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));
      }, [isPresent]);
    })
  };

  // node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
  var import_react62 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/gestures/PanSession.mjs
  var PanSession = function() {
    function PanSession2(event, handlers, _a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.updatePoint = function() {
        if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
          return;
        var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
        var isPanStarted = _this.startEvent !== null;
        var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        var point2 = info2.point;
        var timestamp2 = getFrameData().timestamp;
        _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));
        var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;
        if (!isPanStarted) {
          onStart && onStart(_this.lastMoveEvent, info2);
          _this.startEvent = _this.lastMoveEvent;
        }
        onMove && onMove(_this.lastMoveEvent, info2);
      };
      this.handlePointerMove = function(event2, info2) {
        _this.lastMoveEvent = event2;
        _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
        if (isMouseEvent(event2) && event2.buttons === 0) {
          _this.handlePointerUp(event2, info2);
          return;
        }
        es_default.update(_this.updatePoint, true);
      };
      this.handlePointerUp = function(event2, info2) {
        _this.end();
        var _a2 = _this.handlers, onEnd = _a2.onEnd, onSessionEnd = _a2.onSessionEnd;
        var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
        if (_this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (isTouchEvent(event) && event.touches.length > 1)
        return;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      var info = extractEventInfo(event);
      var initialInfo = transformPoint(info, this.transformPagePoint);
      var point = initialInfo.point;
      var timestamp = getFrameData().timestamp;
      this.history = [__assign(__assign({}, point), { timestamp })];
      var onSessionStart = handlers.onSessionStart;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe2(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
    }
    PanSession2.prototype.updateHandlers = function(handlers) {
      this.handlers = handlers;
    };
    PanSession2.prototype.end = function() {
      this.removeListeners && this.removeListeners();
      cancelSync.update(this.updatePoint);
    };
    return PanSession2;
  }();
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a6, b6) {
    return { x: a6.x - b6.x, y: a6.y - b6.y };
  }
  function getPanInfo(_a, history) {
    var point = _a.point;
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history)),
      offset: subtractPoint(point, startDevicePoint(history)),
      velocity: getVelocity2(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity2(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    var i5 = history.length - 1;
    var timestampedPoint = null;
    var lastPoint = lastDevicePoint(history);
    while (i5 >= 0) {
      timestampedPoint = history[i5];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i5--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
    if (time === 0) {
      return { x: 0, y: 0 };
    }
    var currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time,
      y: (lastPoint.y - timestampedPoint.y) / time
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    if (target === void 0) {
      target = 0;
    }
    if (maxDistance === void 0) {
      maxDistance = 0.01;
    }
    return distance(value, target) < maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin) {
    if (origin === void 0) {
      origin = 0.5;
    }
    delta.origin = origin;
    delta.originPoint = mix(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
      delta.scale = 1;
    delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
    if (isNear(delta.translate) || isNaN(delta.translate))
      delta.translate = 0;
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
    calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout, parent) {
    target.min = layout.min - parent.min;
    target.max = target.min + calcLength(layout);
  }
  function calcRelativePosition(target, layout, parent) {
    calcRelativeAxisPosition(target.x, layout.x, parent.x);
    calcRelativeAxisPosition(target.y, layout.y, parent.y);
  }

  // node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
  function applyConstraints(point, _a, elastic) {
    var min = _a.min, max = _a.max;
    if (min !== void 0 && point < min) {
      point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
    } else if (max !== void 0 && point > max) {
      point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
    }
    return point;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== void 0 ? axis.min + min : void 0,
      max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, _a) {
    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    var _a;
    var min = constraintsAxis.min - layoutAxis.min;
    var max = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      _a = __read([max, min], 2), min = _a[0], max = _a[1];
    }
    return { min, max };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin2(source, target) {
    var origin = 0.5;
    var sourceLength = calcLength(source);
    var targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp2(0, 1, origin);
  }
  function rebaseAxisConstraints(layout, constraints) {
    var relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout.min;
    }
    return relativeConstraints;
  }
  var defaultElastic = 0.35;
  function resolveDragElastic(dragElastic) {
    if (dragElastic === void 0) {
      dragElastic = defaultElastic;
    }
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    var _a;
    return typeof dragElastic === "number" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;
  }

  // node_modules/framer-motion/dist/es/projection/geometry/models.mjs
  var createAxisDelta = function() {
    return {
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    };
  };
  var createDelta = function() {
    return {
      x: createAxisDelta(),
      y: createAxisDelta()
    };
  };
  var createAxis = function() {
    return { min: 0, max: 0 };
  };
  var createBox = function() {
    return {
      x: createAxis(),
      y: createAxis()
    };
  };

  // node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }

  // node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
  function convertBoundingBoxToBox(_a) {
    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox(_a) {
    var x4 = _a.x, y5 = _a.y;
    return { top: y5.min, right: x4.max, bottom: y5.max, left: x4.min };
  }
  function transformBoxPoints(point, transformPoint2) {
    if (!transformPoint2)
      return point;
    var topLeft = transformPoint2({ x: point.left, y: point.top });
    var bottomRight = transformPoint2({ x: point.right, y: point.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }

  // node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale(_a) {
    var scale2 = _a.scale, scaleX = _a.scaleX, scaleY = _a.scaleY;
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
  }
  function hasTransform(values) {
    return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;
  }
  function hasTranslate(value) {
    return value && value !== "0%";
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
  function scalePoint(point, scale2, originPoint) {
    var distanceFromOrigin = point - originPoint;
    var scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
    if (translate === void 0) {
      translate = 0;
    }
    if (scale2 === void 0) {
      scale2 = 1;
    }
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, _a) {
    var x4 = _a.x, y5 = _a.y;
    applyAxisDelta(box.x, x4.translate, x4.scale, x4.originPoint);
    applyAxisDelta(box.y, y5.translate, y5.scale, y5.originPoint);
  }
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {
    var _a, _b;
    if (isSharedTransition === void 0) {
      isSharedTransition = false;
    }
    var treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    var node;
    var delta;
    for (var i5 = 0; i5 < treeLength; i5++) {
      node = treePath[i5];
      delta = node.projectionDelta;
      if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
        continue;
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, transforms, _a) {
    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
    var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
    var originPoint = mix(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
  }
  var xKeys = ["x", "scaleX", "originX"];
  var yKeys = ["y", "scaleY", "originY"];
  function transformBox(box, transform) {
    transformAxis(box.x, transform, xKeys);
    transformAxis(box.y, transform, yKeys);
  }

  // node_modules/framer-motion/dist/es/projection/utils/measure.mjs
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    var viewportBox = measureViewportBox(element, transformPagePoint);
    var scroll = rootProjectionNode2.scroll;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.x);
      translateAxis(viewportBox.y, scroll.y);
    }
    return viewportBox;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
  var elementDragControls = /* @__PURE__ */ new WeakMap();
  var VisualElementDragControls = function() {
    function VisualElementDragControls2(visualElement2) {
      this.openGlobalLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement2;
    }
    VisualElementDragControls2.prototype.start = function(originEvent, _a) {
      var _this = this;
      var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;
      if (this.visualElement.isPresent === false)
        return;
      var onSessionStart = function(event) {
        _this.stopAnimation();
        if (snapToCursor) {
          _this.snapToCursor(extractEventInfo(event, "page").point);
        }
      };
      var onStart = function(event, info) {
        var _a2;
        var _b2 = _this.getProps(), drag2 = _b2.drag, dragPropagation = _b2.dragPropagation, onDragStart = _b2.onDragStart;
        if (drag2 && !dragPropagation) {
          if (_this.openGlobalLock)
            _this.openGlobalLock();
          _this.openGlobalLock = getGlobalLock(drag2);
          if (!_this.openGlobalLock)
            return;
        }
        _this.isDragging = true;
        _this.currentDirection = null;
        _this.resolveConstraints();
        if (_this.visualElement.projection) {
          _this.visualElement.projection.isAnimationBlocked = true;
          _this.visualElement.projection.target = void 0;
        }
        eachAxis(function(axis) {
          var _a3, _b3;
          var current = _this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            var measuredAxis = (_b3 = (_a3 = _this.visualElement.projection) === null || _a3 === void 0 ? void 0 : _a3.layout) === null || _b3 === void 0 ? void 0 : _b3.actual[axis];
            if (measuredAxis) {
              var length_1 = calcLength(measuredAxis);
              current = length_1 * (parseFloat(current) / 100);
            }
          }
          _this.originPoint[axis] = current;
        });
        onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
        (_a2 = _this.visualElement.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Drag, true);
      };
      var onMove = function(event, info) {
        var _a2 = _this.getProps(), dragPropagation = _a2.dragPropagation, dragDirectionLock = _a2.dragDirectionLock, onDirectionLock = _a2.onDirectionLock, onDrag = _a2.onDrag;
        if (!dragPropagation && !_this.openGlobalLock)
          return;
        var offset4 = info.offset;
        if (dragDirectionLock && _this.currentDirection === null) {
          _this.currentDirection = getCurrentDirection(offset4);
          if (_this.currentDirection !== null) {
            onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);
          }
          return;
        }
        _this.updateAxis("x", info.point, offset4);
        _this.updateAxis("y", info.point, offset4);
        _this.visualElement.syncRender();
        onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
      };
      var onSessionEnd = function(event, info) {
        return _this.stop(event, info);
      };
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd
      }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
    };
    VisualElementDragControls2.prototype.stop = function(event, info) {
      var isDragging = this.isDragging;
      this.cancel();
      if (!isDragging)
        return;
      var velocity = info.velocity;
      this.startAnimation(velocity);
      var onDragEnd = this.getProps().onDragEnd;
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
    };
    VisualElementDragControls2.prototype.cancel = function() {
      var _a, _b;
      this.isDragging = false;
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = false;
      }
      (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
      this.panSession = void 0;
      var dragPropagation = this.getProps().dragPropagation;
      if (!dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
    };
    VisualElementDragControls2.prototype.updateAxis = function(axis, _point, offset4) {
      var drag2 = this.getProps().drag;
      if (!offset4 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      var axisValue = this.getAxisMotionValue(axis);
      var next2 = this.originPoint[axis] + offset4[axis];
      if (this.constraints && this.constraints[axis]) {
        next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next2);
    };
    VisualElementDragControls2.prototype.resolveConstraints = function() {
      var _this = this;
      var _a = this.getProps(), dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;
      var layout = (this.visualElement.projection || {}).layout;
      var prevConstraints = this.constraints;
      if (dragConstraints && isRefObject2(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout) {
          this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
        eachAxis(function(axis) {
          if (_this.getAxisMotionValue(axis)) {
            _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);
          }
        });
      }
    };
    VisualElementDragControls2.prototype.resolveRefConstraints = function() {
      var _a = this.getProps(), constraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints;
      if (!constraints || !isRefObject2(constraints))
        return false;
      var constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      var projection = this.visualElement.projection;
      if (!projection || !projection.layout)
        return false;
      var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
      if (onMeasureDragConstraints) {
        var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    };
    VisualElementDragControls2.prototype.startAnimation = function(velocity) {
      var _this = this;
      var _a = this.getProps(), drag2 = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, dragSnapToOrigin = _a.dragSnapToOrigin, onDragTransitionEnd = _a.onDragTransitionEnd;
      var constraints = this.constraints || {};
      var momentumAnimations = eachAxis(function(axis) {
        var _a2;
        if (!shouldDrag(axis, drag2, _this.currentDirection)) {
          return;
        }
        var transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        var bounceStiffness = dragElastic ? 200 : 1e6;
        var bounceDamping = dragElastic ? 40 : 1e7;
        var inertia2 = __assign(__assign({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness, bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);
        return _this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    };
    VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {
      var axisValue = this.getAxisMotionValue(axis);
      return startAnimation(axis, axisValue, 0, transition);
    };
    VisualElementDragControls2.prototype.stopAnimation = function() {
      var _this = this;
      eachAxis(function(axis) {
        return _this.getAxisMotionValue(axis).stop();
      });
    };
    VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
      var _a, _b;
      var dragKey = "_drag" + axis.toUpperCase();
      var externalMotionValue = this.visualElement.getProps()[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);
    };
    VisualElementDragControls2.prototype.snapToCursor = function(point) {
      var _this = this;
      eachAxis(function(axis) {
        var drag2 = _this.getProps().drag;
        if (!shouldDrag(axis, drag2, _this.currentDirection))
          return;
        var projection = _this.visualElement.projection;
        var axisValue = _this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          var _a = projection.layout.actual[axis], min = _a.min, max = _a.max;
          axisValue.set(point[axis] - mix(min, max, 0.5));
        }
      });
    };
    VisualElementDragControls2.prototype.scalePositionWithinConstraints = function() {
      var _this = this;
      var _a;
      var _b = this.getProps(), drag2 = _b.drag, dragConstraints = _b.dragConstraints;
      var projection = this.visualElement.projection;
      if (!isRefObject2(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      var boxProgress = { x: 0, y: 0 };
      eachAxis(function(axis) {
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          var latest = axisValue.get();
          boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, _this.constraints[axis]);
        }
      });
      var transformTemplate = this.visualElement.getProps().transformTemplate;
      this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis(function(axis) {
        if (!shouldDrag(axis, drag2, null))
          return;
        var axisValue = _this.getAxisMotionValue(axis);
        var _a2 = _this.constraints[axis], min = _a2.min, max = _a2.max;
        axisValue.set(mix(min, max, boxProgress[axis]));
      });
    };
    VisualElementDragControls2.prototype.addListeners = function() {
      var _this = this;
      var _a;
      elementDragControls.set(this.visualElement, this);
      var element = this.visualElement.getInstance();
      var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
        var _a2 = _this.getProps(), drag2 = _a2.drag, _b = _a2.dragListener, dragListener = _b === void 0 ? true : _b;
        drag2 && dragListener && _this.start(event);
      });
      var measureDragConstraints = function() {
        var dragConstraints = _this.getProps().dragConstraints;
        if (isRefObject2(dragConstraints)) {
          _this.constraints = _this.resolveRefConstraints();
        }
      };
      var projection = this.visualElement.projection;
      var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
        projection.updateLayout();
      }
      measureDragConstraints();
      var stopResizeListener = addDomEvent(window, "resize", function() {
        return _this.scalePositionWithinConstraints();
      });
      projection.addEventListener("didUpdate", function(_a2) {
        var delta = _a2.delta, hasLayoutChanged = _a2.hasLayoutChanged;
        if (_this.isDragging && hasLayoutChanged) {
          eachAxis(function(axis) {
            var motionValue2 = _this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            _this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          _this.visualElement.syncRender();
        }
      });
      return function() {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
      };
    };
    VisualElementDragControls2.prototype.getProps = function() {
      var props = this.visualElement.getProps();
      var _a = props.drag, drag2 = _a === void 0 ? false : _a, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e = props.dragElastic, dragElastic = _e === void 0 ? defaultElastic : _e, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;
      return __assign(__assign({}, props), { drag: drag2, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum });
    };
    return VisualElementDragControls2;
  }();
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset4, lockThreshold) {
    if (lockThreshold === void 0) {
      lockThreshold = 10;
    }
    var direction = null;
    if (Math.abs(offset4.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset4.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }

  // node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
  function useDrag(props) {
    var groupDragControls = props.dragControls, visualElement2 = props.visualElement;
    var dragControls = useConstant(function() {
      return new VisualElementDragControls(visualElement2);
    });
    (0, import_react62.useEffect)(function() {
      return groupDragControls && groupDragControls.subscribe(dragControls);
    }, [dragControls, groupDragControls]);
    (0, import_react62.useEffect)(function() {
      return dragControls.addListeners();
    }, [dragControls]);
  }

  // node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs
  var import_react63 = __toESM(require_react(), 1);
  function usePanGesture(_a) {
    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement2 = _a.visualElement;
    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
    var panSession = (0, import_react63.useRef)(null);
    var transformPagePoint = (0, import_react63.useContext)(MotionConfigContext).transformPagePoint;
    var handlers = {
      onSessionStart: onPanSessionStart,
      onStart: onPanStart,
      onMove: onPan,
      onEnd: function(event, info) {
        panSession.current = null;
        onPanEnd && onPanEnd(event, info);
      }
    };
    (0, import_react63.useEffect)(function() {
      if (panSession.current !== null) {
        panSession.current.updateHandlers(handlers);
      }
    });
    function onPointerDown(event) {
      panSession.current = new PanSession(event, handlers, {
        transformPagePoint
      });
    }
    usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
    useUnmountEffect(function() {
      return panSession.current && panSession.current.end();
    });
  }

  // node_modules/framer-motion/dist/es/motion/features/drag.mjs
  var drag = {
    pan: makeRenderlessComponent(usePanGesture),
    drag: makeRenderlessComponent(useDrag)
  };

  // node_modules/framer-motion/dist/es/render/utils/lifecycles.mjs
  var names = [
    "LayoutMeasure",
    "BeforeLayoutMeasure",
    "LayoutUpdate",
    "ViewportBoxUpdate",
    "Update",
    "Render",
    "AnimationComplete",
    "LayoutAnimationComplete",
    "AnimationStart",
    "LayoutAnimationStart",
    "SetAxisTarget",
    "Unmount"
  ];
  function createLifecycles() {
    var managers = names.map(function() {
      return new SubscriptionManager();
    });
    var propSubscriptions = {};
    var lifecycles = {
      clearAllListeners: function() {
        return managers.forEach(function(manager) {
          return manager.clear();
        });
      },
      updatePropListeners: function(props) {
        names.forEach(function(name) {
          var _a;
          var on = "on" + name;
          var propListener = props[on];
          (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
          if (propListener) {
            propSubscriptions[name] = lifecycles[on](propListener);
          }
        });
      }
    };
    managers.forEach(function(manager, i5) {
      lifecycles["on" + names[i5]] = function(handler) {
        return manager.add(handler);
      };
      lifecycles["notify" + names[i5]] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return manager.notify.apply(manager, __spreadArray([], __read(args), false));
      };
    });
    return lifecycles;
  }

  // node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
  function updateMotionValuesFromProps(element, next2, prev) {
    var _a;
    for (var key in next2) {
      var nextValue = next2[key];
      var prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
        if (true) {
          warnOnce(nextValue.version === "6.5.1", "Attempting to mix Framer Motion versions ".concat(nextValue.version, " with 6.5.1 may not work as expected."));
        }
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          var existingValue = element.getValue(key);
          !existingValue.hasAnimated && existingValue.set(nextValue);
        } else {
          element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
        }
      }
    }
    for (var key in prev) {
      if (next2[key] === void 0)
        element.removeValue(key);
    }
    return next2;
  }

  // node_modules/framer-motion/dist/es/render/index.mjs
  var visualElement = function(_a) {
    var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox2 = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;
    return function(_a2, options) {
      var parent = _a2.parent, props = _a2.props, presenceId = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState, shouldReduceMotion = _a2.shouldReduceMotion;
      if (options === void 0) {
        options = {};
      }
      var isMounted = false;
      var latestValues = visualState.latestValues, renderState = visualState.renderState;
      var instance;
      var lifecycles = createLifecycles();
      var values = /* @__PURE__ */ new Map();
      var valueSubscriptions = /* @__PURE__ */ new Map();
      var prevMotionValues = {};
      var baseTarget = __assign({}, latestValues);
      var removeFromVariantTree;
      function render2() {
        if (!instance || !isMounted)
          return;
        triggerBuild();
        renderInstance(instance, renderState, props.style, element.projection);
      }
      function triggerBuild() {
        build(element, renderState, latestValues, options, props);
      }
      function update3() {
        lifecycles.notifyUpdate(latestValues);
      }
      function bindToMotionValue(key2, value2) {
        var removeOnChange = value2.onChange(function(latestValue) {
          latestValues[key2] = latestValue;
          props.onUpdate && es_default.update(update3, false, true);
        });
        var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
        valueSubscriptions.set(key2, function() {
          removeOnChange();
          removeOnRenderRequest();
        });
      }
      var initialMotionValues = scrapeMotionValuesFromProps3(props);
      for (var key in initialMotionValues) {
        var value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key], false);
        }
      }
      var isControllingVariants = checkIfControllingVariants(props);
      var isVariantNode = checkIfVariantNode(props);
      var element = __assign(__assign({
        treeType,
        current: null,
        depth: parent ? parent.depth + 1 : 0,
        parent,
        children: /* @__PURE__ */ new Set(),
        presenceId,
        shouldReduceMotion,
        variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
        isVisible: void 0,
        manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
        blockInitialAnimation,
        isMounted: function() {
          return Boolean(instance);
        },
        mount: function(newInstance) {
          isMounted = true;
          instance = element.current = newInstance;
          if (element.projection) {
            element.projection.mount(newInstance);
          }
          if (isVariantNode && parent && !isControllingVariants) {
            removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
          }
          values.forEach(function(value2, key2) {
            return bindToMotionValue(key2, value2);
          });
          parent === null || parent === void 0 ? void 0 : parent.children.add(element);
          element.setProps(props);
        },
        unmount: function() {
          var _a3;
          (_a3 = element.projection) === null || _a3 === void 0 ? void 0 : _a3.unmount();
          cancelSync.update(update3);
          cancelSync.render(render2);
          valueSubscriptions.forEach(function(remove4) {
            return remove4();
          });
          removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
          parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
          lifecycles.clearAllListeners();
          instance = void 0;
          isMounted = false;
        },
        addVariantChild: function(child) {
          var _a3;
          var closestVariantNode = element.getClosestVariantNode();
          if (closestVariantNode) {
            (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child);
            return function() {
              return closestVariantNode.variantChildren.delete(child);
            };
          }
        },
        sortNodePosition: function(other) {
          if (!sortNodePosition || treeType !== other.treeType)
            return 0;
          return sortNodePosition(element.getInstance(), other.getInstance());
        },
        getClosestVariantNode: function() {
          return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
        },
        getLayoutId: function() {
          return props.layoutId;
        },
        getInstance: function() {
          return instance;
        },
        getStaticValue: function(key2) {
          return latestValues[key2];
        },
        setStaticValue: function(key2, value2) {
          return latestValues[key2] = value2;
        },
        getLatestValues: function() {
          return latestValues;
        },
        setVisibility: function(visibility) {
          if (element.isVisible === visibility)
            return;
          element.isVisible = visibility;
          element.scheduleRender();
        },
        makeTargetAnimatable: function(target, canMutate) {
          if (canMutate === void 0) {
            canMutate = true;
          }
          return makeTargetAnimatable(element, target, props, canMutate);
        },
        measureViewportBox: function() {
          return measureViewportBox2(instance, props);
        },
        addValue: function(key2, value2) {
          if (element.hasValue(key2))
            element.removeValue(key2);
          values.set(key2, value2);
          latestValues[key2] = value2.get();
          bindToMotionValue(key2, value2);
        },
        removeValue: function(key2) {
          var _a3;
          values.delete(key2);
          (_a3 = valueSubscriptions.get(key2)) === null || _a3 === void 0 ? void 0 : _a3();
          valueSubscriptions.delete(key2);
          delete latestValues[key2];
          removeValueFromRenderState(key2, renderState);
        },
        hasValue: function(key2) {
          return values.has(key2);
        },
        getValue: function(key2, defaultValue) {
          var value2 = values.get(key2);
          if (value2 === void 0 && defaultValue !== void 0) {
            value2 = motionValue(defaultValue);
            element.addValue(key2, value2);
          }
          return value2;
        },
        forEachValue: function(callback) {
          return values.forEach(callback);
        },
        readValue: function(key2) {
          var _a3;
          return (_a3 = latestValues[key2]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance, key2, options);
        },
        setBaseTarget: function(key2, value2) {
          baseTarget[key2] = value2;
        },
        getBaseTarget: function(key2) {
          if (getBaseTarget) {
            var target = getBaseTarget(props, key2);
            if (target !== void 0 && !isMotionValue(target))
              return target;
          }
          return baseTarget[key2];
        }
      }, lifecycles), {
        build: function() {
          triggerBuild();
          return renderState;
        },
        scheduleRender: function() {
          es_default.render(render2, false, true);
        },
        syncRender: render2,
        setProps: function(newProps) {
          if (newProps.transformTemplate || props.transformTemplate) {
            element.scheduleRender();
          }
          props = newProps;
          lifecycles.updatePropListeners(newProps);
          prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
        },
        getProps: function() {
          return props;
        },
        getVariant: function(name) {
          var _a3;
          return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];
        },
        getDefaultTransition: function() {
          return props.transition;
        },
        getTransformPagePoint: function() {
          return props.transformPagePoint;
        },
        getVariantContext: function(startAtParent) {
          if (startAtParent === void 0) {
            startAtParent = false;
          }
          if (startAtParent)
            return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
          if (!isControllingVariants) {
            var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
            if (props.initial !== void 0) {
              context_1.initial = props.initial;
            }
            return context_1;
          }
          var context2 = {};
          for (var i5 = 0; i5 < numVariantProps; i5++) {
            var name_1 = variantProps[i5];
            var prop2 = props[name_1];
            if (isVariantLabel(prop2) || prop2 === false) {
              context2[name_1] = prop2;
            }
          }
          return context2;
        }
      });
      return element;
    };
  };
  var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder), false);
  var numVariantProps = variantProps.length;

  // node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
  function isCSSVariable2(value) {
    return typeof value === "string" && value.startsWith("var(--");
  }
  var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  function parseCSSVariable(current) {
    var match = cssVariableRegex.exec(current);
    if (!match)
      return [,];
    var _a = __read(match, 3), token = _a[1], fallback = _a[2];
    return [token, fallback];
  }
  var maxDepth = 4;
  function getVariableValue(current, element, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property "'.concat(current, '". This may indicate a circular fallback dependency.'));
    var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
    if (!token)
      return;
    var resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      return resolved.trim();
    } else if (isCSSVariable2(fallback)) {
      return getVariableValue(fallback, element, depth + 1);
    } else {
      return fallback;
    }
  }
  function resolveCSSVariables(visualElement2, _a, transitionEnd) {
    var _b;
    var target = __rest(_a, []);
    var element = visualElement2.getInstance();
    if (!(element instanceof Element))
      return { target, transitionEnd };
    if (transitionEnd) {
      transitionEnd = __assign({}, transitionEnd);
    }
    visualElement2.forEachValue(function(value) {
      var current2 = value.get();
      if (!isCSSVariable2(current2))
        return;
      var resolved2 = getVariableValue(current2, element);
      if (resolved2)
        value.set(resolved2);
    });
    for (var key in target) {
      var current = target[key];
      if (!isCSSVariable2(current))
        continue;
      var resolved = getVariableValue(current, element);
      if (!resolved)
        continue;
      target[key] = resolved;
      if (transitionEnd)
        (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
    }
    return { target, transitionEnd };
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
  var positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y"
  ]);
  var isPositionalKey = function(key) {
    return positionalKeys.has(key);
  };
  var hasPositionalKey = function(target) {
    return Object.keys(target).some(isPositionalKey);
  };
  var setAndResetVelocity = function(value, to2) {
    value.set(to2, false);
    value.set(to2);
  };
  var isNumOrPxType = function(v5) {
    return v5 === number || v5 === px;
  };
  var BoundingBoxDimension;
  (function(BoundingBoxDimension2) {
    BoundingBoxDimension2["width"] = "width";
    BoundingBoxDimension2["height"] = "height";
    BoundingBoxDimension2["left"] = "left";
    BoundingBoxDimension2["right"] = "right";
    BoundingBoxDimension2["top"] = "top";
    BoundingBoxDimension2["bottom"] = "bottom";
  })(BoundingBoxDimension || (BoundingBoxDimension = {}));
  var getPosFromMatrix = function(matrix, pos) {
    return parseFloat(matrix.split(", ")[pos]);
  };
  var getTranslateFromMatrix = function(pos2, pos3) {
    return function(_bbox, _a) {
      var transform = _a.transform;
      if (transform === "none" || !transform)
        return 0;
      var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
      if (matrix3d) {
        return getPosFromMatrix(matrix3d[1], pos3);
      } else {
        var matrix = transform.match(/^matrix\((.+)\)$/);
        if (matrix) {
          return getPosFromMatrix(matrix[1], pos2);
        } else {
          return 0;
        }
      }
    };
  };
  var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  var nonTranslationalTransformKeys = transformProps.filter(function(key) {
    return !transformKeys.has(key);
  });
  function removeNonTranslationalTransform(visualElement2) {
    var removedTransforms = [];
    nonTranslationalTransformKeys.forEach(function(key) {
      var value = visualElement2.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    if (removedTransforms.length)
      visualElement2.syncRender();
    return removedTransforms;
  }
  var positionalValues = {
    width: function(_a, _b) {
      var x4 = _a.x;
      var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? "0" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? "0" : _d;
      return x4.max - x4.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
    },
    height: function(_a, _b) {
      var y5 = _a.y;
      var _c = _b.paddingTop, paddingTop = _c === void 0 ? "0" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? "0" : _d;
      return y5.max - y5.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
    },
    top: function(_bbox, _a) {
      var top = _a.top;
      return parseFloat(top);
    },
    left: function(_bbox, _a) {
      var left = _a.left;
      return parseFloat(left);
    },
    bottom: function(_a, _b) {
      var y5 = _a.y;
      var top = _b.top;
      return parseFloat(top) + (y5.max - y5.min);
    },
    right: function(_a, _b) {
      var x4 = _a.x;
      var left = _b.left;
      return parseFloat(left) + (x4.max - x4.min);
    },
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
  };
  var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
    var originBbox = visualElement2.measureViewportBox();
    var element = visualElement2.getInstance();
    var elementComputedStyle = getComputedStyle(element);
    var display = elementComputedStyle.display;
    var origin = {};
    if (display === "none") {
      visualElement2.setStaticValue("display", target.display || "block");
    }
    changedKeys.forEach(function(key) {
      origin[key] = positionalValues[key](originBbox, elementComputedStyle);
    });
    visualElement2.syncRender();
    var targetBbox = visualElement2.measureViewportBox();
    changedKeys.forEach(function(key) {
      var value = visualElement2.getValue(key);
      setAndResetVelocity(value, origin[key]);
      target[key] = positionalValues[key](targetBbox, elementComputedStyle);
    });
    return target;
  };
  var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
    if (origin === void 0) {
      origin = {};
    }
    if (transitionEnd === void 0) {
      transitionEnd = {};
    }
    target = __assign({}, target);
    transitionEnd = __assign({}, transitionEnd);
    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
    var removedTransformValues = [];
    var hasAttemptedToRemoveTransformValues = false;
    var changedValueTypeKeys = [];
    targetPositionalKeys.forEach(function(key) {
      var value = visualElement2.getValue(key);
      if (!visualElement2.hasValue(key))
        return;
      var from = origin[key];
      var fromType = findDimensionValueType(from);
      var to2 = target[key];
      var toType;
      if (isKeyframesTarget(to2)) {
        var numKeyframes = to2.length;
        var fromIndex = to2[0] === null ? 1 : 0;
        from = to2[fromIndex];
        fromType = findDimensionValueType(from);
        for (var i5 = fromIndex; i5 < numKeyframes; i5++) {
          if (!toType) {
            toType = findDimensionValueType(to2[i5]);
            invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
          } else {
            invariant(findDimensionValueType(to2[i5]) === toType, "All keyframes must be of the same type");
          }
        }
      } else {
        toType = findDimensionValueType(to2);
      }
      if (fromType !== toType) {
        if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
          var current = value.get();
          if (typeof current === "string") {
            value.set(parseFloat(current));
          }
          if (typeof to2 === "string") {
            target[key] = parseFloat(to2);
          } else if (Array.isArray(to2) && toType === px) {
            target[key] = to2.map(parseFloat);
          }
        } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to2 === 0)) {
          if (from === 0) {
            value.set(toType.transform(from));
          } else {
            target[key] = fromType.transform(to2);
          }
        } else {
          if (!hasAttemptedToRemoveTransformValues) {
            removedTransformValues = removeNonTranslationalTransform(visualElement2);
            hasAttemptedToRemoveTransformValues = true;
          }
          changedValueTypeKeys.push(key);
          transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
          setAndResetVelocity(value, to2);
        }
      }
    });
    if (changedValueTypeKeys.length) {
      var scrollY_1 = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
      var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
      if (removedTransformValues.length) {
        removedTransformValues.forEach(function(_a) {
          var _b = __read(_a, 2), key = _b[0], value = _b[1];
          visualElement2.getValue(key).set(value);
        });
      }
      visualElement2.syncRender();
      if (scrollY_1 !== null)
        window.scrollTo({ top: scrollY_1 });
      return { target: convertedTarget, transitionEnd };
    } else {
      return { target, transitionEnd };
    }
  };
  function unitConversion(visualElement2, target, origin, transitionEnd) {
    return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
  }

  // node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
  var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
    var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
    target = resolved.target;
    transitionEnd = resolved.transitionEnd;
    return unitConversion(visualElement2, target, origin, transitionEnd);
  };

  // node_modules/framer-motion/dist/es/render/html/visual-element.mjs
  function getComputedStyle3(element) {
    return window.getComputedStyle(element);
  }
  var htmlConfig = {
    treeType: "dom",
    readValueFromInstance: function(domElement, key) {
      if (isTransformProp(key)) {
        var defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      } else {
        var computedStyle = getComputedStyle3(domElement);
        return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      }
    },
    sortNodePosition: function(a6, b6) {
      return a6.compareDocumentPosition(b6) & 2 ? 1 : -1;
    },
    getBaseTarget: function(props, key) {
      var _a;
      return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
    },
    measureViewportBox: function(element, _a) {
      var transformPagePoint = _a.transformPagePoint;
      return measureViewportBox(element, transformPagePoint);
    },
    resetTransform: function(element, domElement, props) {
      var transformTemplate = props.transformTemplate;
      domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      element.scheduleRender();
    },
    restoreTransform: function(instance, mutableState) {
      instance.style.transform = mutableState.style.transform;
    },
    removeValueFromRenderState: function(key, _a) {
      var vars = _a.vars, style = _a.style;
      delete vars[key];
      delete style[key];
    },
    makeTargetAnimatable: function(element, _a, _b, isMounted) {
      var transformValues = _b.transformValues;
      if (isMounted === void 0) {
        isMounted = true;
      }
      var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
      var origin = getOrigin(target, transition || {}, element);
      if (transformValues) {
        if (transitionEnd)
          transitionEnd = transformValues(transitionEnd);
        if (target)
          target = transformValues(target);
        if (origin)
          origin = transformValues(origin);
      }
      if (isMounted) {
        checkTargetForNewValues(element, target, origin);
        var parsed = parseDomVariant(element, target, origin, transitionEnd);
        transitionEnd = parsed.transitionEnd;
        target = parsed.target;
      }
      return __assign({ transition, transitionEnd }, target);
    },
    scrapeMotionValuesFromProps,
    build: function(element, renderState, latestValues, options, props) {
      if (element.isVisible !== void 0) {
        renderState.style.visibility = element.isVisible ? "visible" : "hidden";
      }
      buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
    },
    render: renderHTML
  };
  var htmlVisualElement = visualElement(htmlConfig);

  // node_modules/framer-motion/dist/es/render/svg/visual-element.mjs
  var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), { getBaseTarget: function(props, key) {
    return props[key];
  }, readValueFromInstance: function(domElement, key) {
    var _a;
    if (isTransformProp(key)) {
      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return domElement.getAttribute(key);
  }, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, build: function(_element, renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);
  }, render: renderSVG }));

  // node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var createDomVisualElement = function(Component2, options) {
    return isSVGComponent(Component2) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var import_react64 = __toESM(require_react(), 1);

  // node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  var correctBorderRadius = {
    correct: function(latest, node) {
      if (!node.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      var x4 = pixelsToPercent(latest, node.target.x);
      var y5 = pixelsToPercent(latest, node.target.y);
      return "".concat(x4, "% ").concat(y5, "%");
    }
  };

  // node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
  var varToken = "_$css";
  var correctBoxShadow = {
    correct: function(latest, _a) {
      var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;
      var original = latest;
      var containsCSSVariables = latest.includes("var(");
      var cssVariables = [];
      if (containsCSSVariables) {
        latest = latest.replace(cssVariableRegex, function(match) {
          cssVariables.push(match);
          return varToken;
        });
      }
      var shadow2 = complex.parse(latest);
      if (shadow2.length > 5)
        return original;
      var template2 = complex.createTransformer(latest);
      var offset4 = typeof shadow2[0] !== "number" ? 1 : 0;
      var xScale = projectionDelta.x.scale * treeScale.x;
      var yScale = projectionDelta.y.scale * treeScale.y;
      shadow2[0 + offset4] /= xScale;
      shadow2[1 + offset4] /= yScale;
      var averageScale = mix(xScale, yScale, 0.5);
      if (typeof shadow2[2 + offset4] === "number")
        shadow2[2 + offset4] /= averageScale;
      if (typeof shadow2[3 + offset4] === "number")
        shadow2[3 + offset4] /= averageScale;
      var output3 = template2(shadow2);
      if (containsCSSVariables) {
        var i_1 = 0;
        output3 = output3.replace(varToken, function() {
          var cssVariable = cssVariables[i_1];
          i_1++;
          return cssVariable;
        });
      }
      return output3;
    }
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var MeasureLayoutWithContext = function(_super) {
    __extends(MeasureLayoutWithContext2, _super);
    function MeasureLayoutWithContext2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MeasureLayoutWithContext2.prototype.componentDidMount = function() {
      var _this = this;
      var _a = this.props, visualElement2 = _a.visualElement, layoutGroup = _a.layoutGroup, switchLayoutGroup = _a.switchLayoutGroup, layoutId = _a.layoutId;
      var projection = visualElement2.projection;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.add(projection);
        if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", function() {
          _this.safeToRemove();
        });
        projection.setOptions(__assign(__assign({}, projection.options), { onExitComplete: function() {
          return _this.safeToRemove();
        } }));
      }
      globalProjectionState.hasEverUpdated = true;
    };
    MeasureLayoutWithContext2.prototype.getSnapshotBeforeUpdate = function(prevProps) {
      var _this = this;
      var _a = this.props, layoutDependency = _a.layoutDependency, visualElement2 = _a.visualElement, drag2 = _a.drag, isPresent = _a.isPresent;
      var projection = visualElement2.projection;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          es_default.postRender(function() {
            var _a2;
            if (!((_a2 = projection.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length)) {
              _this.safeToRemove();
            }
          });
        }
      }
      return null;
    };
    MeasureLayoutWithContext2.prototype.componentDidUpdate = function() {
      var projection = this.props.visualElement.projection;
      if (projection) {
        projection.root.didUpdate();
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      }
    };
    MeasureLayoutWithContext2.prototype.componentWillUnmount = function() {
      var _a = this.props, visualElement2 = _a.visualElement, layoutGroup = _a.layoutGroup, promoteContext = _a.switchLayoutGroup;
      var projection = visualElement2.projection;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    };
    MeasureLayoutWithContext2.prototype.safeToRemove = function() {
      var safeToRemove = this.props.safeToRemove;
      safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
    };
    MeasureLayoutWithContext2.prototype.render = function() {
      return null;
    };
    return MeasureLayoutWithContext2;
  }(import_react64.default.Component);
  function MeasureLayout(props) {
    var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];
    var layoutGroup = (0, import_react64.useContext)(LayoutGroupContext);
    return import_react64.default.createElement(MeasureLayoutWithContext, __assign({}, props, { layoutGroup, switchLayoutGroup: (0, import_react64.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove }));
  }
  var defaultScaleCorrectors = {
    borderRadius: __assign(__assign({}, correctBorderRadius), { applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ] }),
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };

  // node_modules/framer-motion/dist/es/motion/features/layout/index.mjs
  var layoutFeatures = {
    measureLayout: MeasureLayout
  };

  // node_modules/framer-motion/dist/es/animation/animate.mjs
  function animate2(from, to2, transition) {
    if (transition === void 0) {
      transition = {};
    }
    var value = isMotionValue(from) ? from : motionValue(from);
    startAnimation("", value, to2, transition);
    return {
      stop: function() {
        return value.stop();
      },
      isAnimating: function() {
        return value.isAnimating();
      }
    };
  }

  // node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
  var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  var numBorders = borders.length;
  var asNumber = function(value) {
    return typeof value === "string" ? parseFloat(value) : value;
  };
  var isPx = function(value) {
    return typeof value === "number" || px.test(value);
  };
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    var _a, _b, _c, _d;
    if (shouldCrossfadeOpacity) {
      target.opacity = mix(
        0,
        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1,
        easeCrossfadeIn(progress2)
      );
      target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress2);
    }
    for (var i5 = 0; i5 < numBorders; i5++) {
      var borderLabel = "border".concat(borders[i5], "Radius");
      var followRadius = getRadius(follow, borderLabel);
      var leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    var _a;
    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
  }
  var easeCrossfadeIn = compress(0, 0.5, circOut);
  var easeCrossfadeOut = compress(0.5, 0.95, linear);
  function compress(min, max, easing) {
    return function(p5) {
      if (p5 < min)
        return 0;
      if (p5 > max)
        return 1;
      return easing(progress(min, max, p5));
    };
  }

  // node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
  function removePointDelta(point, translate, scale2, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  function removeAxisDelta(axis, translate, scale2, origin, boxScale, originAxis, sourceAxis) {
    if (translate === void 0) {
      translate = 0;
    }
    if (scale2 === void 0) {
      scale2 = 1;
    }
    if (origin === void 0) {
      origin = 0.5;
    }
    if (originAxis === void 0) {
      originAxis = axis;
    }
    if (sourceAxis === void 0) {
      sourceAxis = axis;
    }
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      var relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    var originPoint = mix(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, _a, origin, sourceAxis) {
    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  var xKeys2 = ["x", "scaleX", "originX"];
  var yKeys2 = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
    removeAxisTransforms(box.y, transforms, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
  }

  // node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function boxEquals(a6, b6) {
    return a6.x.min === b6.x.min && a6.x.max === b6.x.max && a6.y.min === b6.y.min && a6.y.max === b6.y.max;
  }

  // node_modules/framer-motion/dist/es/projection/shared/stack.mjs
  var NodeStack = function() {
    function NodeStack2() {
      this.members = [];
    }
    NodeStack2.prototype.add = function(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    };
    NodeStack2.prototype.remove = function(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        var prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    };
    NodeStack2.prototype.relegate = function(node) {
      var indexOfNode = this.members.findIndex(function(member2) {
        return node === member2;
      });
      if (indexOfNode === 0)
        return false;
      var prevLead;
      for (var i5 = indexOfNode; i5 >= 0; i5--) {
        var member = this.members[i5];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    };
    NodeStack2.prototype.promote = function(node, preserveFollowOpacity) {
      var _a;
      var prevLead = this.lead;
      if (node === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          node.snapshot.isShared = true;
        }
        if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {
          node.isLayoutDirty = true;
        }
        var crossfade = node.options.crossfade;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    };
    NodeStack2.prototype.exitAnimationComplete = function() {
      this.members.forEach(function(node) {
        var _a, _b, _c, _d, _e;
        (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);
      });
    };
    NodeStack2.prototype.scheduleRender = function() {
      this.members.forEach(function(node) {
        node.instance && node.scheduleRender(false);
      });
    };
    NodeStack2.prototype.removeLeadSnapshot = function() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    };
    return NodeStack2;
  }();

  // node_modules/framer-motion/dist/es/projection/styles/transform.mjs
  var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    var xTranslate = delta.x.translate / treeScale.x;
    var yTranslate = delta.y.translate / treeScale.y;
    var transform = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");
    transform += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");
    if (latestTransform) {
      var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
      if (rotate)
        transform += "rotate(".concat(rotate, "deg) ");
      if (rotateX)
        transform += "rotateX(".concat(rotateX, "deg) ");
      if (rotateY)
        transform += "rotateY(".concat(rotateY, "deg) ");
    }
    var elementScaleX = delta.x.scale * treeScale.x;
    var elementScaleY = delta.y.scale * treeScale.y;
    transform += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");
    return transform === identityProjection ? "none" : transform;
  }

  // node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
  var compareByDepth = function(a6, b6) {
    return a6.depth - b6.depth;
  };

  // node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
  var FlatTree = function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    };
    return FlatTree2;
  }();

  // node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
  var animationTarget = 1e3;
  function createProjectionNode(_a) {
    var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, checkIsScrollRoot = _a.checkIsScrollRoot, resetTransform = _a.resetTransform;
    return function() {
      function ProjectionNode(id2, latestValues, parent) {
        var _this = this;
        if (latestValues === void 0) {
          latestValues = {};
        }
        if (parent === void 0) {
          parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
        }
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.potentialNodes = /* @__PURE__ */ new Map();
        this.checkUpdateFailed = function() {
          if (_this.isUpdating) {
            _this.isUpdating = false;
            _this.clearAllSnapshots();
          }
        };
        this.updateProjection = function() {
          _this.nodes.forEach(resolveTargetDelta);
          _this.nodes.forEach(calcProjection);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.id = id2;
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        id2 && this.root.registerPotentialNode(id2, this);
        for (var i5 = 0; i5 < this.path.length; i5++) {
          this.path[i5].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      ProjectionNode.prototype.addEventListener = function(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      };
      ProjectionNode.prototype.notifyListeners = function(name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));
      };
      ProjectionNode.prototype.hasListeners = function(name) {
        return this.eventHandlers.has(name);
      };
      ProjectionNode.prototype.registerPotentialNode = function(id2, node) {
        this.potentialNodes.set(id2, node);
      };
      ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {
        var _this = this;
        var _a2;
        if (isLayoutDirty === void 0) {
          isLayoutDirty = false;
        }
        if (this.instance)
          return;
        this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
        this.instance = instance;
        var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement2 = _b.visualElement;
        if (visualElement2 && !visualElement2.getInstance()) {
          visualElement2.mount(instance);
        }
        this.root.nodes.add(this);
        (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.children.add(this);
        this.id && this.root.potentialNodes.delete(this.id);
        if (isLayoutDirty && (layout || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          var unblockTimeout_1;
          var resizeUnblockUpdate_1 = function() {
            return _this.root.updateBlockedByResize = false;
          };
          attachResizeListener(instance, function() {
            _this.root.updateBlockedByResize = true;
            clearTimeout(unblockTimeout_1);
            unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              _this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement2 && (layoutId || layout)) {
          this.addEventListener("didUpdate", function(_a3) {
            var _b2, _c, _d, _e, _f;
            var delta = _a3.delta, hasLayoutChanged = _a3.hasLayoutChanged, hasRelativeTargetChanged = _a3.hasRelativeTargetChanged, newLayout = _a3.layout;
            if (_this.isTreeAnimationBlocked()) {
              _this.target = void 0;
              _this.relativeTarget = void 0;
              return;
            }
            var layoutTransition = (_c = (_b2 = _this.options.transition) !== null && _b2 !== void 0 ? _b2 : visualElement2.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;
            var _g = visualElement2.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;
            var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;
            var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {
              if (_this.resumeFrom) {
                _this.resumingFrom = _this.resumeFrom;
                _this.resumingFrom.resumingFrom = void 0;
              }
              _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, "layout")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });
              if (visualElement2.shouldReduceMotion) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              _this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged && _this.animationProgress === 0) {
                _this.finishAnimation();
              }
              _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));
            }
            _this.targetLayout = newLayout;
          });
        }
      };
      ProjectionNode.prototype.unmount = function() {
        var _a2, _b;
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.remove(this);
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
        this.instance = void 0;
        cancelSync.preRender(this.updateProjection);
      };
      ProjectionNode.prototype.blockUpdate = function() {
        this.updateManuallyBlocked = true;
      };
      ProjectionNode.prototype.unblockUpdate = function() {
        this.updateManuallyBlocked = false;
      };
      ProjectionNode.prototype.isUpdateBlocked = function() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      };
      ProjectionNode.prototype.isTreeAnimationBlocked = function() {
        var _a2;
        return this.isAnimationBlocked || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimationBlocked()) || false;
      };
      ProjectionNode.prototype.startUpdate = function() {
        var _a2;
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        (_a2 = this.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach(resetRotation);
      };
      ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {
        var _a2, _b, _c;
        if (shouldNotifyListeners === void 0) {
          shouldNotifyListeners = true;
        }
        if (this.root.isUpdateBlocked()) {
          (_b = (_a2 = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a2);
          return;
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (var i5 = 0; i5 < this.path.length; i5++) {
          var node = this.path[i5];
          node.shouldResetTransform = true;
          node.updateScroll();
        }
        var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;
        if (layoutId === void 0 && !layout)
          return;
        var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;
        this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      };
      ProjectionNode.prototype.didUpdate = function() {
        var updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating)
          return;
        this.isUpdating = false;
        if (this.potentialNodes.size) {
          this.potentialNodes.forEach(mountNodeEarly);
          this.potentialNodes.clear();
        }
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        flushSync2.update();
        flushSync2.preRender();
        flushSync2.render();
      };
      ProjectionNode.prototype.clearAllSnapshots = function() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      };
      ProjectionNode.prototype.scheduleUpdateProjection = function() {
        es_default.preRender(this.updateProjection, false, true);
      };
      ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {
        var _this = this;
        es_default.postRender(function() {
          if (_this.isLayoutDirty) {
            _this.root.didUpdate();
          } else {
            _this.root.checkUpdateFailed();
          }
        });
      };
      ProjectionNode.prototype.updateSnapshot = function() {
        if (this.snapshot || !this.instance)
          return;
        var measured = this.measure();
        var layout = this.removeTransform(this.removeElementScroll(measured));
        roundBox(layout);
        this.snapshot = {
          measured,
          layout,
          latestValues: {}
        };
      };
      ProjectionNode.prototype.updateLayout = function() {
        var _a2;
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (var i5 = 0; i5 < this.path.length; i5++) {
            var node = this.path[i5];
            node.updateScroll();
          }
        }
        var measured = this.measure();
        roundBox(measured);
        var prevLayout = this.layout;
        this.layout = {
          measured,
          actual: this.removeElementScroll(measured)
        };
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.actual);
        (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
      };
      ProjectionNode.prototype.updateScroll = function() {
        if (this.options.layoutScroll && this.instance) {
          this.isScrollRoot = checkIsScrollRoot(this.instance);
          this.scroll = measureScroll(this.instance);
        }
      };
      ProjectionNode.prototype.resetTransform = function() {
        var _a2;
        if (!resetTransform)
          return;
        var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
        var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        var transformTemplate = (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
        var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      };
      ProjectionNode.prototype.measure = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return createBox();
        var box = visualElement2.measureViewportBox();
        var scroll = this.root.scroll;
        if (scroll) {
          translateAxis(box.x, scroll.x);
          translateAxis(box.y, scroll.y);
        }
        return box;
      };
      ProjectionNode.prototype.removeElementScroll = function(box) {
        var boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        for (var i5 = 0; i5 < this.path.length; i5++) {
          var node = this.path[i5];
          var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;
          if (node !== this.root && scroll_1 && options.layoutScroll) {
            if (isScrollRoot) {
              copyBoxInto(boxWithoutScroll, box);
              var rootScroll = this.root.scroll;
              if (rootScroll) {
                translateAxis(boxWithoutScroll.x, -rootScroll.x);
                translateAxis(boxWithoutScroll.y, -rootScroll.y);
              }
            }
            translateAxis(boxWithoutScroll.x, scroll_1.x);
            translateAxis(boxWithoutScroll.y, scroll_1.y);
          }
        }
        return boxWithoutScroll;
      };
      ProjectionNode.prototype.applyTransform = function(box, transformOnly) {
        if (transformOnly === void 0) {
          transformOnly = false;
        }
        var withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (var i5 = 0; i5 < this.path.length; i5++) {
          var node = this.path[i5];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.x,
              y: -node.scroll.y
            });
          }
          if (!hasTransform(node.latestValues))
            continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      };
      ProjectionNode.prototype.removeTransform = function(box) {
        var _a2;
        var boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (var i5 = 0; i5 < this.path.length; i5++) {
          var node = this.path[i5];
          if (!node.instance)
            continue;
          if (!hasTransform(node.latestValues))
            continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          var sourceBox = createBox();
          var nodeBox = node.measure();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a2 = node.snapshot) === null || _a2 === void 0 ? void 0 : _a2.layout, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      };
      ProjectionNode.prototype.setTargetDelta = function(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
      };
      ProjectionNode.prototype.setOptions = function(options) {
        var _a2;
        this.options = __assign(__assign(__assign({}, this.options), options), { crossfade: (_a2 = options.crossfade) !== null && _a2 !== void 0 ? _a2 : true });
      };
      ProjectionNode.prototype.clearMeasurements = function() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      };
      ProjectionNode.prototype.resolveTargetDelta = function() {
        var _a2;
        var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
        if (!this.layout || !(layout || layoutId))
          return;
        if (!this.targetDelta && !this.relativeTarget) {
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && this.relativeParent.layout) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.target)) {
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.actual);
          } else {
            copyBoxInto(this.target, this.layout.actual);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
      };
      ProjectionNode.prototype.getClosestProjectingParent = function() {
        if (!this.parent || hasTransform(this.parent.latestValues))
          return void 0;
        if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      };
      ProjectionNode.prototype.calcProjection = function() {
        var _a2;
        var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
        this.isTreeAnimating = Boolean(((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout || layoutId))
          return;
        var lead = this.getLead();
        copyBoxInto(this.layoutCorrected, this.layout.actual);
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
        var target = lead.target;
        if (!target)
          return;
        if (!this.projectionDelta) {
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        var prevTreeScaleX = this.treeScale.x;
        var prevTreeScaleY = this.treeScale.y;
        var prevProjectionTransform = this.projectionTransform;
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      };
      ProjectionNode.prototype.hide = function() {
        this.isVisible = false;
      };
      ProjectionNode.prototype.show = function() {
        this.isVisible = true;
      };
      ProjectionNode.prototype.scheduleRender = function(notifyAll) {
        var _a2, _b, _c;
        if (notifyAll === void 0) {
          notifyAll = true;
        }
        (_b = (_a2 = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a2);
        notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      };
      ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {
        var _this = this;
        var _a2;
        if (hasOnlyRelativeTargetChanged === void 0) {
          hasOnlyRelativeTargetChanged = false;
        }
        var snapshot2 = this.snapshot;
        var snapshotLatestValues = (snapshot2 === null || snapshot2 === void 0 ? void 0 : snapshot2.latestValues) || {};
        var mixedValues = __assign({}, this.latestValues);
        var targetDelta = createDelta();
        this.relativeTarget = this.relativeTargetOrigin = void 0;
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        var relativeLayout = createBox();
        var isSharedLayoutAnimation = snapshot2 === null || snapshot2 === void 0 ? void 0 : snapshot2.isShared;
        var isOnlyMember = (((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.members.length) || 0) <= 1;
        var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        this.mixTargetDelta = function(latest) {
          var _a3;
          var progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          _this.setTargetDelta(targetDelta);
          if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a3 = _this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.layout)) {
            calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);
            mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress2);
          }
          if (isSharedLayoutAnimation) {
            _this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          _this.root.scheduleUpdateProjection();
          _this.scheduleRender();
          _this.animationProgress = progress2;
        };
        this.mixTargetDelta(0);
      };
      ProjectionNode.prototype.startAnimation = function(options) {
        var _this = this;
        var _a2, _b;
        this.notifyListeners("animationStart");
        (_a2 = this.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
        if (this.resumingFrom) {
          (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
        }
        if (this.pendingAnimation) {
          cancelSync.update(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = es_default.update(function() {
          globalProjectionState.hasAnimatedSinceResize = true;
          _this.currentAnimation = animate2(0, animationTarget, __assign(__assign({}, options), { onUpdate: function(latest) {
            var _a3;
            _this.mixTargetDelta(latest);
            (_a3 = options.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(options, latest);
          }, onComplete: function() {
            var _a3;
            (_a3 = options.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(options);
            _this.completeAnimation();
          } }));
          if (_this.resumingFrom) {
            _this.resumingFrom.currentAnimation = _this.currentAnimation;
          }
          _this.pendingAnimation = void 0;
        });
      };
      ProjectionNode.prototype.completeAnimation = function() {
        var _a2;
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      };
      ProjectionNode.prototype.finishAnimation = function() {
        var _a2;
        if (this.currentAnimation) {
          (_a2 = this.mixTargetDelta) === null || _a2 === void 0 ? void 0 : _a2.call(this, animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      };
      ProjectionNode.prototype.applyTransformsToTarget = function() {
        var _a2 = this.getLead(), targetWithTransforms = _a2.targetWithTransforms, target = _a2.target, layout = _a2.layout, latestValues = _a2.latestValues;
        if (!targetWithTransforms || !target || !layout)
          return;
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      };
      ProjectionNode.prototype.registerSharedNode = function(layoutId, node) {
        var _a2, _b, _c;
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        var stack4 = this.sharedNodes.get(layoutId);
        stack4.add(node);
        node.promote({
          transition: (_a2 = node.options.initialPromotionConfig) === null || _a2 === void 0 ? void 0 : _a2.transition,
          preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)
        });
      };
      ProjectionNode.prototype.isLead = function() {
        var stack4 = this.getStack();
        return stack4 ? stack4.lead === this : true;
      };
      ProjectionNode.prototype.getLead = function() {
        var _a2;
        var layoutId = this.options.layoutId;
        return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
      };
      ProjectionNode.prototype.getPrevLead = function() {
        var _a2;
        var layoutId = this.options.layoutId;
        return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
      };
      ProjectionNode.prototype.getStack = function() {
        var layoutId = this.options.layoutId;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      };
      ProjectionNode.prototype.promote = function(_a2) {
        var _b = _a2 === void 0 ? {} : _a2, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;
        var stack4 = this.getStack();
        if (stack4)
          stack4.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      };
      ProjectionNode.prototype.relegate = function() {
        var stack4 = this.getStack();
        if (stack4) {
          return stack4.relegate(this);
        } else {
          return false;
        }
      };
      ProjectionNode.prototype.resetRotation = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return;
        var hasRotate = false;
        var resetValues = {};
        for (var i5 = 0; i5 < transformAxes.length; i5++) {
          var axis = transformAxes[i5];
          var key = "rotate" + axis;
          if (!visualElement2.getStaticValue(key)) {
            continue;
          }
          hasRotate = true;
          resetValues[key] = visualElement2.getStaticValue(key);
          visualElement2.setStaticValue(key, 0);
        }
        if (!hasRotate)
          return;
        visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
        for (var key in resetValues) {
          visualElement2.setStaticValue(key, resetValues[key]);
        }
        visualElement2.scheduleRender();
      };
      ProjectionNode.prototype.getProjectionStyles = function(styleProp) {
        var _a2, _b, _c, _d, _e, _f;
        if (styleProp === void 0) {
          styleProp = {};
        }
        var styles = {};
        if (!this.instance || this.isSVG)
          return styles;
        if (!this.isVisible) {
          return { visibility: "hidden" };
        } else {
          styles.visibility = "";
        }
        var transformTemplate = (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.getProps().transformTemplate;
        if (this.needsReset) {
          this.needsReset = false;
          styles.opacity = "";
          styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return styles;
        }
        var lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          var emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        var valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          styles.transform = transformTemplate(valuesToRender, styles.transform);
        }
        var _g = this.projectionDelta, x4 = _g.x, y5 = _g.y;
        styles.transformOrigin = "".concat(x4.origin * 100, "% ").concat(y5.origin * 100, "% 0");
        if (lead.animationValues) {
          styles.opacity = lead === this ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles.opacity = lead === this ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : "" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;
        }
        for (var key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;
          var corrected = correct(valuesToRender[key], lead);
          if (applyTo) {
            var num = applyTo.length;
            for (var i5 = 0; i5 < num; i5++) {
              styles[applyTo[i5]] = corrected;
            }
          } else {
            styles[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
        }
        return styles;
      };
      ProjectionNode.prototype.clearSnapshot = function() {
        this.resumeFrom = this.snapshot = void 0;
      };
      ProjectionNode.prototype.resetTree = function() {
        this.root.nodes.forEach(function(node) {
          var _a2;
          return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      };
      return ProjectionNode;
    }();
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    var _a, _b, _c, _d;
    var snapshot2 = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;
    if (node.isLead() && node.layout && snapshot2 && node.hasListeners("didUpdate")) {
      var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;
      if (node.options.animationType === "size") {
        eachAxis(function(axis) {
          var axisSnapshot = snapshot2.isShared ? snapshot2.measured[axis] : snapshot2.layout[axis];
          var length = calcLength(axisSnapshot);
          axisSnapshot.min = layout_1[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (node.options.animationType === "position") {
        eachAxis(function(axis) {
          var axisSnapshot = snapshot2.isShared ? snapshot2.measured[axis] : snapshot2.layout[axis];
          var length = calcLength(layout_1[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
        });
      }
      var layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout_1, snapshot2.layout);
      var visualDelta = createDelta();
      if (snapshot2.isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot2.measured);
      } else {
        calcBoxDelta(visualDelta, layout_1, snapshot2.layout);
      }
      var hasLayoutChanged = !isDeltaZero(layoutDelta);
      var hasRelativeTargetChanged = false;
      if (!node.resumeFrom) {
        node.relativeParent = node.getClosestProjectingParent();
        if (node.relativeParent && !node.relativeParent.resumeFrom) {
          var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;
          if (parentSnapshot && parentLayout) {
            var relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot2.layout, parentSnapshot.layout);
            var relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);
            if (!boxEquals(relativeSnapshot, relativeLayout)) {
              hasRelativeTargetChanged = true;
            }
          }
        }
      }
      node.notifyListeners("didUpdate", {
        layout: layout_1,
        snapshot: snapshot2,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeTargetChanged
      });
    } else if (node.isLead()) {
      (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);
    }
    node.options.transition = void 0;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function resetTransformStyle(node) {
    var visualElement2 = node.options.visualElement;
    if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
      visualElement2.notifyBeforeLayoutMeasure();
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetRotation(node) {
    node.resetRotation();
  }
  function removeLeadSnapshots(stack4) {
    stack4.removeLeadSnapshot();
  }
  function mixAxisDelta(output3, delta, p5) {
    output3.translate = mix(delta.translate, 0, p5);
    output3.scale = mix(delta.scale, 1, p5);
    output3.origin = delta.origin;
    output3.originPoint = delta.originPoint;
  }
  function mixAxis(output3, from, to2, p5) {
    output3.min = mix(from.min, to2.min, p5);
    output3.max = mix(from.max, to2.max, p5);
  }
  function mixBox(output3, from, to2, p5) {
    mixAxis(output3.x, from.x, to2.x, p5);
    mixAxis(output3.y, from.y, to2.y, p5);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== void 0;
  }
  var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  function mountNodeEarly(node, id2) {
    var searchNode = node.root;
    for (var i5 = node.path.length - 1; i5 >= 0; i5--) {
      if (Boolean(node.path[i5].instance)) {
        searchNode = node.path[i5];
        break;
      }
    }
    var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
    var element = searchElement.querySelector('[data-projection-id="'.concat(id2, '"]'));
    if (element)
      node.mount(element, true);
  }
  function roundAxis(axis) {
    axis.min = Math.round(axis.min);
    axis.max = Math.round(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }

  // node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
  var DocumentProjectionNode = createProjectionNode({
    attachResizeListener: function(ref2, notify) {
      return addDomEvent(ref2, "resize", notify);
    },
    measureScroll: function() {
      return {
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      };
    },
    checkIsScrollRoot: function() {
      return true;
    }
  });

  // node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
  var rootProjectionNode = {
    current: void 0
  };
  var HTMLProjectionNode = createProjectionNode({
    measureScroll: function(instance) {
      return {
        x: instance.scrollLeft,
        y: instance.scrollTop
      };
    },
    defaultParent: function() {
      if (!rootProjectionNode.current) {
        var documentNode = new DocumentProjectionNode(0, {});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: function(instance, value) {
      instance.style.transform = value !== null && value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: function(instance) {
      return Boolean(window.getComputedStyle(instance).position === "fixed");
    }
  });

  // node_modules/framer-motion/dist/es/render/dom/motion.mjs
  var featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutFeatures);
  var motion = /* @__PURE__ */ createMotionProxy(function(Component2, config2) {
    return createDomMotionConfig(Component2, config2, featureBundle, createDomVisualElement, HTMLProjectionNode);
  });

  // node_modules/@wordpress/icons/build-module/icon/index.js
  function Icon(_ref8) {
    let {
      icon,
      size = 24,
      ...props
    } = _ref8;
    return (0, import_react.cloneElement)(icon, {
      width: size,
      height: size,
      ...props
    });
  }
  var icon_default = Icon;

  // node_modules/@wordpress/icons/build-module/library/arrow-down.js
  var arrowDown = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "m16.5 13.5-3.7 3.7V4h-1.5v13.2l-3.8-3.7-1 1 5.5 5.6 5.5-5.6z"
  }));
  var arrow_down_default = arrowDown;

  // node_modules/@wordpress/icons/build-module/library/arrow-right.js
  var arrowRight = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "m14.5 6.5-1 1 3.7 3.7H4v1.6h13.2l-3.7 3.7 1 1 5.6-5.5z"
  }));
  var arrow_right_default = arrowRight;

  // node_modules/@wordpress/icons/build-module/library/block-default.js
  var blockDefault = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M19 8h-1V6h-5v2h-2V6H6v2H5c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8c0-1.1-.9-2-2-2zm.5 10c0 .3-.2.5-.5.5H5c-.3 0-.5-.2-.5-.5v-8c0-.3.2-.5.5-.5h14c.3 0 .5.2.5.5v8z"
  }));
  var block_default_default = blockDefault;

  // node_modules/@wordpress/icons/build-module/library/check.js
  var check = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M16.7 7.1l-6.3 8.5-3.3-2.5-.9 1.2 4.5 3.4L17.9 8z"
  }));
  var check_default = check;

  // node_modules/@wordpress/icons/build-module/library/chevron-down.js
  var chevronDown = (0, import_react.createElement)(SVG, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, (0, import_react.createElement)(Path, {
    d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z"
  }));
  var chevron_down_default = chevronDown;

  // node_modules/@wordpress/icons/build-module/library/chevron-left.js
  var chevronLeft = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M14.6 7l-1.2-1L8 12l5.4 6 1.2-1-4.6-5z"
  }));
  var chevron_left_default = chevronLeft;

  // node_modules/@wordpress/icons/build-module/library/chevron-right.js
  var chevronRight = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M10.6 6L9.4 7l4.6 5-4.6 5 1.2 1 5.4-6z"
  }));
  var chevron_right_default = chevronRight;

  // node_modules/@wordpress/icons/build-module/library/chevron-up.js
  var chevronUp = (0, import_react.createElement)(SVG, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, (0, import_react.createElement)(Path, {
    d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
  }));
  var chevron_up_default = chevronUp;

  // node_modules/@wordpress/icons/build-module/library/close.js
  var close = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M13 11.8l6.1-6.3-1-1-6.1 6.2-6.1-6.2-1 1 6.1 6.3-6.5 6.7 1 1 6.5-6.6 6.5 6.6 1-1z"
  }));
  var close_default = close;

  // node_modules/@wordpress/icons/build-module/library/close-small.js
  var closeSmall = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M12 13.06l3.712 3.713 1.061-1.06L13.061 12l3.712-3.712-1.06-1.06L12 10.938 8.288 7.227l-1.061 1.06L10.939 12l-3.712 3.712 1.06 1.061L12 13.061z"
  }));
  var close_small_default = closeSmall;

  // node_modules/@wordpress/icons/build-module/library/copy.js
  var copy = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M20.2 8v11c0 .7-.6 1.2-1.2 1.2H6v1.5h13c1.5 0 2.7-1.2 2.7-2.8V8zM18 16.4V4.6c0-.9-.7-1.6-1.6-1.6H4.6C3.7 3 3 3.7 3 4.6v11.8c0 .9.7 1.6 1.6 1.6h11.8c.9 0 1.6-.7 1.6-1.6zm-13.5 0V4.6c0-.1.1-.1.1-.1h11.8c.1 0 .1.1.1.1v11.8c0 .1-.1.1-.1.1H4.6l-.1-.1z"
  }));
  var copy_default = copy;

  // node_modules/@wordpress/icons/build-module/library/drag-handle.js
  var dragHandle = (0, import_react.createElement)(SVG, {
    width: "24",
    height: "24",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M8 7h2V5H8v2zm0 6h2v-2H8v2zm0 6h2v-2H8v2zm6-14v2h2V5h-2zm0 8h2v-2h-2v2zm0 6h2v-2h-2v2z"
  }));
  var drag_handle_default = dragHandle;

  // node_modules/@wordpress/icons/build-module/library/group.js
  var group = (0, import_react.createElement)(SVG, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, (0, import_react.createElement)(Path, {
    d: "M18 4h-7c-1.1 0-2 .9-2 2v3H6c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2v-3h3c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4.5 14c0 .3-.2.5-.5.5H6c-.3 0-.5-.2-.5-.5v-7c0-.3.2-.5.5-.5h3V13c0 1.1.9 2 2 2h2.5v3zm0-4.5H11c-.3 0-.5-.2-.5-.5v-2.5H13c.3 0 .5.2.5.5v2.5zm5-.5c0 .3-.2.5-.5.5h-3V11c0-1.1-.9-2-2-2h-2.5V6c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5v7z"
  }));
  var group_default = group;

  // node_modules/@wordpress/icons/build-module/library/justify-left.js
  var justifyLeft = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z"
  }));
  var justify_left_default = justifyLeft;

  // node_modules/@wordpress/icons/build-module/library/justify-center.js
  var justifyCenter = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M20 9h-7.2V4h-1.6v5H4v6h7.2v5h1.6v-5H20z"
  }));
  var justify_center_default = justifyCenter;

  // node_modules/@wordpress/icons/build-module/library/justify-right.js
  var justifyRight = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z"
  }));
  var justify_right_default = justifyRight;

  // node_modules/@wordpress/icons/build-module/library/justify-space-between.js
  var justifySpaceBetween = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z"
  }));
  var justify_space_between_default = justifySpaceBetween;

  // node_modules/@wordpress/icons/build-module/library/lock.js
  var lock = (0, import_react.createElement)(SVG, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, (0, import_react.createElement)(Path, {
    d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1zm-2.8 0H9.8V7c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3z"
  }));
  var lock_default = lock;

  // node_modules/@wordpress/icons/build-module/library/menu.js
  var menu = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M5 5v1.5h14V5H5zm0 7.8h14v-1.5H5v1.5zM5 19h14v-1.5H5V19z"
  }));
  var menu_default = menu;

  // node_modules/@wordpress/icons/build-module/library/more-horizontal.js
  var moreHorizontal = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M11 13h2v-2h-2v2zm-6 0h2v-2H5v2zm12-2v2h2v-2h-2z"
  }));
  var more_horizontal_default = moreHorizontal;

  // node_modules/@wordpress/icons/build-module/library/more-vertical.js
  var moreVertical = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M13 19h-2v-2h2v2zm0-6h-2v-2h2v2zm0-6h-2V5h2v2z"
  }));
  var more_vertical_default = moreVertical;

  // node_modules/@wordpress/icons/build-module/library/position-center.js
  var positionCenter = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M7 9v6h10V9H7zM5 19.8h14v-1.5H5v1.5zM5 4.3v1.5h14V4.3H5z"
  }));
  var position_center_default = positionCenter;

  // node_modules/@wordpress/icons/build-module/library/plus.js
  var plus = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M18 11.2h-5.2V6h-1.6v5.2H6v1.6h5.2V18h1.6v-5.2H18z"
  }));
  var plus_default = plus;

  // node_modules/@wordpress/icons/build-module/library/reset.js
  var reset = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M7 11.5h10V13H7z"
  }));
  var reset_default = reset;

  // node_modules/@wordpress/icons/build-module/library/row.js
  var row = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M9.2 6.5H4V8h5.2c.3 0 .5.2.5.5v7c0 .3-.2.5-.5.5H4v1.5h5.2c1.1 0 2-.9 2-2v-7c0-1.1-.8-2-2-2zM14.8 8H20V6.5h-5.2c-1.1 0-2 .9-2 2v7c0 1.1.9 2 2 2H20V16h-5.2c-.3 0-.5-.2-.5-.5v-7c-.1-.3.2-.5.5-.5z"
  }));
  var row_default = row;

  // node_modules/@wordpress/icons/build-module/library/symbol.js
  var symbol = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M21.3 10.8l-5.6-5.6c-.7-.7-1.8-.7-2.5 0l-5.6 5.6c-.7.7-.7 1.8 0 2.5l5.6 5.6c.3.3.8.5 1.2.5s.9-.2 1.2-.5l5.6-5.6c.8-.7.8-1.9.1-2.5zm-1 1.4l-5.6 5.6c-.1.1-.3.1-.4 0l-5.6-5.6c-.1-.1-.1-.3 0-.4l5.6-5.6s.1-.1.2-.1.1 0 .2.1l5.6 5.6c.1.1.1.3 0 .4zm-16.6-.4L10 5.5l-1-1-6.3 6.3c-.7.7-.7 1.8 0 2.5L9 19.5l1.1-1.1-6.3-6.3c-.2 0-.2-.2-.1-.3z"
  }));
  var symbol_default = symbol;

  // node_modules/@wordpress/icons/build-module/library/search.js
  var search = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M13.5 6C10.5 6 8 8.5 8 11.5c0 1.1.3 2.1.9 3l-3.4 3 1 1.1 3.4-2.9c1 .9 2.2 1.4 3.6 1.4 3 0 5.5-2.5 5.5-5.5C19 8.5 16.5 6 13.5 6zm0 9.5c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"
  }));
  var search_default = search;

  // node_modules/@wordpress/icons/build-module/library/stack.js
  var stack3 = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M16 4v5.2c0 .3-.2.5-.5.5h-7c-.3.1-.5-.2-.5-.5V4H6.5v5.2c0 1.1.9 2 2 2h7c1.1 0 2-.9 2-2V4H16zm-.5 8.8h-7c-1.1 0-2 .9-2 2V20H8v-5.2c0-.3.2-.5.5-.5h7c.3 0 .5.2.5.5V20h1.5v-5.2c0-1.2-.9-2-2-2z"
  }));
  var stack_default = stack3;

  // node_modules/@wordpress/icons/build-module/library/stretch-wide.js
  var stretchWide = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M5 9v6h14V9H5zm11-4.8H8v1.5h8V4.2zM8 19.8h8v-1.5H8v1.5z"
  }));
  var stretch_wide_default = stretchWide;

  // node_modules/@wordpress/icons/build-module/library/tip.js
  var tip = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M12 15.8c-3.7 0-6.8-3-6.8-6.8s3-6.8 6.8-6.8c3.7 0 6.8 3 6.8 6.8s-3.1 6.8-6.8 6.8zm0-12C9.1 3.8 6.8 6.1 6.8 9s2.4 5.2 5.2 5.2c2.9 0 5.2-2.4 5.2-5.2S14.9 3.8 12 3.8zM8 17.5h8V19H8zM10 20.5h4V22h-4z"
  }));
  var tip_default = tip;

  // node_modules/@wordpress/icons/build-module/library/unlock.js
  var unlock = (0, import_react.createElement)(SVG, {
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, (0, import_react.createElement)(Path, {
    d: "M17 10h-1.2V7c0-2.1-1.7-3.8-3.8-3.8-2.1 0-3.8 1.7-3.8 3.8h1.5c0-1.2 1-2.2 2.2-2.2s2.2 1 2.2 2.2v3H7c-.6 0-1 .4-1 1v8c0 .6.4 1 1 1h10c.6 0 1-.4 1-1v-8c0-.6-.4-1-1-1z"
  }));
  var unlock_default = unlock;

  // node_modules/@wordpress/components/build-module/button/index.js
  var import_classnames2 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/dashicon/index.js
  function Dashicon(_ref8) {
    let {
      icon,
      className,
      ...extraProps
    } = _ref8;
    const iconClass = ["dashicon", "dashicons", "dashicons-" + icon, className].filter(Boolean).join(" ");
    return (0, import_react.createElement)("span", _extends({
      className: iconClass
    }, extraProps));
  }
  var dashicon_default = Dashicon;

  // node_modules/@wordpress/components/build-module/icon/index.js
  function Icon2(_ref8) {
    let {
      icon = null,
      size = 24,
      ...additionalProps
    } = _ref8;
    if ("string" === typeof icon) {
      return (0, import_react.createElement)(dashicon_default, _extends({
        icon
      }, additionalProps));
    }
    if ((0, import_react.isValidElement)(icon) && dashicon_default === icon.type) {
      return (0, import_react.cloneElement)(icon, {
        ...additionalProps
      });
    }
    if ("function" === typeof icon) {
      if (icon.prototype instanceof import_react.Component) {
        return (0, import_react.createElement)(icon, {
          size,
          ...additionalProps
        });
      }
      return icon({
        size,
        ...additionalProps
      });
    }
    if (icon && (icon.type === "svg" || icon.type === SVG)) {
      const appliedProps = {
        ...icon.props,
        width: size,
        height: size,
        ...additionalProps
      };
      return (0, import_react.createElement)(SVG, appliedProps);
    }
    if ((0, import_react.isValidElement)(icon)) {
      return (0, import_react.cloneElement)(icon, {
        size,
        ...additionalProps
      });
    }
    return icon;
  }
  var icon_default2 = Icon2;

  // node_modules/@wordpress/components/build-module/ui/context/context-system-provider.js
  var import_lodash15 = __toESM(require_lodash());

  // node_modules/@wordpress/warning/build-module/utils.js
  var logged2 = /* @__PURE__ */ new Set();

  // node_modules/@wordpress/warning/build-module/index.js
  function isDev() {
    return typeof process !== "undefined" && process.env && true;
  }
  function warning4(message) {
    if (!isDev()) {
      return;
    }
    if (logged2.has(message)) {
      return;
    }
    console.warn(message);
    try {
      throw Error(message);
    } catch (x4) {
    }
    logged2.add(message);
  }

  // node_modules/@wordpress/components/build-module/utils/values.js
  function isValueDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isValueEmpty(value) {
    const isEmptyString = value === "";
    return !isValueDefined(value) || isEmptyString;
  }
  function getDefinedValue() {
    var _values$find;
    let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let fallbackValue = arguments.length > 1 ? arguments[1] : void 0;
    return (_values$find = values.find(isValueDefined)) !== null && _values$find !== void 0 ? _values$find : fallbackValue;
  }
  var stringToNumber = (value) => {
    return parseFloat(value);
  };
  var ensureNumber = (value) => {
    return typeof value === "string" ? stringToNumber(value) : value;
  };

  // node_modules/@wordpress/components/build-module/utils/hooks/use-controlled-state.js
  var defaultOptions = {
    initial: void 0,
    fallback: ""
  };
  function useControlledState(currentState) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOptions;
    const {
      initial,
      fallback
    } = {
      ...defaultOptions,
      ...options
    };
    const [internalState, setInternalState] = (0, import_react.useState)(currentState);
    const hasCurrentState = isValueDefined(currentState);
    (0, import_react.useEffect)(() => {
      if (hasCurrentState && internalState) {
        setInternalState(void 0);
      }
    }, [hasCurrentState, internalState]);
    const state = getDefinedValue([currentState, internalState, initial], fallback);
    const setState = (0, import_react.useCallback)((nextState) => {
      if (!hasCurrentState) {
        setInternalState(nextState);
      }
    }, [hasCurrentState]);
    return [state, setState];
  }
  var use_controlled_state_default = useControlledState;

  // node_modules/@wordpress/components/build-module/utils/hooks/use-update-effect.js
  function useUpdateEffect(effect, deps) {
    const mounted = (0, import_react.useRef)(false);
    (0, import_react.useEffect)(() => {
      if (mounted.current) {
        return effect();
      }
      mounted.current = true;
      return void 0;
    }, deps);
  }
  var use_update_effect_default = useUpdateEffect;

  // node_modules/@wordpress/components/build-module/utils/hooks/use-cx.js
  var import_react65 = __toESM(require_emotion_react_cjs());
  var import_utils31 = __toESM(require_emotion_utils_cjs());
  var import_css = __toESM(require_emotion_css_cjs());
  var isSerializedStyles = (o6) => typeof o6 !== "undefined" && o6 !== null && ["name", "styles"].every((p5) => typeof o6[p5] !== "undefined");
  var useCx = () => {
    const cache2 = (0, import_react65.__unsafe_useEmotionCache)();
    const cx = (0, import_react.useCallback)(function() {
      if (cache2 === null) {
        throw new Error("The `useCx` hook should be only used within a valid Emotion Cache Context");
      }
      for (var _len = arguments.length, classNames4 = new Array(_len), _key = 0; _key < _len; _key++) {
        classNames4[_key] = arguments[_key];
      }
      return (0, import_css.cx)(...classNames4.map((arg) => {
        if (isSerializedStyles(arg)) {
          (0, import_utils31.insertStyles)(cache2, arg, false);
          return `${cache2.key}-${arg.name}`;
        }
        return arg;
      }));
    }, [cache2]);
    return cx;
  };

  // node_modules/@wordpress/components/build-module/utils/box-sizing.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var boxSizingReset = false ? {
    name: "kv6lnz",
    styles: "box-sizing:border-box;*,*::before,*::after{box-sizing:inherit;}"
  } : {
    name: "1pa5nhz-boxSizingReset",
    styles: "box-sizing:border-box;*,*::before,*::after{box-sizing:inherit;};label:boxSizingReset;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdXRpbHMvYm94LXNpemluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFLaUMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91dGlscy9ib3gtc2l6aW5nLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgYm94U2l6aW5nUmVzZXQgPSBjc3NgXG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cblx0Kixcblx0Kjo6YmVmb3JlLFxuXHQqOjphZnRlciB7XG5cdFx0Ym94LXNpemluZzogaW5oZXJpdDtcblx0fVxuYDtcbiJdfQ== */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__
  };

  // node_modules/@wordpress/components/build-module/utils/colors.js
  k([names_default]);
  function rgba2() {
    let hexValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let alpha2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return w(hexValue).alpha(alpha2).toRgbString();
  }

  // node_modules/@wordpress/components/build-module/utils/reduce-motion.js
  function reduceMotion() {
    let prop2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transition";
    let style;
    switch (prop2) {
      case "transition":
        style = "transition-duration: 0ms;";
        break;
      case "animation":
        style = "animation-duration: 1ms;";
        break;
      default:
        style = `
				animation-duration: 1ms;
				transition-duration: 0ms;
			`;
    }
    return `
		@media ( prefers-reduced-motion: reduce ) {
			${style};
		}
	`;
  }

  // node_modules/@wordpress/components/build-module/utils/rtl.js
  var import_react66 = __toESM(require_emotion_react_cjs());
  var LOWER_LEFT_REGEXP = new RegExp(/-left/g);
  var LOWER_RIGHT_REGEXP = new RegExp(/-right/g);
  var UPPER_LEFT_REGEXP = new RegExp(/Left/g);
  var UPPER_RIGHT_REGEXP = new RegExp(/Right/g);
  function getConvertedKey(key) {
    if (key === "left") {
      return "right";
    }
    if (key === "right") {
      return "left";
    }
    if (LOWER_LEFT_REGEXP.test(key)) {
      return key.replace(LOWER_LEFT_REGEXP, "-right");
    }
    if (LOWER_RIGHT_REGEXP.test(key)) {
      return key.replace(LOWER_RIGHT_REGEXP, "-left");
    }
    if (UPPER_LEFT_REGEXP.test(key)) {
      return key.replace(UPPER_LEFT_REGEXP, "Right");
    }
    if (UPPER_RIGHT_REGEXP.test(key)) {
      return key.replace(UPPER_RIGHT_REGEXP, "Left");
    }
    return key;
  }
  var convertLTRToRTL = function() {
    let ltrStyles = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.fromEntries(Object.entries(ltrStyles).map((_ref8) => {
      let [key, value] = _ref8;
      return [getConvertedKey(key), value];
    }));
  };
  function rtl() {
    let ltrStyles = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let rtlStyles = arguments.length > 1 ? arguments[1] : void 0;
    return () => {
      if (rtlStyles) {
        return isRTL() ? /* @__PURE__ */ (0, import_react66.css)(rtlStyles, false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdXRpbHMvcnRsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThFb0IiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91dGlscy9ydGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5cbmNvbnN0IExPV0VSX0xFRlRfUkVHRVhQID0gbmV3IFJlZ0V4cCggLy1sZWZ0L2cgKTtcbmNvbnN0IExPV0VSX1JJR0hUX1JFR0VYUCA9IG5ldyBSZWdFeHAoIC8tcmlnaHQvZyApO1xuY29uc3QgVVBQRVJfTEVGVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvTGVmdC9nICk7XG5jb25zdCBVUFBFUl9SSUdIVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvUmlnaHQvZyApO1xuXG4vKipcbiAqIEZsaXBzIGEgQ1NTIHByb3BlcnR5IGZyb20gbGVmdCA8LT4gcmlnaHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZmxpcHBlZCBDU1MgcHJvcGVydHkgbmFtZSwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udmVydGVkS2V5KCBrZXkgKSB7XG5cdGlmICgga2V5ID09PSAnbGVmdCcgKSB7XG5cdFx0cmV0dXJuICdyaWdodCc7XG5cdH1cblxuXHRpZiAoIGtleSA9PT0gJ3JpZ2h0JyApIHtcblx0XHRyZXR1cm4gJ2xlZnQnO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9MRUZUX1JFR0VYUC50ZXN0KCBrZXkgKSApIHtcblx0XHRyZXR1cm4ga2V5LnJlcGxhY2UoIExPV0VSX0xFRlRfUkVHRVhQLCAnLXJpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBMT1dFUl9SSUdIVF9SRUdFWFAsICctbGVmdCcgKTtcblx0fVxuXG5cdGlmICggVVBQRVJfTEVGVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9MRUZUX1JFR0VYUCwgJ1JpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBVUFBFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9SSUdIVF9SRUdFWFAsICdMZWZ0JyApO1xuXHR9XG5cblx0cmV0dXJuIGtleTtcbn1cblxuLyoqXG4gKiBBbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgY29udmVydGVyIGZvciBzdHlsZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gbHRyU3R5bGVzXG4gKlxuICogQHJldHVybiB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXN9IENvbnZlcnRlZCBsdHIgLT4gcnRsIHN0eWxlc1xuICovXG5leHBvcnQgY29uc3QgY29udmVydExUUlRvUlRMID0gKCBsdHJTdHlsZXMgPSB7fSApID0+IHtcblx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcblx0XHRPYmplY3QuZW50cmllcyggbHRyU3R5bGVzICkubWFwKCAoIFsga2V5LCB2YWx1ZSBdICkgPT4gW1xuXHRcdFx0Z2V0Q29udmVydGVkS2V5KCBrZXkgKSxcblx0XHRcdHZhbHVlLFxuXHRcdF0gKVxuXHQpO1xufTtcblxuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgc3R5bGUgY29udmVydGVyIGZvciBDU1Mgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgncmVhY3QnKS5DU1NQcm9wZXJ0aWVzfSBsdHJTdHlsZXMgICBMdHIgc3R5bGVzLiBDb252ZXJ0cyBhbmQgcmVuZGVycyBmcm9tIGx0ciAtPiBydGwgc3R5bGVzLCBpZiBhcHBsaWNhYmxlLlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gW3J0bFN0eWxlc10gUnRsIHN0eWxlcy4gUmVuZGVycyBpZiBwcm92aWRlZC5cbiAqXG4gKiBAcmV0dXJuIHsoKSA9PiBpbXBvcnQoJ0BlbW90aW9uL3JlYWN0JykuU2VyaWFsaXplZFN0eWxlc30gQSBmdW5jdGlvbiB0byBvdXRwdXQgQ1NTIHN0eWxlcyBmb3IgRW1vdGlvbidzIHJlbmRlcmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydGwoIGx0clN0eWxlcyA9IHt9LCBydGxTdHlsZXMgKSB7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCBydGxTdHlsZXMgKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlOiBgY3NzYCB0eXBlcyBhcmUgd3JvbmcsIGl0IGNhbiBhY2NlcHQgYW4gb2JqZWN0OiBodHRwczovL2Vtb3Rpb24uc2gvZG9jcy9vYmplY3Qtc3R5bGVzI3dpdGgtY3NzXG5cdFx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggcnRsU3R5bGVzICkgOiBjc3MoIGx0clN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmU6IGBjc3NgIHR5cGVzIGFyZSB3cm9uZywgaXQgY2FuIGFjY2VwdCBhbiBvYmplY3Q6IGh0dHBzOi8vZW1vdGlvbi5zaC9kb2NzL29iamVjdC1zdHlsZXMjd2l0aC1jc3Ncblx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggY29udmVydExUUlRvUlRMKCBsdHJTdHlsZXMgKSApIDogY3NzKCBsdHJTdHlsZXMgKTtcblx0fTtcbn1cblxuLyoqXG4gKiBDYWxsIHRoaXMgaW4gdGhlIGB1c2VNZW1vYCBkZXBlbmRlbmN5IGFycmF5IHRvIGVuc3VyZSB0aGF0IHN1YnNlcXVlbnQgcmVuZGVycyB3aWxsXG4gKiBjYXVzZSBydGwgc3R5bGVzIHRvIHVwZGF0ZSBiYXNlZCBvbiB0aGUgYGlzUlRMYCByZXR1cm4gdmFsdWUgZXZlbiBpZiBhbGwgb3RoZXIgZGVwZW5kZW5jaWVzXG4gKiByZW1haW4gdGhlIHNhbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IHVzZU1lbW8oICgpID0+IHtcbiAqICAgcmV0dXJuIGNzc2BcbiAqICAgICAkeyBydGwoIHsgbWFyZ2luUmlnaHQ6ICcxMHB4JyB9ICkgfVxuICogICBgO1xuICogfSwgWyBydGwud2F0Y2goKSBdICk7XG4gKi9cbnJ0bC53YXRjaCA9ICgpID0+IGlzUlRMKCk7XG4iXX0= */") : /* @__PURE__ */ (0, import_react66.css)(ltrStyles, false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdXRpbHMvcnRsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThFdUMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91dGlscy9ydGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5cbmNvbnN0IExPV0VSX0xFRlRfUkVHRVhQID0gbmV3IFJlZ0V4cCggLy1sZWZ0L2cgKTtcbmNvbnN0IExPV0VSX1JJR0hUX1JFR0VYUCA9IG5ldyBSZWdFeHAoIC8tcmlnaHQvZyApO1xuY29uc3QgVVBQRVJfTEVGVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvTGVmdC9nICk7XG5jb25zdCBVUFBFUl9SSUdIVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvUmlnaHQvZyApO1xuXG4vKipcbiAqIEZsaXBzIGEgQ1NTIHByb3BlcnR5IGZyb20gbGVmdCA8LT4gcmlnaHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZmxpcHBlZCBDU1MgcHJvcGVydHkgbmFtZSwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udmVydGVkS2V5KCBrZXkgKSB7XG5cdGlmICgga2V5ID09PSAnbGVmdCcgKSB7XG5cdFx0cmV0dXJuICdyaWdodCc7XG5cdH1cblxuXHRpZiAoIGtleSA9PT0gJ3JpZ2h0JyApIHtcblx0XHRyZXR1cm4gJ2xlZnQnO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9MRUZUX1JFR0VYUC50ZXN0KCBrZXkgKSApIHtcblx0XHRyZXR1cm4ga2V5LnJlcGxhY2UoIExPV0VSX0xFRlRfUkVHRVhQLCAnLXJpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBMT1dFUl9SSUdIVF9SRUdFWFAsICctbGVmdCcgKTtcblx0fVxuXG5cdGlmICggVVBQRVJfTEVGVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9MRUZUX1JFR0VYUCwgJ1JpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBVUFBFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9SSUdIVF9SRUdFWFAsICdMZWZ0JyApO1xuXHR9XG5cblx0cmV0dXJuIGtleTtcbn1cblxuLyoqXG4gKiBBbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgY29udmVydGVyIGZvciBzdHlsZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gbHRyU3R5bGVzXG4gKlxuICogQHJldHVybiB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXN9IENvbnZlcnRlZCBsdHIgLT4gcnRsIHN0eWxlc1xuICovXG5leHBvcnQgY29uc3QgY29udmVydExUUlRvUlRMID0gKCBsdHJTdHlsZXMgPSB7fSApID0+IHtcblx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcblx0XHRPYmplY3QuZW50cmllcyggbHRyU3R5bGVzICkubWFwKCAoIFsga2V5LCB2YWx1ZSBdICkgPT4gW1xuXHRcdFx0Z2V0Q29udmVydGVkS2V5KCBrZXkgKSxcblx0XHRcdHZhbHVlLFxuXHRcdF0gKVxuXHQpO1xufTtcblxuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgc3R5bGUgY29udmVydGVyIGZvciBDU1Mgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgncmVhY3QnKS5DU1NQcm9wZXJ0aWVzfSBsdHJTdHlsZXMgICBMdHIgc3R5bGVzLiBDb252ZXJ0cyBhbmQgcmVuZGVycyBmcm9tIGx0ciAtPiBydGwgc3R5bGVzLCBpZiBhcHBsaWNhYmxlLlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gW3J0bFN0eWxlc10gUnRsIHN0eWxlcy4gUmVuZGVycyBpZiBwcm92aWRlZC5cbiAqXG4gKiBAcmV0dXJuIHsoKSA9PiBpbXBvcnQoJ0BlbW90aW9uL3JlYWN0JykuU2VyaWFsaXplZFN0eWxlc30gQSBmdW5jdGlvbiB0byBvdXRwdXQgQ1NTIHN0eWxlcyBmb3IgRW1vdGlvbidzIHJlbmRlcmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydGwoIGx0clN0eWxlcyA9IHt9LCBydGxTdHlsZXMgKSB7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCBydGxTdHlsZXMgKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlOiBgY3NzYCB0eXBlcyBhcmUgd3JvbmcsIGl0IGNhbiBhY2NlcHQgYW4gb2JqZWN0OiBodHRwczovL2Vtb3Rpb24uc2gvZG9jcy9vYmplY3Qtc3R5bGVzI3dpdGgtY3NzXG5cdFx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggcnRsU3R5bGVzICkgOiBjc3MoIGx0clN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmU6IGBjc3NgIHR5cGVzIGFyZSB3cm9uZywgaXQgY2FuIGFjY2VwdCBhbiBvYmplY3Q6IGh0dHBzOi8vZW1vdGlvbi5zaC9kb2NzL29iamVjdC1zdHlsZXMjd2l0aC1jc3Ncblx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggY29udmVydExUUlRvUlRMKCBsdHJTdHlsZXMgKSApIDogY3NzKCBsdHJTdHlsZXMgKTtcblx0fTtcbn1cblxuLyoqXG4gKiBDYWxsIHRoaXMgaW4gdGhlIGB1c2VNZW1vYCBkZXBlbmRlbmN5IGFycmF5IHRvIGVuc3VyZSB0aGF0IHN1YnNlcXVlbnQgcmVuZGVycyB3aWxsXG4gKiBjYXVzZSBydGwgc3R5bGVzIHRvIHVwZGF0ZSBiYXNlZCBvbiB0aGUgYGlzUlRMYCByZXR1cm4gdmFsdWUgZXZlbiBpZiBhbGwgb3RoZXIgZGVwZW5kZW5jaWVzXG4gKiByZW1haW4gdGhlIHNhbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IHVzZU1lbW8oICgpID0+IHtcbiAqICAgcmV0dXJuIGNzc2BcbiAqICAgICAkeyBydGwoIHsgbWFyZ2luUmlnaHQ6ICcxMHB4JyB9ICkgfVxuICogICBgO1xuICogfSwgWyBydGwud2F0Y2goKSBdICk7XG4gKi9cbnJ0bC53YXRjaCA9ICgpID0+IGlzUlRMKCk7XG4iXX0= */");
      }
      return isRTL() ? /* @__PURE__ */ (0, import_react66.css)(convertLTRToRTL(ltrStyles), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdXRpbHMvcnRsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtGbUIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91dGlscy9ydGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5cbmNvbnN0IExPV0VSX0xFRlRfUkVHRVhQID0gbmV3IFJlZ0V4cCggLy1sZWZ0L2cgKTtcbmNvbnN0IExPV0VSX1JJR0hUX1JFR0VYUCA9IG5ldyBSZWdFeHAoIC8tcmlnaHQvZyApO1xuY29uc3QgVVBQRVJfTEVGVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvTGVmdC9nICk7XG5jb25zdCBVUFBFUl9SSUdIVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvUmlnaHQvZyApO1xuXG4vKipcbiAqIEZsaXBzIGEgQ1NTIHByb3BlcnR5IGZyb20gbGVmdCA8LT4gcmlnaHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZmxpcHBlZCBDU1MgcHJvcGVydHkgbmFtZSwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udmVydGVkS2V5KCBrZXkgKSB7XG5cdGlmICgga2V5ID09PSAnbGVmdCcgKSB7XG5cdFx0cmV0dXJuICdyaWdodCc7XG5cdH1cblxuXHRpZiAoIGtleSA9PT0gJ3JpZ2h0JyApIHtcblx0XHRyZXR1cm4gJ2xlZnQnO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9MRUZUX1JFR0VYUC50ZXN0KCBrZXkgKSApIHtcblx0XHRyZXR1cm4ga2V5LnJlcGxhY2UoIExPV0VSX0xFRlRfUkVHRVhQLCAnLXJpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBMT1dFUl9SSUdIVF9SRUdFWFAsICctbGVmdCcgKTtcblx0fVxuXG5cdGlmICggVVBQRVJfTEVGVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9MRUZUX1JFR0VYUCwgJ1JpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBVUFBFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9SSUdIVF9SRUdFWFAsICdMZWZ0JyApO1xuXHR9XG5cblx0cmV0dXJuIGtleTtcbn1cblxuLyoqXG4gKiBBbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgY29udmVydGVyIGZvciBzdHlsZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gbHRyU3R5bGVzXG4gKlxuICogQHJldHVybiB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXN9IENvbnZlcnRlZCBsdHIgLT4gcnRsIHN0eWxlc1xuICovXG5leHBvcnQgY29uc3QgY29udmVydExUUlRvUlRMID0gKCBsdHJTdHlsZXMgPSB7fSApID0+IHtcblx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcblx0XHRPYmplY3QuZW50cmllcyggbHRyU3R5bGVzICkubWFwKCAoIFsga2V5LCB2YWx1ZSBdICkgPT4gW1xuXHRcdFx0Z2V0Q29udmVydGVkS2V5KCBrZXkgKSxcblx0XHRcdHZhbHVlLFxuXHRcdF0gKVxuXHQpO1xufTtcblxuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgc3R5bGUgY29udmVydGVyIGZvciBDU1Mgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgncmVhY3QnKS5DU1NQcm9wZXJ0aWVzfSBsdHJTdHlsZXMgICBMdHIgc3R5bGVzLiBDb252ZXJ0cyBhbmQgcmVuZGVycyBmcm9tIGx0ciAtPiBydGwgc3R5bGVzLCBpZiBhcHBsaWNhYmxlLlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gW3J0bFN0eWxlc10gUnRsIHN0eWxlcy4gUmVuZGVycyBpZiBwcm92aWRlZC5cbiAqXG4gKiBAcmV0dXJuIHsoKSA9PiBpbXBvcnQoJ0BlbW90aW9uL3JlYWN0JykuU2VyaWFsaXplZFN0eWxlc30gQSBmdW5jdGlvbiB0byBvdXRwdXQgQ1NTIHN0eWxlcyBmb3IgRW1vdGlvbidzIHJlbmRlcmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydGwoIGx0clN0eWxlcyA9IHt9LCBydGxTdHlsZXMgKSB7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCBydGxTdHlsZXMgKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlOiBgY3NzYCB0eXBlcyBhcmUgd3JvbmcsIGl0IGNhbiBhY2NlcHQgYW4gb2JqZWN0OiBodHRwczovL2Vtb3Rpb24uc2gvZG9jcy9vYmplY3Qtc3R5bGVzI3dpdGgtY3NzXG5cdFx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggcnRsU3R5bGVzICkgOiBjc3MoIGx0clN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmU6IGBjc3NgIHR5cGVzIGFyZSB3cm9uZywgaXQgY2FuIGFjY2VwdCBhbiBvYmplY3Q6IGh0dHBzOi8vZW1vdGlvbi5zaC9kb2NzL29iamVjdC1zdHlsZXMjd2l0aC1jc3Ncblx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggY29udmVydExUUlRvUlRMKCBsdHJTdHlsZXMgKSApIDogY3NzKCBsdHJTdHlsZXMgKTtcblx0fTtcbn1cblxuLyoqXG4gKiBDYWxsIHRoaXMgaW4gdGhlIGB1c2VNZW1vYCBkZXBlbmRlbmN5IGFycmF5IHRvIGVuc3VyZSB0aGF0IHN1YnNlcXVlbnQgcmVuZGVycyB3aWxsXG4gKiBjYXVzZSBydGwgc3R5bGVzIHRvIHVwZGF0ZSBiYXNlZCBvbiB0aGUgYGlzUlRMYCByZXR1cm4gdmFsdWUgZXZlbiBpZiBhbGwgb3RoZXIgZGVwZW5kZW5jaWVzXG4gKiByZW1haW4gdGhlIHNhbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IHVzZU1lbW8oICgpID0+IHtcbiAqICAgcmV0dXJuIGNzc2BcbiAqICAgICAkeyBydGwoIHsgbWFyZ2luUmlnaHQ6ICcxMHB4JyB9ICkgfVxuICogICBgO1xuICogfSwgWyBydGwud2F0Y2goKSBdICk7XG4gKi9cbnJ0bC53YXRjaCA9ICgpID0+IGlzUlRMKCk7XG4iXX0= */") : /* @__PURE__ */ (0, import_react66.css)(ltrStyles, false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdXRpbHMvcnRsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtGeUQiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91dGlscy9ydGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5cbmNvbnN0IExPV0VSX0xFRlRfUkVHRVhQID0gbmV3IFJlZ0V4cCggLy1sZWZ0L2cgKTtcbmNvbnN0IExPV0VSX1JJR0hUX1JFR0VYUCA9IG5ldyBSZWdFeHAoIC8tcmlnaHQvZyApO1xuY29uc3QgVVBQRVJfTEVGVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvTGVmdC9nICk7XG5jb25zdCBVUFBFUl9SSUdIVF9SRUdFWFAgPSBuZXcgUmVnRXhwKCAvUmlnaHQvZyApO1xuXG4vKipcbiAqIEZsaXBzIGEgQ1NTIHByb3BlcnR5IGZyb20gbGVmdCA8LT4gcmlnaHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgQ1NTIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZmxpcHBlZCBDU1MgcHJvcGVydHkgbmFtZSwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udmVydGVkS2V5KCBrZXkgKSB7XG5cdGlmICgga2V5ID09PSAnbGVmdCcgKSB7XG5cdFx0cmV0dXJuICdyaWdodCc7XG5cdH1cblxuXHRpZiAoIGtleSA9PT0gJ3JpZ2h0JyApIHtcblx0XHRyZXR1cm4gJ2xlZnQnO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9MRUZUX1JFR0VYUC50ZXN0KCBrZXkgKSApIHtcblx0XHRyZXR1cm4ga2V5LnJlcGxhY2UoIExPV0VSX0xFRlRfUkVHRVhQLCAnLXJpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBMT1dFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBMT1dFUl9SSUdIVF9SRUdFWFAsICctbGVmdCcgKTtcblx0fVxuXG5cdGlmICggVVBQRVJfTEVGVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9MRUZUX1JFR0VYUCwgJ1JpZ2h0JyApO1xuXHR9XG5cblx0aWYgKCBVUFBFUl9SSUdIVF9SRUdFWFAudGVzdCgga2V5ICkgKSB7XG5cdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBVUFBFUl9SSUdIVF9SRUdFWFAsICdMZWZ0JyApO1xuXHR9XG5cblx0cmV0dXJuIGtleTtcbn1cblxuLyoqXG4gKiBBbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgY29udmVydGVyIGZvciBzdHlsZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gbHRyU3R5bGVzXG4gKlxuICogQHJldHVybiB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXN9IENvbnZlcnRlZCBsdHIgLT4gcnRsIHN0eWxlc1xuICovXG5leHBvcnQgY29uc3QgY29udmVydExUUlRvUlRMID0gKCBsdHJTdHlsZXMgPSB7fSApID0+IHtcblx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcblx0XHRPYmplY3QuZW50cmllcyggbHRyU3R5bGVzICkubWFwKCAoIFsga2V5LCB2YWx1ZSBdICkgPT4gW1xuXHRcdFx0Z2V0Q29udmVydGVkS2V5KCBrZXkgKSxcblx0XHRcdHZhbHVlLFxuXHRcdF0gKVxuXHQpO1xufTtcblxuLyoqXG4gKiBBIGhpZ2hlci1vcmRlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhbiBpbmNyZWRpYmx5IGJhc2ljIGx0ciAtPiBydGwgc3R5bGUgY29udmVydGVyIGZvciBDU1Mgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgncmVhY3QnKS5DU1NQcm9wZXJ0aWVzfSBsdHJTdHlsZXMgICBMdHIgc3R5bGVzLiBDb252ZXJ0cyBhbmQgcmVuZGVycyBmcm9tIGx0ciAtPiBydGwgc3R5bGVzLCBpZiBhcHBsaWNhYmxlLlxuICogQHBhcmFtIHtpbXBvcnQoJ3JlYWN0JykuQ1NTUHJvcGVydGllc30gW3J0bFN0eWxlc10gUnRsIHN0eWxlcy4gUmVuZGVycyBpZiBwcm92aWRlZC5cbiAqXG4gKiBAcmV0dXJuIHsoKSA9PiBpbXBvcnQoJ0BlbW90aW9uL3JlYWN0JykuU2VyaWFsaXplZFN0eWxlc30gQSBmdW5jdGlvbiB0byBvdXRwdXQgQ1NTIHN0eWxlcyBmb3IgRW1vdGlvbidzIHJlbmRlcmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydGwoIGx0clN0eWxlcyA9IHt9LCBydGxTdHlsZXMgKSB7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCBydGxTdHlsZXMgKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlOiBgY3NzYCB0eXBlcyBhcmUgd3JvbmcsIGl0IGNhbiBhY2NlcHQgYW4gb2JqZWN0OiBodHRwczovL2Vtb3Rpb24uc2gvZG9jcy9vYmplY3Qtc3R5bGVzI3dpdGgtY3NzXG5cdFx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggcnRsU3R5bGVzICkgOiBjc3MoIGx0clN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmU6IGBjc3NgIHR5cGVzIGFyZSB3cm9uZywgaXQgY2FuIGFjY2VwdCBhbiBvYmplY3Q6IGh0dHBzOi8vZW1vdGlvbi5zaC9kb2NzL29iamVjdC1zdHlsZXMjd2l0aC1jc3Ncblx0XHRyZXR1cm4gaXNSVEwoKSA/IGNzcyggY29udmVydExUUlRvUlRMKCBsdHJTdHlsZXMgKSApIDogY3NzKCBsdHJTdHlsZXMgKTtcblx0fTtcbn1cblxuLyoqXG4gKiBDYWxsIHRoaXMgaW4gdGhlIGB1c2VNZW1vYCBkZXBlbmRlbmN5IGFycmF5IHRvIGVuc3VyZSB0aGF0IHN1YnNlcXVlbnQgcmVuZGVycyB3aWxsXG4gKiBjYXVzZSBydGwgc3R5bGVzIHRvIHVwZGF0ZSBiYXNlZCBvbiB0aGUgYGlzUlRMYCByZXR1cm4gdmFsdWUgZXZlbiBpZiBhbGwgb3RoZXIgZGVwZW5kZW5jaWVzXG4gKiByZW1haW4gdGhlIHNhbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IHVzZU1lbW8oICgpID0+IHtcbiAqICAgcmV0dXJuIGNzc2BcbiAqICAgICAkeyBydGwoIHsgbWFyZ2luUmlnaHQ6ICcxMHB4JyB9ICkgfVxuICogICBgO1xuICogfSwgWyBydGwud2F0Y2goKSBdICk7XG4gKi9cbnJ0bC53YXRjaCA9ICgpID0+IGlzUlRMKCk7XG4iXX0= */");
    };
  }
  rtl.watch = () => isRTL();

  // node_modules/@wordpress/components/build-module/utils/font.js
  var import_lodash14 = __toESM(require_lodash());

  // node_modules/@wordpress/components/build-module/utils/font-values.js
  var font_values_default = {
    "default.fontFamily": "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif",
    "default.fontSize": "13px",
    "helpText.fontSize": "12px",
    mobileTextMinFontSize: "16px"
  };

  // node_modules/@wordpress/components/build-module/utils/font.js
  function font(value) {
    return (0, import_lodash14.get)(font_values_default, value, "");
  }

  // node_modules/@wordpress/components/build-module/ui/utils/space.js
  var GRID_BASE = "4px";
  function space(value) {
    var _window$CSS, _window$CSS$supports;
    if (typeof value === "undefined") {
      return void 0;
    }
    if (!value) {
      return "0";
    }
    const asInt = typeof value === "number" ? value : Number(value);
    if (typeof window !== "undefined" && (_window$CSS = window.CSS) !== null && _window$CSS !== void 0 && (_window$CSS$supports = _window$CSS.supports) !== null && _window$CSS$supports !== void 0 && _window$CSS$supports.call(_window$CSS, "margin", value.toString()) || Number.isNaN(asInt)) {
      return value.toString();
    }
    return `calc(${GRID_BASE} * ${value})`;
  }

  // node_modules/@wordpress/components/build-module/utils/colors-values.js
  var white = "#fff";
  var GRAY = {
    900: "#1e1e1e",
    800: "#2f2f2f",
    700: "#757575",
    600: "#949494",
    400: "#ccc",
    300: "#ddd",
    200: "#e0e0e0",
    100: "#f0f0f0"
  };
  var ALERT = {
    yellow: "#f0b849",
    red: "#d94f4f",
    green: "#4ab866"
  };
  var ADMIN = {
    theme: "var( --wp-admin-theme-color, #007cba)",
    themeDark10: "var( --wp-admin-theme-color-darker-10, #006ba1)"
  };
  var UI = {
    theme: ADMIN.theme,
    background: white,
    backgroundDisabled: GRAY[100],
    border: GRAY[700],
    borderHover: GRAY[700],
    borderFocus: ADMIN.themeDark10,
    borderDisabled: GRAY[400],
    textDisabled: GRAY[600],
    textDark: white,
    darkGrayPlaceholder: rgba2(GRAY[900], 0.62),
    lightGrayPlaceholder: rgba2(white, 0.65)
  };
  var COLORS = Object.freeze({
    gray: GRAY,
    white,
    alert: ALERT,
    ui: UI
  });

  // node_modules/@wordpress/components/build-module/utils/config-values.js
  var CONTROL_HEIGHT = "36px";
  var CONTROL_PADDING_X = "12px";
  var CONTROL_PROPS = {
    controlSurfaceColor: COLORS.white,
    controlTextActiveColor: COLORS.ui.theme,
    controlPaddingX: CONTROL_PADDING_X,
    controlPaddingXLarge: `calc(${CONTROL_PADDING_X} * 1.3334)`,
    controlPaddingXSmall: `calc(${CONTROL_PADDING_X} / 1.3334)`,
    controlBackgroundColor: COLORS.white,
    controlBorderRadius: "2px",
    controlBorderColor: COLORS.gray[700],
    controlBoxShadow: "transparent",
    controlBorderColorHover: COLORS.gray[700],
    controlBoxShadowFocus: `0 0 0 0.5px ${COLORS.ui.theme}`,
    controlDestructiveBorderColor: COLORS.alert.red,
    controlHeight: CONTROL_HEIGHT,
    controlHeightXSmall: `calc( ${CONTROL_HEIGHT} * 0.6 )`,
    controlHeightSmall: `calc( ${CONTROL_HEIGHT} * 0.8 )`,
    controlHeightLarge: `calc( ${CONTROL_HEIGHT} * 1.2 )`,
    controlHeightXLarge: `calc( ${CONTROL_HEIGHT} * 1.4 )`
  };
  var TOGGLE_GROUP_CONTROL_PROPS = {
    toggleGroupControlBackgroundColor: CONTROL_PROPS.controlBackgroundColor,
    toggleGroupControlBorderColor: COLORS.ui.border,
    toggleGroupControlBackdropBackgroundColor: CONTROL_PROPS.controlSurfaceColor,
    toggleGroupControlBackdropBorderColor: COLORS.ui.border,
    toggleGroupControlButtonColorActive: CONTROL_PROPS.controlBackgroundColor
  };
  var config_values_default = Object.assign({}, CONTROL_PROPS, TOGGLE_GROUP_CONTROL_PROPS, {
    colorDivider: "rgba(0, 0, 0, 0.1)",
    colorScrollbarThumb: "rgba(0, 0, 0, 0.2)",
    colorScrollbarThumbHover: "rgba(0, 0, 0, 0.5)",
    colorScrollbarTrack: "rgba(0, 0, 0, 0.04)",
    elevationIntensity: 1,
    radiusBlockUi: "2px",
    borderWidth: "1px",
    borderWidthFocus: "1.5px",
    borderWidthTab: "4px",
    spinnerSize: 16,
    fontSize: "13px",
    fontSizeH1: "calc(2.44 * 13px)",
    fontSizeH2: "calc(1.95 * 13px)",
    fontSizeH3: "calc(1.56 * 13px)",
    fontSizeH4: "calc(1.25 * 13px)",
    fontSizeH5: "13px",
    fontSizeH6: "calc(0.8 * 13px)",
    fontSizeInputMobile: "16px",
    fontSizeMobile: "15px",
    fontSizeSmall: "calc(0.92 * 13px)",
    fontSizeXSmall: "calc(0.75 * 13px)",
    fontLineHeightBase: "1.2",
    fontWeight: "normal",
    fontWeightHeading: "600",
    gridBase: "4px",
    cardBorderRadius: "2px",
    cardPaddingXSmall: `${space(2)}`,
    cardPaddingSmall: `${space(4)}`,
    cardPaddingMedium: `${space(4)} ${space(6)}`,
    cardPaddingLarge: `${space(6)} ${space(8)}`,
    surfaceBackgroundColor: COLORS.white,
    surfaceBackgroundSubtleColor: "#F3F3F3",
    surfaceBackgroundTintColor: "#F5F5F5",
    surfaceBorderColor: "rgba(0, 0, 0, 0.1)",
    surfaceBorderBoldColor: "rgba(0, 0, 0, 0.15)",
    surfaceBorderSubtleColor: "rgba(0, 0, 0, 0.05)",
    surfaceBackgroundTertiaryColor: COLORS.white,
    surfaceColor: COLORS.white,
    transitionDuration: "200ms",
    transitionDurationFast: "160ms",
    transitionDurationFaster: "120ms",
    transitionDurationFastest: "100ms",
    transitionTimingFunction: "cubic-bezier(0.08, 0.52, 0.52, 1)",
    transitionTimingFunctionControl: "cubic-bezier(0.12, 0.8, 0.32, 1)"
  });

  // node_modules/@wordpress/components/build-module/utils/base-label.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__2() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var baseLabelTypography = false ? {
    name: "9amh4a",
    styles: "font-size:11px;font-weight:500;line-height:1.4;text-transform:uppercase"
  } : {
    name: "1awj7qe-baseLabelTypography",
    styles: "font-size:11px;font-weight:500;line-height:1.4;text-transform:uppercase;label:baseLabelTypography;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdXRpbHMvYmFzZS1sYWJlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPc0MiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91dGlscy9iYXNlLWxhYmVsLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vLyBUaGlzIGlzIGEgdmVyeSBsb3ctbGV2ZWwgbWl4aW4gd2hpY2ggeW91IHNob3VsZG4ndCBoYXZlIHRvIHVzZSBkaXJlY3RseS5cbi8vIFRyeSB0byB1c2UgQmFzZUNvbnRyb2wncyBTdHlsZWRMYWJlbCBvciBCYXNlQ29udHJvbC5WaXN1YWxMYWJlbCBpZiB5b3UgY2FuLlxuZXhwb3J0IGNvbnN0IGJhc2VMYWJlbFR5cG9ncmFwaHkgPSBjc3NgXG5cdGZvbnQtc2l6ZTogMTFweDtcblx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0bGluZS1oZWlnaHQ6IDEuNDtcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__2
  };

  // node_modules/@wordpress/components/build-module/ui/context/context-system-provider.js
  var ComponentsContext = (0, import_react.createContext)(
    {}
  );
  var useComponentsContext = () => (0, import_react.useContext)(ComponentsContext);
  function useContextSystemBridge(_ref8) {
    let {
      value
    } = _ref8;
    const parentContext = useComponentsContext();
    const valueRef = (0, import_react.useRef)(value);
    use_update_effect_default(() => {
      if ((0, import_lodash15.isEqual)(valueRef.current, value) && valueRef.current !== value) {
        typeof process !== "undefined" && process.env && true ? warning4(`Please memoize your context: ${JSON.stringify(value)}`) : void 0;
      }
    }, [value]);
    const config2 = (0, import_react.useMemo)(() => {
      return (0, import_lodash15.merge)(JSON.parse(JSON.stringify(parentContext)), value);
    }, [parentContext, value]);
    return config2;
  }
  var BaseContextSystemProvider = (_ref22) => {
    let {
      children,
      value
    } = _ref22;
    const contextValue = useContextSystemBridge({
      value
    });
    return (0, import_react.createElement)(ComponentsContext.Provider, {
      value: contextValue
    }, children);
  };
  var ContextSystemProvider = (0, import_react.memo)(BaseContextSystemProvider);

  // node_modules/@wordpress/components/build-module/ui/context/constants.js
  var COMPONENT_NAMESPACE = "data-wp-component";
  var CONNECTED_NAMESPACE = "data-wp-c16t";
  var CONNECT_STATIC_NAMESPACE = "__contextSystemKey__";

  // node_modules/@wordpress/components/build-module/ui/context/get-styled-class-name-from-key.js
  var import_lodash16 = __toESM(require_lodash());
  var import_memize4 = __toESM(require_memize());
  function getStyledClassName(namespace) {
    const kebab = (0, import_lodash16.kebabCase)(namespace);
    return `components-${kebab}`;
  }
  var getStyledClassNameFromKey = (0, import_memize4.default)(getStyledClassName);

  // node_modules/@wordpress/components/build-module/ui/context/context-connect.js
  function contextConnect(Component2, namespace) {
    return _contextConnect(Component2, namespace, {
      forwardsRef: true
    });
  }
  function _contextConnect(Component2, namespace, options) {
    const WrappedComponent = options !== null && options !== void 0 && options.forwardsRef ? (0, import_react.forwardRef)(Component2) : Component2;
    if (typeof namespace === "undefined") {
      typeof process !== "undefined" && process.env && true ? warning4("contextConnect: Please provide a namespace") : void 0;
    }
    let mergedNamespace = WrappedComponent[CONNECT_STATIC_NAMESPACE] || [namespace];
    if (Array.isArray(namespace)) {
      mergedNamespace = [...mergedNamespace, ...namespace];
    }
    if (typeof namespace === "string") {
      mergedNamespace = [...mergedNamespace, namespace];
    }
    return Object.assign(WrappedComponent, {
      [CONNECT_STATIC_NAMESPACE]: [...new Set(mergedNamespace)],
      displayName: namespace,
      selector: `.${getStyledClassNameFromKey(namespace)}`
    });
  }
  function getConnectNamespace(Component2) {
    if (!Component2)
      return [];
    let namespaces = [];
    if (Component2[CONNECT_STATIC_NAMESPACE]) {
      namespaces = Component2[CONNECT_STATIC_NAMESPACE];
    }
    if (Component2.type && Component2.type[CONNECT_STATIC_NAMESPACE]) {
      namespaces = Component2.type[CONNECT_STATIC_NAMESPACE];
    }
    return namespaces;
  }
  function hasConnectNamespace(Component2, match) {
    if (!Component2)
      return false;
    if (typeof match === "string") {
      return getConnectNamespace(Component2).includes(match);
    }
    if (Array.isArray(match)) {
      return match.some((result) => getConnectNamespace(Component2).includes(result));
    }
    return false;
  }

  // node_modules/@wordpress/components/build-module/ui/context/utils.js
  function getNamespace(componentName) {
    return {
      [COMPONENT_NAMESPACE]: componentName
    };
  }
  function getConnectedNamespace() {
    return {
      [CONNECTED_NAMESPACE]: true
    };
  }

  // node_modules/@wordpress/components/build-module/ui/context/use-context-system.js
  function useContextSystem(props, namespace) {
    const contextSystemProps = useComponentsContext();
    if (typeof namespace === "undefined") {
      typeof process !== "undefined" && process.env && true ? warning4("useContextSystem: Please provide a namespace") : void 0;
    }
    const contextProps = (contextSystemProps === null || contextSystemProps === void 0 ? void 0 : contextSystemProps[namespace]) || {};
    const finalComponentProps = {
      ...getConnectedNamespace(),
      ...getNamespace(namespace)
    };
    const {
      _overrides: overrideProps,
      ...otherContextProps
    } = contextProps;
    const initialMergedProps = Object.entries(otherContextProps).length ? Object.assign({}, otherContextProps, props) : props;
    const cx = useCx();
    const classes = cx(getStyledClassNameFromKey(namespace), props.className);
    const rendered = typeof initialMergedProps.renderChildren === "function" ? initialMergedProps.renderChildren(initialMergedProps) : initialMergedProps.children;
    for (const key in initialMergedProps) {
      finalComponentProps[key] = initialMergedProps[key];
    }
    for (const key in overrideProps) {
      finalComponentProps[key] = overrideProps[key];
    }
    if (rendered !== void 0) {
      finalComponentProps.children = rendered;
    }
    finalComponentProps.className = classes;
    return finalComponentProps;
  }

  // node_modules/@wordpress/components/build-module/visually-hidden/styles.js
  var visuallyHidden = {
    border: 0,
    clip: "rect(1px, 1px, 1px, 1px)",
    WebkitClipPath: "inset( 50% )",
    clipPath: "inset( 50% )",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: "1px",
    wordWrap: "normal"
  };

  // node_modules/@wordpress/components/build-module/view/component.js
  var import_base = __toESM(require_emotion_styled_base_cjs());
  var View = (0, import_base.default)("div", false ? {
    target: "e19lxcc00"
  } : {
    target: "e19lxcc00",
    label: "View"
  })(false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdmlldy9jb21wb25lbnQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlDYyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3ZpZXcvY29tcG9uZW50LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgUmVmQXR0cmlidXRlcyB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnQgfSBmcm9tICcuLi91aS9jb250ZXh0L3dvcmRwcmVzcy1jb21wb25lbnQnO1xuaW1wb3J0IHR5cGUgeyBWaWV3UHJvcHMgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBgVmlld2AgaXMgYSBjb3JlIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgZXZlcnl0aGluZyBpbiB0aGUgbGlicmFyeS5cbiAqIEl0IGlzIHRoZSBwcmluY2lwbGUgY29tcG9uZW50IGluIHRoZSBlbnRpcmUgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgeyBWaWV3IH0gZnJvbSBgQHdvcmRwcmVzcy9jb21wb25lbnRzYDtcbiAqXG4gKiBmdW5jdGlvbiBFeGFtcGxlKCkge1xuICogXHRyZXR1cm4gKFxuICogXHRcdDxWaWV3PlxuICogXHRcdFx0IENvZGUgaXMgUG9ldHJ5XG4gKiBcdFx0PC9WaWV3PlxuICogXHQpO1xuICogfVxuICogYGBgXG4gKi9cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmV4cG9ydCBjb25zdCBWaWV3OiBXb3JkUHJlc3NDb21wb25lbnQ8XG5cdCdkaXYnLFxuXHRWaWV3UHJvcHMgJiBSZWZBdHRyaWJ1dGVzPCBhbnkgPlxuPiA9IHN0eWxlZC5kaXZgYDtcblxuVmlldy5zZWxlY3RvciA9ICcuY29tcG9uZW50cy12aWV3JztcblZpZXcuZGlzcGxheU5hbWUgPSAnVmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG4iXX0= */");
  View.selector = ".components-view";
  View.displayName = "View";
  var component_default = View;

  // node_modules/@wordpress/components/build-module/visually-hidden/component.js
  function UnconnectedVisuallyHidden(props, forwardedRef) {
    const {
      style: styleProp,
      ...contextProps
    } = useContextSystem(props, "VisuallyHidden");
    return (0, import_react.createElement)(component_default, _extends({
      ref: forwardedRef
    }, contextProps, {
      style: {
        ...visuallyHidden,
        ...styleProp || {}
      }
    }));
  }
  var VisuallyHidden = contextConnect(UnconnectedVisuallyHidden, "VisuallyHidden");
  var component_default2 = VisuallyHidden;

  // node_modules/@wordpress/components/build-module/button/index.js
  var disabledEventsOnDisabledButton = ["onMouseDown", "onClick"];
  function useDeprecatedProps(_ref8) {
    let {
      isDefault,
      isPrimary,
      isSecondary,
      isTertiary,
      isLink,
      variant,
      ...otherProps
    } = _ref8;
    let computedVariant = variant;
    if (isPrimary) {
      var _computedVariant;
      (_computedVariant = computedVariant) !== null && _computedVariant !== void 0 ? _computedVariant : computedVariant = "primary";
    }
    if (isTertiary) {
      var _computedVariant2;
      (_computedVariant2 = computedVariant) !== null && _computedVariant2 !== void 0 ? _computedVariant2 : computedVariant = "tertiary";
    }
    if (isSecondary) {
      var _computedVariant3;
      (_computedVariant3 = computedVariant) !== null && _computedVariant3 !== void 0 ? _computedVariant3 : computedVariant = "secondary";
    }
    if (isDefault) {
      var _computedVariant4;
      deprecated("Button isDefault prop", {
        since: "5.4",
        alternative: 'variant="secondary"',
        version: "6.2"
      });
      (_computedVariant4 = computedVariant) !== null && _computedVariant4 !== void 0 ? _computedVariant4 : computedVariant = "secondary";
    }
    if (isLink) {
      var _computedVariant5;
      (_computedVariant5 = computedVariant) !== null && _computedVariant5 !== void 0 ? _computedVariant5 : computedVariant = "link";
    }
    return {
      ...otherProps,
      variant: computedVariant
    };
  }
  function Button(props, ref2) {
    var _children$, _children$$props;
    const {
      href,
      target,
      isSmall,
      isPressed,
      isBusy,
      isDestructive,
      className,
      disabled,
      icon,
      iconPosition = "left",
      iconSize,
      showTooltip,
      tooltipPosition,
      shortcut,
      label,
      children,
      text: text3,
      variant,
      __experimentalIsFocusable: isFocusable2,
      describedBy,
      ...additionalProps
    } = useDeprecatedProps(props);
    const instanceId = use_instance_id_default(Button, "components-button__description");
    const hasChildren = (children === null || children === void 0 ? void 0 : children[0]) && children[0] !== null && (children === null || children === void 0 ? void 0 : (_children$ = children[0]) === null || _children$ === void 0 ? void 0 : (_children$$props = _children$.props) === null || _children$$props === void 0 ? void 0 : _children$$props.className) !== "components-tooltip";
    const classes = (0, import_classnames2.default)("components-button", className, {
      "is-secondary": variant === "secondary",
      "is-primary": variant === "primary",
      "is-small": isSmall,
      "is-tertiary": variant === "tertiary",
      "is-pressed": isPressed,
      "is-busy": isBusy,
      "is-link": variant === "link",
      "is-destructive": isDestructive,
      "has-text": !!icon && hasChildren,
      "has-icon": !!icon
    });
    const trulyDisabled = disabled && !isFocusable2;
    const Tag = href !== void 0 && !trulyDisabled ? "a" : "button";
    const tagProps = Tag === "a" ? {
      href,
      target
    } : {
      type: "button",
      disabled: trulyDisabled,
      "aria-pressed": isPressed
    };
    if (disabled && isFocusable2) {
      tagProps["aria-disabled"] = true;
      for (const disabledEvent of disabledEventsOnDisabledButton) {
        additionalProps[disabledEvent] = (event) => {
          event.stopPropagation();
          event.preventDefault();
        };
      }
    }
    const shouldShowTooltip = !trulyDisabled && (showTooltip && label || shortcut || !!label && !(children !== null && children !== void 0 && children.length) && false !== showTooltip);
    const descriptionId = describedBy ? instanceId : null;
    const describedById = additionalProps["aria-describedby"] || descriptionId;
    const element = (0, import_react.createElement)(Tag, _extends({}, tagProps, additionalProps, {
      className: classes,
      "aria-label": additionalProps["aria-label"] || label,
      "aria-describedby": describedById,
      ref: ref2
    }), icon && iconPosition === "left" && (0, import_react.createElement)(icon_default2, {
      icon,
      size: iconSize
    }), text3 && (0, import_react.createElement)(import_react.Fragment, null, text3), icon && iconPosition === "right" && (0, import_react.createElement)(icon_default2, {
      icon,
      size: iconSize
    }), children);
    if (!shouldShowTooltip) {
      return (0, import_react.createElement)(import_react.Fragment, null, element, describedBy && (0, import_react.createElement)(component_default2, null, (0, import_react.createElement)("span", {
        id: descriptionId
      }, describedBy)));
    }
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(tooltip_default, {
      text: children !== null && children !== void 0 && children.length && describedBy ? describedBy : label,
      shortcut,
      position: tooltipPosition
    }, element), describedBy && (0, import_react.createElement)(component_default2, null, (0, import_react.createElement)("span", {
      id: descriptionId
    }, describedBy)));
  }
  var button_default = (0, import_react.forwardRef)(Button);

  // node_modules/@wordpress/components/build-module/scroll-lock/index.js
  var previousScrollTop = 0;
  function setLocked(locked) {
    const scrollingElement = document.scrollingElement || document.body;
    if (locked) {
      previousScrollTop = scrollingElement.scrollTop;
    }
    const methodName = locked ? "add" : "remove";
    scrollingElement.classList[methodName]("lockscroll");
    document.documentElement.classList[methodName]("lockscroll");
    if (!locked) {
      scrollingElement.scrollTop = previousScrollTop;
    }
  }
  var lockCounter = 0;
  function ScrollLock() {
    (0, import_react.useEffect)(() => {
      if (lockCounter === 0) {
        setLocked(true);
      }
      ++lockCounter;
      return () => {
        if (lockCounter === 1) {
          setLocked(false);
        }
        --lockCounter;
      };
    }, []);
    return null;
  }
  var scroll_lock_default = ScrollLock;

  // node_modules/@wordpress/components/build-module/slot-fill/context.js
  var SlotFillContext = (0, import_react.createContext)({
    registerSlot: () => {
    },
    unregisterSlot: () => {
    },
    registerFill: () => {
    },
    unregisterFill: () => {
    },
    getSlot: () => {
    },
    getFills: () => {
    },
    subscribe: () => {
    }
  });
  var context_default3 = SlotFillContext;

  // node_modules/@wordpress/components/build-module/slot-fill/use-slot.js
  var useSlot = (name) => {
    const {
      getSlot,
      subscribe: subscribe4
    } = (0, import_react.useContext)(context_default3);
    const [slot, setSlot] = (0, import_react.useState)(getSlot(name));
    (0, import_react.useEffect)(() => {
      setSlot(getSlot(name));
      const unsubscribe = subscribe4(() => {
        setSlot(getSlot(name));
      });
      return unsubscribe;
    }, [name]);
    return slot;
  };
  var use_slot_default = useSlot;

  // node_modules/@wordpress/components/build-module/slot-fill/fill.js
  function FillComponent(_ref8) {
    let {
      name,
      children,
      registerFill,
      unregisterFill
    } = _ref8;
    const slot = use_slot_default(name);
    const ref2 = (0, import_react.useRef)({
      name,
      children
    });
    (0, import_react.useLayoutEffect)(() => {
      const refValue = ref2.current;
      registerFill(name, refValue);
      return () => unregisterFill(name, refValue);
    }, []);
    (0, import_react.useLayoutEffect)(() => {
      ref2.current.children = children;
      if (slot) {
        slot.forceUpdate();
      }
    }, [children]);
    (0, import_react.useLayoutEffect)(() => {
      if (name === ref2.current.name) {
        return;
      }
      unregisterFill(ref2.current.name, ref2.current);
      ref2.current.name = name;
      registerFill(name, ref2.current);
    }, [name]);
    if (!slot || !slot.node) {
      return null;
    }
    if (typeof children === "function") {
      children = children(slot.props.fillProps);
    }
    return (0, import_react_dom.createPortal)(children, slot.node);
  }
  var Fill = (props) => (0, import_react.createElement)(context_default3.Consumer, null, (_ref22) => {
    let {
      registerFill,
      unregisterFill
    } = _ref22;
    return (0, import_react.createElement)(FillComponent, _extends({}, props, {
      registerFill,
      unregisterFill
    }));
  });
  var fill_default = Fill;

  // node_modules/@wordpress/components/build-module/slot-fill/slot.js
  function isFunction2(maybeFunc) {
    return typeof maybeFunc === "function";
  }
  var SlotComponent = class extends import_react.Component {
    constructor() {
      super(...arguments);
      this.isUnmounted = false;
      this.bindNode = this.bindNode.bind(this);
    }
    componentDidMount() {
      const {
        registerSlot
      } = this.props;
      registerSlot(this.props.name, this);
    }
    componentWillUnmount() {
      const {
        unregisterSlot
      } = this.props;
      this.isUnmounted = true;
      unregisterSlot(this.props.name, this);
    }
    componentDidUpdate(prevProps) {
      const {
        name,
        unregisterSlot,
        registerSlot
      } = this.props;
      if (prevProps.name !== name) {
        unregisterSlot(prevProps.name);
        registerSlot(name, this);
      }
    }
    bindNode(node) {
      this.node = node;
    }
    forceUpdate() {
      if (this.isUnmounted) {
        return;
      }
      super.forceUpdate();
    }
    render() {
      var _getFills;
      const {
        children,
        name,
        fillProps = {},
        getFills
      } = this.props;
      const fills = ((_getFills = getFills(name, this)) !== null && _getFills !== void 0 ? _getFills : []).map((fill) => {
        const fillChildren = isFunction2(fill.children) ? fill.children(fillProps) : fill.children;
        return import_react.Children.map(fillChildren, (child, childIndex) => {
          if (!child || typeof child === "string") {
            return child;
          }
          const childKey = child.key || childIndex;
          return (0, import_react.cloneElement)(child, {
            key: childKey
          });
        });
      }).filter(
        (element) => !isEmptyElement(element)
      );
      return (0, import_react.createElement)(import_react.Fragment, null, isFunction2(children) ? children(fills) : fills);
    }
  };
  var Slot = (props) => (0, import_react.createElement)(context_default3.Consumer, null, (_ref8) => {
    let {
      registerSlot,
      unregisterSlot,
      getFills
    } = _ref8;
    return (0, import_react.createElement)(SlotComponent, _extends({}, props, {
      registerSlot,
      unregisterSlot,
      getFills
    }));
  });
  var slot_default = Slot;

  // node_modules/valtio/esm/index.mjs
  var import_react67 = __toESM(require_react(), 1);

  // node_modules/proxy-compare/dist/index.modern.mjs
  var e3 = Symbol();
  var t4 = Symbol();
  var r4 = Symbol();
  var n4 = (e4, t5) => new Proxy(e4, t5);
  var o5 = Object.getPrototypeOf;
  var s4 = /* @__PURE__ */ new WeakMap();
  var c5 = (e4) => e4 && (s4.has(e4) ? s4.get(e4) : o5(e4) === Object.prototype || o5(e4) === Array.prototype);
  var l4 = (e4) => "object" == typeof e4 && null !== e4;
  var a5 = /* @__PURE__ */ new WeakMap();
  var f4 = (e4) => e4[r4] || e4;
  var i4 = (s5, l5, p5) => {
    if (!c5(s5))
      return s5;
    const y5 = f4(s5), u4 = ((e4) => Object.isFrozen(e4) || Object.values(Object.getOwnPropertyDescriptors(e4)).some((e5) => !e5.writable))(y5);
    let g5 = p5 && p5.get(y5);
    return g5 && g5[1].f === u4 || (g5 = ((n5, o6) => {
      const s6 = { f: o6 };
      let c6 = false;
      const l6 = (t5, r5) => {
        if (!c6) {
          let o7 = s6.a.get(n5);
          o7 || (o7 = /* @__PURE__ */ new Set(), s6.a.set(n5, o7)), r5 && o7.has(e3) || o7.add(t5);
        }
      }, a6 = { get: (e4, t5) => t5 === r4 ? n5 : (l6(t5), i4(e4[t5], s6.a, s6.c)), has: (e4, r5) => r5 === t4 ? (c6 = true, s6.a.delete(n5), true) : (l6(r5), r5 in e4), getOwnPropertyDescriptor: (e4, t5) => (l6(t5, true), Object.getOwnPropertyDescriptor(e4, t5)), ownKeys: (t5) => (l6(e3), Reflect.ownKeys(t5)) };
      return o6 && (a6.set = a6.deleteProperty = () => false), [a6, s6];
    })(y5, u4), g5[1].p = n4(u4 ? ((e4) => {
      let t5 = a5.get(e4);
      if (!t5) {
        if (Array.isArray(e4))
          t5 = Array.from(e4);
        else {
          const r5 = Object.getOwnPropertyDescriptors(e4);
          Object.values(r5).forEach((e5) => {
            e5.configurable = true;
          }), t5 = Object.create(o5(e4), r5);
        }
        a5.set(e4, t5);
      }
      return t5;
    })(y5) : y5, g5[0]), p5 && p5.set(y5, g5)), g5[1].a = l5, g5[1].c = p5, g5[1].p;
  };
  var p4 = (e4, t5) => {
    const r5 = Reflect.ownKeys(e4), n5 = Reflect.ownKeys(t5);
    return r5.length !== n5.length || r5.some((e5, t6) => e5 !== n5[t6]);
  };
  var y4 = (t5, r5, n5, o6) => {
    if (Object.is(t5, r5))
      return false;
    if (!l4(t5) || !l4(r5))
      return true;
    const s5 = n5.get(f4(t5));
    if (!s5)
      return true;
    if (o6) {
      const e4 = o6.get(t5);
      if (e4 && e4.n === r5)
        return e4.g;
      o6.set(t5, { n: r5, g: false });
    }
    let c6 = null;
    for (const l5 of s5) {
      const s6 = l5 === e3 ? p4(t5, r5) : y4(t5[l5], r5[l5], n5, o6);
      if (true !== s6 && false !== s6 || (c6 = s6), c6)
        break;
    }
    return null === c6 && (c6 = true), o6 && o6.set(t5, { n: r5, g: c6 }), c6;
  };
  var g4 = (e4) => c5(e4) && e4[r4] || null;
  var b5 = (e4, t5 = true) => {
    s4.set(e4, t5);
  };

  // node_modules/valtio/esm/index.mjs
  var import_shim = __toESM(require_shim(), 1);

  // node_modules/valtio/esm/vanilla.mjs
  var import_meta = {};
  var isObject4 = (x4) => typeof x4 === "object" && x4 !== null;
  var PROXY_STATE = Symbol();
  var refSet = /* @__PURE__ */ new WeakSet();
  var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x4) => isObject4(x4) && !refSet.has(x4) && (Array.isArray(x4) || !(Symbol.iterator in x4)) && !(x4 instanceof WeakMap) && !(x4 instanceof WeakSet) && !(x4 instanceof Error) && !(x4 instanceof Number) && !(x4 instanceof Date) && !(x4 instanceof String) && !(x4 instanceof RegExp) && !(x4 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
    switch (promise.status) {
      case "fulfilled":
        return promise.value;
      case "rejected":
        throw promise.reason;
      default:
        throw promise;
    }
  }, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, receiver, version, handlePromise = defaultHandlePromise) => {
    const cache2 = snapCache.get(receiver);
    if ((cache2 == null ? void 0 : cache2[0]) === version) {
      return cache2[1];
    }
    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    b5(snap, true);
    snapCache.set(receiver, [version, snap]);
    Reflect.ownKeys(target).forEach((key) => {
      const value = Reflect.get(target, key, receiver);
      if (refSet.has(value)) {
        b5(value, false);
        snap[key] = value;
      } else if (value instanceof Promise) {
        Object.defineProperty(snap, key, {
          get() {
            return handlePromise(value);
          }
        });
      } else if (value == null ? void 0 : value[PROXY_STATE]) {
        snap[key] = snapshot(value, handlePromise);
      } else {
        snap[key] = value;
      }
    });
    return Object.freeze(snap);
  }, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1], proxyFunction2 = (initialObject) => {
    if (!isObject4(initialObject)) {
      throw new Error("object required");
    }
    const found = proxyCache.get(initialObject);
    if (found) {
      return found;
    }
    let version = versionHolder[0];
    const listeners = /* @__PURE__ */ new Set();
    const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
      if (version !== nextVersion) {
        version = nextVersion;
        listeners.forEach((listener2) => listener2(op, nextVersion));
      }
    };
    const propListeners = /* @__PURE__ */ new Map();
    const getPropListener = (prop2) => {
      let propListener = propListeners.get(prop2);
      if (!propListener) {
        propListener = (op, nextVersion) => {
          const newOp = [...op];
          newOp[1] = [prop2, ...newOp[1]];
          notifyUpdate(newOp, nextVersion);
        };
        propListeners.set(prop2, propListener);
      }
      return propListener;
    };
    const popPropListener = (prop2) => {
      const propListener = propListeners.get(prop2);
      propListeners.delete(prop2);
      return propListener;
    };
    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
    const handler = {
      get(target, prop2, receiver) {
        if (prop2 === PROXY_STATE) {
          const state = [
            target,
            receiver,
            version,
            createSnapshot,
            listeners
          ];
          return state;
        }
        return Reflect.get(target, prop2, receiver);
      },
      deleteProperty(target, prop2) {
        var _a;
        const prevValue = Reflect.get(target, prop2);
        const childListeners = (_a = prevValue == null ? void 0 : prevValue[PROXY_STATE]) == null ? void 0 : _a[4];
        if (childListeners) {
          childListeners.delete(popPropListener(prop2));
        }
        const deleted = Reflect.deleteProperty(target, prop2);
        if (deleted) {
          notifyUpdate(["delete", [prop2], prevValue]);
        }
        return deleted;
      },
      set(target, prop2, value, receiver) {
        var _a, _b;
        const hasPrevValue = Reflect.has(target, prop2);
        const prevValue = Reflect.get(target, prop2, receiver);
        if (hasPrevValue && objectIs(prevValue, value)) {
          return true;
        }
        const childListeners = (_a = prevValue == null ? void 0 : prevValue[PROXY_STATE]) == null ? void 0 : _a[4];
        if (childListeners) {
          childListeners.delete(popPropListener(prop2));
        }
        if (isObject4(value)) {
          value = g4(value) || value;
        }
        let nextValue = value;
        if ((_b = Object.getOwnPropertyDescriptor(target, prop2)) == null ? void 0 : _b.set)
          ;
        else if (value instanceof Promise) {
          value.then((v5) => {
            value.status = "fulfilled";
            value.value = v5;
            notifyUpdate(["resolve", [prop2], v5]);
          }).catch((e4) => {
            value.status = "rejected";
            value.reason = e4;
            notifyUpdate(["reject", [prop2], e4]);
          });
        } else {
          if (!(value == null ? void 0 : value[PROXY_STATE]) && canProxy(value)) {
            nextValue = proxy(value);
          }
          if (nextValue == null ? void 0 : nextValue[PROXY_STATE]) {
            nextValue[PROXY_STATE][4].add(
              getPropListener(prop2)
            );
          }
        }
        Reflect.set(target, prop2, nextValue, receiver);
        notifyUpdate(["set", [prop2], value, prevValue]);
        return true;
      }
    };
    const proxyObject = newProxy(baseObject, handler);
    proxyCache.set(initialObject, proxyObject);
    Reflect.ownKeys(initialObject).forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(
        initialObject,
        key
      );
      if (desc.get || desc.set) {
        Object.defineProperty(baseObject, key, desc);
      } else {
        proxyObject[key] = initialObject[key];
      }
    });
    return proxyObject;
  }) => [
    proxyFunction2,
    PROXY_STATE,
    refSet,
    objectIs,
    newProxy,
    canProxy,
    defaultHandlePromise,
    snapCache,
    createSnapshot,
    proxyCache,
    versionHolder
  ];
  var [proxyFunction] = buildProxyFunction();
  function proxy(initialObject = {}) {
    return proxyFunction(initialObject);
  }
  function subscribe3(proxyObject, callback, notifyInSync) {
    if ((import_meta.env && import_meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[PROXY_STATE])) {
      console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const listeners = proxyObject[PROXY_STATE][4];
    const listener2 = (op) => {
      ops.push(op);
      if (notifyInSync) {
        callback(ops.splice(0));
        return;
      }
      if (!promise) {
        promise = Promise.resolve().then(() => {
          promise = void 0;
          if (listeners.has(listener2)) {
            callback(ops.splice(0));
          }
        });
      }
    };
    listeners.add(listener2);
    return () => listeners.delete(listener2);
  }
  function snapshot(proxyObject, handlePromise) {
    if ((import_meta.env && import_meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[PROXY_STATE])) {
      console.warn("Please use proxy object");
    }
    const [target, receiver, version, createSnapshot] = proxyObject[PROXY_STATE];
    return createSnapshot(target, receiver, version, handlePromise);
  }

  // node_modules/valtio/esm/index.mjs
  var import_meta2 = {};
  var { use: use2 } = import_react67.default;
  var { useSyncExternalStore } = import_shim.default;
  var affectedToPathList = (obj, affected) => {
    const list = [];
    const seen = /* @__PURE__ */ new WeakSet();
    const walk = (x4, path) => {
      if (seen.has(x4)) {
        return;
      }
      let used;
      if (typeof x4 === "object" && x4 !== null) {
        seen.add(x4);
        used = affected.get(g4(x4) || x4);
      }
      if (used) {
        used.forEach((key) => {
          if ("value" in (Object.getOwnPropertyDescriptor(x4, key) || {})) {
            walk(x4[key], path ? [...path, key] : [key]);
          }
        });
      } else if (path) {
        list.push(path);
      }
    };
    walk(obj);
    return list;
  };
  var useAffectedDebugValue = (state, affected) => {
    const pathList = (0, import_react67.useRef)();
    (0, import_react67.useEffect)(() => {
      pathList.current = affectedToPathList(state, affected);
    });
    (0, import_react67.useDebugValue)(pathList.current);
  };
  function useSnapshot(proxyObject, options) {
    const notifyInSync = options == null ? void 0 : options.sync;
    const lastSnapshot = (0, import_react67.useRef)();
    const lastAffected = (0, import_react67.useRef)();
    let inRender = true;
    const currSnapshot = useSyncExternalStore(
      (0, import_react67.useCallback)(
        (callback) => {
          const unsub = subscribe3(proxyObject, callback, notifyInSync);
          callback();
          return unsub;
        },
        [proxyObject, notifyInSync]
      ),
      () => {
        const nextSnapshot = snapshot(proxyObject, use2);
        try {
          if (!inRender && lastSnapshot.current && lastAffected.current && !y4(
            lastSnapshot.current,
            nextSnapshot,
            lastAffected.current,
            /* @__PURE__ */ new WeakMap()
          )) {
            return lastSnapshot.current;
          }
        } catch (e4) {
        }
        return nextSnapshot;
      },
      () => snapshot(proxyObject, use2)
    );
    inRender = false;
    const currAffected = /* @__PURE__ */ new WeakMap();
    (0, import_react67.useEffect)(() => {
      lastSnapshot.current = currSnapshot;
      lastAffected.current = currAffected;
    });
    if ((import_meta2.env && import_meta2.env.MODE) !== "production") {
      useAffectedDebugValue(currSnapshot, currAffected);
    }
    const proxyCache = (0, import_react67.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
    return i4(currSnapshot, currAffected, proxyCache);
  }

  // node_modules/valtio/esm/utils.mjs
  var DEVTOOLS = Symbol();
  function proxyMap(entries) {
    const map9 = proxy({
      data: Array.from(entries || []),
      has(key) {
        return this.data.some((p5) => p5[0] === key);
      },
      set(key, value) {
        const record = this.data.find((p5) => p5[0] === key);
        if (record) {
          record[1] = value;
        } else {
          this.data.push([key, value]);
        }
        return this;
      },
      get(key) {
        var _a;
        return (_a = this.data.find((p5) => p5[0] === key)) == null ? void 0 : _a[1];
      },
      delete(key) {
        const index2 = this.data.findIndex((p5) => p5[0] === key);
        if (index2 === -1) {
          return false;
        }
        this.data.splice(index2, 1);
        return true;
      },
      clear() {
        this.data.splice(0);
      },
      get size() {
        return this.data.length;
      },
      toJSON() {
        return new Map(this.data);
      },
      forEach(cb2) {
        this.data.forEach((p5) => {
          cb2(p5[1], p5[0], this);
        });
      },
      keys() {
        return this.data.map((p5) => p5[0]).values();
      },
      values() {
        return this.data.map((p5) => p5[1]).values();
      },
      entries() {
        return new Map(this.data).entries();
      },
      get [Symbol.toStringTag]() {
        return "Map";
      },
      [Symbol.iterator]() {
        return this.entries();
      }
    });
    Object.defineProperties(map9, {
      data: {
        enumerable: false
      },
      size: {
        enumerable: false
      },
      toJSON: {
        enumerable: false
      }
    });
    Object.seal(map9);
    return map9;
  }

  // node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/slot-fill-context.js
  var SlotFillContext2 = (0, import_react.createContext)({
    slots: proxyMap(),
    fills: proxyMap(),
    registerSlot: () => {
      typeof process !== "undefined" && process.env && true ? warning4("Components must be wrapped within `SlotFillProvider`. See https://developer.wordpress.org/block-editor/components/slot-fill/") : void 0;
    },
    updateSlot: () => {
    },
    unregisterSlot: () => {
    },
    registerFill: () => {
    },
    unregisterFill: () => {
    }
  });
  var slot_fill_context_default = SlotFillContext2;

  // node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/use-slot.js
  function useSlot2(name) {
    const {
      updateSlot: registryUpdateSlot,
      unregisterSlot: registryUnregisterSlot,
      registerFill: registryRegisterFill,
      unregisterFill: registryUnregisterFill,
      ...registry
    } = (0, import_react.useContext)(slot_fill_context_default);
    const slots = useSnapshot(registry.slots, {
      sync: true
    });
    const slot = slots.get(name);
    const updateSlot = (0, import_react.useCallback)((fillProps) => {
      registryUpdateSlot(name, fillProps);
    }, [name, registryUpdateSlot]);
    const unregisterSlot = (0, import_react.useCallback)((slotRef) => {
      registryUnregisterSlot(name, slotRef);
    }, [name, registryUnregisterSlot]);
    const registerFill = (0, import_react.useCallback)((fillRef) => {
      registryRegisterFill(name, fillRef);
    }, [name, registryRegisterFill]);
    const unregisterFill = (0, import_react.useCallback)((fillRef) => {
      registryUnregisterFill(name, fillRef);
    }, [name, registryUnregisterFill]);
    return {
      ...slot,
      updateSlot,
      unregisterSlot,
      registerFill,
      unregisterFill
    };
  }

  // node_modules/@wordpress/components/build-module/style-provider/index.js
  var import_react68 = __toESM(require_emotion_react_cjs());
  var import_cache = __toESM(require_emotion_cache_cjs());
  var import_memize5 = __toESM(require_memize());
  var uuidCache = /* @__PURE__ */ new Set();
  var memoizedCreateCacheWithContainer = (0, import_memize5.default)((container) => {
    let key = v4_default().replace(/[0-9]/g, "");
    while (uuidCache.has(key)) {
      key = v4_default().replace(/[0-9]/g, "");
    }
    uuidCache.add(key);
    return (0, import_cache.default)({
      container,
      key
    });
  });
  function StyleProvider(props) {
    const {
      children,
      document: document3
    } = props;
    if (!document3) {
      return null;
    }
    const cache2 = memoizedCreateCacheWithContainer(document3.head);
    return (0, import_react.createElement)(import_react68.CacheProvider, {
      value: cache2
    }, children);
  }
  var style_provider_default = StyleProvider;

  // node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/fill.js
  function useForceUpdate() {
    const [, setState] = (0, import_react.useState)({});
    const mounted = (0, import_react.useRef)(true);
    (0, import_react.useEffect)(() => {
      return () => {
        mounted.current = false;
      };
    }, []);
    return () => {
      if (mounted.current) {
        setState({});
      }
    };
  }
  function Fill2(_ref8) {
    let {
      name,
      children
    } = _ref8;
    const {
      registerFill,
      unregisterFill,
      ...slot
    } = useSlot2(name);
    const ref2 = (0, import_react.useRef)({
      rerender: useForceUpdate()
    });
    (0, import_react.useEffect)(() => {
      registerFill(ref2);
      return () => {
        unregisterFill(ref2);
      };
    }, [registerFill, unregisterFill]);
    if (!slot.ref || !slot.ref.current) {
      return null;
    }
    if (typeof children === "function") {
      children = children(slot.fillProps);
    }
    const wrappedChildren = (0, import_react.createElement)(style_provider_default, {
      document: slot.ref.current.ownerDocument
    }, children);
    return (0, import_react_dom.createPortal)(wrappedChildren, slot.ref.current);
  }

  // node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/slot.js
  function Slot2(_ref8, forwardedRef) {
    let {
      name,
      fillProps = {},
      as: Component2 = "div",
      ...props
    } = _ref8;
    const {
      registerSlot,
      unregisterSlot,
      ...registry
    } = (0, import_react.useContext)(slot_fill_context_default);
    const ref2 = (0, import_react.useRef)();
    (0, import_react.useLayoutEffect)(() => {
      registerSlot(name, ref2, fillProps);
      return () => {
        unregisterSlot(name, ref2);
      };
    }, [registerSlot, unregisterSlot, name]);
    (0, import_react.useLayoutEffect)(() => {
      registry.updateSlot(name, fillProps);
    });
    return (0, import_react.createElement)(Component2, _extends({
      ref: useMergeRefs([forwardedRef, ref2])
    }, props));
  }
  var slot_default2 = (0, import_react.forwardRef)(Slot2);

  // node_modules/@wordpress/components/build-module/slot-fill/bubbles-virtually/use-slot-fills.js
  function useSlotFills(name) {
    const registry = (0, import_react.useContext)(slot_fill_context_default);
    const fills = useSnapshot(registry.fills, {
      sync: true
    });
    return fills.get(name);
  }

  // node_modules/@wordpress/components/build-module/slot-fill/index.js
  function Fill3(props) {
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(fill_default, props), (0, import_react.createElement)(Fill2, props));
  }
  var Slot3 = (0, import_react.forwardRef)((_ref8, ref2) => {
    let {
      bubblesVirtually,
      ...props
    } = _ref8;
    if (bubblesVirtually) {
      return (0, import_react.createElement)(slot_default2, _extends({}, props, {
        ref: ref2
      }));
    }
    return (0, import_react.createElement)(slot_default, props);
  });
  function createSlotFill(name) {
    const FillComponent2 = (props) => (0, import_react.createElement)(Fill3, _extends({
      name
    }, props));
    FillComponent2.displayName = name + "Fill";
    const SlotComponent2 = (props) => (0, import_react.createElement)(Slot3, _extends({
      name
    }, props));
    SlotComponent2.displayName = name + "Slot";
    SlotComponent2.__unstableName = name;
    return {
      Fill: FillComponent2,
      Slot: SlotComponent2
    };
  }

  // node_modules/@wordpress/components/build-module/popover/utils.js
  var POSITION_TO_PLACEMENT = {
    bottom: "bottom",
    top: "top",
    "middle left": "left",
    "middle right": "right",
    "bottom left": "bottom-end",
    "bottom center": "bottom",
    "bottom right": "bottom-start",
    "top left": "top-end",
    "top center": "top",
    "top right": "top-start",
    "middle left left": "left",
    "middle left right": "left",
    "middle left bottom": "left-end",
    "middle left top": "left-start",
    "middle right left": "right",
    "middle right right": "right",
    "middle right bottom": "right-end",
    "middle right top": "right-start",
    "bottom left left": "bottom-end",
    "bottom left right": "bottom-end",
    "bottom left bottom": "bottom-end",
    "bottom left top": "bottom-end",
    "bottom center left": "bottom",
    "bottom center right": "bottom",
    "bottom center bottom": "bottom",
    "bottom center top": "bottom",
    "bottom right left": "bottom-start",
    "bottom right right": "bottom-start",
    "bottom right bottom": "bottom-start",
    "bottom right top": "bottom-start",
    "top left left": "top-end",
    "top left right": "top-end",
    "top left bottom": "top-end",
    "top left top": "top-end",
    "top center left": "top",
    "top center right": "top",
    "top center bottom": "top",
    "top center top": "top",
    "top right left": "top-start",
    "top right right": "top-start",
    "top right bottom": "top-start",
    "top right top": "top-start",
    middle: "bottom",
    "middle center": "bottom",
    "middle center bottom": "bottom",
    "middle center left": "bottom",
    "middle center right": "bottom",
    "middle center top": "bottom"
  };
  var positionToPlacement = (position) => {
    var _POSITION_TO_PLACEMEN;
    return (_POSITION_TO_PLACEMEN = POSITION_TO_PLACEMENT[position]) !== null && _POSITION_TO_PLACEMEN !== void 0 ? _POSITION_TO_PLACEMEN : "bottom";
  };
  var PLACEMENT_TO_ANIMATION_ORIGIN = {
    top: {
      originX: 0.5,
      originY: 1
    },
    "top-start": {
      originX: 0,
      originY: 1
    },
    "top-end": {
      originX: 1,
      originY: 1
    },
    right: {
      originX: 0,
      originY: 0.5
    },
    "right-start": {
      originX: 0,
      originY: 0
    },
    "right-end": {
      originX: 0,
      originY: 1
    },
    bottom: {
      originX: 0.5,
      originY: 0
    },
    "bottom-start": {
      originX: 0,
      originY: 0
    },
    "bottom-end": {
      originX: 1,
      originY: 0
    },
    left: {
      originX: 1,
      originY: 0.5
    },
    "left-start": {
      originX: 1,
      originY: 0
    },
    "left-end": {
      originX: 1,
      originY: 1
    }
  };
  var placementToMotionAnimationProps = (placement) => {
    const translateProp = placement.startsWith("top") || placement.startsWith("bottom") ? "translateY" : "translateX";
    const translateDirection = placement.startsWith("top") || placement.startsWith("left") ? 1 : -1;
    return {
      style: PLACEMENT_TO_ANIMATION_ORIGIN[placement],
      initial: {
        opacity: 0,
        scale: 0,
        [translateProp]: `${2 * translateDirection}em`
      },
      animate: {
        opacity: 1,
        scale: 1,
        [translateProp]: 0
      },
      transition: {
        duration: 0.1,
        ease: [0, 0, 0.2, 1]
      }
    };
  };
  var getFrameOffset = (document3) => {
    var _document$defaultView;
    const frameElement = document3 === null || document3 === void 0 ? void 0 : (_document$defaultView = document3.defaultView) === null || _document$defaultView === void 0 ? void 0 : _document$defaultView.frameElement;
    if (!frameElement) {
      return;
    }
    const iframeRect = frameElement.getBoundingClientRect();
    return {
      x: iframeRect.left,
      y: iframeRect.top
    };
  };
  var getReferenceOwnerDocument = (_ref8) => {
    var _resultingReferenceOw;
    let {
      anchor,
      anchorRef,
      anchorRect,
      getAnchorRect,
      fallbackReferenceElement,
      fallbackDocument
    } = _ref8;
    let resultingReferenceOwnerDoc;
    if (anchor) {
      resultingReferenceOwnerDoc = anchor.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.top) {
      resultingReferenceOwnerDoc = anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.top.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.startContainer) {
      resultingReferenceOwnerDoc = anchorRef.startContainer.ownerDocument;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.current) {
      resultingReferenceOwnerDoc = anchorRef.current.ownerDocument;
    } else if (anchorRef) {
      resultingReferenceOwnerDoc = anchorRef.ownerDocument;
    } else if (anchorRect && anchorRect !== null && anchorRect !== void 0 && anchorRect.ownerDocument) {
      resultingReferenceOwnerDoc = anchorRect.ownerDocument;
    } else if (getAnchorRect) {
      var _getAnchorRect;
      resultingReferenceOwnerDoc = (_getAnchorRect = getAnchorRect(fallbackReferenceElement)) === null || _getAnchorRect === void 0 ? void 0 : _getAnchorRect.ownerDocument;
    }
    return (_resultingReferenceOw = resultingReferenceOwnerDoc) !== null && _resultingReferenceOw !== void 0 ? _resultingReferenceOw : fallbackDocument;
  };
  var getReferenceElement = (_ref22) => {
    var _referenceElement;
    let {
      anchor,
      anchorRef,
      anchorRect,
      getAnchorRect,
      fallbackReferenceElement
    } = _ref22;
    let referenceElement = null;
    if (anchor) {
      referenceElement = anchor;
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.top) {
      referenceElement = {
        getBoundingClientRect() {
          const topRect = anchorRef.top.getBoundingClientRect();
          const bottomRect = anchorRef.bottom.getBoundingClientRect();
          return new window.DOMRect(topRect.x, topRect.y, topRect.width, bottomRect.bottom - topRect.top);
        }
      };
    } else if (anchorRef !== null && anchorRef !== void 0 && anchorRef.current) {
      referenceElement = anchorRef.current;
    } else if (anchorRef) {
      referenceElement = anchorRef;
    } else if (anchorRect) {
      referenceElement = {
        getBoundingClientRect() {
          return anchorRect;
        }
      };
    } else if (getAnchorRect) {
      referenceElement = {
        getBoundingClientRect() {
          var _rect$x, _rect$y, _rect$width, _rect$height;
          const rect = getAnchorRect(fallbackReferenceElement);
          return new window.DOMRect((_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left, (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top, (_rect$width = rect.width) !== null && _rect$width !== void 0 ? _rect$width : rect.right - rect.left, (_rect$height = rect.height) !== null && _rect$height !== void 0 ? _rect$height : rect.bottom - rect.top);
        }
      };
    } else if (fallbackReferenceElement) {
      referenceElement = fallbackReferenceElement.parentElement;
    }
    return (_referenceElement = referenceElement) !== null && _referenceElement !== void 0 ? _referenceElement : null;
  };

  // node_modules/@wordpress/components/build-module/popover/limit-shift.js
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
  }
  function getCrossAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  var limitShift = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return {
      options,
      fn(middlewareArguments) {
        var _middlewareData$frame;
        const {
          x: x4,
          y: y5,
          placement,
          rects,
          middlewareData
        } = middlewareArguments;
        const {
          offset: offset4 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = options;
        const coords = {
          x: x4,
          y: y5
        };
        const mainAxis = getMainAxisFromPlacement(placement);
        const crossAxis = getCrossAxis(mainAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = typeof offset4 === "function" ? offset4(middlewareArguments) : offset4;
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        const additionalFrameOffset = {
          x: 0,
          y: 0,
          ...(_middlewareData$frame = middlewareData.frameOffset) === null || _middlewareData$frame === void 0 ? void 0 : _middlewareData$frame.amount
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis + additionalFrameOffset[mainAxis];
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis + additionalFrameOffset[mainAxis];
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = ["top", "left"].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) === null || _middlewareData$offse2 === void 0 ? void 0 : _middlewareData$offse2[crossAxis]) !== null && _middlewareData$offse !== void 0 ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis) + additionalFrameOffset[crossAxis];
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) === null || _middlewareData$offse4 === void 0 ? void 0 : _middlewareData$offse4[crossAxis]) !== null && _middlewareData$offse3 !== void 0 ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0) + additionalFrameOffset[crossAxis];
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };

  // node_modules/@wordpress/components/build-module/popover/index.js
  var SLOT_NAME = "Popover";
  var ArrowTriangle = () => (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: `0 0 100 100`,
    className: "components-popover__triangle",
    role: "presentation"
  }, (0, import_react.createElement)(Path, {
    className: "components-popover__triangle-bg",
    d: "M 0 0 L 50 50 L 100 0"
  }), (0, import_react.createElement)(Path, {
    className: "components-popover__triangle-border",
    d: "M 0 0 L 50 50 L 100 0",
    vectorEffect: "non-scaling-stroke"
  }));
  var AnimatedWrapper = (0, import_react.forwardRef)((_ref8, forwardedRef) => {
    let {
      style: receivedInlineStyles,
      placement,
      shouldAnimate = false,
      ...props
    } = _ref8;
    const [hasAnimatedOnce, setHasAnimatedOnce] = (0, import_react.useState)(false);
    const shouldReduceMotion = useReducedMotion2();
    const {
      style: motionInlineStyles,
      ...otherMotionProps
    } = (0, import_react.useMemo)(() => placementToMotionAnimationProps(placement), [placement]);
    const onAnimationComplete = (0, import_react.useCallback)(() => setHasAnimatedOnce(true), []);
    const computedAnimationProps = shouldAnimate && !shouldReduceMotion ? {
      style: {
        ...motionInlineStyles,
        ...receivedInlineStyles
      },
      ...otherMotionProps,
      onAnimationComplete,
      animate: hasAnimatedOnce ? false : otherMotionProps.animate
    } : {
      animate: false,
      style: receivedInlineStyles
    };
    return (0, import_react.createElement)(motion.div, _extends({}, computedAnimationProps, props, {
      ref: forwardedRef
    }));
  });
  var slotNameContext = (0, import_react.createContext)(void 0);
  var UnforwardedPopover = (props, forwardedRef) => {
    var _frameOffsetRef$curre, _frameOffsetRef$curre2, _frameOffsetRef$curre3, _frameOffsetRef$curre4;
    const {
      animate: animate3 = true,
      headerTitle,
      onClose,
      children,
      className,
      noArrow = true,
      position,
      placement: placementProp = "bottom-start",
      offset: offsetProp = 0,
      focusOnMount = "firstElement",
      anchor,
      expandOnMobile,
      onFocusOutside,
      __unstableSlotName = SLOT_NAME,
      flip = true,
      resize = true,
      shift = false,
      variant,
      __unstableForcePosition,
      anchorRef,
      anchorRect,
      getAnchorRect,
      isAlternate,
      ...contentProps
    } = props;
    let computedFlipProp = flip;
    let computedResizeProp = resize;
    if (__unstableForcePosition !== void 0) {
      deprecated("`__unstableForcePosition` prop in wp.components.Popover", {
        since: "6.1",
        version: "6.3",
        alternative: "`flip={ false }` and  `resize={ false }`"
      });
      computedFlipProp = !__unstableForcePosition;
      computedResizeProp = !__unstableForcePosition;
    }
    if (anchorRef !== void 0) {
      deprecated("`anchorRef` prop in wp.components.Popover", {
        since: "6.1",
        alternative: "`anchor` prop"
      });
    }
    if (anchorRect !== void 0) {
      deprecated("`anchorRect` prop in wp.components.Popover", {
        since: "6.1",
        alternative: "`anchor` prop"
      });
    }
    if (getAnchorRect !== void 0) {
      deprecated("`getAnchorRect` prop in wp.components.Popover", {
        since: "6.1",
        alternative: "`anchor` prop"
      });
    }
    const computedVariant = isAlternate ? "toolbar" : variant;
    if (isAlternate !== void 0) {
      deprecated("`isAlternate` prop in wp.components.Popover", {
        since: "6.2",
        alternative: "`variant` prop with the `'toolbar'` value"
      });
    }
    const arrowRef = (0, import_react.useRef)(null);
    const [fallbackReferenceElement, setFallbackReferenceElement] = (0, import_react.useState)(null);
    const [referenceOwnerDocument, setReferenceOwnerDocument] = (0, import_react.useState)();
    const anchorRefFallback = (0, import_react.useCallback)((node) => {
      setFallbackReferenceElement(node);
    }, []);
    const isMobileViewport = use_viewport_match_default("medium", "<");
    const isExpanded = expandOnMobile && isMobileViewport;
    const hasArrow = !isExpanded && !noArrow;
    const normalizedPlacementFromProps = position ? positionToPlacement(position) : placementProp;
    const frameOffsetRef = (0, import_react.useRef)(getFrameOffset(referenceOwnerDocument));
    const middleware = [
      {
        name: "frameOffset",
        fn(_ref22) {
          let {
            x: x5,
            y: y6
          } = _ref22;
          if (!frameOffsetRef.current) {
            return {
              x: x5,
              y: y6
            };
          }
          return {
            x: x5 + frameOffsetRef.current.x,
            y: y6 + frameOffsetRef.current.y,
            data: {
              amount: frameOffsetRef.current
            }
          };
        }
      },
      T(offsetProp),
      computedFlipProp ? b2() : void 0,
      computedResizeProp ? k2({
        apply(sizeProps) {
          var _refs$floating$curren;
          const {
            firstElementChild
          } = (_refs$floating$curren = refs.floating.current) !== null && _refs$floating$curren !== void 0 ? _refs$floating$curren : {};
          if (!(firstElementChild instanceof HTMLElement))
            return;
          Object.assign(firstElementChild.style, {
            maxHeight: `${sizeProps.availableHeight}px`,
            overflow: "auto"
          });
        }
      }) : void 0,
      shift ? L({
        crossAxis: true,
        limiter: limitShift(),
        padding: 1
      }) : void 0,
      arrow({
        element: arrowRef
      })
    ].filter((m4) => m4 !== void 0);
    const slotName = (0, import_react.useContext)(slotNameContext) || __unstableSlotName;
    const slot = useSlot2(slotName);
    let onDialogClose;
    if (onClose || onFocusOutside) {
      onDialogClose = (type, event) => {
        if (type === "focus-outside" && onFocusOutside) {
          onFocusOutside(event);
        } else if (onClose) {
          onClose();
        }
      };
    }
    const [dialogRef, dialogProps] = use_dialog_default({
      focusOnMount,
      __unstableOnClose: onDialogClose,
      onClose: onDialogClose
    });
    const {
      x: x4,
      y: y5,
      reference: referenceCallbackRef,
      floating,
      refs,
      strategy,
      update: update3,
      placement: computedPlacement,
      middlewareData: {
        arrow: arrowData
      }
    } = useFloating({
      placement: normalizedPlacementFromProps,
      middleware,
      whileElementsMounted: (referenceParam, floatingParam, updateParam) => z(referenceParam, floatingParam, updateParam, {
        animationFrame: true
      })
    });
    const arrowCallbackRef = (0, import_react.useCallback)((node) => {
      arrowRef.current = node;
      update3();
    }, [update3]);
    (0, import_react.useLayoutEffect)(() => {
      const resultingReferenceOwnerDoc = getReferenceOwnerDocument({
        anchor,
        anchorRef,
        anchorRect,
        getAnchorRect,
        fallbackReferenceElement,
        fallbackDocument: document
      });
      const resultingReferenceElement = getReferenceElement({
        anchor,
        anchorRef,
        anchorRect,
        getAnchorRect,
        fallbackReferenceElement
      });
      referenceCallbackRef(resultingReferenceElement);
      setReferenceOwnerDocument(resultingReferenceOwnerDoc);
    }, [anchor, anchorRef, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.top, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.bottom, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.startContainer, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current, anchorRect, getAnchorRect, fallbackReferenceElement, referenceCallbackRef]);
    (0, import_react.useLayoutEffect)(() => {
      var _refs$floating, _refs$floating$curren2, _referenceOwnerDocume;
      if (referenceOwnerDocument === document || referenceOwnerDocument === (refs === null || refs === void 0 ? void 0 : (_refs$floating = refs.floating) === null || _refs$floating === void 0 ? void 0 : (_refs$floating$curren2 = _refs$floating.current) === null || _refs$floating$curren2 === void 0 ? void 0 : _refs$floating$curren2.ownerDocument) || !(referenceOwnerDocument !== null && referenceOwnerDocument !== void 0 && (_referenceOwnerDocume = referenceOwnerDocument.defaultView) !== null && _referenceOwnerDocume !== void 0 && _referenceOwnerDocume.frameElement)) {
        frameOffsetRef.current = void 0;
        return;
      }
      const {
        defaultView
      } = referenceOwnerDocument;
      const updateFrameOffset = () => {
        frameOffsetRef.current = getFrameOffset(referenceOwnerDocument);
        update3();
      };
      defaultView.addEventListener("resize", updateFrameOffset);
      updateFrameOffset();
      return () => {
        defaultView.removeEventListener("resize", updateFrameOffset);
      };
    }, [referenceOwnerDocument, update3]);
    const mergedFloatingRef = useMergeRefs([floating, dialogRef, forwardedRef]);
    let content = (0, import_react.createElement)(AnimatedWrapper, _extends({
      shouldAnimate: animate3 && !isExpanded,
      placement: computedPlacement,
      className: (0, import_classnames3.default)("components-popover", className, {
        "is-expanded": isExpanded,
        [`is-${computedVariant === "toolbar" ? "alternate" : computedVariant}`]: computedVariant
      })
    }, contentProps, {
      ref: mergedFloatingRef
    }, dialogProps, {
      tabIndex: -1,
      style: isExpanded ? void 0 : {
        position: strategy,
        left: Number.isNaN(x4) ? 0 : x4 !== null && x4 !== void 0 ? x4 : void 0,
        top: Number.isNaN(y5) ? 0 : y5 !== null && y5 !== void 0 ? y5 : void 0
      }
    }), isExpanded && (0, import_react.createElement)(scroll_lock_default, null), isExpanded && (0, import_react.createElement)("div", {
      className: "components-popover__header"
    }, (0, import_react.createElement)("span", {
      className: "components-popover__header-title"
    }, headerTitle), (0, import_react.createElement)(button_default, {
      className: "components-popover__close",
      icon: close_default,
      onClick: onClose
    })), (0, import_react.createElement)("div", {
      className: "components-popover__content"
    }, children), hasArrow && (0, import_react.createElement)("div", {
      ref: arrowCallbackRef,
      className: ["components-popover__arrow", `is-${computedPlacement.split("-")[0]}`].join(" "),
      style: {
        left: typeof (arrowData === null || arrowData === void 0 ? void 0 : arrowData.x) !== "undefined" && Number.isFinite(arrowData.x) ? `${arrowData.x + ((_frameOffsetRef$curre = (_frameOffsetRef$curre2 = frameOffsetRef.current) === null || _frameOffsetRef$curre2 === void 0 ? void 0 : _frameOffsetRef$curre2.x) !== null && _frameOffsetRef$curre !== void 0 ? _frameOffsetRef$curre : 0)}px` : "",
        top: typeof (arrowData === null || arrowData === void 0 ? void 0 : arrowData.y) !== "undefined" && Number.isFinite(arrowData.y) ? `${arrowData.y + ((_frameOffsetRef$curre3 = (_frameOffsetRef$curre4 = frameOffsetRef.current) === null || _frameOffsetRef$curre4 === void 0 ? void 0 : _frameOffsetRef$curre4.y) !== null && _frameOffsetRef$curre3 !== void 0 ? _frameOffsetRef$curre3 : 0)}px` : ""
      }
    }, (0, import_react.createElement)(ArrowTriangle, null)));
    if (slot.ref) {
      content = (0, import_react.createElement)(Fill3, {
        name: slotName
      }, content);
    }
    if (anchorRef || anchorRect || anchor) {
      return content;
    }
    return (0, import_react.createElement)("span", {
      ref: anchorRefFallback
    }, content);
  };
  var Popover = (0, import_react.forwardRef)(UnforwardedPopover);
  function PopoverSlot(_ref32, ref2) {
    let {
      name = SLOT_NAME
    } = _ref32;
    return (0, import_react.createElement)(
      Slot3,
      {
        bubblesVirtually: true,
        name,
        className: "popover-slot",
        ref: ref2
      }
    );
  }
  Popover.Slot = (0, import_react.forwardRef)(PopoverSlot);
  Popover.__unstableSlotNameProvider = slotNameContext.Provider;
  var popover_default = Popover;

  // node_modules/@wordpress/components/build-module/shortcut/index.js
  function Shortcut(props) {
    const {
      shortcut,
      className
    } = props;
    if (!shortcut) {
      return null;
    }
    let displayText;
    let ariaLabel;
    if (typeof shortcut === "string") {
      displayText = shortcut;
    }
    if (shortcut !== null && typeof shortcut === "object") {
      displayText = shortcut.display;
      ariaLabel = shortcut.ariaLabel;
    }
    return (0, import_react.createElement)("span", {
      className,
      "aria-label": ariaLabel
    }, displayText);
  }
  var shortcut_default = Shortcut;

  // node_modules/@wordpress/components/build-module/tooltip/index.js
  var TOOLTIP_DELAY = 700;
  var eventCatcher = (0, import_react.createElement)("div", {
    className: "event-catcher"
  });
  var getDisabledElement = (_ref8) => {
    let {
      eventHandlers,
      child,
      childrenWithPopover,
      mergedRefs
    } = _ref8;
    return (0, import_react.cloneElement)((0, import_react.createElement)("span", {
      className: "disabled-element-wrapper"
    }, (0, import_react.cloneElement)(eventCatcher, eventHandlers), (0, import_react.cloneElement)(child, {
      children: childrenWithPopover,
      ref: mergedRefs
    })), {
      ...eventHandlers
    });
  };
  var getRegularElement = (_ref22) => {
    let {
      child,
      eventHandlers,
      childrenWithPopover,
      mergedRefs
    } = _ref22;
    return (0, import_react.cloneElement)(child, {
      ...eventHandlers,
      children: childrenWithPopover,
      ref: mergedRefs
    });
  };
  var addPopoverToGrandchildren = (_ref32) => {
    let {
      anchor,
      grandchildren,
      isOver,
      offset: offset4,
      position,
      shortcut,
      text: text3
    } = _ref32;
    return concatChildren(grandchildren, isOver && (0, import_react.createElement)(popover_default, {
      focusOnMount: false,
      position,
      className: "components-tooltip",
      "aria-hidden": "true",
      animate: false,
      offset: offset4,
      anchor,
      shift: true
    }, text3, (0, import_react.createElement)(shortcut_default, {
      className: "components-tooltip__shortcut",
      shortcut
    })));
  };
  var emitToChild = (children, eventName, event) => {
    if (import_react.Children.count(children) !== 1) {
      return;
    }
    const child = import_react.Children.only(children);
    if (child.props.disabled) {
      return;
    }
    if (typeof child.props[eventName] === "function") {
      child.props[eventName](event);
    }
  };
  function Tooltip(props) {
    var _Children$toArray$;
    const {
      children,
      position = "bottom middle",
      text: text3,
      shortcut,
      delay = TOOLTIP_DELAY
    } = props;
    const [isMouseDown, setIsMouseDown] = (0, import_react.useState)(false);
    const [isOver, setIsOver] = (0, import_react.useState)(false);
    const delayedSetIsOver = useDebounce(setIsOver, delay);
    const [popoverAnchor, setPopoverAnchor] = (0, import_react.useState)(null);
    const existingChildRef = (_Children$toArray$ = import_react.Children.toArray(children)[0]) === null || _Children$toArray$ === void 0 ? void 0 : _Children$toArray$.ref;
    const mergedChildRefs = useMergeRefs([setPopoverAnchor, existingChildRef]);
    const createMouseDown = (event) => {
      if (event.target.tagName === "OPTION") {
        return;
      }
      emitToChild(children, "onMouseDown", event);
      document.addEventListener("mouseup", cancelIsMouseDown);
      setIsMouseDown(true);
    };
    const createMouseUp = (event) => {
      if (event.target.tagName === "OPTION") {
        return;
      }
      emitToChild(children, "onMouseUp", event);
      document.removeEventListener("mouseup", cancelIsMouseDown);
      setIsMouseDown(false);
    };
    const createMouseEvent = (type) => {
      if (type === "mouseUp")
        return createMouseUp;
      if (type === "mouseDown")
        return createMouseDown;
    };
    const cancelIsMouseDown = createMouseEvent("mouseUp");
    const createToggleIsOver = (eventName, isDelayed) => {
      return (event) => {
        emitToChild(children, eventName, event);
        if (event.currentTarget.disabled) {
          return;
        }
        if ("focus" === event.type && isMouseDown) {
          return;
        }
        delayedSetIsOver.cancel();
        const _isOver = ["focus", "mouseenter"].includes(event.type);
        if (_isOver === isOver) {
          return;
        }
        if (isDelayed) {
          delayedSetIsOver(_isOver);
        } else {
          setIsOver(_isOver);
        }
      };
    };
    const clearOnUnmount = () => {
      delayedSetIsOver.cancel();
      document.removeEventListener("mouseup", cancelIsMouseDown);
    };
    (0, import_react.useEffect)(() => clearOnUnmount, []);
    if (import_react.Children.count(children) !== 1) {
      if (true) {
        console.error("Tooltip should be called with only a single child element.");
      }
      return children;
    }
    const eventHandlers = {
      onMouseEnter: createToggleIsOver("onMouseEnter", true),
      onMouseLeave: createToggleIsOver("onMouseLeave"),
      onClick: createToggleIsOver("onClick"),
      onFocus: createToggleIsOver("onFocus"),
      onBlur: createToggleIsOver("onBlur"),
      onMouseDown: createMouseEvent("mouseDown")
    };
    const child = import_react.Children.only(children);
    const {
      children: grandchildren,
      disabled
    } = child.props;
    const getElementWithPopover = disabled ? getDisabledElement : getRegularElement;
    const popoverData = {
      anchor: popoverAnchor,
      isOver,
      offset: 4,
      position,
      shortcut,
      text: text3
    };
    const childrenWithPopover = addPopoverToGrandchildren({
      grandchildren,
      ...popoverData
    });
    return getElementWithPopover({
      child,
      eventHandlers,
      childrenWithPopover,
      mergedRefs: mergedChildRefs
    });
  }
  var tooltip_default = Tooltip;

  // node_modules/@wordpress/components/build-module/flex/flex/hook.js
  var import_react69 = __toESM(require_emotion_react_cjs());

  // node_modules/@wordpress/components/build-module/ui/utils/use-responsive-value.js
  var breakpoints = ["40em", "52em", "64em"];
  var useBreakpointIndex = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      defaultIndex = 0
    } = options;
    if (typeof defaultIndex !== "number") {
      throw new TypeError(`Default breakpoint index should be a number. Got: ${defaultIndex}, ${typeof defaultIndex}`);
    } else if (defaultIndex < 0 || defaultIndex > breakpoints.length - 1) {
      throw new RangeError(`Default breakpoint index out of range. Theme has ${breakpoints.length} breakpoints, got index ${defaultIndex}`);
    }
    const [value, setValue] = (0, import_react.useState)(defaultIndex);
    (0, import_react.useEffect)(() => {
      const getIndex = () => breakpoints.filter((bp) => {
        return typeof window !== "undefined" ? window.matchMedia(`screen and (min-width: ${bp})`).matches : false;
      }).length;
      const onResize = () => {
        const newValue = getIndex();
        if (value !== newValue) {
          setValue(newValue);
        }
      };
      onResize();
      if (typeof window !== "undefined") {
        window.addEventListener("resize", onResize);
      }
      return () => {
        if (typeof window !== "undefined") {
          window.removeEventListener("resize", onResize);
        }
      };
    }, [value]);
    return value;
  };
  function useResponsiveValue(values) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const index2 = useBreakpointIndex(options);
    if (!Array.isArray(values) && typeof values !== "function")
      return values;
    const array = values || [];
    return array[index2 >= array.length ? array.length - 1 : index2];
  }

  // node_modules/@wordpress/components/build-module/flex/styles.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__3() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var Flex = false ? {
    name: "zjik7",
    styles: "display:flex"
  } : {
    name: "a57899-Flex",
    styles: "display:flex;label:Flex;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS3VCIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBGbGV4ID0gY3NzYFxuXHRkaXNwbGF5OiBmbGV4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEl0ZW0gPSBjc3NgXG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXgtaGVpZ2h0OiAxMDAlO1xuXHRtYXgtd2lkdGg6IDEwMCU7XG5cdG1pbi1oZWlnaHQ6IDA7XG5cdG1pbi13aWR0aDogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBibG9jayA9IGNzc2Bcblx0ZmxleDogMTtcbmA7XG5cbi8qKlxuICogV29ya2Fyb3VuZCB0byBvcHRpbWl6ZSBET00gcmVuZGVyaW5nLlxuICogV2UnbGwgZW5oYW5jZSBhbGlnbm1lbnQgd2l0aCBuYWl2ZSBwYXJlbnQgZmxleCBhc3N1bXB0aW9ucy5cbiAqXG4gKiBUcmFkZS1vZmY6XG4gKiBGYXIgbGVzcyBET00gbGVzcy4gSG93ZXZlciwgVUkgcmVuZGVyaW5nIGlzIG5vdCBhcyByZWxpYWJsZS5cbiAqL1xuXG4vKipcbiAqIEltcHJvdmVzIHN0YWJpbGl0eSBvZiB3aWR0aC9oZWlnaHQgcmVuZGVyaW5nLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0l0c0pvblEvZzIvcHVsbC8xNDlcbiAqL1xuZXhwb3J0IGNvbnN0IEl0ZW1zQ29sdW1uID0gY3NzYFxuXHQ+ICoge1xuXHRcdG1pbi1oZWlnaHQ6IDA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBJdGVtc1JvdyA9IGNzc2Bcblx0PiAqIHtcblx0XHRtaW4td2lkdGg6IDA7XG5cdH1cbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__3
  };
  var Item = false ? {
    name: "qgaee5",
    styles: "display:block;max-height:100%;max-width:100%;min-height:0;min-width:0"
  } : {
    name: "14ac8g8-Item",
    styles: "display:block;max-height:100%;max-width:100%;min-height:0;min-width:0;label:Item;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBU3VCIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBGbGV4ID0gY3NzYFxuXHRkaXNwbGF5OiBmbGV4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEl0ZW0gPSBjc3NgXG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXgtaGVpZ2h0OiAxMDAlO1xuXHRtYXgtd2lkdGg6IDEwMCU7XG5cdG1pbi1oZWlnaHQ6IDA7XG5cdG1pbi13aWR0aDogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBibG9jayA9IGNzc2Bcblx0ZmxleDogMTtcbmA7XG5cbi8qKlxuICogV29ya2Fyb3VuZCB0byBvcHRpbWl6ZSBET00gcmVuZGVyaW5nLlxuICogV2UnbGwgZW5oYW5jZSBhbGlnbm1lbnQgd2l0aCBuYWl2ZSBwYXJlbnQgZmxleCBhc3N1bXB0aW9ucy5cbiAqXG4gKiBUcmFkZS1vZmY6XG4gKiBGYXIgbGVzcyBET00gbGVzcy4gSG93ZXZlciwgVUkgcmVuZGVyaW5nIGlzIG5vdCBhcyByZWxpYWJsZS5cbiAqL1xuXG4vKipcbiAqIEltcHJvdmVzIHN0YWJpbGl0eSBvZiB3aWR0aC9oZWlnaHQgcmVuZGVyaW5nLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0l0c0pvblEvZzIvcHVsbC8xNDlcbiAqL1xuZXhwb3J0IGNvbnN0IEl0ZW1zQ29sdW1uID0gY3NzYFxuXHQ+ICoge1xuXHRcdG1pbi1oZWlnaHQ6IDA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBJdGVtc1JvdyA9IGNzc2Bcblx0PiAqIHtcblx0XHRtaW4td2lkdGg6IDA7XG5cdH1cbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__3
  };
  var block = false ? {
    name: "82a6rk",
    styles: "flex:1"
  } : {
    name: "1ya6i3g-block",
    styles: "flex:1;label:block;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJ3QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2ZsZXgvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgRmxleCA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcbmA7XG5cbmV4cG9ydCBjb25zdCBJdGVtID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcblx0bWF4LWhlaWdodDogMTAwJTtcblx0bWF4LXdpZHRoOiAxMDAlO1xuXHRtaW4taGVpZ2h0OiAwO1xuXHRtaW4td2lkdGg6IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgYmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG4vKipcbiAqIFdvcmthcm91bmQgdG8gb3B0aW1pemUgRE9NIHJlbmRlcmluZy5cbiAqIFdlJ2xsIGVuaGFuY2UgYWxpZ25tZW50IHdpdGggbmFpdmUgcGFyZW50IGZsZXggYXNzdW1wdGlvbnMuXG4gKlxuICogVHJhZGUtb2ZmOlxuICogRmFyIGxlc3MgRE9NIGxlc3MuIEhvd2V2ZXIsIFVJIHJlbmRlcmluZyBpcyBub3QgYXMgcmVsaWFibGUuXG4gKi9cblxuLyoqXG4gKiBJbXByb3ZlcyBzdGFiaWxpdHkgb2Ygd2lkdGgvaGVpZ2h0IHJlbmRlcmluZy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9JdHNKb25RL2cyL3B1bGwvMTQ5XG4gKi9cbmV4cG9ydCBjb25zdCBJdGVtc0NvbHVtbiA9IGNzc2Bcblx0PiAqIHtcblx0XHRtaW4taGVpZ2h0OiAwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgSXRlbXNSb3cgPSBjc3NgXG5cdD4gKiB7XG5cdFx0bWluLXdpZHRoOiAwO1xuXHR9XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__3
  };
  var ItemsColumn = false ? {
    name: "13nosa1",
    styles: ">*{min-height:0;}"
  } : {
    name: "9k4k7f-ItemsColumn",
    styles: ">*{min-height:0;};label:ItemsColumn;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUM4QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2ZsZXgvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgRmxleCA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcbmA7XG5cbmV4cG9ydCBjb25zdCBJdGVtID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcblx0bWF4LWhlaWdodDogMTAwJTtcblx0bWF4LXdpZHRoOiAxMDAlO1xuXHRtaW4taGVpZ2h0OiAwO1xuXHRtaW4td2lkdGg6IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgYmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG4vKipcbiAqIFdvcmthcm91bmQgdG8gb3B0aW1pemUgRE9NIHJlbmRlcmluZy5cbiAqIFdlJ2xsIGVuaGFuY2UgYWxpZ25tZW50IHdpdGggbmFpdmUgcGFyZW50IGZsZXggYXNzdW1wdGlvbnMuXG4gKlxuICogVHJhZGUtb2ZmOlxuICogRmFyIGxlc3MgRE9NIGxlc3MuIEhvd2V2ZXIsIFVJIHJlbmRlcmluZyBpcyBub3QgYXMgcmVsaWFibGUuXG4gKi9cblxuLyoqXG4gKiBJbXByb3ZlcyBzdGFiaWxpdHkgb2Ygd2lkdGgvaGVpZ2h0IHJlbmRlcmluZy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9JdHNKb25RL2cyL3B1bGwvMTQ5XG4gKi9cbmV4cG9ydCBjb25zdCBJdGVtc0NvbHVtbiA9IGNzc2Bcblx0PiAqIHtcblx0XHRtaW4taGVpZ2h0OiAwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgSXRlbXNSb3cgPSBjc3NgXG5cdD4gKiB7XG5cdFx0bWluLXdpZHRoOiAwO1xuXHR9XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__3
  };
  var ItemsRow = false ? {
    name: "1pwxzk4",
    styles: ">*{min-width:0;}"
  } : {
    name: "1ozeagb-ItemsRow",
    styles: ">*{min-width:0;};label:ItemsRow;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBdUMyQiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2ZsZXgvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgRmxleCA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcbmA7XG5cbmV4cG9ydCBjb25zdCBJdGVtID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcblx0bWF4LWhlaWdodDogMTAwJTtcblx0bWF4LXdpZHRoOiAxMDAlO1xuXHRtaW4taGVpZ2h0OiAwO1xuXHRtaW4td2lkdGg6IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgYmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG4vKipcbiAqIFdvcmthcm91bmQgdG8gb3B0aW1pemUgRE9NIHJlbmRlcmluZy5cbiAqIFdlJ2xsIGVuaGFuY2UgYWxpZ25tZW50IHdpdGggbmFpdmUgcGFyZW50IGZsZXggYXNzdW1wdGlvbnMuXG4gKlxuICogVHJhZGUtb2ZmOlxuICogRmFyIGxlc3MgRE9NIGxlc3MuIEhvd2V2ZXIsIFVJIHJlbmRlcmluZyBpcyBub3QgYXMgcmVsaWFibGUuXG4gKi9cblxuLyoqXG4gKiBJbXByb3ZlcyBzdGFiaWxpdHkgb2Ygd2lkdGgvaGVpZ2h0IHJlbmRlcmluZy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9JdHNKb25RL2cyL3B1bGwvMTQ5XG4gKi9cbmV4cG9ydCBjb25zdCBJdGVtc0NvbHVtbiA9IGNzc2Bcblx0PiAqIHtcblx0XHRtaW4taGVpZ2h0OiAwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgSXRlbXNSb3cgPSBjc3NgXG5cdD4gKiB7XG5cdFx0bWluLXdpZHRoOiAwO1xuXHR9XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__3
  };

  // node_modules/@wordpress/components/build-module/flex/flex/hook.js
  function useDeprecatedProps2(props) {
    const {
      isReversed,
      ...otherProps
    } = props;
    if (typeof isReversed !== "undefined") {
      deprecated("Flex isReversed", {
        alternative: 'Flex direction="row-reverse" or "column-reverse"',
        since: "5.9"
      });
      return {
        ...otherProps,
        direction: isReversed ? "row-reverse" : "row"
      };
    }
    return otherProps;
  }
  function useFlex(props) {
    const {
      align = "center",
      className,
      direction: directionProp = "row",
      expanded = true,
      gap = 2,
      justify = "space-between",
      wrap: wrap3 = false,
      ...otherProps
    } = useContextSystem(useDeprecatedProps2(props), "Flex");
    const directionAsArray = Array.isArray(directionProp) ? directionProp : [directionProp];
    const direction = useResponsiveValue(directionAsArray);
    const isColumn = typeof direction === "string" && !!direction.includes("column");
    const isReverse = typeof direction === "string" && direction.includes("reverse");
    const cx = useCx();
    const classes = (0, import_react.useMemo)(() => {
      const base = /* @__PURE__ */ (0, import_react69.css)({
        alignItems: isColumn ? "normal" : align,
        flexDirection: direction,
        flexWrap: wrap3 ? "wrap" : void 0,
        gap: space(gap),
        justifyContent: justify,
        height: isColumn && expanded ? "100%" : void 0,
        width: !isColumn && expanded ? "100%" : void 0
      }, false ? "" : ";label:base;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9mbGV4L2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUVlIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9mbGV4L2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcbmltcG9ydCBkZXByZWNhdGVkIGZyb20gJ0B3b3JkcHJlc3MvZGVwcmVjYXRlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyB1c2VSZXNwb25zaXZlVmFsdWUgfSBmcm9tICcuLi8uLi91aS91dGlscy91c2UtcmVzcG9uc2l2ZS12YWx1ZSc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuLi9zdHlsZXMnO1xuaW1wb3J0IHsgdXNlQ3ggfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IEZsZXhQcm9wcyB9IGZyb20gJy4uL3R5cGVzJztcblxuZnVuY3Rpb24gdXNlRGVwcmVjYXRlZFByb3BzKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IEZsZXhQcm9wcywgJ2RpdicgPlxuKTogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IEZsZXhQcm9wcywgJ2RpdicgPiB7XG5cdGNvbnN0IHsgaXNSZXZlcnNlZCwgLi4ub3RoZXJQcm9wcyB9ID0gcHJvcHM7XG5cblx0aWYgKCB0eXBlb2YgaXNSZXZlcnNlZCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0ZGVwcmVjYXRlZCggJ0ZsZXggaXNSZXZlcnNlZCcsIHtcblx0XHRcdGFsdGVybmF0aXZlOiAnRmxleCBkaXJlY3Rpb249XCJyb3ctcmV2ZXJzZVwiIG9yIFwiY29sdW1uLXJldmVyc2VcIicsXG5cdFx0XHRzaW5jZTogJzUuOScsXG5cdFx0fSApO1xuXHRcdHJldHVybiB7XG5cdFx0XHQuLi5vdGhlclByb3BzLFxuXHRcdFx0ZGlyZWN0aW9uOiBpc1JldmVyc2VkID8gJ3Jvdy1yZXZlcnNlJyA6ICdyb3cnLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gb3RoZXJQcm9wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZsZXgoIHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczwgRmxleFByb3BzLCAnZGl2JyA+ICkge1xuXHRjb25zdCB7XG5cdFx0YWxpZ24gPSAnY2VudGVyJyxcblx0XHRjbGFzc05hbWUsXG5cdFx0ZGlyZWN0aW9uOiBkaXJlY3Rpb25Qcm9wID0gJ3JvdycsXG5cdFx0ZXhwYW5kZWQgPSB0cnVlLFxuXHRcdGdhcCA9IDIsXG5cdFx0anVzdGlmeSA9ICdzcGFjZS1iZXR3ZWVuJyxcblx0XHR3cmFwID0gZmFsc2UsXG5cdFx0Li4ub3RoZXJQcm9wc1xuXHR9ID0gdXNlQ29udGV4dFN5c3RlbSggdXNlRGVwcmVjYXRlZFByb3BzKCBwcm9wcyApLCAnRmxleCcgKTtcblxuXHRjb25zdCBkaXJlY3Rpb25Bc0FycmF5ID0gQXJyYXkuaXNBcnJheSggZGlyZWN0aW9uUHJvcCApXG5cdFx0PyBkaXJlY3Rpb25Qcm9wXG5cdFx0OiBbIGRpcmVjdGlvblByb3AgXTtcblx0Y29uc3QgZGlyZWN0aW9uID0gdXNlUmVzcG9uc2l2ZVZhbHVlKCBkaXJlY3Rpb25Bc0FycmF5ICk7XG5cblx0Y29uc3QgaXNDb2x1bW4gPVxuXHRcdHR5cGVvZiBkaXJlY3Rpb24gPT09ICdzdHJpbmcnICYmICEhIGRpcmVjdGlvbi5pbmNsdWRlcyggJ2NvbHVtbicgKTtcblx0Y29uc3QgaXNSZXZlcnNlID1cblx0XHR0eXBlb2YgZGlyZWN0aW9uID09PSAnc3RyaW5nJyAmJiBkaXJlY3Rpb24uaW5jbHVkZXMoICdyZXZlcnNlJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gdXNlTWVtbyggKCkgPT4ge1xuXHRcdGNvbnN0IGJhc2UgPSBjc3MoIHtcblx0XHRcdGFsaWduSXRlbXM6IGlzQ29sdW1uID8gJ25vcm1hbCcgOiBhbGlnbixcblx0XHRcdGZsZXhEaXJlY3Rpb246IGRpcmVjdGlvbixcblx0XHRcdGZsZXhXcmFwOiB3cmFwID8gJ3dyYXAnIDogdW5kZWZpbmVkLFxuXHRcdFx0Z2FwOiBzcGFjZSggZ2FwICksXG5cdFx0XHRqdXN0aWZ5Q29udGVudDoganVzdGlmeSxcblx0XHRcdGhlaWdodDogaXNDb2x1bW4gJiYgZXhwYW5kZWQgPyAnMTAwJScgOiB1bmRlZmluZWQsXG5cdFx0XHR3aWR0aDogISBpc0NvbHVtbiAmJiBleHBhbmRlZCA/ICcxMDAlJyA6IHVuZGVmaW5lZCxcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gY3goXG5cdFx0XHRzdHlsZXMuRmxleCxcblx0XHRcdGJhc2UsXG5cdFx0XHRpc0NvbHVtbiA/IHN0eWxlcy5JdGVtc0NvbHVtbiA6IHN0eWxlcy5JdGVtc1Jvdyxcblx0XHRcdGNsYXNzTmFtZVxuXHRcdCk7XG5cdH0sIFtcblx0XHRhbGlnbixcblx0XHRjbGFzc05hbWUsXG5cdFx0Y3gsXG5cdFx0ZGlyZWN0aW9uLFxuXHRcdGV4cGFuZGVkLFxuXHRcdGdhcCxcblx0XHRpc0NvbHVtbixcblx0XHRpc1JldmVyc2UsXG5cdFx0anVzdGlmeSxcblx0XHR3cmFwLFxuXHRdICk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzLCBpc0NvbHVtbiB9O1xufVxuIl19 */");
      return cx(Flex, base, isColumn ? ItemsColumn : ItemsRow, className);
    }, [align, className, cx, direction, expanded, gap, isColumn, isReverse, justify, wrap3]);
    return {
      ...otherProps,
      className: classes,
      isColumn
    };
  }

  // node_modules/@wordpress/components/build-module/flex/context.js
  var FlexContext = (0, import_react.createContext)({
    flexItemDisplay: void 0
  });
  var useFlexContext = () => (0, import_react.useContext)(FlexContext);

  // node_modules/@wordpress/components/build-module/flex/flex/component.js
  function UnconnectedFlex(props, forwardedRef) {
    const {
      children,
      isColumn,
      ...otherProps
    } = useFlex(props);
    return (0, import_react.createElement)(FlexContext.Provider, {
      value: {
        flexItemDisplay: isColumn ? "block" : void 0
      }
    }, (0, import_react.createElement)(component_default, _extends({}, otherProps, {
      ref: forwardedRef
    }), children));
  }
  var Flex2 = contextConnect(UnconnectedFlex, "Flex");
  var component_default3 = Flex2;

  // node_modules/@wordpress/components/build-module/flex/flex-item/hook.js
  var import_react70 = __toESM(require_emotion_react_cjs());
  function useFlexItem(props) {
    const {
      className,
      display: displayProp,
      isBlock = false,
      ...otherProps
    } = useContextSystem(props, "FlexItem");
    const sx = {};
    const contextDisplay = useFlexContext().flexItemDisplay;
    sx.Base = /* @__PURE__ */ (0, import_react70.css)({
      display: displayProp || contextDisplay
    }, false ? "" : ";label:sx-Base;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZmxleC9mbGV4LWl0ZW0vaG9vay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4QlciLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9mbGV4L2ZsZXgtaXRlbS9ob29rLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzLCBTZXJpYWxpemVkU3R5bGVzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyB1c2VDb250ZXh0U3lzdGVtLCBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgdXNlRmxleENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCAqIGFzIHN0eWxlcyBmcm9tICcuLi9zdHlsZXMnO1xuaW1wb3J0IHsgdXNlQ3ggfSBmcm9tICcuLi8uLi91dGlscy9ob29rcy91c2UtY3gnO1xuaW1wb3J0IHR5cGUgeyBGbGV4SXRlbVByb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRmxleEl0ZW0oXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczwgRmxleEl0ZW1Qcm9wcywgJ2RpdicgPlxuKSB7XG5cdGNvbnN0IHtcblx0XHRjbGFzc05hbWUsXG5cdFx0ZGlzcGxheTogZGlzcGxheVByb3AsXG5cdFx0aXNCbG9jayA9IGZhbHNlLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnRmxleEl0ZW0nICk7XG5cblx0Y29uc3Qgc3g6IHtcblx0XHRCYXNlPzogU2VyaWFsaXplZFN0eWxlcztcblx0fSA9IHt9O1xuXG5cdGNvbnN0IGNvbnRleHREaXNwbGF5ID0gdXNlRmxleENvbnRleHQoKS5mbGV4SXRlbURpc3BsYXk7XG5cblx0c3guQmFzZSA9IGNzcygge1xuXHRcdGRpc3BsYXk6IGRpc3BsYXlQcm9wIHx8IGNvbnRleHREaXNwbGF5LFxuXHR9ICk7XG5cblx0Y29uc3QgY3ggPSB1c2VDeCgpO1xuXG5cdGNvbnN0IGNsYXNzZXMgPSBjeChcblx0XHRzdHlsZXMuSXRlbSxcblx0XHRzeC5CYXNlLFxuXHRcdGlzQmxvY2sgJiYgc3R5bGVzLmJsb2NrLFxuXHRcdGNsYXNzTmFtZVxuXHQpO1xuXG5cdHJldHVybiB7XG5cdFx0Li4ub3RoZXJQcm9wcyxcblx0XHRjbGFzc05hbWU6IGNsYXNzZXMsXG5cdH07XG59XG4iXX0= */");
    const cx = useCx();
    const classes = cx(Item, sx.Base, isBlock && block, className);
    return {
      ...otherProps,
      className: classes
    };
  }

  // node_modules/@wordpress/components/build-module/flex/flex-item/component.js
  function UnconnectedFlexItem(props, forwardedRef) {
    const flexItemProps = useFlexItem(props);
    return (0, import_react.createElement)(component_default, _extends({}, flexItemProps, {
      ref: forwardedRef
    }));
  }
  var FlexItem = contextConnect(UnconnectedFlexItem, "FlexItem");
  var component_default4 = FlexItem;

  // node_modules/@wordpress/components/build-module/flex/flex-block/hook.js
  function useFlexBlock(props) {
    const otherProps = useContextSystem(props, "FlexBlock");
    const flexItemProps = useFlexItem({
      isBlock: true,
      ...otherProps
    });
    return flexItemProps;
  }

  // node_modules/@wordpress/components/build-module/flex/flex-block/component.js
  function UnconnectedFlexBlock(props, forwardedRef) {
    const flexBlockProps = useFlexBlock(props);
    return (0, import_react.createElement)(component_default, _extends({}, flexBlockProps, {
      ref: forwardedRef
    }));
  }
  var FlexBlock = contextConnect(UnconnectedFlexBlock, "FlexBlock");
  var component_default5 = FlexBlock;

  // node_modules/@wordpress/components/build-module/number-control/index.js
  var import_classnames5 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/number-control/styles/number-control-styles.js
  var import_base3 = __toESM(require_emotion_styled_base_cjs());
  var import_react77 = __toESM(require_emotion_react_cjs());

  // node_modules/@wordpress/components/build-module/input-control/index.js
  var import_classnames4 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js
  var import_base2 = __toESM(require_emotion_styled_base_cjs());
  var import_react74 = __toESM(require_emotion_react_cjs());

  // node_modules/@wordpress/components/build-module/text/hook.js
  var import_react73 = __toESM(require_emotion_react_cjs());

  // node_modules/@wordpress/components/build-module/truncate/hook.js
  var import_react71 = __toESM(require_emotion_react_cjs());

  // node_modules/@wordpress/components/build-module/truncate/styles.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__4() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var Truncate = false ? {
    name: "hdknak",
    styles: "display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
  } : {
    name: "abxxyf-Truncate",
    styles: "display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;label:Truncate;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdHJ1bmNhdGUvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUsyQiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RydW5jYXRlL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IFRydW5jYXRlID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcblx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__4
  };

  // node_modules/@wordpress/components/build-module/truncate/utils.js
  var TRUNCATE_ELLIPSIS = "\u2026";
  var TRUNCATE_TYPE = {
    auto: "auto",
    head: "head",
    middle: "middle",
    tail: "tail",
    none: "none"
  };
  var TRUNCATE_DEFAULT_PROPS = {
    ellipsis: TRUNCATE_ELLIPSIS,
    ellipsizeMode: TRUNCATE_TYPE.auto,
    limit: 0,
    numberOfLines: 0
  };
  function truncateMiddle(word, headLength, tailLength, ellipsis) {
    if (typeof word !== "string") {
      return "";
    }
    const wordLength = word.length;
    const frontLength = ~~headLength;
    const backLength = ~~tailLength;
    const truncateStr = isValueDefined(ellipsis) ? ellipsis : TRUNCATE_ELLIPSIS;
    if (frontLength === 0 && backLength === 0 || frontLength >= wordLength || backLength >= wordLength || frontLength + backLength >= wordLength) {
      return word;
    } else if (backLength === 0) {
      return word.slice(0, frontLength) + truncateStr;
    }
    return word.slice(0, frontLength) + truncateStr + word.slice(wordLength - backLength);
  }
  function truncateContent() {
    let words = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let props = arguments.length > 1 ? arguments[1] : void 0;
    const mergedProps = {
      ...TRUNCATE_DEFAULT_PROPS,
      ...props
    };
    const {
      ellipsis,
      ellipsizeMode,
      limit
    } = mergedProps;
    if (ellipsizeMode === TRUNCATE_TYPE.none) {
      return words;
    }
    let truncateHead;
    let truncateTail;
    switch (ellipsizeMode) {
      case TRUNCATE_TYPE.head:
        truncateHead = 0;
        truncateTail = limit;
        break;
      case TRUNCATE_TYPE.middle:
        truncateHead = Math.floor(limit / 2);
        truncateTail = Math.floor(limit / 2);
        break;
      default:
        truncateHead = limit;
        truncateTail = 0;
    }
    const truncatedContent = ellipsizeMode !== TRUNCATE_TYPE.auto ? truncateMiddle(words, truncateHead, truncateTail, ellipsis) : words;
    return truncatedContent;
  }

  // node_modules/@wordpress/components/build-module/truncate/hook.js
  function useTruncate(props) {
    const {
      className,
      children,
      ellipsis = TRUNCATE_ELLIPSIS,
      ellipsizeMode = TRUNCATE_TYPE.auto,
      limit = 0,
      numberOfLines = 0,
      ...otherProps
    } = useContextSystem(props, "Truncate");
    const cx = useCx();
    const truncatedContent = truncateContent(typeof children === "string" ? children : "", {
      ellipsis,
      ellipsizeMode,
      limit,
      numberOfLines
    });
    const shouldTruncate = ellipsizeMode === TRUNCATE_TYPE.auto;
    const classes = (0, import_react.useMemo)(() => {
      const truncateLines = /* @__PURE__ */ (0, import_react71.css)("-webkit-box-orient:vertical;-webkit-line-clamp:", numberOfLines, ";display:-webkit-box;overflow:hidden;" + (false ? "" : ";label:truncateLines;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdHJ1bmNhdGUvaG9vay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErQzJCIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdHJ1bmNhdGUvaG9vay50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdAd29yZHByZXNzL2VsZW1lbnQnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyB1c2VDb250ZXh0U3lzdGVtLCBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vc3R5bGVzJztcbmltcG9ydCB7IFRSVU5DQVRFX0VMTElQU0lTLCBUUlVOQ0FURV9UWVBFLCB0cnVuY2F0ZUNvbnRlbnQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHVzZUN4IH0gZnJvbSAnLi4vdXRpbHMvaG9va3MvdXNlLWN4JztcbmltcG9ydCB0eXBlIHsgVHJ1bmNhdGVQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VUcnVuY2F0ZShcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPCBUcnVuY2F0ZVByb3BzLCAnc3BhbicgPlxuKSB7XG5cdGNvbnN0IHtcblx0XHRjbGFzc05hbWUsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0ZWxsaXBzaXMgPSBUUlVOQ0FURV9FTExJUFNJUyxcblx0XHRlbGxpcHNpemVNb2RlID0gVFJVTkNBVEVfVFlQRS5hdXRvLFxuXHRcdGxpbWl0ID0gMCxcblx0XHRudW1iZXJPZkxpbmVzID0gMCxcblx0XHQuLi5vdGhlclByb3BzXG5cdH0gPSB1c2VDb250ZXh0U3lzdGVtKCBwcm9wcywgJ1RydW5jYXRlJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCB0cnVuY2F0ZWRDb250ZW50ID0gdHJ1bmNhdGVDb250ZW50KFxuXHRcdHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgPyBjaGlsZHJlbiA6ICcnLFxuXHRcdHtcblx0XHRcdGVsbGlwc2lzLFxuXHRcdFx0ZWxsaXBzaXplTW9kZSxcblx0XHRcdGxpbWl0LFxuXHRcdFx0bnVtYmVyT2ZMaW5lcyxcblx0XHR9XG5cdCk7XG5cblx0Y29uc3Qgc2hvdWxkVHJ1bmNhdGUgPSBlbGxpcHNpemVNb2RlID09PSBUUlVOQ0FURV9UWVBFLmF1dG87XG5cblx0Y29uc3QgY2xhc3NlcyA9IHVzZU1lbW8oICgpID0+IHtcblx0XHRjb25zdCB0cnVuY2F0ZUxpbmVzID0gY3NzYFxuXHRcdFx0LXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcblx0XHRcdC13ZWJraXQtbGluZS1jbGFtcDogJHsgbnVtYmVyT2ZMaW5lcyB9O1xuXHRcdFx0ZGlzcGxheTogLXdlYmtpdC1ib3g7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdGA7XG5cblx0XHRyZXR1cm4gY3goXG5cdFx0XHRzaG91bGRUcnVuY2F0ZSAmJiAhIG51bWJlck9mTGluZXMgJiYgc3R5bGVzLlRydW5jYXRlLFxuXHRcdFx0c2hvdWxkVHJ1bmNhdGUgJiYgISEgbnVtYmVyT2ZMaW5lcyAmJiB0cnVuY2F0ZUxpbmVzLFxuXHRcdFx0Y2xhc3NOYW1lXG5cdFx0KTtcblx0fSwgWyBjbGFzc05hbWUsIGN4LCBudW1iZXJPZkxpbmVzLCBzaG91bGRUcnVuY2F0ZSBdICk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzLCBjaGlsZHJlbjogdHJ1bmNhdGVkQ29udGVudCB9O1xufVxuIl19 */");
      return cx(shouldTruncate && !numberOfLines && Truncate, shouldTruncate && !!numberOfLines && truncateLines, className);
    }, [className, cx, numberOfLines, shouldTruncate]);
    return {
      ...otherProps,
      className: classes,
      children: truncatedContent
    };
  }

  // node_modules/@wordpress/components/build-module/truncate/component.js
  function UnconnectedTruncate(props, forwardedRef) {
    const truncateProps = useTruncate(props);
    return (0, import_react.createElement)(component_default, _extends({
      as: "span"
    }, truncateProps, {
      ref: forwardedRef
    }));
  }
  var Truncate2 = contextConnect(UnconnectedTruncate, "Truncate");
  var component_default6 = Truncate2;

  // node_modules/@wordpress/components/build-module/ui/utils/colors.js
  var import_memize6 = __toESM(require_memize());
  var colorComputationNode;
  k([names_default]);
  function getColorComputationNode() {
    if (typeof document === "undefined")
      return;
    if (!colorComputationNode) {
      const el = document.createElement("div");
      el.setAttribute("data-g2-color-computation-node", "");
      document.body.appendChild(el);
      colorComputationNode = el;
    }
    return colorComputationNode;
  }
  function isColor(value) {
    if (typeof value !== "string")
      return false;
    const test2 = w(value);
    return test2.isValid();
  }
  function _getComputedBackgroundColor(backgroundColor) {
    var _window2;
    if (typeof backgroundColor !== "string")
      return "";
    if (isColor(backgroundColor))
      return backgroundColor;
    if (!backgroundColor.includes("var("))
      return "";
    if (typeof document === "undefined")
      return "";
    const el = getColorComputationNode();
    if (!el)
      return "";
    el.style.background = backgroundColor;
    const computedColor = (_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.getComputedStyle(el).background;
    el.style.background = "";
    return computedColor || "";
  }
  var getComputedBackgroundColor = (0, import_memize6.default)(_getComputedBackgroundColor);
  function getOptimalTextColor(backgroundColor) {
    const background2 = getComputedBackgroundColor(backgroundColor);
    return w(background2).isLight() ? "#000000" : "#ffffff";
  }
  function getOptimalTextShade(backgroundColor) {
    const result = getOptimalTextColor(backgroundColor);
    return result === "#000000" ? "dark" : "light";
  }

  // node_modules/@wordpress/components/build-module/text/styles.js
  var styles_exports3 = {};
  __export(styles_exports3, {
    Text: () => Text,
    block: () => block2,
    destructive: () => destructive,
    highlighterText: () => highlighterText,
    muted: () => muted,
    positive: () => positive,
    upperCase: () => upperCase
  });
  var import_react72 = __toESM(require_emotion_react_cjs());
  function _EMOTION_STRINGIFIED_CSS_ERROR__5() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var Text = /* @__PURE__ */ (0, import_react72.css)("color:", COLORS.gray[900], ";line-height:", config_values_default.fontLineHeightBase, ";margin:0;" + (false ? "" : ";label:Text;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVXVCIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTE9SUywgQ09ORklHIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgVGV4dCA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHRsaW5lLWhlaWdodDogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9O1xuXHRtYXJnaW46IDA7XG5gO1xuXG5leHBvcnQgY29uc3QgYmxvY2sgPSBjc3NgXG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IHBvc2l0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LmdyZWVuIH07XG5gO1xuXG5leHBvcnQgY29uc3QgZGVzdHJ1Y3RpdmUgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuYWxlcnQucmVkIH07XG5gO1xuXG5leHBvcnQgY29uc3QgbXV0ZWQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcbmA7XG5cbmV4cG9ydCBjb25zdCBoaWdobGlnaHRlclRleHQgPSBjc3NgXG5cdG1hcmsge1xuXHRcdGJhY2tncm91bmQ6ICR7IENPTE9SUy5hbGVydC55ZWxsb3cgfTtcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XG5cdFx0Ym94LXNoYWRvdzogMCAwIDAgMXB4IHJnYmEoIDAsIDAsIDAsIDAuMDUgKSBpbnNldCxcblx0XHRcdDAgLTFweCAwIHJnYmEoIDAsIDAsIDAsIDAuMSApIGluc2V0O1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgdXBwZXJDYXNlID0gY3NzYFxuXHR0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuYDtcbiJdfQ== */");
  var block2 = false ? {
    name: "4zleql",
    styles: "display:block"
  } : {
    name: "14aceuy-block",
    styles: "display:block;label:block;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0J3QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0bGluZS1oZWlnaHQ6ICR7IENPTkZJRy5mb250TGluZUhlaWdodEJhc2UgfTtcblx0bWFyZ2luOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGl2ZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5hbGVydC5ncmVlbiB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlc3RydWN0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LnJlZCB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IG11dGVkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDcwMCBdIH07XG5gO1xuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ZXJUZXh0ID0gY3NzYFxuXHRtYXJrIHtcblx0XHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuYWxlcnQueWVsbG93IH07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKCAwLCAwLCAwLCAwLjA1ICkgaW5zZXQsXG5cdFx0XHQwIC0xcHggMCByZ2JhKCAwLCAwLCAwLCAwLjEgKSBpbnNldDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZSA9IGNzc2Bcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__5
  };
  var positive = /* @__PURE__ */ (0, import_react72.css)("color:", COLORS.alert.green, ";" + (false ? "" : ";label:positive;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb0IyQiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0bGluZS1oZWlnaHQ6ICR7IENPTkZJRy5mb250TGluZUhlaWdodEJhc2UgfTtcblx0bWFyZ2luOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGl2ZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5hbGVydC5ncmVlbiB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlc3RydWN0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LnJlZCB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IG11dGVkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDcwMCBdIH07XG5gO1xuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ZXJUZXh0ID0gY3NzYFxuXHRtYXJrIHtcblx0XHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuYWxlcnQueWVsbG93IH07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKCAwLCAwLCAwLCAwLjA1ICkgaW5zZXQsXG5cdFx0XHQwIC0xcHggMCByZ2JhKCAwLCAwLCAwLCAwLjEgKSBpbnNldDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZSA9IGNzc2Bcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */");
  var destructive = /* @__PURE__ */ (0, import_react72.css)("color:", COLORS.alert.red, ";" + (false ? "" : ";label:destructive;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0I4QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0bGluZS1oZWlnaHQ6ICR7IENPTkZJRy5mb250TGluZUhlaWdodEJhc2UgfTtcblx0bWFyZ2luOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGl2ZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5hbGVydC5ncmVlbiB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlc3RydWN0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LnJlZCB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IG11dGVkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDcwMCBdIH07XG5gO1xuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ZXJUZXh0ID0gY3NzYFxuXHRtYXJrIHtcblx0XHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuYWxlcnQueWVsbG93IH07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKCAwLCAwLCAwLCAwLjA1ICkgaW5zZXQsXG5cdFx0XHQwIC0xcHggMCByZ2JhKCAwLCAwLCAwLCAwLjEgKSBpbnNldDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZSA9IGNzc2Bcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */");
  var muted = /* @__PURE__ */ (0, import_react72.css)("color:", COLORS.gray[700], ";" + (false ? "" : ";label:muted;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNEJ3QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0bGluZS1oZWlnaHQ6ICR7IENPTkZJRy5mb250TGluZUhlaWdodEJhc2UgfTtcblx0bWFyZ2luOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGl2ZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5hbGVydC5ncmVlbiB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlc3RydWN0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LnJlZCB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IG11dGVkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDcwMCBdIH07XG5gO1xuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ZXJUZXh0ID0gY3NzYFxuXHRtYXJrIHtcblx0XHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuYWxlcnQueWVsbG93IH07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKCAwLCAwLCAwLCAwLjA1ICkgaW5zZXQsXG5cdFx0XHQwIC0xcHggMCByZ2JhKCAwLCAwLCAwLCAwLjEgKSBpbnNldDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZSA9IGNzc2Bcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */");
  var highlighterText = /* @__PURE__ */ (0, import_react72.css)("mark{background:", COLORS.alert.yellow, ";border-radius:2px;box-shadow:0 0 0 1px rgba( 0, 0, 0, 0.05 ) inset,0 -1px 0 rgba( 0, 0, 0, 0.1 ) inset;}" + (false ? "" : ";label:highlighterText;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0NrQyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0bGluZS1oZWlnaHQ6ICR7IENPTkZJRy5mb250TGluZUhlaWdodEJhc2UgfTtcblx0bWFyZ2luOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGl2ZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5hbGVydC5ncmVlbiB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlc3RydWN0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LnJlZCB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IG11dGVkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDcwMCBdIH07XG5gO1xuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ZXJUZXh0ID0gY3NzYFxuXHRtYXJrIHtcblx0XHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuYWxlcnQueWVsbG93IH07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKCAwLCAwLCAwLCAwLjA1ICkgaW5zZXQsXG5cdFx0XHQwIC0xcHggMCByZ2JhKCAwLCAwLCAwLCAwLjEgKSBpbnNldDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZSA9IGNzc2Bcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */");
  var upperCase = false ? {
    name: "50zrmy",
    styles: "text-transform:uppercase"
  } : {
    name: "1mrt3zt-upperCase",
    styles: "text-transform:uppercase;label:upperCase;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9zdHlsZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeUM0QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRleHQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0bGluZS1oZWlnaHQ6ICR7IENPTkZJRy5mb250TGluZUhlaWdodEJhc2UgfTtcblx0bWFyZ2luOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBwb3NpdGl2ZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5hbGVydC5ncmVlbiB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IGRlc3RydWN0aXZlID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmFsZXJ0LnJlZCB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IG11dGVkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDcwMCBdIH07XG5gO1xuXG5leHBvcnQgY29uc3QgaGlnaGxpZ2h0ZXJUZXh0ID0gY3NzYFxuXHRtYXJrIHtcblx0XHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuYWxlcnQueWVsbG93IH07XG5cdFx0Ym9yZGVyLXJhZGl1czogMnB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKCAwLCAwLCAwLCAwLjA1ICkgaW5zZXQsXG5cdFx0XHQwIC0xcHggMCByZ2JhKCAwLCAwLCAwLCAwLjEgKSBpbnNldDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IHVwcGVyQ2FzZSA9IGNzc2Bcblx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__5
  };

  // node_modules/@wordpress/components/build-module/text/utils.js
  var import_memize7 = __toESM(require_memize());
  var import_highlight_words_core = __toESM(require_dist2());
  var lowercaseProps = (object) => {
    const mapped = {};
    for (const key in object) {
      mapped[key.toLowerCase()] = object[key];
    }
    return mapped;
  };
  var memoizedLowercaseProps = (0, import_memize7.default)(lowercaseProps);
  function createHighlighterText(_ref8) {
    let {
      activeClassName = "",
      activeIndex = -1,
      activeStyle,
      autoEscape,
      caseSensitive = false,
      children,
      findChunks,
      highlightClassName = "",
      highlightStyle = {},
      highlightTag = "mark",
      sanitize: sanitize2,
      searchWords = [],
      unhighlightClassName = "",
      unhighlightStyle
    } = _ref8;
    if (!children)
      return null;
    if (typeof children !== "string")
      return children;
    const textToHighlight = children;
    const chunks = (0, import_highlight_words_core.findAll)({
      autoEscape,
      caseSensitive,
      findChunks,
      sanitize: sanitize2,
      searchWords,
      textToHighlight
    });
    const HighlightTag = highlightTag;
    let highlightIndex = -1;
    let highlightClassNames = "";
    let highlightStyles;
    const textContent = chunks.map((chunk2, index2) => {
      const text3 = textToHighlight.substr(chunk2.start, chunk2.end - chunk2.start);
      if (chunk2.highlight) {
        highlightIndex++;
        let highlightClass;
        if (typeof highlightClassName === "object") {
          if (!caseSensitive) {
            highlightClassName = memoizedLowercaseProps(highlightClassName);
            highlightClass = highlightClassName[text3.toLowerCase()];
          } else {
            highlightClass = highlightClassName[text3];
          }
        } else {
          highlightClass = highlightClassName;
        }
        const isActive = highlightIndex === +activeIndex;
        highlightClassNames = `${highlightClass} ${isActive ? activeClassName : ""}`;
        highlightStyles = isActive === true && activeStyle !== null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;
        const props = {
          children: text3,
          className: highlightClassNames,
          key: index2,
          style: highlightStyles
        };
        if (typeof HighlightTag !== "string") {
          props.highlightIndex = highlightIndex;
        }
        return (0, import_react.createElement)(HighlightTag, props);
      }
      return (0, import_react.createElement)("span", {
        children: text3,
        className: unhighlightClassName,
        key: index2,
        style: unhighlightStyle
      });
    });
    return textContent;
  }

  // node_modules/@wordpress/components/build-module/ui/utils/font-size.js
  var BASE_FONT_SIZE = 13;
  var PRESET_FONT_SIZES = {
    body: BASE_FONT_SIZE,
    caption: 10,
    footnote: 11,
    largeTitle: 28,
    subheadline: 12,
    title: 20
  };
  var HEADING_FONT_SIZES = [1, 2, 3, 4, 5, 6].flatMap((n5) => [n5, n5.toString()]);
  function getFontSize() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : BASE_FONT_SIZE;
    if (size in PRESET_FONT_SIZES) {
      return getFontSize(PRESET_FONT_SIZES[size]);
    }
    if (typeof size !== "number") {
      const parsed = parseFloat(size);
      if (Number.isNaN(parsed))
        return size;
      size = parsed;
    }
    const ratio = `(${size} / ${BASE_FONT_SIZE})`;
    return `calc(${ratio} * ${config_values_default.fontSize})`;
  }
  function getHeadingFontSize() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
    if (!HEADING_FONT_SIZES.includes(size)) {
      return getFontSize(size);
    }
    const headingSize = `fontSizeH${size}`;
    return config_values_default[headingSize];
  }

  // node_modules/@wordpress/components/build-module/text/get-line-height.js
  function getLineHeight(adjustLineHeightForInnerControls, lineHeight2) {
    if (lineHeight2)
      return lineHeight2;
    if (!adjustLineHeightForInnerControls)
      return;
    let value = `calc(${config_values_default.controlHeight} + ${space(2)})`;
    switch (adjustLineHeightForInnerControls) {
      case "large":
        value = `calc(${config_values_default.controlHeightLarge} + ${space(2)})`;
        break;
      case "small":
        value = `calc(${config_values_default.controlHeightSmall} + ${space(2)})`;
        break;
      case "xSmall":
        value = `calc(${config_values_default.controlHeightXSmall} + ${space(2)})`;
        break;
      default:
        break;
    }
    return value;
  }

  // node_modules/@wordpress/components/build-module/text/hook.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__6() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var _ref = false ? {
    name: "50zrmy",
    styles: "text-transform:uppercase"
  } : {
    name: "18bqwxz-sx-upperCase",
    styles: "text-transform:uppercase;label:sx-upperCase;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9HaUIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90ZXh0L2hvb2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyB1c2VNZW1vLCBDaGlsZHJlbiwgY2xvbmVFbGVtZW50IH0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgaGFzQ29ubmVjdE5hbWVzcGFjZSwgdXNlQ29udGV4dFN5c3RlbSB9IGZyb20gJy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgdXNlVHJ1bmNhdGUgfSBmcm9tICcuLi90cnVuY2F0ZSc7XG5pbXBvcnQgeyBnZXRPcHRpbWFsVGV4dFNoYWRlIH0gZnJvbSAnLi4vdWkvdXRpbHMnO1xuaW1wb3J0ICogYXMgc3R5bGVzIGZyb20gJy4vc3R5bGVzJztcbmltcG9ydCB7IGNyZWF0ZUhpZ2hsaWdodGVyVGV4dCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Rm9udFNpemUgfSBmcm9tICcuLi91aS91dGlscy9mb250LXNpemUnO1xuaW1wb3J0IHsgQ09ORklHLCBDT0xPUlMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBnZXRMaW5lSGVpZ2h0IH0gZnJvbSAnLi9nZXQtbGluZS1oZWlnaHQnO1xuaW1wb3J0IHsgdXNlQ3ggfSBmcm9tICcuLi91dGlscy9ob29rcy91c2UtY3gnO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi91aS9jb250ZXh0JykuV29yZFByZXNzQ29tcG9uZW50UHJvcHM8aW1wb3J0KCcuL3R5cGVzJykuUHJvcHMsICdzcGFuJz59IHByb3BzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVRleHQoIHByb3BzICkge1xuXHRjb25zdCB7XG5cdFx0YWRqdXN0TGluZUhlaWdodEZvcklubmVyQ29udHJvbHMsXG5cdFx0YWxpZ24sXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y2xhc3NOYW1lLFxuXHRcdGNvbG9yLFxuXHRcdGVsbGlwc2l6ZU1vZGUsXG5cdFx0aXNEZXN0cnVjdGl2ZSA9IGZhbHNlLFxuXHRcdGRpc3BsYXksXG5cdFx0aGlnaGxpZ2h0RXNjYXBlID0gZmFsc2UsXG5cdFx0aGlnaGxpZ2h0Q2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuXHRcdGhpZ2hsaWdodFdvcmRzLFxuXHRcdGhpZ2hsaWdodFNhbml0aXplLFxuXHRcdGlzQmxvY2sgPSBmYWxzZSxcblx0XHRsZXR0ZXJTcGFjaW5nLFxuXHRcdGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRQcm9wLFxuXHRcdG9wdGltaXplUmVhZGFiaWxpdHlGb3IsXG5cdFx0c2l6ZSxcblx0XHR0cnVuY2F0ZSA9IGZhbHNlLFxuXHRcdHVwcGVyQ2FzZSA9IGZhbHNlLFxuXHRcdHZhcmlhbnQsXG5cdFx0d2VpZ2h0ID0gQ09ORklHLmZvbnRXZWlnaHQsXG5cdFx0Li4ub3RoZXJQcm9wc1xuXHR9ID0gdXNlQ29udGV4dFN5c3RlbSggcHJvcHMsICdUZXh0JyApO1xuXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCdyZWFjdCcpLlJlYWN0Tm9kZX0gKi9cblx0bGV0IGNvbnRlbnQgPSBjaGlsZHJlbjtcblx0Y29uc3QgaXNIaWdobGlnaHRlciA9IEFycmF5LmlzQXJyYXkoIGhpZ2hsaWdodFdvcmRzICk7XG5cdGNvbnN0IGlzQ2FwdGlvbiA9IHNpemUgPT09ICdjYXB0aW9uJztcblxuXHRpZiAoIGlzSGlnaGxpZ2h0ZXIgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY2hpbGRyZW4gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcblx0XHRcdFx0J2BjaGlsZHJlbmAgb2YgYFRleHRgIG11c3Qgb25seSBiZSBgc3RyaW5nYCB0eXBlcyB3aGVuIGBoaWdobGlnaHRXb3Jkc2AgaXMgZGVmaW5lZCdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29udGVudCA9IGNyZWF0ZUhpZ2hsaWdodGVyVGV4dCgge1xuXHRcdFx0YXV0b0VzY2FwZTogaGlnaGxpZ2h0RXNjYXBlLFxuXHRcdFx0Ly8gRGlzYWJsZSByZWFzb246IFdlIG5lZWQgdG8gZGlzYWJsZSB0aGlzIG90aGVyd2lzZSBpdCBlcmFzZXMgdGhlIGNhc3Rcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYmplY3Qtc2hvcnRoYW5kXG5cdFx0XHRjaGlsZHJlbjogLyoqIEB0eXBlIHtzdHJpbmd9ICovICggY2hpbGRyZW4gKSxcblx0XHRcdGNhc2VTZW5zaXRpdmU6IGhpZ2hsaWdodENhc2VTZW5zaXRpdmUsXG5cdFx0XHRzZWFyY2hXb3JkczogaGlnaGxpZ2h0V29yZHMsXG5cdFx0XHRzYW5pdGl6ZTogaGlnaGxpZ2h0U2FuaXRpemUsXG5cdFx0fSApO1xuXHR9XG5cblx0Y29uc3QgY3ggPSB1c2VDeCgpO1xuXG5cdGNvbnN0IGNsYXNzZXMgPSB1c2VNZW1vKCAoKSA9PiB7XG5cdFx0Y29uc3Qgc3ggPSB7fTtcblxuXHRcdGNvbnN0IGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KFxuXHRcdFx0YWRqdXN0TGluZUhlaWdodEZvcklubmVyQ29udHJvbHMsXG5cdFx0XHRsaW5lSGVpZ2h0UHJvcFxuXHRcdCk7XG5cblx0XHRzeC5CYXNlID0gY3NzKCB7XG5cdFx0XHRjb2xvcixcblx0XHRcdGRpc3BsYXksXG5cdFx0XHRmb250U2l6ZTogZ2V0Rm9udFNpemUoIHNpemUgKSxcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGpzZG9jL3ZhbGlkLXR5cGVzICovXG5cdFx0XHRmb250V2VpZ2h0OlxuXHRcdFx0XHQvKiogQHR5cGUge2ltcG9ydCgncmVhY3QnKS5DU1NQcm9wZXJ0aWVzWydmb250V2VpZ2h0J119ICovIChcblx0XHRcdFx0XHR3ZWlnaHRcblx0XHRcdFx0KSxcblx0XHRcdC8qIGVzbGludC1lbmFibGUganNkb2MvdmFsaWQtdHlwZXMgKi9cblx0XHRcdGxpbmVIZWlnaHQsXG5cdFx0XHRsZXR0ZXJTcGFjaW5nLFxuXHRcdFx0dGV4dEFsaWduOiBhbGlnbixcblx0XHR9ICk7XG5cblx0XHRzeC51cHBlckNhc2UgPSBjc3MoIHsgdGV4dFRyYW5zZm9ybTogJ3VwcGVyY2FzZScgfSApO1xuXG5cdFx0c3gub3B0aW1hbFRleHRDb2xvciA9IG51bGw7XG5cblx0XHRpZiAoIG9wdGltaXplUmVhZGFiaWxpdHlGb3IgKSB7XG5cdFx0XHRjb25zdCBpc09wdGltYWxUZXh0Q29sb3JEYXJrID1cblx0XHRcdFx0Z2V0T3B0aW1hbFRleHRTaGFkZSggb3B0aW1pemVSZWFkYWJpbGl0eUZvciApID09PSAnZGFyayc7XG5cblx0XHRcdHN4Lm9wdGltYWxUZXh0Q29sb3IgPSBpc09wdGltYWxUZXh0Q29sb3JEYXJrXG5cdFx0XHRcdD8gY3NzKCB7IGNvbG9yOiBDT0xPUlMuZ3JheVsgOTAwIF0gfSApXG5cdFx0XHRcdDogY3NzKCB7IGNvbG9yOiBDT0xPUlMud2hpdGUgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBjeChcblx0XHRcdHN0eWxlcy5UZXh0LFxuXHRcdFx0c3guQmFzZSxcblx0XHRcdHN4Lm9wdGltYWxUZXh0Q29sb3IsXG5cdFx0XHRpc0Rlc3RydWN0aXZlICYmIHN0eWxlcy5kZXN0cnVjdGl2ZSxcblx0XHRcdCEhIGlzSGlnaGxpZ2h0ZXIgJiYgc3R5bGVzLmhpZ2hsaWdodGVyVGV4dCxcblx0XHRcdGlzQmxvY2sgJiYgc3R5bGVzLmJsb2NrLFxuXHRcdFx0aXNDYXB0aW9uICYmIHN0eWxlcy5tdXRlZCxcblx0XHRcdHZhcmlhbnQgJiYgc3R5bGVzWyB2YXJpYW50IF0sXG5cdFx0XHR1cHBlckNhc2UgJiYgc3gudXBwZXJDYXNlLFxuXHRcdFx0Y2xhc3NOYW1lXG5cdFx0KTtcblx0fSwgW1xuXHRcdGFkanVzdExpbmVIZWlnaHRGb3JJbm5lckNvbnRyb2xzLFxuXHRcdGFsaWduLFxuXHRcdGNsYXNzTmFtZSxcblx0XHRjb2xvcixcblx0XHRjeCxcblx0XHRkaXNwbGF5LFxuXHRcdGlzQmxvY2ssXG5cdFx0aXNDYXB0aW9uLFxuXHRcdGlzRGVzdHJ1Y3RpdmUsXG5cdFx0aXNIaWdobGlnaHRlcixcblx0XHRsZXR0ZXJTcGFjaW5nLFxuXHRcdGxpbmVIZWlnaHRQcm9wLFxuXHRcdG9wdGltaXplUmVhZGFiaWxpdHlGb3IsXG5cdFx0c2l6ZSxcblx0XHR1cHBlckNhc2UsXG5cdFx0dmFyaWFudCxcblx0XHR3ZWlnaHQsXG5cdF0gKTtcblxuXHQvKiogQHR5cGUge3VuZGVmaW5lZCB8ICdhdXRvJyB8ICdub25lJ30gKi9cblx0bGV0IGZpbmFsRWxsaXBzaXplTW9kZTtcblx0aWYgKCB0cnVuY2F0ZSA9PT0gdHJ1ZSApIHtcblx0XHRmaW5hbEVsbGlwc2l6ZU1vZGUgPSAnYXV0byc7XG5cdH1cblx0aWYgKCB0cnVuY2F0ZSA9PT0gZmFsc2UgKSB7XG5cdFx0ZmluYWxFbGxpcHNpemVNb2RlID0gJ25vbmUnO1xuXHR9XG5cblx0Y29uc3QgZmluYWxDb21wb25lbnRQcm9wcyA9IHtcblx0XHQuLi5vdGhlclByb3BzLFxuXHRcdGNsYXNzTmFtZTogY2xhc3Nlcyxcblx0XHRjaGlsZHJlbixcblx0XHRlbGxpcHNpemVNb2RlOiBlbGxpcHNpemVNb2RlIHx8IGZpbmFsRWxsaXBzaXplTW9kZSxcblx0fTtcblxuXHRjb25zdCB0cnVuY2F0ZVByb3BzID0gdXNlVHJ1bmNhdGUoIGZpbmFsQ29tcG9uZW50UHJvcHMgKTtcblxuXHQvKipcblx0ICogRW5oYW5jZSBjaGlsZCBgPExpbmsgLz5gIGNvbXBvbmVudHMgdG8gaW5oZXJpdCBmb250IHNpemUuXG5cdCAqL1xuXHRpZiAoICEgdHJ1bmNhdGUgJiYgQXJyYXkuaXNBcnJheSggY2hpbGRyZW4gKSApIHtcblx0XHRjb250ZW50ID0gQ2hpbGRyZW4ubWFwKCBjaGlsZHJlbiwgKCBjaGlsZCApID0+IHtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fFxuXHRcdFx0XHRjaGlsZCA9PT0gbnVsbCB8fFxuXHRcdFx0XHQhICggJ3Byb3BzJyBpbiBjaGlsZCApXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpc0xpbmsgPSBoYXNDb25uZWN0TmFtZXNwYWNlKCBjaGlsZCwgWyAnTGluaycgXSApO1xuXHRcdFx0aWYgKCBpc0xpbmsgKSB7XG5cdFx0XHRcdHJldHVybiBjbG9uZUVsZW1lbnQoIGNoaWxkLCB7XG5cdFx0XHRcdFx0c2l6ZTogY2hpbGQucHJvcHMuc2l6ZSB8fCAnaW5oZXJpdCcsXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Li4udHJ1bmNhdGVQcm9wcyxcblx0XHRjaGlsZHJlbjogdHJ1bmNhdGUgPyB0cnVuY2F0ZVByb3BzLmNoaWxkcmVuIDogY29udGVudCxcblx0fTtcbn1cbiJdfQ== */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__6
  };
  function useText(props) {
    const {
      adjustLineHeightForInnerControls,
      align,
      children,
      className,
      color: color4,
      ellipsizeMode,
      isDestructive = false,
      display,
      highlightEscape = false,
      highlightCaseSensitive = false,
      highlightWords,
      highlightSanitize,
      isBlock = false,
      letterSpacing: letterSpacing2,
      lineHeight: lineHeightProp,
      optimizeReadabilityFor,
      size,
      truncate = false,
      upperCase: upperCase2 = false,
      variant,
      weight = config_values_default.fontWeight,
      ...otherProps
    } = useContextSystem(props, "Text");
    let content = children;
    const isHighlighter = Array.isArray(highlightWords);
    const isCaption = size === "caption";
    if (isHighlighter) {
      if (typeof children !== "string") {
        throw new TypeError("`children` of `Text` must only be `string` types when `highlightWords` is defined");
      }
      content = createHighlighterText({
        autoEscape: highlightEscape,
        children,
        caseSensitive: highlightCaseSensitive,
        searchWords: highlightWords,
        sanitize: highlightSanitize
      });
    }
    const cx = useCx();
    const classes = (0, import_react.useMemo)(() => {
      const sx = {};
      const lineHeight2 = getLineHeight(adjustLineHeightForInnerControls, lineHeightProp);
      sx.Base = /* @__PURE__ */ (0, import_react73.css)({
        color: color4,
        display,
        fontSize: getFontSize(size),
        fontWeight: weight,
        lineHeight: lineHeight2,
        letterSpacing: letterSpacing2,
        textAlign: align
      }, false ? "" : ";label:sx-Base;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXFGWSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvaG9vay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZU1lbW8sIENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdAd29yZHByZXNzL2VsZW1lbnQnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBoYXNDb25uZWN0TmFtZXNwYWNlLCB1c2VDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyB1c2VUcnVuY2F0ZSB9IGZyb20gJy4uL3RydW5jYXRlJztcbmltcG9ydCB7IGdldE9wdGltYWxUZXh0U2hhZGUgfSBmcm9tICcuLi91aS91dGlscyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9zdHlsZXMnO1xuaW1wb3J0IHsgY3JlYXRlSGlnaGxpZ2h0ZXJUZXh0IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZXRGb250U2l6ZSB9IGZyb20gJy4uL3VpL3V0aWxzL2ZvbnQtc2l6ZSc7XG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldExpbmVIZWlnaHQgfSBmcm9tICcuL2dldC1saW5lLWhlaWdodCc7XG5pbXBvcnQgeyB1c2VDeCB9IGZyb20gJy4uL3V0aWxzL2hvb2tzL3VzZS1jeCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3VpL2NvbnRleHQnKS5Xb3JkUHJlc3NDb21wb25lbnRQcm9wczxpbXBvcnQoJy4vdHlwZXMnKS5Qcm9wcywgJ3NwYW4nPn0gcHJvcHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlVGV4dCggcHJvcHMgKSB7XG5cdGNvbnN0IHtcblx0XHRhZGp1c3RMaW5lSGVpZ2h0Rm9ySW5uZXJDb250cm9scyxcblx0XHRhbGlnbixcblx0XHRjaGlsZHJlbixcblx0XHRjbGFzc05hbWUsXG5cdFx0Y29sb3IsXG5cdFx0ZWxsaXBzaXplTW9kZSxcblx0XHRpc0Rlc3RydWN0aXZlID0gZmFsc2UsXG5cdFx0ZGlzcGxheSxcblx0XHRoaWdobGlnaHRFc2NhcGUgPSBmYWxzZSxcblx0XHRoaWdobGlnaHRDYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG5cdFx0aGlnaGxpZ2h0V29yZHMsXG5cdFx0aGlnaGxpZ2h0U2FuaXRpemUsXG5cdFx0aXNCbG9jayA9IGZhbHNlLFxuXHRcdGxldHRlclNwYWNpbmcsXG5cdFx0bGluZUhlaWdodDogbGluZUhlaWdodFByb3AsXG5cdFx0b3B0aW1pemVSZWFkYWJpbGl0eUZvcixcblx0XHRzaXplLFxuXHRcdHRydW5jYXRlID0gZmFsc2UsXG5cdFx0dXBwZXJDYXNlID0gZmFsc2UsXG5cdFx0dmFyaWFudCxcblx0XHR3ZWlnaHQgPSBDT05GSUcuZm9udFdlaWdodCxcblx0XHQuLi5vdGhlclByb3BzXG5cdH0gPSB1c2VDb250ZXh0U3lzdGVtKCBwcm9wcywgJ1RleHQnICk7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJ3JlYWN0JykuUmVhY3ROb2RlfSAqL1xuXHRsZXQgY29udGVudCA9IGNoaWxkcmVuO1xuXHRjb25zdCBpc0hpZ2hsaWdodGVyID0gQXJyYXkuaXNBcnJheSggaGlnaGxpZ2h0V29yZHMgKTtcblx0Y29uc3QgaXNDYXB0aW9uID0gc2l6ZSA9PT0gJ2NhcHRpb24nO1xuXG5cdGlmICggaXNIaWdobGlnaHRlciApIHtcblx0XHRpZiAoIHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XHQnYGNoaWxkcmVuYCBvZiBgVGV4dGAgbXVzdCBvbmx5IGJlIGBzdHJpbmdgIHR5cGVzIHdoZW4gYGhpZ2hsaWdodFdvcmRzYCBpcyBkZWZpbmVkJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb250ZW50ID0gY3JlYXRlSGlnaGxpZ2h0ZXJUZXh0KCB7XG5cdFx0XHRhdXRvRXNjYXBlOiBoaWdobGlnaHRFc2NhcGUsXG5cdFx0XHQvLyBEaXNhYmxlIHJlYXNvbjogV2UgbmVlZCB0byBkaXNhYmxlIHRoaXMgb3RoZXJ3aXNlIGl0IGVyYXNlcyB0aGUgY2FzdFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9iamVjdC1zaG9ydGhhbmRcblx0XHRcdGNoaWxkcmVuOiAvKiogQHR5cGUge3N0cmluZ30gKi8gKCBjaGlsZHJlbiApLFxuXHRcdFx0Y2FzZVNlbnNpdGl2ZTogaGlnaGxpZ2h0Q2FzZVNlbnNpdGl2ZSxcblx0XHRcdHNlYXJjaFdvcmRzOiBoaWdobGlnaHRXb3Jkcyxcblx0XHRcdHNhbml0aXplOiBoaWdobGlnaHRTYW5pdGl6ZSxcblx0XHR9ICk7XG5cdH1cblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cblx0Y29uc3QgY2xhc3NlcyA9IHVzZU1lbW8oICgpID0+IHtcblx0XHRjb25zdCBzeCA9IHt9O1xuXG5cdFx0Y29uc3QgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoXG5cdFx0XHRhZGp1c3RMaW5lSGVpZ2h0Rm9ySW5uZXJDb250cm9scyxcblx0XHRcdGxpbmVIZWlnaHRQcm9wXG5cdFx0KTtcblxuXHRcdHN4LkJhc2UgPSBjc3MoIHtcblx0XHRcdGNvbG9yLFxuXHRcdFx0ZGlzcGxheSxcblx0XHRcdGZvbnRTaXplOiBnZXRGb250U2l6ZSggc2l6ZSApLFxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUganNkb2MvdmFsaWQtdHlwZXMgKi9cblx0XHRcdGZvbnRXZWlnaHQ6XG5cdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXNbJ2ZvbnRXZWlnaHQnXX0gKi8gKFxuXHRcdFx0XHRcdHdlaWdodFxuXHRcdFx0XHQpLFxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBqc2RvYy92YWxpZC10eXBlcyAqL1xuXHRcdFx0bGluZUhlaWdodCxcblx0XHRcdGxldHRlclNwYWNpbmcsXG5cdFx0XHR0ZXh0QWxpZ246IGFsaWduLFxuXHRcdH0gKTtcblxuXHRcdHN4LnVwcGVyQ2FzZSA9IGNzcyggeyB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJyB9ICk7XG5cblx0XHRzeC5vcHRpbWFsVGV4dENvbG9yID0gbnVsbDtcblxuXHRcdGlmICggb3B0aW1pemVSZWFkYWJpbGl0eUZvciApIHtcblx0XHRcdGNvbnN0IGlzT3B0aW1hbFRleHRDb2xvckRhcmsgPVxuXHRcdFx0XHRnZXRPcHRpbWFsVGV4dFNoYWRlKCBvcHRpbWl6ZVJlYWRhYmlsaXR5Rm9yICkgPT09ICdkYXJrJztcblxuXHRcdFx0c3gub3B0aW1hbFRleHRDb2xvciA9IGlzT3B0aW1hbFRleHRDb2xvckRhcmtcblx0XHRcdFx0PyBjc3MoIHsgY29sb3I6IENPTE9SUy5ncmF5WyA5MDAgXSB9IClcblx0XHRcdFx0OiBjc3MoIHsgY29sb3I6IENPTE9SUy53aGl0ZSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN4KFxuXHRcdFx0c3R5bGVzLlRleHQsXG5cdFx0XHRzeC5CYXNlLFxuXHRcdFx0c3gub3B0aW1hbFRleHRDb2xvcixcblx0XHRcdGlzRGVzdHJ1Y3RpdmUgJiYgc3R5bGVzLmRlc3RydWN0aXZlLFxuXHRcdFx0ISEgaXNIaWdobGlnaHRlciAmJiBzdHlsZXMuaGlnaGxpZ2h0ZXJUZXh0LFxuXHRcdFx0aXNCbG9jayAmJiBzdHlsZXMuYmxvY2ssXG5cdFx0XHRpc0NhcHRpb24gJiYgc3R5bGVzLm11dGVkLFxuXHRcdFx0dmFyaWFudCAmJiBzdHlsZXNbIHZhcmlhbnQgXSxcblx0XHRcdHVwcGVyQ2FzZSAmJiBzeC51cHBlckNhc2UsXG5cdFx0XHRjbGFzc05hbWVcblx0XHQpO1xuXHR9LCBbXG5cdFx0YWRqdXN0TGluZUhlaWdodEZvcklubmVyQ29udHJvbHMsXG5cdFx0YWxpZ24sXG5cdFx0Y2xhc3NOYW1lLFxuXHRcdGNvbG9yLFxuXHRcdGN4LFxuXHRcdGRpc3BsYXksXG5cdFx0aXNCbG9jayxcblx0XHRpc0NhcHRpb24sXG5cdFx0aXNEZXN0cnVjdGl2ZSxcblx0XHRpc0hpZ2hsaWdodGVyLFxuXHRcdGxldHRlclNwYWNpbmcsXG5cdFx0bGluZUhlaWdodFByb3AsXG5cdFx0b3B0aW1pemVSZWFkYWJpbGl0eUZvcixcblx0XHRzaXplLFxuXHRcdHVwcGVyQ2FzZSxcblx0XHR2YXJpYW50LFxuXHRcdHdlaWdodCxcblx0XSApO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgJ2F1dG8nIHwgJ25vbmUnfSAqL1xuXHRsZXQgZmluYWxFbGxpcHNpemVNb2RlO1xuXHRpZiAoIHRydW5jYXRlID09PSB0cnVlICkge1xuXHRcdGZpbmFsRWxsaXBzaXplTW9kZSA9ICdhdXRvJztcblx0fVxuXHRpZiAoIHRydW5jYXRlID09PSBmYWxzZSApIHtcblx0XHRmaW5hbEVsbGlwc2l6ZU1vZGUgPSAnbm9uZSc7XG5cdH1cblxuXHRjb25zdCBmaW5hbENvbXBvbmVudFByb3BzID0ge1xuXHRcdC4uLm90aGVyUHJvcHMsXG5cdFx0Y2xhc3NOYW1lOiBjbGFzc2VzLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGVsbGlwc2l6ZU1vZGU6IGVsbGlwc2l6ZU1vZGUgfHwgZmluYWxFbGxpcHNpemVNb2RlLFxuXHR9O1xuXG5cdGNvbnN0IHRydW5jYXRlUHJvcHMgPSB1c2VUcnVuY2F0ZSggZmluYWxDb21wb25lbnRQcm9wcyApO1xuXG5cdC8qKlxuXHQgKiBFbmhhbmNlIGNoaWxkIGA8TGluayAvPmAgY29tcG9uZW50cyB0byBpbmhlcml0IGZvbnQgc2l6ZS5cblx0ICovXG5cdGlmICggISB0cnVuY2F0ZSAmJiBBcnJheS5pc0FycmF5KCBjaGlsZHJlbiApICkge1xuXHRcdGNvbnRlbnQgPSBDaGlsZHJlbi5tYXAoIGNoaWxkcmVuLCAoIGNoaWxkICkgPT4ge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8XG5cdFx0XHRcdGNoaWxkID09PSBudWxsIHx8XG5cdFx0XHRcdCEgKCAncHJvcHMnIGluIGNoaWxkIClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGlzTGluayA9IGhhc0Nvbm5lY3ROYW1lc3BhY2UoIGNoaWxkLCBbICdMaW5rJyBdICk7XG5cdFx0XHRpZiAoIGlzTGluayApIHtcblx0XHRcdFx0cmV0dXJuIGNsb25lRWxlbWVudCggY2hpbGQsIHtcblx0XHRcdFx0XHRzaXplOiBjaGlsZC5wcm9wcy5zaXplIHx8ICdpbmhlcml0Jyxcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQuLi50cnVuY2F0ZVByb3BzLFxuXHRcdGNoaWxkcmVuOiB0cnVuY2F0ZSA/IHRydW5jYXRlUHJvcHMuY2hpbGRyZW4gOiBjb250ZW50LFxuXHR9O1xufVxuIl19 */");
      sx.upperCase = _ref;
      sx.optimalTextColor = null;
      if (optimizeReadabilityFor) {
        const isOptimalTextColorDark = getOptimalTextShade(optimizeReadabilityFor) === "dark";
        sx.optimalTextColor = isOptimalTextColorDark ? /* @__PURE__ */ (0, import_react73.css)({
          color: COLORS.gray[900]
        }, false ? "" : ";label:sx-optimalTextColor;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZHTSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvaG9vay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZU1lbW8sIENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdAd29yZHByZXNzL2VsZW1lbnQnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBoYXNDb25uZWN0TmFtZXNwYWNlLCB1c2VDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyB1c2VUcnVuY2F0ZSB9IGZyb20gJy4uL3RydW5jYXRlJztcbmltcG9ydCB7IGdldE9wdGltYWxUZXh0U2hhZGUgfSBmcm9tICcuLi91aS91dGlscyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9zdHlsZXMnO1xuaW1wb3J0IHsgY3JlYXRlSGlnaGxpZ2h0ZXJUZXh0IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZXRGb250U2l6ZSB9IGZyb20gJy4uL3VpL3V0aWxzL2ZvbnQtc2l6ZSc7XG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldExpbmVIZWlnaHQgfSBmcm9tICcuL2dldC1saW5lLWhlaWdodCc7XG5pbXBvcnQgeyB1c2VDeCB9IGZyb20gJy4uL3V0aWxzL2hvb2tzL3VzZS1jeCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3VpL2NvbnRleHQnKS5Xb3JkUHJlc3NDb21wb25lbnRQcm9wczxpbXBvcnQoJy4vdHlwZXMnKS5Qcm9wcywgJ3NwYW4nPn0gcHJvcHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlVGV4dCggcHJvcHMgKSB7XG5cdGNvbnN0IHtcblx0XHRhZGp1c3RMaW5lSGVpZ2h0Rm9ySW5uZXJDb250cm9scyxcblx0XHRhbGlnbixcblx0XHRjaGlsZHJlbixcblx0XHRjbGFzc05hbWUsXG5cdFx0Y29sb3IsXG5cdFx0ZWxsaXBzaXplTW9kZSxcblx0XHRpc0Rlc3RydWN0aXZlID0gZmFsc2UsXG5cdFx0ZGlzcGxheSxcblx0XHRoaWdobGlnaHRFc2NhcGUgPSBmYWxzZSxcblx0XHRoaWdobGlnaHRDYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG5cdFx0aGlnaGxpZ2h0V29yZHMsXG5cdFx0aGlnaGxpZ2h0U2FuaXRpemUsXG5cdFx0aXNCbG9jayA9IGZhbHNlLFxuXHRcdGxldHRlclNwYWNpbmcsXG5cdFx0bGluZUhlaWdodDogbGluZUhlaWdodFByb3AsXG5cdFx0b3B0aW1pemVSZWFkYWJpbGl0eUZvcixcblx0XHRzaXplLFxuXHRcdHRydW5jYXRlID0gZmFsc2UsXG5cdFx0dXBwZXJDYXNlID0gZmFsc2UsXG5cdFx0dmFyaWFudCxcblx0XHR3ZWlnaHQgPSBDT05GSUcuZm9udFdlaWdodCxcblx0XHQuLi5vdGhlclByb3BzXG5cdH0gPSB1c2VDb250ZXh0U3lzdGVtKCBwcm9wcywgJ1RleHQnICk7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJ3JlYWN0JykuUmVhY3ROb2RlfSAqL1xuXHRsZXQgY29udGVudCA9IGNoaWxkcmVuO1xuXHRjb25zdCBpc0hpZ2hsaWdodGVyID0gQXJyYXkuaXNBcnJheSggaGlnaGxpZ2h0V29yZHMgKTtcblx0Y29uc3QgaXNDYXB0aW9uID0gc2l6ZSA9PT0gJ2NhcHRpb24nO1xuXG5cdGlmICggaXNIaWdobGlnaHRlciApIHtcblx0XHRpZiAoIHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XHQnYGNoaWxkcmVuYCBvZiBgVGV4dGAgbXVzdCBvbmx5IGJlIGBzdHJpbmdgIHR5cGVzIHdoZW4gYGhpZ2hsaWdodFdvcmRzYCBpcyBkZWZpbmVkJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb250ZW50ID0gY3JlYXRlSGlnaGxpZ2h0ZXJUZXh0KCB7XG5cdFx0XHRhdXRvRXNjYXBlOiBoaWdobGlnaHRFc2NhcGUsXG5cdFx0XHQvLyBEaXNhYmxlIHJlYXNvbjogV2UgbmVlZCB0byBkaXNhYmxlIHRoaXMgb3RoZXJ3aXNlIGl0IGVyYXNlcyB0aGUgY2FzdFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9iamVjdC1zaG9ydGhhbmRcblx0XHRcdGNoaWxkcmVuOiAvKiogQHR5cGUge3N0cmluZ30gKi8gKCBjaGlsZHJlbiApLFxuXHRcdFx0Y2FzZVNlbnNpdGl2ZTogaGlnaGxpZ2h0Q2FzZVNlbnNpdGl2ZSxcblx0XHRcdHNlYXJjaFdvcmRzOiBoaWdobGlnaHRXb3Jkcyxcblx0XHRcdHNhbml0aXplOiBoaWdobGlnaHRTYW5pdGl6ZSxcblx0XHR9ICk7XG5cdH1cblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cblx0Y29uc3QgY2xhc3NlcyA9IHVzZU1lbW8oICgpID0+IHtcblx0XHRjb25zdCBzeCA9IHt9O1xuXG5cdFx0Y29uc3QgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoXG5cdFx0XHRhZGp1c3RMaW5lSGVpZ2h0Rm9ySW5uZXJDb250cm9scyxcblx0XHRcdGxpbmVIZWlnaHRQcm9wXG5cdFx0KTtcblxuXHRcdHN4LkJhc2UgPSBjc3MoIHtcblx0XHRcdGNvbG9yLFxuXHRcdFx0ZGlzcGxheSxcblx0XHRcdGZvbnRTaXplOiBnZXRGb250U2l6ZSggc2l6ZSApLFxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUganNkb2MvdmFsaWQtdHlwZXMgKi9cblx0XHRcdGZvbnRXZWlnaHQ6XG5cdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXNbJ2ZvbnRXZWlnaHQnXX0gKi8gKFxuXHRcdFx0XHRcdHdlaWdodFxuXHRcdFx0XHQpLFxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBqc2RvYy92YWxpZC10eXBlcyAqL1xuXHRcdFx0bGluZUhlaWdodCxcblx0XHRcdGxldHRlclNwYWNpbmcsXG5cdFx0XHR0ZXh0QWxpZ246IGFsaWduLFxuXHRcdH0gKTtcblxuXHRcdHN4LnVwcGVyQ2FzZSA9IGNzcyggeyB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJyB9ICk7XG5cblx0XHRzeC5vcHRpbWFsVGV4dENvbG9yID0gbnVsbDtcblxuXHRcdGlmICggb3B0aW1pemVSZWFkYWJpbGl0eUZvciApIHtcblx0XHRcdGNvbnN0IGlzT3B0aW1hbFRleHRDb2xvckRhcmsgPVxuXHRcdFx0XHRnZXRPcHRpbWFsVGV4dFNoYWRlKCBvcHRpbWl6ZVJlYWRhYmlsaXR5Rm9yICkgPT09ICdkYXJrJztcblxuXHRcdFx0c3gub3B0aW1hbFRleHRDb2xvciA9IGlzT3B0aW1hbFRleHRDb2xvckRhcmtcblx0XHRcdFx0PyBjc3MoIHsgY29sb3I6IENPTE9SUy5ncmF5WyA5MDAgXSB9IClcblx0XHRcdFx0OiBjc3MoIHsgY29sb3I6IENPTE9SUy53aGl0ZSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN4KFxuXHRcdFx0c3R5bGVzLlRleHQsXG5cdFx0XHRzeC5CYXNlLFxuXHRcdFx0c3gub3B0aW1hbFRleHRDb2xvcixcblx0XHRcdGlzRGVzdHJ1Y3RpdmUgJiYgc3R5bGVzLmRlc3RydWN0aXZlLFxuXHRcdFx0ISEgaXNIaWdobGlnaHRlciAmJiBzdHlsZXMuaGlnaGxpZ2h0ZXJUZXh0LFxuXHRcdFx0aXNCbG9jayAmJiBzdHlsZXMuYmxvY2ssXG5cdFx0XHRpc0NhcHRpb24gJiYgc3R5bGVzLm11dGVkLFxuXHRcdFx0dmFyaWFudCAmJiBzdHlsZXNbIHZhcmlhbnQgXSxcblx0XHRcdHVwcGVyQ2FzZSAmJiBzeC51cHBlckNhc2UsXG5cdFx0XHRjbGFzc05hbWVcblx0XHQpO1xuXHR9LCBbXG5cdFx0YWRqdXN0TGluZUhlaWdodEZvcklubmVyQ29udHJvbHMsXG5cdFx0YWxpZ24sXG5cdFx0Y2xhc3NOYW1lLFxuXHRcdGNvbG9yLFxuXHRcdGN4LFxuXHRcdGRpc3BsYXksXG5cdFx0aXNCbG9jayxcblx0XHRpc0NhcHRpb24sXG5cdFx0aXNEZXN0cnVjdGl2ZSxcblx0XHRpc0hpZ2hsaWdodGVyLFxuXHRcdGxldHRlclNwYWNpbmcsXG5cdFx0bGluZUhlaWdodFByb3AsXG5cdFx0b3B0aW1pemVSZWFkYWJpbGl0eUZvcixcblx0XHRzaXplLFxuXHRcdHVwcGVyQ2FzZSxcblx0XHR2YXJpYW50LFxuXHRcdHdlaWdodCxcblx0XSApO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgJ2F1dG8nIHwgJ25vbmUnfSAqL1xuXHRsZXQgZmluYWxFbGxpcHNpemVNb2RlO1xuXHRpZiAoIHRydW5jYXRlID09PSB0cnVlICkge1xuXHRcdGZpbmFsRWxsaXBzaXplTW9kZSA9ICdhdXRvJztcblx0fVxuXHRpZiAoIHRydW5jYXRlID09PSBmYWxzZSApIHtcblx0XHRmaW5hbEVsbGlwc2l6ZU1vZGUgPSAnbm9uZSc7XG5cdH1cblxuXHRjb25zdCBmaW5hbENvbXBvbmVudFByb3BzID0ge1xuXHRcdC4uLm90aGVyUHJvcHMsXG5cdFx0Y2xhc3NOYW1lOiBjbGFzc2VzLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGVsbGlwc2l6ZU1vZGU6IGVsbGlwc2l6ZU1vZGUgfHwgZmluYWxFbGxpcHNpemVNb2RlLFxuXHR9O1xuXG5cdGNvbnN0IHRydW5jYXRlUHJvcHMgPSB1c2VUcnVuY2F0ZSggZmluYWxDb21wb25lbnRQcm9wcyApO1xuXG5cdC8qKlxuXHQgKiBFbmhhbmNlIGNoaWxkIGA8TGluayAvPmAgY29tcG9uZW50cyB0byBpbmhlcml0IGZvbnQgc2l6ZS5cblx0ICovXG5cdGlmICggISB0cnVuY2F0ZSAmJiBBcnJheS5pc0FycmF5KCBjaGlsZHJlbiApICkge1xuXHRcdGNvbnRlbnQgPSBDaGlsZHJlbi5tYXAoIGNoaWxkcmVuLCAoIGNoaWxkICkgPT4ge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8XG5cdFx0XHRcdGNoaWxkID09PSBudWxsIHx8XG5cdFx0XHRcdCEgKCAncHJvcHMnIGluIGNoaWxkIClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGlzTGluayA9IGhhc0Nvbm5lY3ROYW1lc3BhY2UoIGNoaWxkLCBbICdMaW5rJyBdICk7XG5cdFx0XHRpZiAoIGlzTGluayApIHtcblx0XHRcdFx0cmV0dXJuIGNsb25lRWxlbWVudCggY2hpbGQsIHtcblx0XHRcdFx0XHRzaXplOiBjaGlsZC5wcm9wcy5zaXplIHx8ICdpbmhlcml0Jyxcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQuLi50cnVuY2F0ZVByb3BzLFxuXHRcdGNoaWxkcmVuOiB0cnVuY2F0ZSA/IHRydW5jYXRlUHJvcHMuY2hpbGRyZW4gOiBjb250ZW50LFxuXHR9O1xufVxuIl19 */") : /* @__PURE__ */ (0, import_react73.css)({
          color: COLORS.white
        }, false ? "" : ";label:sx-optimalTextColor;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdGV4dC9ob29rLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThHTSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RleHQvaG9vay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBXb3JkUHJlc3MgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZU1lbW8sIENoaWxkcmVuLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdAd29yZHByZXNzL2VsZW1lbnQnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBoYXNDb25uZWN0TmFtZXNwYWNlLCB1c2VDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyB1c2VUcnVuY2F0ZSB9IGZyb20gJy4uL3RydW5jYXRlJztcbmltcG9ydCB7IGdldE9wdGltYWxUZXh0U2hhZGUgfSBmcm9tICcuLi91aS91dGlscyc7XG5pbXBvcnQgKiBhcyBzdHlsZXMgZnJvbSAnLi9zdHlsZXMnO1xuaW1wb3J0IHsgY3JlYXRlSGlnaGxpZ2h0ZXJUZXh0IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBnZXRGb250U2l6ZSB9IGZyb20gJy4uL3VpL3V0aWxzL2ZvbnQtc2l6ZSc7XG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldExpbmVIZWlnaHQgfSBmcm9tICcuL2dldC1saW5lLWhlaWdodCc7XG5pbXBvcnQgeyB1c2VDeCB9IGZyb20gJy4uL3V0aWxzL2hvb2tzL3VzZS1jeCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3VpL2NvbnRleHQnKS5Xb3JkUHJlc3NDb21wb25lbnRQcm9wczxpbXBvcnQoJy4vdHlwZXMnKS5Qcm9wcywgJ3NwYW4nPn0gcHJvcHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlVGV4dCggcHJvcHMgKSB7XG5cdGNvbnN0IHtcblx0XHRhZGp1c3RMaW5lSGVpZ2h0Rm9ySW5uZXJDb250cm9scyxcblx0XHRhbGlnbixcblx0XHRjaGlsZHJlbixcblx0XHRjbGFzc05hbWUsXG5cdFx0Y29sb3IsXG5cdFx0ZWxsaXBzaXplTW9kZSxcblx0XHRpc0Rlc3RydWN0aXZlID0gZmFsc2UsXG5cdFx0ZGlzcGxheSxcblx0XHRoaWdobGlnaHRFc2NhcGUgPSBmYWxzZSxcblx0XHRoaWdobGlnaHRDYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG5cdFx0aGlnaGxpZ2h0V29yZHMsXG5cdFx0aGlnaGxpZ2h0U2FuaXRpemUsXG5cdFx0aXNCbG9jayA9IGZhbHNlLFxuXHRcdGxldHRlclNwYWNpbmcsXG5cdFx0bGluZUhlaWdodDogbGluZUhlaWdodFByb3AsXG5cdFx0b3B0aW1pemVSZWFkYWJpbGl0eUZvcixcblx0XHRzaXplLFxuXHRcdHRydW5jYXRlID0gZmFsc2UsXG5cdFx0dXBwZXJDYXNlID0gZmFsc2UsXG5cdFx0dmFyaWFudCxcblx0XHR3ZWlnaHQgPSBDT05GSUcuZm9udFdlaWdodCxcblx0XHQuLi5vdGhlclByb3BzXG5cdH0gPSB1c2VDb250ZXh0U3lzdGVtKCBwcm9wcywgJ1RleHQnICk7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJ3JlYWN0JykuUmVhY3ROb2RlfSAqL1xuXHRsZXQgY29udGVudCA9IGNoaWxkcmVuO1xuXHRjb25zdCBpc0hpZ2hsaWdodGVyID0gQXJyYXkuaXNBcnJheSggaGlnaGxpZ2h0V29yZHMgKTtcblx0Y29uc3QgaXNDYXB0aW9uID0gc2l6ZSA9PT0gJ2NhcHRpb24nO1xuXG5cdGlmICggaXNIaWdobGlnaHRlciApIHtcblx0XHRpZiAoIHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHRcdFx0XHQnYGNoaWxkcmVuYCBvZiBgVGV4dGAgbXVzdCBvbmx5IGJlIGBzdHJpbmdgIHR5cGVzIHdoZW4gYGhpZ2hsaWdodFdvcmRzYCBpcyBkZWZpbmVkJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb250ZW50ID0gY3JlYXRlSGlnaGxpZ2h0ZXJUZXh0KCB7XG5cdFx0XHRhdXRvRXNjYXBlOiBoaWdobGlnaHRFc2NhcGUsXG5cdFx0XHQvLyBEaXNhYmxlIHJlYXNvbjogV2UgbmVlZCB0byBkaXNhYmxlIHRoaXMgb3RoZXJ3aXNlIGl0IGVyYXNlcyB0aGUgY2FzdFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9iamVjdC1zaG9ydGhhbmRcblx0XHRcdGNoaWxkcmVuOiAvKiogQHR5cGUge3N0cmluZ30gKi8gKCBjaGlsZHJlbiApLFxuXHRcdFx0Y2FzZVNlbnNpdGl2ZTogaGlnaGxpZ2h0Q2FzZVNlbnNpdGl2ZSxcblx0XHRcdHNlYXJjaFdvcmRzOiBoaWdobGlnaHRXb3Jkcyxcblx0XHRcdHNhbml0aXplOiBoaWdobGlnaHRTYW5pdGl6ZSxcblx0XHR9ICk7XG5cdH1cblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cblx0Y29uc3QgY2xhc3NlcyA9IHVzZU1lbW8oICgpID0+IHtcblx0XHRjb25zdCBzeCA9IHt9O1xuXG5cdFx0Y29uc3QgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoXG5cdFx0XHRhZGp1c3RMaW5lSGVpZ2h0Rm9ySW5uZXJDb250cm9scyxcblx0XHRcdGxpbmVIZWlnaHRQcm9wXG5cdFx0KTtcblxuXHRcdHN4LkJhc2UgPSBjc3MoIHtcblx0XHRcdGNvbG9yLFxuXHRcdFx0ZGlzcGxheSxcblx0XHRcdGZvbnRTaXplOiBnZXRGb250U2l6ZSggc2l6ZSApLFxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUganNkb2MvdmFsaWQtdHlwZXMgKi9cblx0XHRcdGZvbnRXZWlnaHQ6XG5cdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCdyZWFjdCcpLkNTU1Byb3BlcnRpZXNbJ2ZvbnRXZWlnaHQnXX0gKi8gKFxuXHRcdFx0XHRcdHdlaWdodFxuXHRcdFx0XHQpLFxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBqc2RvYy92YWxpZC10eXBlcyAqL1xuXHRcdFx0bGluZUhlaWdodCxcblx0XHRcdGxldHRlclNwYWNpbmcsXG5cdFx0XHR0ZXh0QWxpZ246IGFsaWduLFxuXHRcdH0gKTtcblxuXHRcdHN4LnVwcGVyQ2FzZSA9IGNzcyggeyB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJyB9ICk7XG5cblx0XHRzeC5vcHRpbWFsVGV4dENvbG9yID0gbnVsbDtcblxuXHRcdGlmICggb3B0aW1pemVSZWFkYWJpbGl0eUZvciApIHtcblx0XHRcdGNvbnN0IGlzT3B0aW1hbFRleHRDb2xvckRhcmsgPVxuXHRcdFx0XHRnZXRPcHRpbWFsVGV4dFNoYWRlKCBvcHRpbWl6ZVJlYWRhYmlsaXR5Rm9yICkgPT09ICdkYXJrJztcblxuXHRcdFx0c3gub3B0aW1hbFRleHRDb2xvciA9IGlzT3B0aW1hbFRleHRDb2xvckRhcmtcblx0XHRcdFx0PyBjc3MoIHsgY29sb3I6IENPTE9SUy5ncmF5WyA5MDAgXSB9IClcblx0XHRcdFx0OiBjc3MoIHsgY29sb3I6IENPTE9SUy53aGl0ZSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN4KFxuXHRcdFx0c3R5bGVzLlRleHQsXG5cdFx0XHRzeC5CYXNlLFxuXHRcdFx0c3gub3B0aW1hbFRleHRDb2xvcixcblx0XHRcdGlzRGVzdHJ1Y3RpdmUgJiYgc3R5bGVzLmRlc3RydWN0aXZlLFxuXHRcdFx0ISEgaXNIaWdobGlnaHRlciAmJiBzdHlsZXMuaGlnaGxpZ2h0ZXJUZXh0LFxuXHRcdFx0aXNCbG9jayAmJiBzdHlsZXMuYmxvY2ssXG5cdFx0XHRpc0NhcHRpb24gJiYgc3R5bGVzLm11dGVkLFxuXHRcdFx0dmFyaWFudCAmJiBzdHlsZXNbIHZhcmlhbnQgXSxcblx0XHRcdHVwcGVyQ2FzZSAmJiBzeC51cHBlckNhc2UsXG5cdFx0XHRjbGFzc05hbWVcblx0XHQpO1xuXHR9LCBbXG5cdFx0YWRqdXN0TGluZUhlaWdodEZvcklubmVyQ29udHJvbHMsXG5cdFx0YWxpZ24sXG5cdFx0Y2xhc3NOYW1lLFxuXHRcdGNvbG9yLFxuXHRcdGN4LFxuXHRcdGRpc3BsYXksXG5cdFx0aXNCbG9jayxcblx0XHRpc0NhcHRpb24sXG5cdFx0aXNEZXN0cnVjdGl2ZSxcblx0XHRpc0hpZ2hsaWdodGVyLFxuXHRcdGxldHRlclNwYWNpbmcsXG5cdFx0bGluZUhlaWdodFByb3AsXG5cdFx0b3B0aW1pemVSZWFkYWJpbGl0eUZvcixcblx0XHRzaXplLFxuXHRcdHVwcGVyQ2FzZSxcblx0XHR2YXJpYW50LFxuXHRcdHdlaWdodCxcblx0XSApO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgJ2F1dG8nIHwgJ25vbmUnfSAqL1xuXHRsZXQgZmluYWxFbGxpcHNpemVNb2RlO1xuXHRpZiAoIHRydW5jYXRlID09PSB0cnVlICkge1xuXHRcdGZpbmFsRWxsaXBzaXplTW9kZSA9ICdhdXRvJztcblx0fVxuXHRpZiAoIHRydW5jYXRlID09PSBmYWxzZSApIHtcblx0XHRmaW5hbEVsbGlwc2l6ZU1vZGUgPSAnbm9uZSc7XG5cdH1cblxuXHRjb25zdCBmaW5hbENvbXBvbmVudFByb3BzID0ge1xuXHRcdC4uLm90aGVyUHJvcHMsXG5cdFx0Y2xhc3NOYW1lOiBjbGFzc2VzLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGVsbGlwc2l6ZU1vZGU6IGVsbGlwc2l6ZU1vZGUgfHwgZmluYWxFbGxpcHNpemVNb2RlLFxuXHR9O1xuXG5cdGNvbnN0IHRydW5jYXRlUHJvcHMgPSB1c2VUcnVuY2F0ZSggZmluYWxDb21wb25lbnRQcm9wcyApO1xuXG5cdC8qKlxuXHQgKiBFbmhhbmNlIGNoaWxkIGA8TGluayAvPmAgY29tcG9uZW50cyB0byBpbmhlcml0IGZvbnQgc2l6ZS5cblx0ICovXG5cdGlmICggISB0cnVuY2F0ZSAmJiBBcnJheS5pc0FycmF5KCBjaGlsZHJlbiApICkge1xuXHRcdGNvbnRlbnQgPSBDaGlsZHJlbi5tYXAoIGNoaWxkcmVuLCAoIGNoaWxkICkgPT4ge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8XG5cdFx0XHRcdGNoaWxkID09PSBudWxsIHx8XG5cdFx0XHRcdCEgKCAncHJvcHMnIGluIGNoaWxkIClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGlzTGluayA9IGhhc0Nvbm5lY3ROYW1lc3BhY2UoIGNoaWxkLCBbICdMaW5rJyBdICk7XG5cdFx0XHRpZiAoIGlzTGluayApIHtcblx0XHRcdFx0cmV0dXJuIGNsb25lRWxlbWVudCggY2hpbGQsIHtcblx0XHRcdFx0XHRzaXplOiBjaGlsZC5wcm9wcy5zaXplIHx8ICdpbmhlcml0Jyxcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHQuLi50cnVuY2F0ZVByb3BzLFxuXHRcdGNoaWxkcmVuOiB0cnVuY2F0ZSA/IHRydW5jYXRlUHJvcHMuY2hpbGRyZW4gOiBjb250ZW50LFxuXHR9O1xufVxuIl19 */");
      }
      return cx(Text, sx.Base, sx.optimalTextColor, isDestructive && destructive, !!isHighlighter && highlighterText, isBlock && block2, isCaption && muted, variant && styles_exports3[variant], upperCase2 && sx.upperCase, className);
    }, [adjustLineHeightForInnerControls, align, className, color4, cx, display, isBlock, isCaption, isDestructive, isHighlighter, letterSpacing2, lineHeightProp, optimizeReadabilityFor, size, upperCase2, variant, weight]);
    let finalEllipsizeMode;
    if (truncate === true) {
      finalEllipsizeMode = "auto";
    }
    if (truncate === false) {
      finalEllipsizeMode = "none";
    }
    const finalComponentProps = {
      ...otherProps,
      className: classes,
      children,
      ellipsizeMode: ellipsizeMode || finalEllipsizeMode
    };
    const truncateProps = useTruncate(finalComponentProps);
    if (!truncate && Array.isArray(children)) {
      content = import_react.Children.map(children, (child) => {
        if (typeof child !== "object" || child === null || !("props" in child)) {
          return child;
        }
        const isLink = hasConnectNamespace(child, ["Link"]);
        if (isLink) {
          return (0, import_react.cloneElement)(child, {
            size: child.props.size || "inherit"
          });
        }
        return child;
      });
    }
    return {
      ...truncateProps,
      children: truncate ? truncateProps.children : content
    };
  }

  // node_modules/@wordpress/components/build-module/text/component.js
  function Text2(props, forwardedRef) {
    const textProps = useText(props);
    return (0, import_react.createElement)(component_default, _extends({
      as: "span"
    }, textProps, {
      ref: forwardedRef
    }));
  }
  var ConnectedText = contextConnect(Text2, "Text");
  var component_default7 = ConnectedText;

  // node_modules/@wordpress/components/build-module/input-control/styles/input-control-styles.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__7() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var _ref2 = false ? {
    name: "1739oy8",
    styles: "z-index:1"
  } : {
    name: "1x8rmag-rootFocusedStyles",
    styles: "z-index:1;label:rootFocusedStyles;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdDUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__7
  };
  var rootFocusedStyles = (_ref32) => {
    let {
      isFocused
    } = _ref32;
    if (!isFocused)
      return "";
    return _ref2;
  };
  var Root = /* @__PURE__ */ (0, import_base2.default)(component_default3, false ? {
    target: "em5sgkm7"
  } : {
    target: "em5sgkm7",
    label: "Root"
  })("box-sizing:border-box;position:relative;border-radius:2px;padding-top:0;", rootFocusedStyles, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1DK0MiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */"));
  var containerDisabledStyles = (_ref42) => {
    let {
      disabled
    } = _ref42;
    const backgroundColor = disabled ? COLORS.ui.backgroundDisabled : COLORS.ui.background;
    return /* @__PURE__ */ (0, import_react74.css)({
      backgroundColor
    }, false ? "" : ";label:containerDisabledStyles;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdEUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var _ref3 = false ? {
    name: "1d3w5wq",
    styles: "width:100%"
  } : {
    name: "uo2pd2-containerWidthStyles",
    styles: "width:100%;label:containerWidthStyles;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVEc0MiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__7
  };
  var containerWidthStyles = (_ref52) => {
    let {
      __unstableInputWidth,
      labelPosition
    } = _ref52;
    if (!__unstableInputWidth)
      return _ref3;
    if (labelPosition === "side")
      return "";
    if (labelPosition === "edge") {
      return /* @__PURE__ */ (0, import_react74.css)({
        flex: `0 0 ${__unstableInputWidth}`
      }, false ? "" : ";label:containerWidthStyles;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTREUyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
    }
    return /* @__PURE__ */ (0, import_react74.css)({
      width: __unstableInputWidth
    }, false ? "" : ";label:containerWidthStyles;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlFUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var Container = (0, import_base2.default)("div", false ? {
    target: "em5sgkm6"
  } : {
    target: "em5sgkm6",
    label: "Container"
  })("align-items:center;box-sizing:border-box;border-radius:inherit;display:flex;flex:1;position:relative;", containerDisabledStyles, " ", containerWidthStyles, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9FcUQiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */"));
  var disabledStyles = (_ref62) => {
    let {
      disabled
    } = _ref62;
    if (!disabled)
      return "";
    return /* @__PURE__ */ (0, import_react74.css)({
      color: COLORS.ui.textDisabled
    }, false ? "" : ";label:disabledStyles;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZGUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var fontSizeStyles = (_ref72) => {
    let {
      inputSize: size
    } = _ref72;
    const sizes = {
      default: "13px",
      small: "11px",
      "__unstable-large": "13px"
    };
    const fontSize2 = sizes[size] || sizes.default;
    const fontSizeMobile = "16px";
    if (!fontSize2)
      return "";
    return /* @__PURE__ */ (0, import_react74.css)("font-size:", fontSizeMobile, ";@media ( min-width: 600px ){font-size:", fontSize2, ";}" + (false ? "" : ";label:fontSizeStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThHVyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var getSizeConfig = (_ref8) => {
    let {
      inputSize: size,
      __next36pxDefaultSize
    } = _ref8;
    const sizes = {
      default: {
        height: 36,
        lineHeight: 1,
        minHeight: 36,
        paddingLeft: space(4),
        paddingRight: space(4)
      },
      small: {
        height: 24,
        lineHeight: 1,
        minHeight: 24,
        paddingLeft: space(2),
        paddingRight: space(2)
      },
      "__unstable-large": {
        height: 40,
        lineHeight: 1,
        minHeight: 40,
        paddingLeft: space(4),
        paddingRight: space(4)
      }
    };
    if (!__next36pxDefaultSize) {
      sizes.default = {
        height: 30,
        lineHeight: 1,
        minHeight: 30,
        paddingLeft: space(2),
        paddingRight: space(2)
      };
    }
    return sizes[size] || sizes.default;
  };
  var sizeStyles = (props) => {
    return /* @__PURE__ */ (0, import_react74.css)(getSizeConfig(props), false ? "" : ";label:sizeStyles;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtLUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var customPaddings = (_ref9) => {
    let {
      paddingInlineStart,
      paddingInlineEnd
    } = _ref9;
    return /* @__PURE__ */ (0, import_react74.css)({
      paddingInlineStart,
      paddingInlineEnd
    }, false ? "" : ";label:customPaddings;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlLUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var dragStyles = (_ref10) => {
    let {
      isDragging,
      dragCursor
    } = _ref10;
    let defaultArrowStyles;
    let activeDragCursorStyles;
    if (isDragging) {
      defaultArrowStyles = /* @__PURE__ */ (0, import_react74.css)("cursor:", dragCursor, ";user-select:none;&::-webkit-outer-spin-button,&::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}" + (false ? "" : ";label:defaultArrowStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlMMEIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */");
    }
    if (isDragging && dragCursor) {
      activeDragCursorStyles = /* @__PURE__ */ (0, import_react74.css)("&:active{cursor:", dragCursor, ";}" + (false ? "" : ";label:activeDragCursorStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThMOEIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */");
    }
    return /* @__PURE__ */ (0, import_react74.css)(defaultArrowStyles, " ", activeDragCursorStyles, ";" + (false ? "" : ";label:dragStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXFNVyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var Input = (0, import_base2.default)("input", false ? {
    target: "em5sgkm5"
  } : {
    target: "em5sgkm5",
    label: "Input"
  })("&&&{background-color:transparent;box-sizing:border-box;border:none;box-shadow:none!important;color:", COLORS.gray[900], ";display:block;font-family:inherit;margin:0;outline:none;width:100%;", dragStyles, " ", disabledStyles, " ", fontSizeStyles, " ", sizeStyles, " ", customPaddings, " &::-webkit-input-placeholder{line-height:normal;}}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThNK0MiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */"));
  var BaseLabel = /* @__PURE__ */ (0, import_base2.default)(component_default7, false ? {
    target: "em5sgkm4"
  } : {
    target: "em5sgkm4",
    label: "BaseLabel"
  })("&&&{", baseLabelTypography, ";box-sizing:border-box;display:block;padding-top:0;padding-bottom:0;max-width:100%;z-index:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVPcUUiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */"));
  var Label = (props) => (0, import_react.createElement)(BaseLabel, _extends({}, props, {
    as: "label"
  }));
  var LabelWrapper = /* @__PURE__ */ (0, import_base2.default)(component_default4, false ? {
    target: "em5sgkm3"
  } : {
    target: "em5sgkm3",
    label: "LabelWrapper"
  })(false ? {
    name: "1b6uupn",
    styles: "max-width:calc( 100% - 10px )"
  } : {
    name: "1b6uupn",
    styles: "max-width:calc( 100% - 10px )",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdROEMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__7
  });
  var backdropFocusedStyles = (_ref11) => {
    let {
      disabled,
      isFocused
    } = _ref11;
    let borderColor = isFocused ? COLORS.ui.borderFocus : COLORS.ui.border;
    let boxShadow;
    if (isFocused) {
      boxShadow = `0 0 0 1px ${COLORS.ui.borderFocus} inset`;
    }
    if (disabled) {
      borderColor = COLORS.ui.borderDisabled;
    }
    return /* @__PURE__ */ (0, import_react74.css)({
      boxShadow,
      borderColor,
      borderStyle: "solid",
      borderWidth: 1
    }, false ? "" : ";label:backdropFocusedStyles;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlSUSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcywgU2VyaWFsaXplZFN0eWxlcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBGbGV4LCBGbGV4SXRlbSB9IGZyb20gJy4uLy4uL2ZsZXgnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3RleHQnO1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgQ09MT1JTLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IExhYmVsUG9zaXRpb24sIFNpemUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxudHlwZSBDb250YWluZXJQcm9wcyA9IHtcblx0ZGlzYWJsZWQ/OiBib29sZWFuO1xuXHRoaWRlTGFiZWw/OiBib29sZWFuO1xuXHRfX3Vuc3RhYmxlSW5wdXRXaWR0aD86IENTU1Byb3BlcnRpZXNbICd3aWR0aCcgXTtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG50eXBlIFJvb3RQcm9wcyA9IHtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcblx0bGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247XG59O1xuXG5jb25zdCByb290Rm9jdXNlZFN0eWxlcyA9ICggeyBpc0ZvY3VzZWQgfTogUm9vdFByb3BzICkgPT4ge1xuXHRpZiAoICEgaXNGb2N1c2VkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHsgekluZGV4OiAxIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSb290ID0gc3R5bGVkKCBGbGV4ICk8IFJvb3RQcm9wcyA+YFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdGJvcmRlci1yYWRpdXM6IDJweDtcblx0cGFkZGluZy10b3A6IDA7XG5cdCR7IHJvb3RGb2N1c2VkU3R5bGVzIH1cbmA7XG5cbmNvbnN0IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzID0gKCB7IGRpc2FibGVkIH06IENvbnRhaW5lclByb3BzICkgPT4ge1xuXHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkaXNhYmxlZFxuXHRcdD8gQ09MT1JTLnVpLmJhY2tncm91bmREaXNhYmxlZFxuXHRcdDogQ09MT1JTLnVpLmJhY2tncm91bmQ7XG5cblx0cmV0dXJuIGNzcyggeyBiYWNrZ3JvdW5kQ29sb3IgfSApO1xufTtcblxuY29uc3QgY29udGFpbmVyV2lkdGhTdHlsZXMgPSAoIHtcblx0X191bnN0YWJsZUlucHV0V2lkdGgsXG5cdGxhYmVsUG9zaXRpb24sXG59OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0aWYgKCAhIF9fdW5zdGFibGVJbnB1dFdpZHRoICkgcmV0dXJuIGNzcyggeyB3aWR0aDogJzEwMCUnIH0gKTtcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdzaWRlJyApIHJldHVybiAnJztcblxuXHRpZiAoIGxhYmVsUG9zaXRpb24gPT09ICdlZGdlJyApIHtcblx0XHRyZXR1cm4gY3NzKCB7XG5cdFx0XHRmbGV4OiBgMCAwICR7IF9fdW5zdGFibGVJbnB1dFdpZHRoIH1gLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiBjc3MoIHsgd2lkdGg6IF9fdW5zdGFibGVJbnB1dFdpZHRoIH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSBzdHlsZWQuZGl2PCBDb250YWluZXJQcm9wcyA+YFxuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRmbGV4OiAxO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0JHsgY29udGFpbmVyRGlzYWJsZWRTdHlsZXMgfVxuXHQkeyBjb250YWluZXJXaWR0aFN0eWxlcyB9XG5gO1xuXG50eXBlIElucHV0UHJvcHMgPSB7XG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZT86IGJvb2xlYW47XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aW5wdXRTaXplPzogU2l6ZTtcblx0aXNEcmFnZ2luZz86IGJvb2xlYW47XG5cdGRyYWdDdXJzb3I/OiBDU1NQcm9wZXJ0aWVzWyAnY3Vyc29yJyBdO1xuXHRwYWRkaW5nSW5saW5lU3RhcnQ/OiBDU1NQcm9wZXJ0aWVzWyAncGFkZGluZ0lubGluZVN0YXJ0JyBdO1xuXHRwYWRkaW5nSW5saW5lRW5kPzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVFbmQnIF07XG59O1xuXG5jb25zdCBkaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRpZiAoICEgZGlzYWJsZWQgKSByZXR1cm4gJyc7XG5cblx0cmV0dXJuIGNzcygge1xuXHRcdGNvbG9yOiBDT0xPUlMudWkudGV4dERpc2FibGVkLFxuXHR9ICk7XG59O1xuXG5jb25zdCBmb250U2l6ZVN0eWxlcyA9ICggeyBpbnB1dFNpemU6IHNpemUgfTogSW5wdXRQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzEzcHgnLFxuXHRcdHNtYWxsOiAnMTFweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnMTNweCcsXG5cdH07XG5cblx0Y29uc3QgZm9udFNpemUgPSBzaXplc1sgc2l6ZSBhcyBTaXplIF0gfHwgc2l6ZXMuZGVmYXVsdDtcblx0Y29uc3QgZm9udFNpemVNb2JpbGUgPSAnMTZweCc7XG5cblx0aWYgKCAhIGZvbnRTaXplICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Zm9udC1zaXplOiAkeyBmb250U2l6ZU1vYmlsZSB9O1xuXG5cdFx0QG1lZGlhICggbWluLXdpZHRoOiA2MDBweCApIHtcblx0XHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemUgfTtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U2l6ZUNvbmZpZyA9ICgge1xuXHRpbnB1dFNpemU6IHNpemUsXG5cdF9fbmV4dDM2cHhEZWZhdWx0U2l6ZSxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdC8vIFBhZGRpbmdzIG1heSBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjdXN0b20gcGFkZGluZ3MgcHJvcHMuXG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdGhlaWdodDogMzYsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzNixcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggNCApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggNCApLFxuXHRcdH0sXG5cdFx0c21hbGw6IHtcblx0XHRcdGhlaWdodDogMjQsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAyNCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH0sXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiB7XG5cdFx0XHRoZWlnaHQ6IDQwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogNDAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHR9O1xuXG5cdGlmICggISBfX25leHQzNnB4RGVmYXVsdFNpemUgKSB7XG5cdFx0c2l6ZXMuZGVmYXVsdCA9IHtcblx0XHRcdGhlaWdodDogMzAsXG5cdFx0XHRsaW5lSGVpZ2h0OiAxLFxuXHRcdFx0bWluSGVpZ2h0OiAzMCxcblx0XHRcdHBhZGRpbmdMZWZ0OiBzcGFjZSggMiApLFxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBzcGFjZSggMiApLFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBzaXplU3R5bGVzID0gKCBwcm9wczogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggZ2V0U2l6ZUNvbmZpZyggcHJvcHMgKSApO1xufTtcblxuY29uc3QgY3VzdG9tUGFkZGluZ3MgPSAoIHtcblx0cGFkZGluZ0lubGluZVN0YXJ0LFxuXHRwYWRkaW5nSW5saW5lRW5kLFxufTogSW5wdXRQcm9wcyApID0+IHtcblx0cmV0dXJuIGNzcyggeyBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdJbmxpbmVFbmQgfSApO1xufTtcblxuY29uc3QgZHJhZ1N0eWxlcyA9ICggeyBpc0RyYWdnaW5nLCBkcmFnQ3Vyc29yIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGxldCBkZWZhdWx0QXJyb3dTdHlsZXM6IFNlcmlhbGl6ZWRTdHlsZXMgfCB1bmRlZmluZWQ7XG5cdGxldCBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXG5cdGlmICggaXNEcmFnZ2luZyApIHtcblx0XHRkZWZhdWx0QXJyb3dTdHlsZXMgPSBjc3NgXG5cdFx0XHRjdXJzb3I6ICR7IGRyYWdDdXJzb3IgfTtcblx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0XHQmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XG5cdFx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHRcdH1cblx0XHRgO1xuXHR9XG5cblx0aWYgKCBpc0RyYWdnaW5nICYmIGRyYWdDdXJzb3IgKSB7XG5cdFx0YWN0aXZlRHJhZ0N1cnNvclN0eWxlcyA9IGNzc2Bcblx0XHRcdCY6YWN0aXZlIHtcblx0XHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0JHsgZGVmYXVsdEFycm93U3R5bGVzIH1cblx0XHQkeyBhY3RpdmVEcmFnQ3Vyc29yU3R5bGVzIH1cblx0YDtcbn07XG5cbi8vIFRPRE86IFJlc29sdmUgbmVlZCB0byB1c2UgJiYmIHRvIGluY3JlYXNlIHNwZWNpZmljaXR5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vV29yZFByZXNzL2d1dGVuYmVyZy9pc3N1ZXMvMTg0ODNcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PCBJbnB1dFByb3BzID5gXG5cdCYmJiB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRtYXJnaW46IDA7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblxuXHRcdCR7IGRyYWdTdHlsZXMgfVxuXHRcdCR7IGRpc2FibGVkU3R5bGVzIH1cblx0XHQkeyBmb250U2l6ZVN0eWxlcyB9XG5cdFx0JHsgc2l6ZVN0eWxlcyB9XG5cdFx0JHsgY3VzdG9tUGFkZGluZ3MgfVxuXG5cdFx0Jjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG5cdFx0XHRsaW5lLWhlaWdodDogbm9ybWFsO1xuXHRcdH1cblx0fVxuYDtcblxuY29uc3QgQmFzZUxhYmVsID0gc3R5bGVkKCBUZXh0ICk8IHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb24gfSA+YFxuXHQmJiYge1xuXHRcdCR7IGJhc2VMYWJlbFR5cG9ncmFwaHkgfTtcblxuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0cGFkZGluZy10b3A6IDA7XG5cdFx0cGFkZGluZy1ib3R0b206IDA7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDE7XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBMYWJlbCA9IChcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPFxuXHRcdHsgbGFiZWxQb3NpdGlvbj86IExhYmVsUG9zaXRpb247IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSxcblx0XHQnbGFiZWwnLFxuXHRcdGZhbHNlXG5cdD5cbikgPT4gPEJhc2VMYWJlbCB7IC4uLnByb3BzIH0gYXM9XCJsYWJlbFwiIC8+O1xuXG5leHBvcnQgY29uc3QgTGFiZWxXcmFwcGVyID0gc3R5bGVkKCBGbGV4SXRlbSApYFxuXHRtYXgtd2lkdGg6IGNhbGMoIDEwMCUgLSAxMHB4ICk7XG5gO1xuXG50eXBlIEJhY2tkcm9wUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aXNGb2N1c2VkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyA9ICgge1xuXHRkaXNhYmxlZCxcblx0aXNGb2N1c2VkLFxufTogQmFja2Ryb3BQcm9wcyApOiBTZXJpYWxpemVkU3R5bGVzID0+IHtcblx0bGV0IGJvcmRlckNvbG9yID0gaXNGb2N1c2VkID8gQ09MT1JTLnVpLmJvcmRlckZvY3VzIDogQ09MT1JTLnVpLmJvcmRlcjtcblxuXHRsZXQgYm94U2hhZG93O1xuXG5cdGlmICggaXNGb2N1c2VkICkge1xuXHRcdGJveFNoYWRvdyA9IGAwIDAgMCAxcHggJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH0gaW5zZXRgO1xuXHR9XG5cblx0aWYgKCBkaXNhYmxlZCApIHtcblx0XHRib3JkZXJDb2xvciA9IENPTE9SUy51aS5ib3JkZXJEaXNhYmxlZDtcblx0fVxuXG5cdHJldHVybiBjc3MoIHtcblx0XHRib3hTaGFkb3csXG5cdFx0Ym9yZGVyQ29sb3IsXG5cdFx0Ym9yZGVyU3R5bGU6ICdzb2xpZCcsXG5cdFx0Ym9yZGVyV2lkdGg6IDEsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFVJID0gc3R5bGVkLmRpdjwgQmFja2Ryb3BQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXG5cdFx0JHsgYmFja2Ryb3BGb2N1c2VkU3R5bGVzIH1cblx0XHQkeyBydGwoIHsgcGFkZGluZ0xlZnQ6IDIgfSApIH1cblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IFByZWZpeCA9IHN0eWxlZC5zcGFuYFxuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRkaXNwbGF5OiBibG9jaztcbmA7XG5cbmV4cG9ydCBjb25zdCBTdWZmaXggPSBzdHlsZWQuc3BhbmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YWxpZ24tc2VsZjogc3RyZXRjaDtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var BackdropUI = (0, import_base2.default)("div", false ? {
    target: "em5sgkm2"
  } : {
    target: "em5sgkm2",
    label: "BackdropUI"
  })("&&&{box-sizing:border-box;border-radius:inherit;bottom:0;left:0;margin:0;padding:0;pointer-events:none;position:absolute;right:0;top:0;", backdropFocusedStyles, " ", rtl({
    paddingLeft: 2
  }), ";}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlTcUQiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */"));
  var Prefix = (0, import_base2.default)("span", false ? {
    target: "em5sgkm1"
  } : {
    target: "em5sgkm1",
    label: "Prefix"
  })(false ? {
    name: "pvvbxf",
    styles: "box-sizing:border-box;display:block"
  } : {
    name: "pvvbxf",
    styles: "box-sizing:border-box;display:block",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1UaUMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__7
  });
  var Suffix = (0, import_base2.default)("span", false ? {
    target: "em5sgkm0"
  } : {
    target: "em5sgkm0",
    label: "Suffix"
  })(false ? {
    name: "jgf79h",
    styles: "align-items:center;align-self:stretch;box-sizing:border-box;display:flex"
  } : {
    name: "jgf79h",
    styles: "align-items:center;align-self:stretch;box-sizing:border-box;display:flex",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdUaUMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9pbnB1dC1jb250cm9sL3N0eWxlcy9pbnB1dC1jb250cm9sLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MsIFNlcmlhbGl6ZWRTdHlsZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgdHlwZSB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uLy4uL3VpL2NvbnRleHQnO1xuaW1wb3J0IHsgRmxleCwgRmxleEl0ZW0gfSBmcm9tICcuLi8uLi9mbGV4JztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90ZXh0JztcbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIENPTE9SUywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMYWJlbFBvc2l0aW9uLCBTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbnR5cGUgQ29udGFpbmVyUHJvcHMgPSB7XG5cdGRpc2FibGVkPzogYm9vbGVhbjtcblx0aGlkZUxhYmVsPzogYm9vbGVhbjtcblx0X191bnN0YWJsZUlucHV0V2lkdGg/OiBDU1NQcm9wZXJ0aWVzWyAnd2lkdGgnIF07XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxudHlwZSBSb290UHJvcHMgPSB7XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG5cdGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uO1xufTtcblxuY29uc3Qgcm9vdEZvY3VzZWRTdHlsZXMgPSAoIHsgaXNGb2N1c2VkIH06IFJvb3RQcm9wcyApID0+IHtcblx0aWYgKCAhIGlzRm9jdXNlZCApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzKCB7IHpJbmRleDogMSB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgUm9vdCA9IHN0eWxlZCggRmxleCApPCBSb290UHJvcHMgPmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRib3JkZXItcmFkaXVzOiAycHg7XG5cdHBhZGRpbmctdG9wOiAwO1xuXHQkeyByb290Rm9jdXNlZFN0eWxlcyB9XG5gO1xuXG5jb25zdCBjb250YWluZXJEaXNhYmxlZFN0eWxlcyA9ICggeyBkaXNhYmxlZCB9OiBDb250YWluZXJQcm9wcyApID0+IHtcblx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gZGlzYWJsZWRcblx0XHQ/IENPTE9SUy51aS5iYWNrZ3JvdW5kRGlzYWJsZWRcblx0XHQ6IENPTE9SUy51aS5iYWNrZ3JvdW5kO1xuXG5cdHJldHVybiBjc3MoIHsgYmFja2dyb3VuZENvbG9yIH0gKTtcbn07XG5cbmNvbnN0IGNvbnRhaW5lcldpZHRoU3R5bGVzID0gKCB7XG5cdF9fdW5zdGFibGVJbnB1dFdpZHRoLFxuXHRsYWJlbFBvc2l0aW9uLFxufTogQ29udGFpbmVyUHJvcHMgKSA9PiB7XG5cdGlmICggISBfX3Vuc3RhYmxlSW5wdXRXaWR0aCApIHJldHVybiBjc3MoIHsgd2lkdGg6ICcxMDAlJyB9ICk7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnc2lkZScgKSByZXR1cm4gJyc7XG5cblx0aWYgKCBsYWJlbFBvc2l0aW9uID09PSAnZWRnZScgKSB7XG5cdFx0cmV0dXJuIGNzcygge1xuXHRcdFx0ZmxleDogYDAgMCAkeyBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9YCxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7IHdpZHRoOiBfX3Vuc3RhYmxlSW5wdXRXaWR0aCB9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29udGFpbmVyID0gc3R5bGVkLmRpdjwgQ29udGFpbmVyUHJvcHMgPmBcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0Ym9yZGVyLXJhZGl1czogaW5oZXJpdDtcblx0ZGlzcGxheTogZmxleDtcblx0ZmxleDogMTtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdCR7IGNvbnRhaW5lckRpc2FibGVkU3R5bGVzIH1cblx0JHsgY29udGFpbmVyV2lkdGhTdHlsZXMgfVxuYDtcblxudHlwZSBJbnB1dFByb3BzID0ge1xuXHRfX25leHQzNnB4RGVmYXVsdFNpemU/OiBib29sZWFuO1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlucHV0U2l6ZT86IFNpemU7XG5cdGlzRHJhZ2dpbmc/OiBib29sZWFuO1xuXHRkcmFnQ3Vyc29yPzogQ1NTUHJvcGVydGllc1sgJ2N1cnNvcicgXTtcblx0cGFkZGluZ0lubGluZVN0YXJ0PzogQ1NTUHJvcGVydGllc1sgJ3BhZGRpbmdJbmxpbmVTdGFydCcgXTtcblx0cGFkZGluZ0lubGluZUVuZD86IENTU1Byb3BlcnRpZXNbICdwYWRkaW5nSW5saW5lRW5kJyBdO1xufTtcblxuY29uc3QgZGlzYWJsZWRTdHlsZXMgPSAoIHsgZGlzYWJsZWQgfTogSW5wdXRQcm9wcyApID0+IHtcblx0aWYgKCAhIGRpc2FibGVkICkgcmV0dXJuICcnO1xuXG5cdHJldHVybiBjc3MoIHtcblx0XHRjb2xvcjogQ09MT1JTLnVpLnRleHREaXNhYmxlZCxcblx0fSApO1xufTtcblxuY29uc3QgZm9udFNpemVTdHlsZXMgPSAoIHsgaW5wdXRTaXplOiBzaXplIH06IElucHV0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICcxM3B4Jyxcblx0XHRzbWFsbDogJzExcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzEzcHgnLFxuXHR9O1xuXG5cdGNvbnN0IGZvbnRTaXplID0gc2l6ZXNbIHNpemUgYXMgU2l6ZSBdIHx8IHNpemVzLmRlZmF1bHQ7XG5cdGNvbnN0IGZvbnRTaXplTW9iaWxlID0gJzE2cHgnO1xuXG5cdGlmICggISBmb250U2l6ZSApIHJldHVybiAnJztcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGZvbnQtc2l6ZTogJHsgZm9udFNpemVNb2JpbGUgfTtcblxuXHRcdEBtZWRpYSAoIG1pbi13aWR0aDogNjAwcHggKSB7XG5cdFx0XHRmb250LXNpemU6ICR7IGZvbnRTaXplIH07XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFNpemVDb25maWcgPSAoIHtcblx0aW5wdXRTaXplOiBzaXplLFxuXHRfX25leHQzNnB4RGVmYXVsdFNpemUsXG59OiBJbnB1dFByb3BzICkgPT4ge1xuXHQvLyBQYWRkaW5ncyBtYXkgYmUgb3ZlcnJpZGRlbiBieSB0aGUgY3VzdG9tIHBhZGRpbmdzIHByb3BzLlxuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRoZWlnaHQ6IDM2LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzYsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDQgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDQgKSxcblx0XHR9LFxuXHRcdHNtYWxsOiB7XG5cdFx0XHRoZWlnaHQ6IDI0LFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMjQsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9LFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzoge1xuXHRcdFx0aGVpZ2h0OiA0MCxcblx0XHRcdGxpbmVIZWlnaHQ6IDEsXG5cdFx0XHRtaW5IZWlnaHQ6IDQwLFxuXHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCA0ICksXG5cdFx0XHRwYWRkaW5nUmlnaHQ6IHNwYWNlKCA0ICksXG5cdFx0fSxcblx0fTtcblxuXHRpZiAoICEgX19uZXh0MzZweERlZmF1bHRTaXplICkge1xuXHRcdHNpemVzLmRlZmF1bHQgPSB7XG5cdFx0XHRoZWlnaHQ6IDMwLFxuXHRcdFx0bGluZUhlaWdodDogMSxcblx0XHRcdG1pbkhlaWdodDogMzAsXG5cdFx0XHRwYWRkaW5nTGVmdDogc3BhY2UoIDIgKSxcblx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIDIgKSxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHNpemVzWyBzaXplIGFzIFNpemUgXSB8fCBzaXplcy5kZWZhdWx0O1xufTtcblxuY29uc3Qgc2l6ZVN0eWxlcyA9ICggcHJvcHM6IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIGdldFNpemVDb25maWcoIHByb3BzICkgKTtcbn07XG5cbmNvbnN0IGN1c3RvbVBhZGRpbmdzID0gKCB7XG5cdHBhZGRpbmdJbmxpbmVTdGFydCxcblx0cGFkZGluZ0lubGluZUVuZCxcbn06IElucHV0UHJvcHMgKSA9PiB7XG5cdHJldHVybiBjc3MoIHsgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nSW5saW5lRW5kIH0gKTtcbn07XG5cbmNvbnN0IGRyYWdTdHlsZXMgPSAoIHsgaXNEcmFnZ2luZywgZHJhZ0N1cnNvciB9OiBJbnB1dFByb3BzICkgPT4ge1xuXHRsZXQgZGVmYXVsdEFycm93U3R5bGVzOiBTZXJpYWxpemVkU3R5bGVzIHwgdW5kZWZpbmVkO1xuXHRsZXQgYWN0aXZlRHJhZ0N1cnNvclN0eWxlczogU2VyaWFsaXplZFN0eWxlcyB8IHVuZGVmaW5lZDtcblxuXHRpZiAoIGlzRHJhZ2dpbmcgKSB7XG5cdFx0ZGVmYXVsdEFycm93U3R5bGVzID0gY3NzYFxuXHRcdFx0Y3Vyc29yOiAkeyBkcmFnQ3Vyc29yIH07XG5cdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdFx0Jjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcblx0XHRcdCY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmUgIWltcG9ydGFudDtcblx0XHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0XHR9XG5cdFx0YDtcblx0fVxuXG5cdGlmICggaXNEcmFnZ2luZyAmJiBkcmFnQ3Vyc29yICkge1xuXHRcdGFjdGl2ZURyYWdDdXJzb3JTdHlsZXMgPSBjc3NgXG5cdFx0XHQmOmFjdGl2ZSB7XG5cdFx0XHRcdGN1cnNvcjogJHsgZHJhZ0N1cnNvciB9O1xuXHRcdFx0fVxuXHRcdGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdCR7IGRlZmF1bHRBcnJvd1N0eWxlcyB9XG5cdFx0JHsgYWN0aXZlRHJhZ0N1cnNvclN0eWxlcyB9XG5cdGA7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHN0eWxlZC5pbnB1dDwgSW5wdXRQcm9wcyA+YFxuXHQmJiYge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cblx0XHQkeyBkcmFnU3R5bGVzIH1cblx0XHQkeyBkaXNhYmxlZFN0eWxlcyB9XG5cdFx0JHsgZm9udFNpemVTdHlsZXMgfVxuXHRcdCR7IHNpemVTdHlsZXMgfVxuXHRcdCR7IGN1c3RvbVBhZGRpbmdzIH1cblxuXHRcdCY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xuXHRcdFx0bGluZS1oZWlnaHQ6IG5vcm1hbDtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IEJhc2VMYWJlbCA9IHN0eWxlZCggVGV4dCApPCB7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uIH0gPmBcblx0JiYmIHtcblx0XHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmctdG9wOiAwO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxO1xuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgTGFiZWwgPSAoXG5cdHByb3BzOiBXb3JkUHJlc3NDb21wb25lbnRQcm9wczxcblx0XHR7IGxhYmVsUG9zaXRpb24/OiBMYWJlbFBvc2l0aW9uOyBjaGlsZHJlbjogUmVhY3ROb2RlIH0sXG5cdFx0J2xhYmVsJyxcblx0XHRmYWxzZVxuXHQ+XG4pID0+IDxCYXNlTGFiZWwgeyAuLi5wcm9wcyB9IGFzPVwibGFiZWxcIiAvPjtcblxuZXhwb3J0IGNvbnN0IExhYmVsV3JhcHBlciA9IHN0eWxlZCggRmxleEl0ZW0gKWBcblx0bWF4LXdpZHRoOiBjYWxjKCAxMDAlIC0gMTBweCApO1xuYDtcblxudHlwZSBCYWNrZHJvcFByb3BzID0ge1xuXHRkaXNhYmxlZD86IGJvb2xlYW47XG5cdGlzRm9jdXNlZD86IGJvb2xlYW47XG59O1xuXG5jb25zdCBiYWNrZHJvcEZvY3VzZWRTdHlsZXMgPSAoIHtcblx0ZGlzYWJsZWQsXG5cdGlzRm9jdXNlZCxcbn06IEJhY2tkcm9wUHJvcHMgKTogU2VyaWFsaXplZFN0eWxlcyA9PiB7XG5cdGxldCBib3JkZXJDb2xvciA9IGlzRm9jdXNlZCA/IENPTE9SUy51aS5ib3JkZXJGb2N1cyA6IENPTE9SUy51aS5ib3JkZXI7XG5cblx0bGV0IGJveFNoYWRvdztcblxuXHRpZiAoIGlzRm9jdXNlZCApIHtcblx0XHRib3hTaGFkb3cgPSBgMCAwIDAgMXB4ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9IGluc2V0YDtcblx0fVxuXG5cdGlmICggZGlzYWJsZWQgKSB7XG5cdFx0Ym9yZGVyQ29sb3IgPSBDT0xPUlMudWkuYm9yZGVyRGlzYWJsZWQ7XG5cdH1cblxuXHRyZXR1cm4gY3NzKCB7XG5cdFx0Ym94U2hhZG93LFxuXHRcdGJvcmRlckNvbG9yLFxuXHRcdGJvcmRlclN0eWxlOiAnc29saWQnLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BVSSA9IHN0eWxlZC5kaXY8IEJhY2tkcm9wUHJvcHMgPmBcblx0JiYmIHtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblxuXHRcdCR7IGJhY2tkcm9wRm9jdXNlZFN0eWxlcyB9XG5cdFx0JHsgcnRsKCB7IHBhZGRpbmdMZWZ0OiAyIH0gKSB9XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQcmVmaXggPSBzdHlsZWQuc3BhbmBcblx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgU3VmZml4ID0gc3R5bGVkLnNwYW5gXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFsaWduLXNlbGY6IHN0cmV0Y2g7XG5cdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__7
  });

  // node_modules/@wordpress/components/build-module/input-control/backdrop.js
  function Backdrop(_ref8) {
    let {
      disabled = false,
      isFocused = false
    } = _ref8;
    return (0, import_react.createElement)(BackdropUI, {
      "aria-hidden": "true",
      className: "components-input-control__backdrop",
      disabled,
      isFocused
    });
  }
  var MemoizedBackdrop = (0, import_react.memo)(Backdrop);
  var backdrop_default = MemoizedBackdrop;

  // node_modules/@wordpress/components/build-module/input-control/label.js
  function Label2(_ref8) {
    let {
      children,
      hideLabelFromVision,
      htmlFor,
      ...props
    } = _ref8;
    if (!children)
      return null;
    if (hideLabelFromVision) {
      return (0, import_react.createElement)(component_default2, {
        as: "label",
        htmlFor
      }, children);
    }
    return (0, import_react.createElement)(LabelWrapper, null, (0, import_react.createElement)(Label, _extends({
      htmlFor
    }, props), children));
  }

  // node_modules/@wordpress/components/build-module/input-control/input-base.js
  function useUniqueId(idProp) {
    const instanceId = use_instance_id_default(InputBase);
    const id2 = `input-base-control-${instanceId}`;
    return idProp || id2;
  }
  function getUIFlexProps(labelPosition) {
    const props = {};
    switch (labelPosition) {
      case "top":
        props.direction = "column";
        props.gap = 0;
        break;
      case "bottom":
        props.direction = "column-reverse";
        props.gap = 0;
        break;
      case "edge":
        props.justify = "space-between";
        break;
    }
    return props;
  }
  function InputBase(_ref8, ref2) {
    let {
      __next36pxDefaultSize,
      __unstableInputWidth,
      children,
      className,
      disabled = false,
      hideLabelFromVision = false,
      labelPosition,
      id: idProp,
      isFocused = false,
      label,
      prefix: prefix2,
      size = "default",
      suffix,
      ...props
    } = _ref8;
    const id2 = useUniqueId(idProp);
    const hideLabel = hideLabelFromVision || !label;
    const {
      paddingLeft,
      paddingRight
    } = getSizeConfig({
      inputSize: size,
      __next36pxDefaultSize
    });
    const prefixSuffixContextValue = (0, import_react.useMemo)(() => {
      return {
        InputControlPrefixWrapper: {
          paddingLeft
        },
        InputControlSuffixWrapper: {
          paddingRight
        }
      };
    }, [paddingLeft, paddingRight]);
    return (0, import_react.createElement)(Root, _extends({}, props, getUIFlexProps(labelPosition), {
      className,
      gap: 2,
      isFocused,
      labelPosition,
      ref: ref2
    }), (0, import_react.createElement)(Label2, {
      className: "components-input-control__label",
      hideLabelFromVision,
      labelPosition,
      htmlFor: id2
    }, label), (0, import_react.createElement)(Container, {
      __unstableInputWidth,
      className: "components-input-control__container",
      disabled,
      hideLabel,
      labelPosition
    }, (0, import_react.createElement)(ContextSystemProvider, {
      value: prefixSuffixContextValue
    }, prefix2 && (0, import_react.createElement)(Prefix, {
      className: "components-input-control__prefix"
    }, prefix2), children, suffix && (0, import_react.createElement)(Suffix, {
      className: "components-input-control__suffix"
    }, suffix)), (0, import_react.createElement)(backdrop_default, {
      disabled,
      isFocused
    })));
  }
  var input_base_default = (0, import_react.forwardRef)(InputBase);

  // node_modules/@use-gesture/core/dist/maths-b28d9b98.esm.js
  function clamp3(v5, min, max) {
    return Math.max(min, Math.min(v5, max));
  }
  var V = {
    toVector(v5, fallback) {
      if (v5 === void 0)
        v5 = fallback;
      return Array.isArray(v5) ? v5 : [v5, v5];
    },
    add(v1, v22) {
      return [v1[0] + v22[0], v1[1] + v22[1]];
    },
    sub(v1, v22) {
      return [v1[0] - v22[0], v1[1] - v22[1]];
    },
    addTo(v1, v22) {
      v1[0] += v22[0];
      v1[1] += v22[1];
    },
    subTo(v1, v22) {
      v1[0] -= v22[0];
      v1[1] -= v22[1];
    }
  };
  function rubberband(distance2, dimension, constant) {
    if (dimension === 0 || Math.abs(dimension) === Infinity)
      return Math.pow(distance2, constant * 5);
    return distance2 * dimension * constant / (dimension + constant * distance2);
  }
  function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
    if (constant === 0)
      return clamp3(position, min, max);
    if (position < min)
      return -rubberband(min - position, max - min, constant) + min;
    if (position > max)
      return +rubberband(position - max, max - min, constant) + max;
    return position;
  }
  function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
    const [[X0, X1], [Y0, Y1]] = bounds;
    return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
  }

  // node_modules/@use-gesture/core/dist/actions-71ad3053.esm.js
  function _defineProperty5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread25(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = null != arguments[i5] ? arguments[i5] : {};
      i5 % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty5(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var EVENT_TYPE_MAP = {
    pointer: {
      start: "down",
      change: "move",
      end: "up"
    },
    mouse: {
      start: "down",
      change: "move",
      end: "up"
    },
    touch: {
      start: "start",
      change: "move",
      end: "end"
    },
    gesture: {
      start: "start",
      change: "change",
      end: "end"
    }
  };
  function capitalize(string2) {
    if (!string2)
      return "";
    return string2[0].toUpperCase() + string2.slice(1);
  }
  var actionsWithoutCaptureSupported = ["enter", "leave"];
  function hasCapture(capture = false, actionKey) {
    return capture && !actionsWithoutCaptureSupported.includes(actionKey);
  }
  function toHandlerProp(device, action = "", capture = false) {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
  }
  var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
  function parseProp(prop2) {
    let eventKey = prop2.substring(2).toLowerCase();
    const passive = !!~eventKey.indexOf("passive");
    if (passive)
      eventKey = eventKey.replace("passive", "");
    const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
    const capture = !!~eventKey.indexOf(captureKey);
    if (capture)
      eventKey = eventKey.replace("capture", "");
    return {
      device: eventKey,
      capture,
      passive
    };
  }
  function toDomEventType(device, action = "") {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return device + actionKey;
  }
  function isTouch(event) {
    return "touches" in event;
  }
  function getPointerType(event) {
    if (isTouch(event))
      return "touch";
    if ("pointerType" in event)
      return event.pointerType;
    return "mouse";
  }
  function getCurrentTargetTouchList(event) {
    return Array.from(event.touches).filter((e4) => {
      var _event$currentTarget, _event$currentTarget$;
      return e4.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e4.target));
    });
  }
  function getTouchList(event) {
    return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
  }
  function getValueEvent(event) {
    return isTouch(event) ? getTouchList(event)[0] : event;
  }
  function touchIds(event) {
    return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
  }
  function pointerId(event) {
    const valueEvent = getValueEvent(event);
    return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
  }
  function pointerValues(event) {
    const valueEvent = getValueEvent(event);
    return [valueEvent.clientX, valueEvent.clientY];
  }
  function getEventDetails(event) {
    const payload = {};
    if ("buttons" in event)
      payload.buttons = event.buttons;
    if ("shiftKey" in event) {
      const {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      } = event;
      Object.assign(payload, {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      });
    }
    return payload;
  }
  function call(v5, ...args) {
    if (typeof v5 === "function") {
      return v5(...args);
    } else {
      return v5;
    }
  }
  function noop3() {
  }
  function chain(...fns) {
    if (fns.length === 0)
      return noop3;
    if (fns.length === 1)
      return fns[0];
    return function() {
      let result;
      for (const fn of fns) {
        result = fn.apply(this, arguments) || result;
      }
      return result;
    };
  }
  function assignDefault(value, fallback) {
    return Object.assign({}, fallback, value || {});
  }
  var BEFORE_LAST_KINEMATICS_DELAY = 32;
  var Engine = class {
    constructor(ctrl, args, key) {
      this.ctrl = ctrl;
      this.args = args;
      this.key = key;
      if (!this.state) {
        this.state = {};
        this.computeValues([0, 0]);
        this.computeInitial();
        if (this.init)
          this.init();
        this.reset();
      }
    }
    get state() {
      return this.ctrl.state[this.key];
    }
    set state(state) {
      this.ctrl.state[this.key] = state;
    }
    get shared() {
      return this.ctrl.state.shared;
    }
    get eventStore() {
      return this.ctrl.gestureEventStores[this.key];
    }
    get timeoutStore() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
    get config() {
      return this.ctrl.config[this.key];
    }
    get sharedConfig() {
      return this.ctrl.config.shared;
    }
    get handler() {
      return this.ctrl.handlers[this.key];
    }
    reset() {
      const {
        state,
        shared,
        ingKey,
        args
      } = this;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = void 0;
      state.memo = void 0;
      state.elapsedTime = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
    start(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config2.from ? call(config2.from, state) : state.offset;
        state.offset = state.lastOffset;
      }
      state.startTime = state.timeStamp = event.timeStamp;
    }
    computeValues(values) {
      const state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
    computeInitial() {
      const state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
    compute(event) {
      const {
        state,
        config: config2,
        shared
      } = this;
      state.args = this.args;
      let dt = 0;
      if (event) {
        state.event = event;
        if (config2.preventDefault && event.cancelable)
          state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }
      if (state._active) {
        const _absoluteDelta = state._delta.map(Math.abs);
        V.addTo(state._distance, _absoluteDelta);
      }
      if (this.axisIntent)
        this.axisIntent(event);
      const [_m0, _m1] = state._movement;
      const [t0, t1] = config2.threshold;
      const {
        _step,
        values
      } = state;
      if (config2.hasCustomTransform) {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }
      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional)
        return;
      const movement = [0, 0];
      if (config2.hasCustomTransform) {
        const [v0, v1] = values;
        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }
      if (this.restrictToAxis && !state._blocked)
        this.restrictToAxis(movement);
      const previousOffset = state.offset;
      const gestureIsActive = state._active && !state._blocked || state.active;
      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;
        if (event) {
          if (state.first) {
            if ("bounds" in config2)
              state._bounds = call(config2.bounds, state);
            if (this.setup)
              this.setup();
          }
          state.movement = movement;
          this.computeOffset();
        }
      }
      const [ox, oy] = state.offset;
      const [[x0, x1], [y0, y1]] = state._bounds;
      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
      state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
      state.delta = V.sub(state.offset, previousOffset);
      this.computeMovement();
      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = V.sub(state.offset, previousOffset);
        const absoluteDelta = state.delta.map(Math.abs);
        V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);
        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        }
      }
    }
    emit() {
      const state = this.state;
      const shared = this.shared;
      const config2 = this.config;
      if (!state._active)
        this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents)
        return;
      const memo3 = this.handler(_objectSpread25(_objectSpread25(_objectSpread25({}, shared), state), {}, {
        [this.aliasKey]: state.values
      }));
      if (memo3 !== void 0)
        state.memo = memo3;
    }
    clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  };
  function selectAxis([dx, dy], threshold) {
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx > absDy && absDx > threshold) {
      return "x";
    }
    if (absDy > absDx && absDy > threshold) {
      return "y";
    }
    return void 0;
  }
  var CoordinatesEngine = class extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty5(this, "aliasKey", "xy");
    }
    reset() {
      super.reset();
      this.state.axis = void 0;
    }
    init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
    computeOffset() {
      this.state.offset = V.add(this.state.lastOffset, this.state.movement);
    }
    computeMovement() {
      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
    }
    axisIntent(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state.axis && event) {
        const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }
      state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
    }
    restrictToAxis(v5) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case "x":
            v5[1] = 0;
            break;
          case "y":
            v5[0] = 0;
            break;
        }
      }
    }
  };
  var identity2 = (v5) => v5;
  var DEFAULT_RUBBERBAND = 0.15;
  var commonConfigResolver = {
    enabled(value = true) {
      return value;
    },
    eventOptions(value, _k, config2) {
      return _objectSpread25(_objectSpread25({}, config2.shared.eventOptions), value);
    },
    preventDefault(value = false) {
      return value;
    },
    triggerAllEvents(value = false) {
      return value;
    },
    rubberband(value = 0) {
      switch (value) {
        case true:
          return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case false:
          return [0, 0];
        default:
          return V.toVector(value);
      }
    },
    from(value) {
      if (typeof value === "function")
        return value;
      if (value != null)
        return V.toVector(value);
    },
    transform(value, _k, config2) {
      const transform = value || config2.shared.transform;
      this.hasCustomTransform = !!transform;
      if (true) {
        const originalTransform = transform || identity2;
        return (v5) => {
          const r5 = originalTransform(v5);
          if (!isFinite(r5[0]) || !isFinite(r5[1])) {
            console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r5[0]},${[1]}]`);
          }
          return r5;
        };
      }
      return transform || identity2;
    },
    threshold(value) {
      return V.toVector(value, 0);
    }
  };
  if (true) {
    Object.assign(commonConfigResolver, {
      domTarget(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
        }
        return NaN;
      },
      lockDirection(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
        }
        return NaN;
      },
      initial(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
        }
        return NaN;
      }
    });
  }
  var DEFAULT_AXIS_THRESHOLD = 0;
  var coordinatesConfigResolver = _objectSpread25(_objectSpread25({}, commonConfigResolver), {}, {
    axis(_v, _k, {
      axis
    }) {
      this.lockDirection = axis === "lock";
      if (!this.lockDirection)
        return axis;
    },
    axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
      return value;
    },
    bounds(value = {}) {
      if (typeof value === "function") {
        return (state) => coordinatesConfigResolver.bounds(value(state));
      }
      if ("current" in value) {
        return () => value.current;
      }
      if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
        return value;
      }
      const {
        left = -Infinity,
        right = Infinity,
        top = -Infinity,
        bottom = Infinity
      } = value;
      return [[left, right], [top, bottom]];
    }
  });
  var DISPLACEMENT = 10;
  var KEYS_DELTA_MAP = {
    ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
    ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
    ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
    ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
  };
  var DragEngine = class extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty5(this, "ingKey", "dragging");
    }
    reset() {
      super.reset();
      const state = this.state;
      state._pointerId = void 0;
      state._pointerActive = false;
      state._keyboardActive = false;
      state._preventScroll = false;
      state._delayed = false;
      state.swipe = [0, 0];
      state.tap = false;
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
    }
    setup() {
      const state = this.state;
      if (state._bounds instanceof HTMLElement) {
        const boundRect = state._bounds.getBoundingClientRect();
        const targetRect = state.currentTarget.getBoundingClientRect();
        const _bounds = {
          left: boundRect.left - targetRect.left + state.offset[0],
          right: boundRect.right - targetRect.right + state.offset[0],
          top: boundRect.top - targetRect.top + state.offset[1],
          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
        };
        state._bounds = coordinatesConfigResolver.bounds(_bounds);
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled)
        return;
      state.canceled = true;
      state._active = false;
      setTimeout(() => {
        this.compute();
        this.emit();
      }, 0);
    }
    setActive() {
      this.state._active = this.state._pointerActive || this.state._keyboardActive;
    }
    clean() {
      this.pointerClean();
      this.state._pointerActive = false;
      this.state._keyboardActive = false;
      super.clean();
    }
    pointerDown(event) {
      const config2 = this.config;
      const state = this.state;
      if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons))
        return;
      const ctrlIds = this.ctrl.setEventIds(event);
      if (config2.pointerCapture) {
        event.target.setPointerCapture(event.pointerId);
      }
      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)
        return;
      this.start(event);
      this.setupPointer(event);
      state._pointerId = pointerId(event);
      state._pointerActive = true;
      this.computeValues(pointerValues(event));
      this.computeInitial();
      if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
        state._active = false;
        this.setupScrollPrevention(event);
      } else if (config2.delay > 0) {
        this.setupDelayTrigger(event);
        if (config2.triggerAllEvents) {
          this.compute(event);
          this.emit();
        }
      } else {
        this.startPointerDrag(event);
      }
    }
    startPointerDrag(event) {
      const state = this.state;
      state._active = true;
      state._preventScroll = true;
      state._delayed = false;
      this.compute(event);
      this.emit();
    }
    pointerMove(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._pointerActive)
        return;
      if (state.type === event.type && event.timeStamp === state.timeStamp)
        return;
      const id2 = pointerId(event);
      if (state._pointerId !== void 0 && id2 !== state._pointerId)
        return;
      const _values = pointerValues(event);
      if (document.pointerLockElement === event.target) {
        state._delta = [event.movementX, event.movementY];
      } else {
        state._delta = V.sub(_values, state._values);
        this.computeValues(_values);
      }
      V.addTo(state._movement, state._delta);
      this.compute(event);
      if (state._delayed && state.intentional) {
        this.timeoutStore.remove("dragDelay");
        state.active = false;
        this.startPointerDrag(event);
        return;
      }
      if (config2.preventScrollAxis && !state._preventScroll) {
        if (state.axis) {
          if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
            state._active = false;
            this.clean();
            return;
          } else {
            this.timeoutStore.remove("startPointerDrag");
            this.startPointerDrag(event);
            return;
          }
        } else {
          return;
        }
      }
      this.emit();
    }
    pointerUp(event) {
      this.ctrl.setEventIds(event);
      try {
        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
          ;
          event.target.releasePointerCapture(event.pointerId);
        }
      } catch (_unused) {
        if (true) {
          console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
        }
      }
      const state = this.state;
      const config2 = this.config;
      if (!state._active || !state._pointerActive)
        return;
      const id2 = pointerId(event);
      if (state._pointerId !== void 0 && id2 !== state._pointerId)
        return;
      this.state._pointerActive = false;
      this.setActive();
      this.compute(event);
      const [dx, dy] = state._distance;
      state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
      if (state.tap && config2.filterTaps) {
        state._force = true;
      } else {
        const [dirx, diry] = state.direction;
        const [vx, vy] = state.velocity;
        const [mx, my] = state.movement;
        const [svx, svy] = config2.swipe.velocity;
        const [sx, sy] = config2.swipe.distance;
        const sdt = config2.swipe.duration;
        if (state.elapsedTime < sdt) {
          if (Math.abs(vx) > svx && Math.abs(mx) > sx)
            state.swipe[0] = dirx;
          if (Math.abs(vy) > svy && Math.abs(my) > sy)
            state.swipe[1] = diry;
        }
      }
      this.emit();
    }
    pointerClick(event) {
      if (!this.state.tap && event.detail > 0) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    setupPointer(event) {
      const config2 = this.config;
      const device = config2.device;
      if (true) {
        try {
          if (device === "pointer" && config2.preventScrollDelay === void 0) {
            const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
            const style = window.getComputedStyle(currentTarget);
            if (style.touchAction === "auto") {
              console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
            }
          }
        } catch (_unused2) {
        }
      }
      if (config2.pointerLock) {
        event.currentTarget.requestPointerLock();
      }
      if (!config2.pointerCapture) {
        this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
      }
    }
    pointerClean() {
      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
        document.exitPointerLock();
      }
    }
    preventScroll(event) {
      if (this.state._preventScroll && event.cancelable) {
        event.preventDefault();
      }
    }
    setupScrollPrevention(event) {
      this.state._preventScroll = false;
      persistEvent(event);
      const remove4 = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
        passive: false
      });
      this.eventStore.add(this.sharedConfig.window, "touch", "end", remove4);
      this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove4);
      this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
    }
    setupDelayTrigger(event) {
      this.state._delayed = true;
      this.timeoutStore.add("dragDelay", () => {
        this.state._step = [0, 0];
        this.startPointerDrag(event);
      }, this.config.delay);
    }
    keyDown(event) {
      const deltaFn = KEYS_DELTA_MAP[event.key];
      if (deltaFn) {
        const state = this.state;
        const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
        this.start(event);
        state._delta = deltaFn(factor);
        state._keyboardActive = true;
        V.addTo(state._movement, state._delta);
        this.compute(event);
        this.emit();
      }
    }
    keyUp(event) {
      if (!(event.key in KEYS_DELTA_MAP))
        return;
      this.state._keyboardActive = false;
      this.setActive();
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      bindFunction(device, "start", this.pointerDown.bind(this));
      if (this.config.pointerCapture) {
        bindFunction(device, "change", this.pointerMove.bind(this));
        bindFunction(device, "end", this.pointerUp.bind(this));
        bindFunction(device, "cancel", this.pointerUp.bind(this));
        bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
      }
      if (this.config.keys) {
        bindFunction("key", "down", this.keyDown.bind(this));
        bindFunction("key", "up", this.keyUp.bind(this));
      }
      if (this.config.filterTaps) {
        bindFunction("click", "", this.pointerClick.bind(this), {
          capture: true,
          passive: false
        });
      }
    }
  };
  function persistEvent(event) {
    "persist" in event && typeof event.persist === "function" && event.persist();
  }
  var isBrowser2 = typeof window !== "undefined" && window.document && window.document.createElement;
  function supportsTouchEvents2() {
    return isBrowser2 && "ontouchstart" in window;
  }
  function isTouchScreen() {
    return supportsTouchEvents2() || isBrowser2 && window.navigator.maxTouchPoints > 1;
  }
  function supportsPointerEvents2() {
    return isBrowser2 && "onpointerdown" in window;
  }
  function supportsPointerLock() {
    return isBrowser2 && "exitPointerLock" in window.document;
  }
  function supportsGestureEvents() {
    try {
      return "constructor" in GestureEvent;
    } catch (e4) {
      return false;
    }
  }
  var SUPPORT = {
    isBrowser: isBrowser2,
    gesture: supportsGestureEvents(),
    touch: isTouchScreen(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents2(),
    pointerLock: supportsPointerLock()
  };
  var DEFAULT_PREVENT_SCROLL_DELAY = 250;
  var DEFAULT_DRAG_DELAY = 180;
  var DEFAULT_SWIPE_VELOCITY = 0.5;
  var DEFAULT_SWIPE_DISTANCE = 50;
  var DEFAULT_SWIPE_DURATION = 250;
  var DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
  var dragConfigResolver = _objectSpread25(_objectSpread25({}, coordinatesConfigResolver), {}, {
    device(_v, _k, {
      pointer: {
        touch = false,
        lock: lock2 = false,
        mouse = false
      } = {}
    }) {
      this.pointerLock = lock2 && SUPPORT.pointerLock;
      if (SUPPORT.touch && touch)
        return "touch";
      if (this.pointerLock)
        return "mouse";
      if (SUPPORT.pointer && !mouse)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
      return "mouse";
    },
    preventScrollAxis(value, _k, {
      preventScroll
    }) {
      this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
      if (!SUPPORT.touchscreen || preventScroll === false)
        return void 0;
      return value ? value : preventScroll !== void 0 ? "y" : void 0;
    },
    pointerCapture(_v, _k, {
      pointer: {
        capture = true,
        buttons = 1
      } = {}
    }) {
      this.pointerButtons = buttons;
      return !this.pointerLock && this.device === "pointer" && capture;
    },
    keys(value = true) {
      return value;
    },
    threshold(value, _k, {
      filterTaps = false,
      tapsThreshold = 3,
      axis = void 0
    }) {
      const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
      this.filterTaps = filterTaps;
      this.tapsThreshold = tapsThreshold;
      return threshold;
    },
    swipe({
      velocity = DEFAULT_SWIPE_VELOCITY,
      distance: distance2 = DEFAULT_SWIPE_DISTANCE,
      duration = DEFAULT_SWIPE_DURATION
    } = {}) {
      return {
        velocity: this.transform(V.toVector(velocity)),
        distance: this.transform(V.toVector(distance2)),
        duration
      };
    },
    delay(value = 0) {
      switch (value) {
        case true:
          return DEFAULT_DRAG_DELAY;
        case false:
          return 0;
        default:
          return value;
      }
    },
    axisThreshold(value) {
      if (!value)
        return DEFAULT_DRAG_AXIS_THRESHOLD;
      return _objectSpread25(_objectSpread25({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
    }
  });
  if (true) {
    Object.assign(dragConfigResolver, {
      useTouch(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
        }
        return NaN;
      },
      experimental_preventWindowScrollY(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
        }
        return NaN;
      },
      swipeVelocity(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
        }
        return NaN;
      },
      swipeDistance(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
        }
        return NaN;
      },
      swipeDuration(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
        }
        return NaN;
      }
    });
  }
  var pinchConfigResolver = _objectSpread25(_objectSpread25({}, commonConfigResolver), {}, {
    device(_v, _k, {
      shared,
      pointer: {
        touch = false
      } = {}
    }) {
      const sharedConfig = shared;
      if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
        return "gesture";
      if (SUPPORT.touch && touch)
        return "touch";
      if (SUPPORT.touchscreen) {
        if (SUPPORT.pointer)
          return "pointer";
        if (SUPPORT.touch)
          return "touch";
      }
    },
    bounds(_v, _k, {
      scaleBounds = {},
      angleBounds = {}
    }) {
      const _scaleBounds = (state) => {
        const D3 = assignDefault(call(scaleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [D3.min, D3.max];
      };
      const _angleBounds = (state) => {
        const A2 = assignDefault(call(angleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [A2.min, A2.max];
      };
      if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
        return [_scaleBounds(), _angleBounds()];
      return (state) => [_scaleBounds(state), _angleBounds(state)];
    },
    threshold(value, _k, config2) {
      this.lockDirection = config2.axis === "lock";
      const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
      return threshold;
    },
    modifierKey(value) {
      if (value === void 0)
        return "ctrlKey";
      return value;
    },
    pinchOnWheel(value = true) {
      return value;
    }
  });
  var moveConfigResolver = _objectSpread25(_objectSpread25({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  var hoverConfigResolver = _objectSpread25(_objectSpread25({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  var EngineMap = /* @__PURE__ */ new Map();
  var ConfigResolverMap = /* @__PURE__ */ new Map();
  function registerAction(action) {
    EngineMap.set(action.key, action.engine);
    ConfigResolverMap.set(action.key, action.resolver);
  }
  var dragAction = {
    key: "drag",
    engine: DragEngine,
    resolver: dragConfigResolver
  };

  // node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
  var import_react75 = __toESM(require_react());

  // node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
  function _objectWithoutPropertiesLoose4(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i5;
    for (i5 = 0; i5 < sourceKeys.length; i5++) {
      key = sourceKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose4(source, excluded);
    var key, i5;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {
        key = sourceSymbolKeys[i5];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var sharedConfigResolver = {
    target(value) {
      if (value) {
        return () => "current" in value ? value.current : value;
      }
      return void 0;
    },
    enabled(value = true) {
      return value;
    },
    window(value = SUPPORT.isBrowser ? window : void 0) {
      return value;
    },
    eventOptions({
      passive = true,
      capture = false
    } = {}) {
      return {
        passive,
        capture
      };
    },
    transform(value) {
      return value;
    }
  };
  var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
  function resolveWith(config2 = {}, resolvers) {
    const result = {};
    for (const [key, resolver] of Object.entries(resolvers)) {
      switch (typeof resolver) {
        case "function":
          if (true) {
            const r5 = resolver.call(result, config2[key], key, config2);
            if (!Number.isNaN(r5))
              result[key] = r5;
          } else {
            result[key] = resolver.call(result, config2[key], key, config2);
          }
          break;
        case "object":
          result[key] = resolveWith(config2[key], resolver);
          break;
        case "boolean":
          if (resolver)
            result[key] = config2[key];
          break;
      }
    }
    return result;
  }
  function parse5(newConfig, gestureKey, _config = {}) {
    const _ref8 = newConfig, {
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    } = _ref8, rest = _objectWithoutProperties(_ref8, _excluded);
    _config.shared = resolveWith({
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    }, sharedConfigResolver);
    if (gestureKey) {
      const resolver = ConfigResolverMap.get(gestureKey);
      _config[gestureKey] = resolveWith(_objectSpread25({
        shared: _config.shared
      }, rest), resolver);
    } else {
      for (const key in rest) {
        const resolver = ConfigResolverMap.get(key);
        if (resolver) {
          _config[key] = resolveWith(_objectSpread25({
            shared: _config.shared
          }, rest[key]), resolver);
        } else if (true) {
          if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
            if (key === "domTarget") {
              throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
            }
            console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
          }
        }
      }
    }
    return _config;
  }
  var EventStore = class {
    constructor(ctrl, gestureKey) {
      _defineProperty5(this, "_listeners", /* @__PURE__ */ new Set());
      this._ctrl = ctrl;
      this._gestureKey = gestureKey;
    }
    add(element, device, action, handler, options) {
      const listeners = this._listeners;
      const type = toDomEventType(device, action);
      const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
      const eventOptions = _objectSpread25(_objectSpread25({}, _options), options);
      element.addEventListener(type, handler, eventOptions);
      const remove4 = () => {
        element.removeEventListener(type, handler, eventOptions);
        listeners.delete(remove4);
      };
      listeners.add(remove4);
      return remove4;
    }
    clean() {
      this._listeners.forEach((remove4) => remove4());
      this._listeners.clear();
    }
  };
  var TimeoutStore = class {
    constructor() {
      _defineProperty5(this, "_timeouts", /* @__PURE__ */ new Map());
    }
    add(key, callback, ms = 140, ...args) {
      this.remove(key);
      this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
    }
    remove(key) {
      const timeout = this._timeouts.get(key);
      if (timeout)
        window.clearTimeout(timeout);
    }
    clean() {
      this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
      this._timeouts.clear();
    }
  };
  var Controller = class {
    constructor(handlers) {
      _defineProperty5(this, "gestures", /* @__PURE__ */ new Set());
      _defineProperty5(this, "_targetEventStore", new EventStore(this));
      _defineProperty5(this, "gestureEventStores", {});
      _defineProperty5(this, "gestureTimeoutStores", {});
      _defineProperty5(this, "handlers", {});
      _defineProperty5(this, "config", {});
      _defineProperty5(this, "pointerIds", /* @__PURE__ */ new Set());
      _defineProperty5(this, "touchIds", /* @__PURE__ */ new Set());
      _defineProperty5(this, "state", {
        shared: {
          shiftKey: false,
          metaKey: false,
          ctrlKey: false,
          altKey: false
        }
      });
      resolveGestures(this, handlers);
    }
    setEventIds(event) {
      if (isTouch(event)) {
        this.touchIds = new Set(touchIds(event));
        return this.touchIds;
      } else if ("pointerId" in event) {
        if (event.type === "pointerup" || event.type === "pointercancel")
          this.pointerIds.delete(event.pointerId);
        else if (event.type === "pointerdown")
          this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
    applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
    applyConfig(config2, gestureKey) {
      this.config = parse5(config2, gestureKey, this.config);
    }
    clean() {
      this._targetEventStore.clean();
      for (const key of this.gestures) {
        this.gestureEventStores[key].clean();
        this.gestureTimeoutStores[key].clean();
      }
    }
    effect() {
      if (this.config.shared.target)
        this.bind();
      return () => this._targetEventStore.clean();
    }
    bind(...args) {
      const sharedConfig = this.config.shared;
      const props = {};
      let target;
      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target)
          return;
      }
      if (sharedConfig.enabled) {
        for (const gestureKey of this.gestures) {
          const gestureConfig = this.config[gestureKey];
          const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
          if (gestureConfig.enabled) {
            const Engine2 = EngineMap.get(gestureKey);
            new Engine2(this, args, gestureKey).bind(bindFunction);
          }
        }
        const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
        for (const eventKey in this.nativeHandlers) {
          nativeBindFunction(
            eventKey,
            "",
            (event) => this.nativeHandlers[eventKey](_objectSpread25(_objectSpread25({}, this.state.shared), {}, {
              event,
              args
            })),
            void 0,
            true
          );
        }
      }
      for (const handlerProp in props) {
        props[handlerProp] = chain(...props[handlerProp]);
      }
      if (!target)
        return props;
      for (const handlerProp in props) {
        const {
          device,
          capture,
          passive
        } = parseProp(handlerProp);
        this._targetEventStore.add(target, device, "", props[handlerProp], {
          capture,
          passive
        });
      }
    }
  };
  function setupGesture(ctrl, gestureKey) {
    ctrl.gestures.add(gestureKey);
    ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
    ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
  }
  function resolveGestures(ctrl, internalHandlers) {
    if (internalHandlers.drag)
      setupGesture(ctrl, "drag");
    if (internalHandlers.wheel)
      setupGesture(ctrl, "wheel");
    if (internalHandlers.scroll)
      setupGesture(ctrl, "scroll");
    if (internalHandlers.move)
      setupGesture(ctrl, "move");
    if (internalHandlers.pinch)
      setupGesture(ctrl, "pinch");
    if (internalHandlers.hover)
      setupGesture(ctrl, "hover");
  }
  var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
    var _options$capture, _options$passive;
    const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
    if (withPassiveOption && passive)
      handlerProp += "Passive";
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };

  // node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
  function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
    const ctrl = import_react75.default.useMemo(() => new Controller(handlers), []);
    ctrl.applyHandlers(handlers, nativeHandlers);
    ctrl.applyConfig(config2, gestureKey);
    import_react75.default.useEffect(ctrl.effect.bind(ctrl));
    import_react75.default.useEffect(() => {
      return ctrl.clean.bind(ctrl);
    }, []);
    if (config2.target === void 0) {
      return ctrl.bind.bind(ctrl);
    }
    return void 0;
  }
  function useDrag2(handler, config2) {
    registerAction(dragAction);
    return useRecognizers({
      drag: handler
    }, config2 || {}, "drag");
  }

  // node_modules/@wordpress/components/build-module/input-control/utils.js
  function getDragCursor(dragDirection) {
    let dragCursor = "ns-resize";
    switch (dragDirection) {
      case "n":
      case "s":
        dragCursor = "ns-resize";
        break;
      case "e":
      case "w":
        dragCursor = "ew-resize";
        break;
    }
    return dragCursor;
  }
  function useDragCursor(isDragging, dragDirection) {
    const dragCursor = getDragCursor(dragDirection);
    (0, import_react.useEffect)(() => {
      if (isDragging) {
        document.documentElement.style.cursor = dragCursor;
      } else {
        document.documentElement.style.cursor = null;
      }
    }, [isDragging, dragCursor]);
    return dragCursor;
  }
  function useDraft(props) {
    const refPreviousValue = (0, import_react.useRef)(props.value);
    const [draft, setDraft] = (0, import_react.useState)({});
    const value = draft.value !== void 0 ? draft.value : props.value;
    (0, import_react.useLayoutEffect)(() => {
      const {
        current: previousValue
      } = refPreviousValue;
      refPreviousValue.current = props.value;
      if (draft.value !== void 0 && !draft.isStale)
        setDraft({
          ...draft,
          isStale: true
        });
      else if (draft.isStale && props.value !== previousValue)
        setDraft({});
    }, [props.value, draft]);
    const onChange = (nextValue, extra) => {
      setDraft((current) => Object.assign(current, {
        value: nextValue,
        isStale: false
      }));
      props.onChange(nextValue, extra);
    };
    const onBlur = (event) => {
      var _props$onBlur;
      setDraft({});
      (_props$onBlur = props.onBlur) === null || _props$onBlur === void 0 ? void 0 : _props$onBlur.call(props, event);
    };
    return {
      value,
      onBlur,
      onChange
    };
  }

  // node_modules/@wordpress/components/build-module/input-control/reducer/state.js
  var initialStateReducer = (state) => state;
  var initialInputControlState = {
    error: null,
    initialValue: "",
    isDirty: false,
    isDragEnabled: false,
    isDragging: false,
    isPressEnterToChange: false,
    value: ""
  };

  // node_modules/@wordpress/components/build-module/input-control/reducer/actions.js
  var CHANGE = "CHANGE";
  var COMMIT = "COMMIT";
  var CONTROL = "CONTROL";
  var DRAG_END = "DRAG_END";
  var DRAG_START = "DRAG_START";
  var DRAG = "DRAG";
  var INVALIDATE = "INVALIDATE";
  var PRESS_DOWN = "PRESS_DOWN";
  var PRESS_ENTER = "PRESS_ENTER";
  var PRESS_UP = "PRESS_UP";
  var RESET = "RESET";

  // node_modules/@wordpress/components/build-module/input-control/reducer/reducer.js
  function mergeInitialState() {
    let initialState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialInputControlState;
    const {
      value
    } = initialState;
    return {
      ...initialInputControlState,
      ...initialState,
      initialValue: value
    };
  }
  function inputControlStateReducer(composedStateReducers) {
    return (state, action) => {
      const nextState = {
        ...state
      };
      switch (action.type) {
        case CONTROL:
          nextState.value = action.payload.value;
          nextState.isDirty = false;
          nextState._event = void 0;
          return nextState;
        case PRESS_UP:
          nextState.isDirty = false;
          break;
        case PRESS_DOWN:
          nextState.isDirty = false;
          break;
        case DRAG_START:
          nextState.isDragging = true;
          break;
        case DRAG_END:
          nextState.isDragging = false;
          break;
        case CHANGE:
          nextState.error = null;
          nextState.value = action.payload.value;
          if (state.isPressEnterToChange) {
            nextState.isDirty = true;
          }
          break;
        case COMMIT:
          nextState.value = action.payload.value;
          nextState.isDirty = false;
          break;
        case RESET:
          nextState.error = null;
          nextState.isDirty = false;
          nextState.value = action.payload.value || state.initialValue;
          break;
        case INVALIDATE:
          nextState.error = action.payload.error;
          break;
      }
      nextState._event = action.payload.event;
      return composedStateReducers(nextState, action);
    };
  }
  function useInputControlStateReducer() {
    let stateReducer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialStateReducer;
    let initialState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : initialInputControlState;
    let onChangeHandler = arguments.length > 2 ? arguments[2] : void 0;
    const [state, dispatch2] = (0, import_react.useReducer)(inputControlStateReducer(stateReducer), mergeInitialState(initialState));
    const createChangeEvent = (type) => (nextValue, event) => {
      dispatch2({
        type,
        payload: {
          value: nextValue,
          event
        }
      });
    };
    const createKeyEvent = (type) => (event) => {
      dispatch2({
        type,
        payload: {
          event
        }
      });
    };
    const createDragEvent = (type) => (payload) => {
      dispatch2({
        type,
        payload
      });
    };
    const change = createChangeEvent(CHANGE);
    const invalidate = (error2, event) => dispatch2({
      type: INVALIDATE,
      payload: {
        error: error2,
        event
      }
    });
    const reset2 = createChangeEvent(RESET);
    const commit = createChangeEvent(COMMIT);
    const dragStart = createDragEvent(DRAG_START);
    const drag2 = createDragEvent(DRAG);
    const dragEnd = createDragEvent(DRAG_END);
    const pressUp = createKeyEvent(PRESS_UP);
    const pressDown = createKeyEvent(PRESS_DOWN);
    const pressEnter = createKeyEvent(PRESS_ENTER);
    const currentState = (0, import_react.useRef)(state);
    const refProps = (0, import_react.useRef)({
      value: initialState.value,
      onChangeHandler
    });
    (0, import_react.useLayoutEffect)(() => {
      currentState.current = state;
      refProps.current = {
        value: initialState.value,
        onChangeHandler
      };
    });
    (0, import_react.useLayoutEffect)(() => {
      if (currentState.current._event !== void 0 && state.value !== refProps.current.value && !state.isDirty) {
        var _state$value;
        refProps.current.onChangeHandler((_state$value = state.value) !== null && _state$value !== void 0 ? _state$value : "", {
          event: currentState.current._event
        });
      }
    }, [state.value, state.isDirty]);
    (0, import_react.useLayoutEffect)(() => {
      if (initialState.value !== currentState.current.value && !currentState.current.isDirty) {
        var _initialState$value;
        dispatch2({
          type: CONTROL,
          payload: {
            value: (_initialState$value = initialState.value) !== null && _initialState$value !== void 0 ? _initialState$value : ""
          }
        });
      }
    }, [initialState.value]);
    return {
      change,
      commit,
      dispatch: dispatch2,
      drag: drag2,
      dragEnd,
      dragStart,
      invalidate,
      pressDown,
      pressEnter,
      pressUp,
      reset: reset2,
      state
    };
  }

  // node_modules/@wordpress/components/build-module/input-control/input-field.js
  var noop4 = () => {
  };
  function InputField(_ref8, ref2) {
    let {
      disabled = false,
      dragDirection = "n",
      dragThreshold = 10,
      id: id2,
      isDragEnabled = false,
      isFocused,
      isPressEnterToChange = false,
      onBlur = noop4,
      onChange = noop4,
      onDrag = noop4,
      onDragEnd = noop4,
      onDragStart = noop4,
      onFocus = noop4,
      onKeyDown = noop4,
      onValidate = noop4,
      size = "default",
      setIsFocused,
      stateReducer = (state2) => state2,
      value: valueProp,
      type,
      ...props
    } = _ref8;
    const {
      state,
      change,
      commit,
      drag: drag2,
      dragEnd,
      dragStart,
      invalidate,
      pressDown,
      pressEnter,
      pressUp,
      reset: reset2
    } = useInputControlStateReducer(stateReducer, {
      isDragEnabled,
      value: valueProp,
      isPressEnterToChange
    }, onChange);
    const {
      value,
      isDragging,
      isDirty
    } = state;
    const wasDirtyOnBlur = (0, import_react.useRef)(false);
    const dragCursor = useDragCursor(isDragging, dragDirection);
    const handleOnBlur = (event) => {
      onBlur(event);
      setIsFocused === null || setIsFocused === void 0 ? void 0 : setIsFocused(false);
      if (isDirty || !event.target.validity.valid) {
        wasDirtyOnBlur.current = true;
        handleOnCommit(event);
      }
    };
    const handleOnFocus = (event) => {
      onFocus(event);
      setIsFocused === null || setIsFocused === void 0 ? void 0 : setIsFocused(true);
    };
    const handleOnChange = (event) => {
      const nextValue = event.target.value;
      change(nextValue, event);
    };
    const handleOnCommit = (event) => {
      const nextValue = event.currentTarget.value;
      try {
        onValidate(nextValue);
        commit(nextValue, event);
      } catch (err) {
        invalidate(err, event);
      }
    };
    const handleOnKeyDown = (event) => {
      const {
        key
      } = event;
      onKeyDown(event);
      switch (key) {
        case "ArrowUp":
          pressUp(event);
          break;
        case "ArrowDown":
          pressDown(event);
          break;
        case "Enter":
          pressEnter(event);
          if (isPressEnterToChange) {
            event.preventDefault();
            handleOnCommit(event);
          }
          break;
        case "Escape":
          if (isPressEnterToChange && isDirty) {
            event.preventDefault();
            reset2(valueProp, event);
          }
          break;
      }
    };
    const dragGestureProps = useDrag2((dragProps2) => {
      const {
        distance: distance2,
        dragging,
        event,
        target
      } = dragProps2;
      dragProps2.event = {
        ...dragProps2.event,
        target
      };
      if (!distance2)
        return;
      event.stopPropagation();
      if (!dragging) {
        onDragEnd(dragProps2);
        dragEnd(dragProps2);
        return;
      }
      onDrag(dragProps2);
      drag2(dragProps2);
      if (!isDragging) {
        onDragStart(dragProps2);
        dragStart(dragProps2);
      }
    }, {
      axis: dragDirection === "e" || dragDirection === "w" ? "x" : "y",
      threshold: dragThreshold,
      enabled: isDragEnabled,
      pointer: {
        capture: false
      }
    });
    const dragProps = isDragEnabled ? dragGestureProps() : {};
    let handleOnMouseDown;
    if (type === "number") {
      handleOnMouseDown = (event) => {
        var _props$onMouseDown;
        (_props$onMouseDown = props.onMouseDown) === null || _props$onMouseDown === void 0 ? void 0 : _props$onMouseDown.call(props, event);
        if (event.currentTarget !== event.currentTarget.ownerDocument.activeElement) {
          event.currentTarget.focus();
        }
      };
    }
    return (0, import_react.createElement)(Input, _extends({}, props, dragProps, {
      className: "components-input-control__input",
      disabled,
      dragCursor,
      isDragging,
      id: id2,
      onBlur: handleOnBlur,
      onChange: handleOnChange,
      onFocus: handleOnFocus,
      onKeyDown: handleOnKeyDown,
      onMouseDown: handleOnMouseDown,
      ref: ref2,
      inputSize: size,
      value,
      type
    }));
  }
  var ForwardedComponent = (0, import_react.forwardRef)(InputField);
  var input_field_default = ForwardedComponent;

  // node_modules/@wordpress/components/build-module/input-control/index.js
  var noop5 = () => {
  };
  function useUniqueId2(idProp) {
    const instanceId = use_instance_id_default(InputControl);
    const id2 = `inspector-input-control-${instanceId}`;
    return idProp || id2;
  }
  function UnforwardedInputControl(_ref8, ref2) {
    let {
      __next36pxDefaultSize,
      __unstableStateReducer: stateReducer = (state) => state,
      __unstableInputWidth,
      className,
      disabled = false,
      hideLabelFromVision = false,
      id: idProp,
      isPressEnterToChange = false,
      label,
      labelPosition = "top",
      onChange = noop5,
      onValidate = noop5,
      onKeyDown = noop5,
      prefix: prefix2,
      size = "default",
      style,
      suffix,
      value,
      ...props
    } = _ref8;
    const [isFocused, setIsFocused] = (0, import_react.useState)(false);
    const id2 = useUniqueId2(idProp);
    const classes = (0, import_classnames4.default)("components-input-control", className);
    const draftHookProps = useDraft({
      value,
      onBlur: props.onBlur,
      onChange
    });
    return (0, import_react.createElement)(input_base_default, {
      __next36pxDefaultSize,
      __unstableInputWidth,
      className: classes,
      disabled,
      gap: 3,
      hideLabelFromVision,
      id: id2,
      isFocused,
      justify: "left",
      label,
      labelPosition,
      prefix: prefix2,
      size,
      style,
      suffix
    }, (0, import_react.createElement)(input_field_default, _extends({}, props, {
      __next36pxDefaultSize,
      className: "components-input-control__input",
      disabled,
      id: id2,
      isFocused,
      isPressEnterToChange,
      onKeyDown,
      onValidate,
      paddingInlineStart: prefix2 ? space(2) : void 0,
      paddingInlineEnd: suffix ? space(2) : void 0,
      ref: ref2,
      setIsFocused,
      size,
      stateReducer
    }, draftHookProps)));
  }
  var InputControl = (0, import_react.forwardRef)(UnforwardedInputControl);
  var input_control_default = InputControl;

  // node_modules/@wordpress/components/build-module/number-control/styles/number-control-styles.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__8() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var _ref4 = false ? {
    name: "euqsgg",
    styles: "input[type='number']::-webkit-outer-spin-button,input[type='number']::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}input[type='number']{-moz-appearance:textfield;}"
  } : {
    name: "jl4rev-htmlArrowStyles",
    styles: "input[type='number']::-webkit-outer-spin-button,input[type='number']::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}input[type='number']{-moz-appearance:textfield;};label:htmlArrowStyles;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbnVtYmVyLWNvbnRyb2wvc3R5bGVzL251bWJlci1jb250cm9sLXN0eWxlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvQlciLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9udW1iZXItY29udHJvbC9zdHlsZXMvbnVtYmVyLWNvbnRyb2wtc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IElucHV0Q29udHJvbCBmcm9tICcuLi8uLi9pbnB1dC1jb250cm9sJztcbmltcG9ydCB7IENPTE9SUyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG5jb25zdCBodG1sQXJyb3dTdHlsZXMgPSAoIHsgaGlkZUhUTUxBcnJvd3MgfSApID0+IHtcblx0aWYgKCAhIGhpZGVIVE1MQXJyb3dzICkge1xuXHRcdHJldHVybiBgYDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0aW5wdXRbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24sXG5cdFx0aW5wdXRbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lICFpbXBvcnRhbnQ7XG5cdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHR9XG5cblx0XHRpbnB1dFt0eXBlPSdudW1iZXInXSB7XG5cdFx0XHQtbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgSW5wdXQgPSBzdHlsZWQoIElucHV0Q29udHJvbCApYFxuXHQkeyBodG1sQXJyb3dTdHlsZXMgfTtcbmA7XG5cbmNvbnN0IHNwaW5CdXR0b25TaXplU3R5bGVzID0gKCB7IHNpemUgfSApID0+IHtcblx0aWYgKCBzaXplICE9PSAnc21hbGwnICkge1xuXHRcdHJldHVybiBgYDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0d2lkdGg6ICR7IHNwYWNlKCA1ICkgfTtcblx0XHRtaW4td2lkdGg6ICR7IHNwYWNlKCA1ICkgfTtcblx0XHRoZWlnaHQ6ICR7IHNwYWNlKCA1ICkgfTtcblx0YDtcbn07XG5cbmV4cG9ydCBjb25zdCBTcGluQnV0dG9uID0gc3R5bGVkKCBCdXR0b24gKWBcblx0JiYmJiYge1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHQkeyBzcGluQnV0dG9uU2l6ZVN0eWxlcyB9XG5cdH1cbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__8
  };
  var htmlArrowStyles = (_ref22) => {
    let {
      hideHTMLArrows
    } = _ref22;
    if (!hideHTMLArrows) {
      return ``;
    }
    return _ref4;
  };
  var Input2 = /* @__PURE__ */ (0, import_base3.default)(input_control_default, false ? {
    target: "ep48uk91"
  } : {
    target: "ep48uk91",
    label: "Input"
  })(htmlArrowStyles, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbnVtYmVyLWNvbnRyb2wvc3R5bGVzL251bWJlci1jb250cm9sLXN0eWxlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQzJDIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbnVtYmVyLWNvbnRyb2wvc3R5bGVzL251bWJlci1jb250cm9sLXN0eWxlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBJbnB1dENvbnRyb2wgZnJvbSAnLi4vLi4vaW5wdXQtY29udHJvbCc7XG5pbXBvcnQgeyBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2J1dHRvbic7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuY29uc3QgaHRtbEFycm93U3R5bGVzID0gKCB7IGhpZGVIVE1MQXJyb3dzIH0gKSA9PiB7XG5cdGlmICggISBoaWRlSFRNTEFycm93cyApIHtcblx0XHRyZXR1cm4gYGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdGlucHV0W3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdGlucHV0W3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcblx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0fVxuXG5cdFx0aW5wdXRbdHlwZT0nbnVtYmVyJ10ge1xuXHRcdFx0LW1vei1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkKCBJbnB1dENvbnRyb2wgKWBcblx0JHsgaHRtbEFycm93U3R5bGVzIH07XG5gO1xuXG5jb25zdCBzcGluQnV0dG9uU2l6ZVN0eWxlcyA9ICggeyBzaXplIH0gKSA9PiB7XG5cdGlmICggc2l6ZSAhPT0gJ3NtYWxsJyApIHtcblx0XHRyZXR1cm4gYGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdHdpZHRoOiAkeyBzcGFjZSggNSApIH07XG5cdFx0bWluLXdpZHRoOiAkeyBzcGFjZSggNSApIH07XG5cdFx0aGVpZ2h0OiAkeyBzcGFjZSggNSApIH07XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgU3BpbkJ1dHRvbiA9IHN0eWxlZCggQnV0dG9uIClgXG5cdCYmJiYmIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0JHsgc3BpbkJ1dHRvblNpemVTdHlsZXMgfVxuXHR9XG5gO1xuIl19 */"));
  var spinButtonSizeStyles = (_ref32) => {
    let {
      size
    } = _ref32;
    if (size !== "small") {
      return ``;
    }
    return /* @__PURE__ */ (0, import_react77.css)("width:", space(5), ";min-width:", space(5), ";height:", space(5), ";" + (false ? "" : ";label:spinButtonSizeStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbnVtYmVyLWNvbnRyb2wvc3R5bGVzL251bWJlci1jb250cm9sLXN0eWxlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEwQ1ciLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9udW1iZXItY29udHJvbC9zdHlsZXMvbnVtYmVyLWNvbnRyb2wtc3R5bGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IElucHV0Q29udHJvbCBmcm9tICcuLi8uLi9pbnB1dC1jb250cm9sJztcbmltcG9ydCB7IENPTE9SUyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG5jb25zdCBodG1sQXJyb3dTdHlsZXMgPSAoIHsgaGlkZUhUTUxBcnJvd3MgfSApID0+IHtcblx0aWYgKCAhIGhpZGVIVE1MQXJyb3dzICkge1xuXHRcdHJldHVybiBgYDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0aW5wdXRbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24sXG5cdFx0aW5wdXRbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuXHRcdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lICFpbXBvcnRhbnQ7XG5cdFx0XHRtYXJnaW46IDAgIWltcG9ydGFudDtcblx0XHR9XG5cblx0XHRpbnB1dFt0eXBlPSdudW1iZXInXSB7XG5cdFx0XHQtbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcblx0XHR9XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgSW5wdXQgPSBzdHlsZWQoIElucHV0Q29udHJvbCApYFxuXHQkeyBodG1sQXJyb3dTdHlsZXMgfTtcbmA7XG5cbmNvbnN0IHNwaW5CdXR0b25TaXplU3R5bGVzID0gKCB7IHNpemUgfSApID0+IHtcblx0aWYgKCBzaXplICE9PSAnc21hbGwnICkge1xuXHRcdHJldHVybiBgYDtcblx0fVxuXG5cdHJldHVybiBjc3NgXG5cdFx0d2lkdGg6ICR7IHNwYWNlKCA1ICkgfTtcblx0XHRtaW4td2lkdGg6ICR7IHNwYWNlKCA1ICkgfTtcblx0XHRoZWlnaHQ6ICR7IHNwYWNlKCA1ICkgfTtcblx0YDtcbn07XG5cbmV4cG9ydCBjb25zdCBTcGluQnV0dG9uID0gc3R5bGVkKCBCdXR0b24gKWBcblx0JiYmJiYge1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHQkeyBzcGluQnV0dG9uU2l6ZVN0eWxlcyB9XG5cdH1cbmA7XG4iXX0= */");
  };
  var SpinButton = /* @__PURE__ */ (0, import_base3.default)(button_default, false ? {
    target: "ep48uk90"
  } : {
    target: "ep48uk90",
    label: "SpinButton"
  })("&&&&&{color:", COLORS.ui.theme, ";", spinButtonSizeStyles, ";}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbnVtYmVyLWNvbnRyb2wvc3R5bGVzL251bWJlci1jb250cm9sLXN0eWxlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpRDBDIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbnVtYmVyLWNvbnRyb2wvc3R5bGVzL251bWJlci1jb250cm9sLXN0eWxlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1ub2NoZWNrXG4vKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBJbnB1dENvbnRyb2wgZnJvbSAnLi4vLi4vaW5wdXQtY29udHJvbCc7XG5pbXBvcnQgeyBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL2J1dHRvbic7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuY29uc3QgaHRtbEFycm93U3R5bGVzID0gKCB7IGhpZGVIVE1MQXJyb3dzIH0gKSA9PiB7XG5cdGlmICggISBoaWRlSFRNTEFycm93cyApIHtcblx0XHRyZXR1cm4gYGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdGlucHV0W3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuXHRcdGlucHV0W3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcblx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdFx0bWFyZ2luOiAwICFpbXBvcnRhbnQ7XG5cdFx0fVxuXG5cdFx0aW5wdXRbdHlwZT0nbnVtYmVyJ10ge1xuXHRcdFx0LW1vei1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG5cdFx0fVxuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkKCBJbnB1dENvbnRyb2wgKWBcblx0JHsgaHRtbEFycm93U3R5bGVzIH07XG5gO1xuXG5jb25zdCBzcGluQnV0dG9uU2l6ZVN0eWxlcyA9ICggeyBzaXplIH0gKSA9PiB7XG5cdGlmICggc2l6ZSAhPT0gJ3NtYWxsJyApIHtcblx0XHRyZXR1cm4gYGA7XG5cdH1cblxuXHRyZXR1cm4gY3NzYFxuXHRcdHdpZHRoOiAkeyBzcGFjZSggNSApIH07XG5cdFx0bWluLXdpZHRoOiAkeyBzcGFjZSggNSApIH07XG5cdFx0aGVpZ2h0OiAkeyBzcGFjZSggNSApIH07XG5cdGA7XG59O1xuXG5leHBvcnQgY29uc3QgU3BpbkJ1dHRvbiA9IHN0eWxlZCggQnV0dG9uIClgXG5cdCYmJiYmIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0JHsgc3BpbkJ1dHRvblNpemVTdHlsZXMgfVxuXHR9XG5gO1xuIl19 */"));

  // node_modules/@wordpress/components/build-module/utils/math.js
  function getNumber(value) {
    const number2 = Number(value);
    return isNaN(number2) ? 0 : number2;
  }
  function add() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args.reduce(
      (sum, arg) => sum + getNumber(arg),
      0
    );
  }
  function subtract() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return args.reduce(
      (diff, arg, index2) => {
        const value = getNumber(arg);
        return index2 === 0 ? value : diff - value;
      },
      0
    );
  }
  function getPrecision(value) {
    const split = (value + "").split(".");
    return split[1] !== void 0 ? split[1].length : 0;
  }
  function clamp4(value, min, max) {
    const baseValue = getNumber(value);
    return Math.max(min, Math.min(baseValue, max));
  }
  function roundClamp() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
    let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    let step = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    const baseValue = getNumber(value);
    const stepValue = getNumber(step);
    const precision = getPrecision(step);
    const rounded2 = Math.round(baseValue / stepValue) * stepValue;
    const clampedValue = clamp4(rounded2, min, max);
    return precision ? getNumber(clampedValue.toFixed(precision)) : clampedValue;
  }

  // node_modules/@wordpress/components/build-module/h-stack/utils.js
  var H_ALIGNMENTS = {
    bottom: {
      align: "flex-end",
      justify: "center"
    },
    bottomLeft: {
      align: "flex-start",
      justify: "flex-end"
    },
    bottomRight: {
      align: "flex-end",
      justify: "flex-end"
    },
    center: {
      align: "center",
      justify: "center"
    },
    edge: {
      align: "center",
      justify: "space-between"
    },
    left: {
      align: "center",
      justify: "flex-start"
    },
    right: {
      align: "center",
      justify: "flex-end"
    },
    stretch: {
      align: "stretch"
    },
    top: {
      align: "flex-start",
      justify: "center"
    },
    topLeft: {
      align: "flex-start",
      justify: "flex-start"
    },
    topRight: {
      align: "flex-start",
      justify: "flex-end"
    }
  };
  var V_ALIGNMENTS = {
    bottom: {
      justify: "flex-end",
      align: "center"
    },
    bottomLeft: {
      justify: "flex-start",
      align: "flex-end"
    },
    bottomRight: {
      justify: "flex-end",
      align: "flex-end"
    },
    center: {
      justify: "center",
      align: "center"
    },
    edge: {
      justify: "space-between",
      align: "center"
    },
    left: {
      justify: "center",
      align: "flex-start"
    },
    right: {
      justify: "center",
      align: "flex-end"
    },
    stretch: {
      justify: "stretch"
    },
    top: {
      justify: "flex-start",
      align: "center"
    },
    topLeft: {
      justify: "flex-start",
      align: "flex-start"
    },
    topRight: {
      justify: "flex-start",
      align: "flex-end"
    }
  };
  function getAlignmentProps(alignment) {
    let direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "row";
    if (!isValueDefined(alignment)) {
      return {};
    }
    const isVertical = direction === "column";
    const props = isVertical ? V_ALIGNMENTS : H_ALIGNMENTS;
    const alignmentProps = alignment in props ? props[alignment] : {
      align: alignment
    };
    return alignmentProps;
  }

  // node_modules/@wordpress/components/build-module/ui/utils/get-valid-children.js
  function getValidChildren(children) {
    if (typeof children === "string")
      return [children];
    return import_react.Children.toArray(children).filter((child) => (0, import_react.isValidElement)(child));
  }

  // node_modules/@wordpress/components/build-module/h-stack/hook.js
  function useHStack(props) {
    const {
      alignment = "edge",
      children,
      direction,
      spacing = 2,
      ...otherProps
    } = useContextSystem(props, "HStack");
    const align = getAlignmentProps(alignment, direction);
    const validChildren = getValidChildren(children);
    const clonedChildren = validChildren.map((child, index2) => {
      const _isSpacer = hasConnectNamespace(child, ["Spacer"]);
      if (_isSpacer) {
        const childElement = child;
        const _key = childElement.key || `hstack-${index2}`;
        return (0, import_react.createElement)(component_default4, _extends({
          isBlock: true,
          key: _key
        }, childElement.props));
      }
      return child;
    });
    const propsForFlex = {
      children: clonedChildren,
      direction,
      justify: "center",
      ...align,
      ...otherProps,
      gap: spacing
    };
    const flexProps = useFlex(propsForFlex);
    return flexProps;
  }

  // node_modules/@wordpress/components/build-module/h-stack/component.js
  function UnconnectedHStack(props, forwardedRef) {
    const hStackProps = useHStack(props);
    return (0, import_react.createElement)(component_default, _extends({}, hStackProps, {
      ref: forwardedRef
    }));
  }
  var HStack = contextConnect(UnconnectedHStack, "HStack");
  var component_default8 = HStack;

  // node_modules/@wordpress/components/build-module/spacer/hook.js
  var import_react78 = __toESM(require_emotion_react_cjs());
  var isDefined = (o6) => typeof o6 !== "undefined" && o6 !== null;
  function useSpacer(props) {
    const {
      className,
      margin: margin2,
      marginBottom = 2,
      marginLeft,
      marginRight,
      marginTop,
      marginX,
      marginY,
      padding: padding2,
      paddingBottom,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingX,
      paddingY: paddingY2,
      ...otherProps
    } = useContextSystem(props, "Spacer");
    const cx = useCx();
    const classes = cx(isDefined(margin2) && /* @__PURE__ */ (0, import_react78.css)("margin:", space(margin2), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMENNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(marginY) && /* @__PURE__ */ (0, import_react78.css)("margin-bottom:", space(marginY), ";margin-top:", space(marginY), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBOENNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(marginX) && /* @__PURE__ */ (0, import_react78.css)("margin-left:", space(marginX), ";margin-right:", space(marginX), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbURNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(marginTop) && /* @__PURE__ */ (0, import_react78.css)("margin-top:", space(marginTop), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0RNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(marginBottom) && /* @__PURE__ */ (0, import_react78.css)("margin-bottom:", space(marginBottom), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNERNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(marginLeft) && rtl({
      marginLeft: space(marginLeft)
    })(), isDefined(marginRight) && rtl({
      marginRight: space(marginRight)
    })(), isDefined(padding2) && /* @__PURE__ */ (0, import_react78.css)("padding:", space(padding2), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBd0VNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(paddingY2) && /* @__PURE__ */ (0, import_react78.css)("padding-bottom:", space(paddingY2), ";padding-top:", space(paddingY2), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNEVNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(paddingX) && /* @__PURE__ */ (0, import_react78.css)("padding-left:", space(paddingX), ";padding-right:", space(paddingX), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUZNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(paddingTop) && /* @__PURE__ */ (0, import_react78.css)("padding-top:", space(paddingTop), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0ZNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(paddingBottom) && /* @__PURE__ */ (0, import_react78.css)("padding-bottom:", space(paddingBottom), ";" + (false ? "" : ";label:classes;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMEZNIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvc3BhY2VyL2hvb2sudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IHVzZUNvbnRleHRTeXN0ZW0sIFdvcmRQcmVzc0NvbXBvbmVudFByb3BzIH0gZnJvbSAnLi4vdWkvY29udGV4dCc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uL3VpL3V0aWxzL3NwYWNlJztcbmltcG9ydCB7IHJ0bCwgdXNlQ3ggfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFNwYWNlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGlzRGVmaW5lZCA9IDwgVCA+KCBvOiBUICk6IG8gaXMgRXhjbHVkZTwgVCwgbnVsbCB8IHVuZGVmaW5lZCA+ID0+XG5cdHR5cGVvZiBvICE9PSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3BhY2VyKFxuXHRwcm9wczogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFNwYWNlclByb3BzLCAnZGl2JyA+XG4pIHtcblx0Y29uc3Qge1xuXHRcdGNsYXNzTmFtZSxcblx0XHRtYXJnaW4sXG5cdFx0bWFyZ2luQm90dG9tID0gMixcblx0XHRtYXJnaW5MZWZ0LFxuXHRcdG1hcmdpblJpZ2h0LFxuXHRcdG1hcmdpblRvcCxcblx0XHRtYXJnaW5YLFxuXHRcdG1hcmdpblksXG5cdFx0cGFkZGluZyxcblx0XHRwYWRkaW5nQm90dG9tLFxuXHRcdHBhZGRpbmdMZWZ0LFxuXHRcdHBhZGRpbmdSaWdodCxcblx0XHRwYWRkaW5nVG9wLFxuXHRcdHBhZGRpbmdYLFxuXHRcdHBhZGRpbmdZLFxuXHRcdC4uLm90aGVyUHJvcHNcblx0fSA9IHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnU3BhY2VyJyApO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblxuXHRjb25zdCBjbGFzc2VzID0gY3goXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW4gKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW46ICR7IHNwYWNlKCBtYXJnaW4gKSB9O1xuXHRcdFx0YCxcblx0XHRpc0RlZmluZWQoIG1hcmdpblkgKSAmJlxuXHRcdFx0Y3NzYFxuXHRcdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggbWFyZ2luWSApIH07XG5cdFx0XHRcdG1hcmdpbi10b3A6ICR7IHNwYWNlKCBtYXJnaW5ZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBtYXJnaW5YICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWxlZnQ6ICR7IHNwYWNlKCBtYXJnaW5YICkgfTtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiAkeyBzcGFjZSggbWFyZ2luWCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIG1hcmdpblRvcCApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIG1hcmdpbkJvdHRvbSApIH07XG5cdFx0XHRgLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0bWFyZ2luTGVmdDogc3BhY2UoIG1hcmdpbkxlZnQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggbWFyZ2luUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdG1hcmdpblJpZ2h0OiBzcGFjZSggbWFyZ2luUmlnaHQgKSxcblx0XHRcdH0gKSgpLFxuXHRcdGlzRGVmaW5lZCggcGFkZGluZyApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCBwYWRkaW5nICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWSApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAkeyBzcGFjZSggcGFkZGluZ1kgKSB9O1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogJHsgc3BhY2UoIHBhZGRpbmdZICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nWCApICYmXG5cdFx0XHRjc3NgXG5cdFx0XHRcdHBhZGRpbmctbGVmdDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdFx0cGFkZGluZy1yaWdodDogJHsgc3BhY2UoIHBhZGRpbmdYICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nVG9wICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy10b3A6ICR7IHNwYWNlKCBwYWRkaW5nVG9wICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nQm90dG9tICkgJiZcblx0XHRcdGNzc2Bcblx0XHRcdFx0cGFkZGluZy1ib3R0b206ICR7IHNwYWNlKCBwYWRkaW5nQm90dG9tICkgfTtcblx0XHRcdGAsXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nTGVmdCApICYmXG5cdFx0XHRydGwoIHtcblx0XHRcdFx0cGFkZGluZ0xlZnQ6IHNwYWNlKCBwYWRkaW5nTGVmdCApLFxuXHRcdFx0fSApKCksXG5cdFx0aXNEZWZpbmVkKCBwYWRkaW5nUmlnaHQgKSAmJlxuXHRcdFx0cnRsKCB7XG5cdFx0XHRcdHBhZGRpbmdSaWdodDogc3BhY2UoIHBhZGRpbmdSaWdodCApLFxuXHRcdFx0fSApKCksXG5cdFx0Y2xhc3NOYW1lXG5cdCk7XG5cblx0cmV0dXJuIHsgLi4ub3RoZXJQcm9wcywgY2xhc3NOYW1lOiBjbGFzc2VzIH07XG59XG4iXX0= */"), isDefined(paddingLeft) && rtl({
      paddingLeft: space(paddingLeft)
    })(), isDefined(paddingRight) && rtl({
      paddingRight: space(paddingRight)
    })(), className);
    return {
      ...otherProps,
      className: classes
    };
  }

  // node_modules/@wordpress/components/build-module/spacer/component.js
  function UnconnectedSpacer(props, forwardedRef) {
    const spacerProps = useSpacer(props);
    return (0, import_react.createElement)(component_default, _extends({}, spacerProps, {
      ref: forwardedRef
    }));
  }
  var Spacer = contextConnect(UnconnectedSpacer, "Spacer");
  var component_default9 = Spacer;

  // node_modules/@wordpress/components/build-module/number-control/index.js
  var noop6 = () => {
  };
  function UnforwardedNumberControl(_ref8, forwardedRef) {
    let {
      __unstableStateReducer: stateReducerProp,
      className,
      dragDirection = "n",
      hideHTMLArrows = false,
      spinControls = "native",
      isDragEnabled = true,
      isShiftStepEnabled = true,
      label,
      max = Infinity,
      min = -Infinity,
      required = false,
      shiftStep = 10,
      step = 1,
      type: typeProp = "number",
      value: valueProp,
      size = "default",
      suffix,
      onChange = noop6,
      ...props
    } = _ref8;
    if (hideHTMLArrows) {
      deprecated("hideHTMLArrows", {
        alternative: 'spinControls="none"',
        since: "6.2",
        version: "6.3"
      });
      spinControls = "none";
    }
    const inputRef = (0, import_react.useRef)();
    const mergedRef = useMergeRefs([inputRef, forwardedRef]);
    const isStepAny = step === "any";
    const baseStep = isStepAny ? 1 : ensureNumber(step);
    const baseValue = roundClamp(0, min, max, baseStep);
    const constrainValue = (value, stepOverride) => {
      return isStepAny ? Math.min(max, Math.max(min, ensureNumber(value))) : roundClamp(value, min, max, stepOverride !== null && stepOverride !== void 0 ? stepOverride : baseStep);
    };
    const autoComplete = typeProp === "number" ? "off" : void 0;
    const classes = (0, import_classnames5.default)("components-number-control", className);
    const spinValue = (value, direction, event) => {
      event === null || event === void 0 ? void 0 : event.preventDefault();
      const shift = (event === null || event === void 0 ? void 0 : event.shiftKey) && isShiftStepEnabled;
      const delta = shift ? ensureNumber(shiftStep) * baseStep : baseStep;
      let nextValue = isValueEmpty(value) ? baseValue : value;
      if (direction === "up") {
        nextValue = add(nextValue, delta);
      } else if (direction === "down") {
        nextValue = subtract(nextValue, delta);
      }
      return constrainValue(nextValue, shift ? delta : void 0);
    };
    const numberControlStateReducer = (state, action) => {
      const nextState = {
        ...state
      };
      const {
        type,
        payload
      } = action;
      const event = payload.event;
      const currentValue = nextState.value;
      if (type === PRESS_UP || type === PRESS_DOWN) {
        nextState.value = spinValue(currentValue, type === PRESS_UP ? "up" : "down", event);
      }
      if (type === DRAG && isDragEnabled) {
        const [x4, y5] = payload.delta;
        const enableShift = payload.shiftKey && isShiftStepEnabled;
        const modifier = enableShift ? ensureNumber(shiftStep) * baseStep : baseStep;
        let directionModifier;
        let delta;
        switch (dragDirection) {
          case "n":
            delta = y5;
            directionModifier = -1;
            break;
          case "e":
            delta = x4;
            directionModifier = isRTL() ? -1 : 1;
            break;
          case "s":
            delta = y5;
            directionModifier = 1;
            break;
          case "w":
            delta = x4;
            directionModifier = isRTL() ? 1 : -1;
            break;
        }
        if (delta !== 0) {
          delta = Math.ceil(Math.abs(delta)) * Math.sign(delta);
          const distance2 = delta * modifier * directionModifier;
          nextState.value = constrainValue(
            add(currentValue, distance2),
            enableShift ? modifier : void 0
          );
        }
      }
      if (type === PRESS_ENTER || type === COMMIT) {
        const applyEmptyValue = required === false && currentValue === "";
        nextState.value = applyEmptyValue ? currentValue : constrainValue(currentValue);
      }
      return nextState;
    };
    const buildSpinButtonClickHandler = (direction) => (event) => onChange(String(spinValue(valueProp, direction, event)), {
      event: {
        ...event,
        target: inputRef.current
      }
    });
    return (0, import_react.createElement)(Input2, _extends({
      autoComplete,
      inputMode: "numeric"
    }, props, {
      className: classes,
      dragDirection,
      hideHTMLArrows: spinControls !== "native",
      isDragEnabled,
      label,
      max,
      min,
      ref: mergedRef,
      required,
      step,
      type: typeProp,
      value: valueProp,
      __unstableStateReducer: (state, action) => {
        var _stateReducerProp;
        const baseState = numberControlStateReducer(state, action);
        return (_stateReducerProp = stateReducerProp === null || stateReducerProp === void 0 ? void 0 : stateReducerProp(baseState, action)) !== null && _stateReducerProp !== void 0 ? _stateReducerProp : baseState;
      },
      size,
      suffix: spinControls === "custom" ? (0, import_react.createElement)(import_react.Fragment, null, suffix, (0, import_react.createElement)(component_default9, {
        marginBottom: 0,
        marginRight: 2
      }, (0, import_react.createElement)(component_default8, {
        spacing: 1
      }, (0, import_react.createElement)(SpinButton, {
        icon: plus_default,
        isSmall: true,
        "aria-hidden": "true",
        "aria-label": __("Increment"),
        tabIndex: -1,
        onClick: buildSpinButtonClickHandler("up"),
        size
      }), (0, import_react.createElement)(SpinButton, {
        icon: reset_default,
        isSmall: true,
        "aria-hidden": "true",
        "aria-label": __("Decrement"),
        tabIndex: -1,
        onClick: buildSpinButtonClickHandler("down"),
        size
      })))) : suffix,
      onChange
    }));
  }
  var NumberControl = (0, import_react.forwardRef)(UnforwardedNumberControl);
  var number_control_default = NumberControl;

  // node_modules/@wordpress/rich-text/build-module/store/reducer.js
  function formatTypes() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "ADD_FORMAT_TYPES":
        return {
          ...state,
          ...action.formatTypes.reduce((newFormatTypes, type) => ({
            ...newFormatTypes,
            [type.name]: type
          }), {})
        };
      case "REMOVE_FORMAT_TYPES":
        return Object.fromEntries(Object.entries(state).filter((_ref8) => {
          let [key] = _ref8;
          return !action.names.includes(key);
        }));
    }
    return state;
  }
  var reducer_default3 = combineReducers2({
    formatTypes
  });

  // node_modules/@wordpress/rich-text/build-module/store/selectors.js
  var selectors_exports3 = {};
  __export(selectors_exports3, {
    getFormatType: () => getFormatType,
    getFormatTypeForBareElement: () => getFormatTypeForBareElement,
    getFormatTypeForClassName: () => getFormatTypeForClassName,
    getFormatTypes: () => getFormatTypes
  });
  var getFormatTypes = rememo_default((state) => Object.values(state.formatTypes), (state) => [state.formatTypes]);
  function getFormatType(state, name) {
    return state.formatTypes[name];
  }
  function getFormatTypeForBareElement(state, bareElementTagName) {
    return getFormatTypes(state).find((_ref8) => {
      let {
        className,
        tagName
      } = _ref8;
      return className === null && bareElementTagName === tagName;
    });
  }
  function getFormatTypeForClassName(state, elementClassName) {
    return getFormatTypes(state).find((_ref22) => {
      let {
        className
      } = _ref22;
      if (className === null) {
        return false;
      }
      return ` ${elementClassName} `.indexOf(` ${className} `) >= 0;
    });
  }

  // node_modules/@wordpress/rich-text/build-module/store/actions.js
  var actions_exports4 = {};
  __export(actions_exports4, {
    addFormatTypes: () => addFormatTypes,
    removeFormatTypes: () => removeFormatTypes
  });
  function addFormatTypes(formatTypes2) {
    return {
      type: "ADD_FORMAT_TYPES",
      formatTypes: Array.isArray(formatTypes2) ? formatTypes2 : [formatTypes2]
    };
  }
  function removeFormatTypes(names2) {
    return {
      type: "REMOVE_FORMAT_TYPES",
      names: Array.isArray(names2) ? names2 : [names2]
    };
  }

  // node_modules/@wordpress/rich-text/build-module/store/index.js
  var STORE_NAME2 = "core/rich-text";
  var store2 = createReduxStore(STORE_NAME2, {
    reducer: reducer_default3,
    selectors: selectors_exports3,
    actions: actions_exports4
  });
  register(store2);

  // node_modules/@wordpress/rich-text/build-module/is-format-equal.js
  function isFormatEqual(format1, format2) {
    if (format1 === format2) {
      return true;
    }
    if (!format1 || !format2) {
      return false;
    }
    if (format1.type !== format2.type) {
      return false;
    }
    const attributes1 = format1.attributes;
    const attributes2 = format2.attributes;
    if (attributes1 === attributes2) {
      return true;
    }
    if (!attributes1 || !attributes2) {
      return false;
    }
    const keys1 = Object.keys(attributes1);
    const keys2 = Object.keys(attributes2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    const length = keys1.length;
    for (let i5 = 0; i5 < length; i5++) {
      const name = keys1[i5];
      if (attributes1[name] !== attributes2[name]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@wordpress/rich-text/build-module/normalise-formats.js
  function normaliseFormats(value) {
    const newFormats = value.formats.slice();
    newFormats.forEach((formatsAtIndex, index2) => {
      const formatsAtPreviousIndex = newFormats[index2 - 1];
      if (formatsAtPreviousIndex) {
        const newFormatsAtIndex = formatsAtIndex.slice();
        newFormatsAtIndex.forEach((format, formatIndex) => {
          const previousFormat = formatsAtPreviousIndex[formatIndex];
          if (isFormatEqual(format, previousFormat)) {
            newFormatsAtIndex[formatIndex] = previousFormat;
          }
        });
        newFormats[index2] = newFormatsAtIndex;
      }
    });
    return {
      ...value,
      formats: newFormats
    };
  }

  // node_modules/@wordpress/rich-text/build-module/create-element.js
  function createElement7(_ref8, html2) {
    let {
      implementation
    } = _ref8;
    if (!createElement7.body) {
      createElement7.body = implementation.createHTMLDocument("").body;
    }
    createElement7.body.innerHTML = html2;
    return createElement7.body;
  }

  // node_modules/@wordpress/rich-text/build-module/special-characters.js
  var LINE_SEPARATOR = "\u2028";
  var OBJECT_REPLACEMENT_CHARACTER = "\uFFFC";
  var ZWNBSP = "\uFEFF";

  // node_modules/@wordpress/rich-text/build-module/create.js
  function createEmptyValue() {
    return {
      formats: [],
      replacements: [],
      text: ""
    };
  }
  function toFormat(_ref8) {
    let {
      type,
      attributes
    } = _ref8;
    let formatType;
    if (attributes && attributes.class) {
      formatType = select(store2).getFormatTypeForClassName(attributes.class);
      if (formatType) {
        attributes.class = ` ${attributes.class} `.replace(` ${formatType.className} `, " ").trim();
        if (!attributes.class) {
          delete attributes.class;
        }
      }
    }
    if (!formatType) {
      formatType = select(store2).getFormatTypeForBareElement(type);
    }
    if (!formatType) {
      return attributes ? {
        type,
        attributes
      } : {
        type
      };
    }
    if (formatType.__experimentalCreatePrepareEditableTree && !formatType.__experimentalCreateOnChangeEditableValue) {
      return null;
    }
    if (!attributes) {
      return {
        type: formatType.name
      };
    }
    const registeredAttributes = {};
    const unregisteredAttributes = {};
    const _attributes = {
      ...attributes
    };
    for (const key in formatType.attributes) {
      const name = formatType.attributes[key];
      registeredAttributes[key] = _attributes[name];
      if (formatType.__unstableFilterAttributeValue) {
        registeredAttributes[key] = formatType.__unstableFilterAttributeValue(key, registeredAttributes[key]);
      }
      delete _attributes[name];
      if (typeof registeredAttributes[key] === "undefined") {
        delete registeredAttributes[key];
      }
    }
    for (const name in _attributes) {
      unregisteredAttributes[name] = attributes[name];
    }
    return {
      type: formatType.name,
      attributes: registeredAttributes,
      unregisteredAttributes
    };
  }
  function create2() {
    let {
      element,
      text: text3,
      html: html2,
      range,
      multilineTag,
      multilineWrapperTags,
      __unstableIsEditableTree: isEditableTree,
      preserveWhiteSpace
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof text3 === "string" && text3.length > 0) {
      return {
        formats: Array(text3.length),
        replacements: Array(text3.length),
        text: text3
      };
    }
    if (typeof html2 === "string" && html2.length > 0) {
      element = createElement7(document, html2);
    }
    if (typeof element !== "object") {
      return createEmptyValue();
    }
    if (!multilineTag) {
      return createFromElement({
        element,
        range,
        isEditableTree,
        preserveWhiteSpace
      });
    }
    return createFromMultilineElement({
      element,
      range,
      multilineTag,
      multilineWrapperTags,
      isEditableTree,
      preserveWhiteSpace
    });
  }
  function accumulateSelection(accumulator, node, range, value) {
    if (!range) {
      return;
    }
    const {
      parentNode
    } = node;
    const {
      startContainer,
      startOffset,
      endContainer,
      endOffset
    } = range;
    const currentLength = accumulator.text.length;
    if (value.start !== void 0) {
      accumulator.start = currentLength + value.start;
    } else if (node === startContainer && node.nodeType === node.TEXT_NODE) {
      accumulator.start = currentLength + startOffset;
    } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset]) {
      accumulator.start = currentLength;
    } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset - 1]) {
      accumulator.start = currentLength + value.text.length;
    } else if (node === startContainer) {
      accumulator.start = currentLength;
    }
    if (value.end !== void 0) {
      accumulator.end = currentLength + value.end;
    } else if (node === endContainer && node.nodeType === node.TEXT_NODE) {
      accumulator.end = currentLength + endOffset;
    } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset - 1]) {
      accumulator.end = currentLength + value.text.length;
    } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset]) {
      accumulator.end = currentLength;
    } else if (node === endContainer) {
      accumulator.end = currentLength + endOffset;
    }
  }
  function filterRange(node, range, filter5) {
    if (!range) {
      return;
    }
    const {
      startContainer,
      endContainer
    } = range;
    let {
      startOffset,
      endOffset
    } = range;
    if (node === startContainer) {
      startOffset = filter5(node.nodeValue.slice(0, startOffset)).length;
    }
    if (node === endContainer) {
      endOffset = filter5(node.nodeValue.slice(0, endOffset)).length;
    }
    return {
      startContainer,
      startOffset,
      endContainer,
      endOffset
    };
  }
  function collapseWhiteSpace(string2) {
    return string2.replace(/[\n\r\t]+/g, " ");
  }
  function removeReservedCharacters(string2) {
    return string2.replace(new RegExp(`[${ZWNBSP}${OBJECT_REPLACEMENT_CHARACTER}]`, "gu"), "");
  }
  function createFromElement(_ref22) {
    let {
      element,
      range,
      multilineTag,
      multilineWrapperTags,
      currentWrapperTags = [],
      isEditableTree,
      preserveWhiteSpace
    } = _ref22;
    const accumulator = createEmptyValue();
    if (!element) {
      return accumulator;
    }
    if (!element.hasChildNodes()) {
      accumulateSelection(accumulator, element, range, createEmptyValue());
      return accumulator;
    }
    const length = element.childNodes.length;
    for (let index2 = 0; index2 < length; index2++) {
      const node = element.childNodes[index2];
      const type = node.nodeName.toLowerCase();
      if (node.nodeType === node.TEXT_NODE) {
        let filter5 = removeReservedCharacters;
        if (!preserveWhiteSpace) {
          filter5 = (string2) => removeReservedCharacters(collapseWhiteSpace(string2));
        }
        const text3 = filter5(node.nodeValue);
        range = filterRange(node, range, filter5);
        accumulateSelection(accumulator, node, range, {
          text: text3
        });
        accumulator.formats.length += text3.length;
        accumulator.replacements.length += text3.length;
        accumulator.text += text3;
        continue;
      }
      if (node.nodeType !== node.ELEMENT_NODE) {
        continue;
      }
      if (isEditableTree && (node.getAttribute("data-rich-text-placeholder") || type === "br" && !node.getAttribute("data-rich-text-line-break"))) {
        accumulateSelection(accumulator, node, range, createEmptyValue());
        continue;
      }
      if (type === "script") {
        const value2 = {
          formats: [,],
          replacements: [{
            type,
            attributes: {
              "data-rich-text-script": node.getAttribute("data-rich-text-script") || encodeURIComponent(node.innerHTML)
            }
          }],
          text: OBJECT_REPLACEMENT_CHARACTER
        };
        accumulateSelection(accumulator, node, range, value2);
        mergePair(accumulator, value2);
        continue;
      }
      if (type === "br") {
        accumulateSelection(accumulator, node, range, createEmptyValue());
        mergePair(accumulator, create2({
          text: "\n"
        }));
        continue;
      }
      const format = toFormat({
        type,
        attributes: getAttributes({
          element: node
        })
      });
      if (multilineWrapperTags && multilineWrapperTags.indexOf(type) !== -1) {
        const value2 = createFromMultilineElement({
          element: node,
          range,
          multilineTag,
          multilineWrapperTags,
          currentWrapperTags: [...currentWrapperTags, format],
          isEditableTree,
          preserveWhiteSpace
        });
        accumulateSelection(accumulator, node, range, value2);
        mergePair(accumulator, value2);
        continue;
      }
      const value = createFromElement({
        element: node,
        range,
        multilineTag,
        multilineWrapperTags,
        isEditableTree,
        preserveWhiteSpace
      });
      accumulateSelection(accumulator, node, range, value);
      if (!format) {
        mergePair(accumulator, value);
      } else if (value.text.length === 0) {
        if (format.attributes) {
          mergePair(accumulator, {
            formats: [,],
            replacements: [format],
            text: OBJECT_REPLACEMENT_CHARACTER
          });
        }
      } else {
        let mergeFormats = function(formats) {
          if (mergeFormats.formats === formats) {
            return mergeFormats.newFormats;
          }
          const newFormats = formats ? [format, ...formats] : [format];
          mergeFormats.formats = formats;
          mergeFormats.newFormats = newFormats;
          return newFormats;
        };
        mergeFormats.newFormats = [format];
        mergePair(accumulator, {
          ...value,
          formats: Array.from(value.formats, mergeFormats)
        });
      }
    }
    return accumulator;
  }
  function createFromMultilineElement(_ref32) {
    let {
      element,
      range,
      multilineTag,
      multilineWrapperTags,
      currentWrapperTags = [],
      isEditableTree,
      preserveWhiteSpace
    } = _ref32;
    const accumulator = createEmptyValue();
    if (!element || !element.hasChildNodes()) {
      return accumulator;
    }
    const length = element.children.length;
    for (let index2 = 0; index2 < length; index2++) {
      const node = element.children[index2];
      if (node.nodeName.toLowerCase() !== multilineTag) {
        continue;
      }
      const value = createFromElement({
        element: node,
        range,
        multilineTag,
        multilineWrapperTags,
        currentWrapperTags,
        isEditableTree,
        preserveWhiteSpace
      });
      if (index2 !== 0 || currentWrapperTags.length > 0) {
        mergePair(accumulator, {
          formats: [,],
          replacements: currentWrapperTags.length > 0 ? [currentWrapperTags] : [,],
          text: LINE_SEPARATOR
        });
      }
      accumulateSelection(accumulator, node, range, value);
      mergePair(accumulator, value);
    }
    return accumulator;
  }
  function getAttributes(_ref42) {
    let {
      element
    } = _ref42;
    if (!element.hasAttributes()) {
      return;
    }
    const length = element.attributes.length;
    let accumulator;
    for (let i5 = 0; i5 < length; i5++) {
      const {
        name,
        value
      } = element.attributes[i5];
      if (name.indexOf("data-rich-text-") === 0) {
        continue;
      }
      const safeName = /^on/i.test(name) ? "data-disable-rich-text-" + name : name;
      accumulator = accumulator || {};
      accumulator[safeName] = value;
    }
    return accumulator;
  }

  // node_modules/@wordpress/rich-text/build-module/concat.js
  function mergePair(a6, b6) {
    a6.formats = a6.formats.concat(b6.formats);
    a6.replacements = a6.replacements.concat(b6.replacements);
    a6.text += b6.text;
    return a6;
  }

  // node_modules/@wordpress/rich-text/build-module/get-active-formats.js
  function getActiveFormats(_ref8) {
    let {
      formats,
      start: start2,
      end,
      activeFormats
    } = _ref8;
    let EMPTY_ACTIVE_FORMATS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (start2 === void 0) {
      return EMPTY_ACTIVE_FORMATS;
    }
    if (start2 === end) {
      if (activeFormats) {
        return activeFormats;
      }
      const formatsBefore = formats[start2 - 1] || EMPTY_ACTIVE_FORMATS;
      const formatsAfter = formats[start2] || EMPTY_ACTIVE_FORMATS;
      if (formatsBefore.length < formatsAfter.length) {
        return formatsBefore;
      }
      return formatsAfter;
    }
    return formats[start2] || EMPTY_ACTIVE_FORMATS;
  }

  // node_modules/@wordpress/rich-text/build-module/insert.js
  function insert(value, valueToInsert) {
    let startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : value.start;
    let endIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : value.end;
    const {
      formats,
      replacements,
      text: text3
    } = value;
    if (typeof valueToInsert === "string") {
      valueToInsert = create2({
        text: valueToInsert
      });
    }
    const index2 = startIndex + valueToInsert.text.length;
    return normaliseFormats({
      formats: formats.slice(0, startIndex).concat(valueToInsert.formats, formats.slice(endIndex)),
      replacements: replacements.slice(0, startIndex).concat(valueToInsert.replacements, replacements.slice(endIndex)),
      text: text3.slice(0, startIndex) + valueToInsert.text + text3.slice(endIndex),
      start: index2,
      end: index2
    });
  }

  // node_modules/@wordpress/rich-text/build-module/remove.js
  function remove2(value, startIndex, endIndex) {
    return insert(value, create2(), startIndex, endIndex);
  }

  // node_modules/@wordpress/rich-text/build-module/get-format-type.js
  function getFormatType2(name) {
    return select(store2).getFormatType(name);
  }

  // node_modules/@wordpress/rich-text/build-module/to-tree.js
  function restoreOnAttributes(attributes, isEditableTree) {
    if (isEditableTree) {
      return attributes;
    }
    const newAttributes = {};
    for (const key in attributes) {
      let newKey = key;
      if (key.startsWith("data-disable-rich-text-")) {
        newKey = key.slice("data-disable-rich-text-".length);
      }
      newAttributes[newKey] = attributes[key];
    }
    return newAttributes;
  }
  function fromFormat(_ref8) {
    let {
      type,
      attributes,
      unregisteredAttributes,
      object,
      boundaryClass,
      isEditableTree
    } = _ref8;
    const formatType = getFormatType2(type);
    let elementAttributes = {};
    if (boundaryClass) {
      elementAttributes["data-rich-text-format-boundary"] = "true";
    }
    if (!formatType) {
      if (attributes) {
        elementAttributes = {
          ...attributes,
          ...elementAttributes
        };
      }
      return {
        type,
        attributes: restoreOnAttributes(elementAttributes, isEditableTree),
        object
      };
    }
    elementAttributes = {
      ...unregisteredAttributes,
      ...elementAttributes
    };
    for (const name in attributes) {
      const key = formatType.attributes ? formatType.attributes[name] : false;
      if (key) {
        elementAttributes[key] = attributes[name];
      } else {
        elementAttributes[name] = attributes[name];
      }
    }
    if (formatType.className) {
      if (elementAttributes.class) {
        elementAttributes.class = `${formatType.className} ${elementAttributes.class}`;
      } else {
        elementAttributes.class = formatType.className;
      }
    }
    return {
      type: formatType.tagName,
      object: formatType.object,
      attributes: restoreOnAttributes(elementAttributes, isEditableTree)
    };
  }
  function isEqualUntil(a6, b6, index2) {
    do {
      if (a6[index2] !== b6[index2]) {
        return false;
      }
    } while (index2--);
    return true;
  }
  function toTree(_ref22) {
    let {
      value,
      multilineTag,
      preserveWhiteSpace,
      createEmpty: createEmpty2,
      append: append2,
      getLastChild: getLastChild2,
      getParent: getParent2,
      isText: isText2,
      getText: getText2,
      remove: remove4,
      appendText: appendText2,
      onStartIndex,
      onEndIndex,
      isEditableTree,
      placeholder
    } = _ref22;
    const {
      formats,
      replacements,
      text: text3,
      start: start2,
      end
    } = value;
    const formatsLength = formats.length + 1;
    const tree = createEmpty2();
    const multilineFormat = {
      type: multilineTag
    };
    const activeFormats = getActiveFormats(value);
    const deepestActiveFormat = activeFormats[activeFormats.length - 1];
    let lastSeparatorFormats;
    let lastCharacterFormats;
    let lastCharacter;
    if (multilineTag) {
      append2(append2(tree, {
        type: multilineTag
      }), "");
      lastCharacterFormats = lastSeparatorFormats = [multilineFormat];
    } else {
      append2(tree, "");
    }
    for (let i5 = 0; i5 < formatsLength; i5++) {
      const character = text3.charAt(i5);
      const shouldInsertPadding = isEditableTree && (!lastCharacter || lastCharacter === LINE_SEPARATOR || lastCharacter === "\n");
      let characterFormats = formats[i5];
      if (multilineTag) {
        if (character === LINE_SEPARATOR) {
          characterFormats = lastSeparatorFormats = (replacements[i5] || []).reduce((accumulator, format) => {
            accumulator.push(format, multilineFormat);
            return accumulator;
          }, [multilineFormat]);
        } else {
          characterFormats = [...lastSeparatorFormats, ...characterFormats || []];
        }
      }
      let pointer = getLastChild2(tree);
      if (shouldInsertPadding && character === LINE_SEPARATOR) {
        let node = pointer;
        while (!isText2(node)) {
          node = getLastChild2(node);
        }
        append2(getParent2(node), ZWNBSP);
      }
      if (lastCharacter === LINE_SEPARATOR) {
        let node = pointer;
        while (!isText2(node)) {
          node = getLastChild2(node);
        }
        if (onStartIndex && start2 === i5) {
          onStartIndex(tree, node);
        }
        if (onEndIndex && end === i5) {
          onEndIndex(tree, node);
        }
      }
      if (characterFormats) {
        characterFormats.forEach((format, formatIndex) => {
          if (pointer && lastCharacterFormats && isEqualUntil(characterFormats, lastCharacterFormats, formatIndex) && (character !== LINE_SEPARATOR || characterFormats.length - 1 !== formatIndex)) {
            pointer = getLastChild2(pointer);
            return;
          }
          const {
            type,
            attributes,
            unregisteredAttributes
          } = format;
          const boundaryClass = isEditableTree && character !== LINE_SEPARATOR && format === deepestActiveFormat;
          const parent = getParent2(pointer);
          const newNode = append2(parent, fromFormat({
            type,
            attributes,
            unregisteredAttributes,
            boundaryClass,
            isEditableTree
          }));
          if (isText2(pointer) && getText2(pointer).length === 0) {
            remove4(pointer);
          }
          pointer = append2(newNode, "");
        });
      }
      if (character === LINE_SEPARATOR) {
        lastCharacterFormats = characterFormats;
        lastCharacter = character;
        continue;
      }
      if (i5 === 0) {
        if (onStartIndex && start2 === 0) {
          onStartIndex(tree, pointer);
        }
        if (onEndIndex && end === 0) {
          onEndIndex(tree, pointer);
        }
      }
      if (character === OBJECT_REPLACEMENT_CHARACTER) {
        var _replacements$i;
        if (!isEditableTree && ((_replacements$i = replacements[i5]) === null || _replacements$i === void 0 ? void 0 : _replacements$i.type) === "script") {
          pointer = append2(getParent2(pointer), fromFormat({
            type: "script",
            isEditableTree
          }));
          append2(pointer, {
            html: decodeURIComponent(replacements[i5].attributes["data-rich-text-script"])
          });
        } else {
          pointer = append2(getParent2(pointer), fromFormat({
            ...replacements[i5],
            object: true,
            isEditableTree
          }));
        }
        pointer = append2(getParent2(pointer), "");
      } else if (!preserveWhiteSpace && character === "\n") {
        pointer = append2(getParent2(pointer), {
          type: "br",
          attributes: isEditableTree ? {
            "data-rich-text-line-break": "true"
          } : void 0,
          object: true
        });
        pointer = append2(getParent2(pointer), "");
      } else if (!isText2(pointer)) {
        pointer = append2(getParent2(pointer), character);
      } else {
        appendText2(pointer, character);
      }
      if (onStartIndex && start2 === i5 + 1) {
        onStartIndex(tree, pointer);
      }
      if (onEndIndex && end === i5 + 1) {
        onEndIndex(tree, pointer);
      }
      if (shouldInsertPadding && i5 === text3.length) {
        append2(getParent2(pointer), ZWNBSP);
        if (placeholder && text3.length === 0) {
          append2(getParent2(pointer), {
            type: "span",
            attributes: {
              "data-rich-text-placeholder": placeholder,
              contenteditable: "false",
              style: "pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;"
            }
          });
        }
      }
      lastCharacterFormats = characterFormats;
      lastCharacter = character;
    }
    return tree;
  }

  // node_modules/@wordpress/rich-text/build-module/to-html-string.js
  function toHTMLString(_ref8) {
    let {
      value,
      multilineTag,
      preserveWhiteSpace
    } = _ref8;
    const tree = toTree({
      value,
      multilineTag,
      preserveWhiteSpace,
      createEmpty,
      append,
      getLastChild,
      getParent,
      isText,
      getText,
      remove: remove3,
      appendText
    });
    return createChildrenHTML(tree.children);
  }
  function createEmpty() {
    return {};
  }
  function getLastChild(_ref22) {
    let {
      children
    } = _ref22;
    return children && children[children.length - 1];
  }
  function append(parent, object) {
    if (typeof object === "string") {
      object = {
        text: object
      };
    }
    object.parent = parent;
    parent.children = parent.children || [];
    parent.children.push(object);
    return object;
  }
  function appendText(object, text3) {
    object.text += text3;
  }
  function getParent(_ref32) {
    let {
      parent
    } = _ref32;
    return parent;
  }
  function isText(_ref42) {
    let {
      text: text3
    } = _ref42;
    return typeof text3 === "string";
  }
  function getText(_ref52) {
    let {
      text: text3
    } = _ref52;
    return text3;
  }
  function remove3(object) {
    const index2 = object.parent.children.indexOf(object);
    if (index2 !== -1) {
      object.parent.children.splice(index2, 1);
    }
    return object;
  }
  function createElementHTML(_ref62) {
    let {
      type,
      attributes,
      object,
      children
    } = _ref62;
    let attributeString = "";
    for (const key in attributes) {
      if (!isValidAttributeName(key)) {
        continue;
      }
      attributeString += ` ${key}="${escapeAttribute(attributes[key])}"`;
    }
    if (object) {
      return `<${type}${attributeString}>`;
    }
    return `<${type}${attributeString}>${createChildrenHTML(children)}</${type}>`;
  }
  function createChildrenHTML() {
    let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return children.map((child) => {
      if (child.html !== void 0) {
        return child.html;
      }
      return child.text === void 0 ? createElementHTML(child) : escapeEditableHTML(child.text);
    }).join("");
  }

  // node_modules/@wordpress/dom-ready/build-module/index.js
  function domReady(callback) {
    if (typeof document === "undefined") {
      return;
    }
    if (document.readyState === "complete" || document.readyState === "interactive") {
      return void callback();
    }
    document.addEventListener("DOMContentLoaded", callback);
  }

  // node_modules/@wordpress/a11y/build-module/add-intro-text.js
  function addIntroText() {
    const introText = document.createElement("p");
    introText.id = "a11y-speak-intro-text";
    introText.className = "a11y-speak-intro-text";
    introText.textContent = __("Notifications");
    introText.setAttribute("style", "position: absolute;margin: -1px;padding: 0;height: 1px;width: 1px;overflow: hidden;clip: rect(1px, 1px, 1px, 1px);-webkit-clip-path: inset(50%);clip-path: inset(50%);border: 0;word-wrap: normal !important;");
    introText.setAttribute("hidden", "hidden");
    const {
      body
    } = document;
    if (body) {
      body.appendChild(introText);
    }
    return introText;
  }

  // node_modules/@wordpress/a11y/build-module/add-container.js
  function addContainer() {
    let ariaLive = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "polite";
    const container = document.createElement("div");
    container.id = `a11y-speak-${ariaLive}`;
    container.className = "a11y-speak-region";
    container.setAttribute("style", "position: absolute;margin: -1px;padding: 0;height: 1px;width: 1px;overflow: hidden;clip: rect(1px, 1px, 1px, 1px);-webkit-clip-path: inset(50%);clip-path: inset(50%);border: 0;word-wrap: normal !important;");
    container.setAttribute("aria-live", ariaLive);
    container.setAttribute("aria-relevant", "additions text");
    container.setAttribute("aria-atomic", "true");
    const {
      body
    } = document;
    if (body) {
      body.appendChild(container);
    }
    return container;
  }

  // node_modules/@wordpress/a11y/build-module/clear.js
  function clear() {
    const regions = document.getElementsByClassName("a11y-speak-region");
    const introText = document.getElementById("a11y-speak-intro-text");
    for (let i5 = 0; i5 < regions.length; i5++) {
      regions[i5].textContent = "";
    }
    if (introText) {
      introText.setAttribute("hidden", "hidden");
    }
  }

  // node_modules/@wordpress/a11y/build-module/filter-message.js
  var previousMessage = "";
  function filterMessage(message) {
    message = message.replace(/<[^<>]+>/g, " ");
    if (previousMessage === message) {
      message += "\xA0";
    }
    previousMessage = message;
    return message;
  }

  // node_modules/@wordpress/a11y/build-module/index.js
  function setup() {
    const introText = document.getElementById("a11y-speak-intro-text");
    const containerAssertive = document.getElementById("a11y-speak-assertive");
    const containerPolite = document.getElementById("a11y-speak-polite");
    if (introText === null) {
      addIntroText();
    }
    if (containerAssertive === null) {
      addContainer("assertive");
    }
    if (containerPolite === null) {
      addContainer("polite");
    }
  }
  domReady(setup);
  function speak(message, ariaLive) {
    clear();
    message = filterMessage(message);
    const introText = document.getElementById("a11y-speak-intro-text");
    const containerAssertive = document.getElementById("a11y-speak-assertive");
    const containerPolite = document.getElementById("a11y-speak-polite");
    if (containerAssertive && ariaLive === "assertive") {
      containerAssertive.textContent = message;
    } else if (containerPolite) {
      containerPolite.textContent = message;
    }
    if (introText) {
      introText.removeAttribute("hidden");
    }
  }

  // node_modules/@wordpress/components/build-module/base-control/index.js
  var import_classnames6 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/base-control/styles/base-control-styles.js
  var import_base4 = __toESM(require_emotion_styled_base_cjs());
  var import_react79 = __toESM(require_emotion_react_cjs());
  function _EMOTION_STRINGIFIED_CSS_ERROR__9() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var Wrapper = (0, import_base4.default)("div", false ? {
    target: "ej5x27r4"
  } : {
    target: "ej5x27r4",
    label: "Wrapper"
  })("font-family:", font("default.fontFamily"), ";font-size:", font("default.fontSize"), ";", boxSizingReset, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVlpQyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2Jhc2UtY29udHJvbC9zdHlsZXMvYmFzZS1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgYm94U2l6aW5nUmVzZXQsIGZvbnQsIENPTE9SUyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXZgXG5cdGZvbnQtZmFtaWx5OiAkeyBmb250KCAnZGVmYXVsdC5mb250RmFtaWx5JyApIH07XG5cdGZvbnQtc2l6ZTogJHsgZm9udCggJ2RlZmF1bHQuZm9udFNpemUnICkgfTtcblxuXHQkeyBib3hTaXppbmdSZXNldCB9XG5gO1xuXG5jb25zdCBkZXByZWNhdGVkTWFyZ2luRmllbGQgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggMiApIH07XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEZpZWxkID0gc3R5bGVkLmRpdmBcblx0JHsgZGVwcmVjYXRlZE1hcmdpbkZpZWxkIH1cblxuXHQuY29tcG9uZW50cy1wYW5lbF9fcm93ICYge1xuXHRcdG1hcmdpbi1ib3R0b206IGluaGVyaXQ7XG5cdH1cbmA7XG5cbmNvbnN0IGxhYmVsU3R5bGVzID0gY3NzYFxuXHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggMiApIH07XG5cdC8qKlxuXHQgKiBSZW1vdmVzIENocm9tZS9TYWZhcmkvRmlyZWZveCB1c2VyIGFnZW50IHN0eWxlc2hlZXQgcGFkZGluZyBmcm9tXG5cdCAqIFN0eWxlZExhYmVsIHdoZW4gaXQgaXMgcmVuZGVyZWQgYXMgYSBsZWdlbmQuXG5cdCAqL1xuXHRwYWRkaW5nOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZExhYmVsID0gc3R5bGVkLmxhYmVsYFxuXHQkeyBsYWJlbFN0eWxlcyB9XG5gO1xuXG5jb25zdCBkZXByZWNhdGVkTWFyZ2luSGVscCA9ICggeyBfX25leHRIYXNOb01hcmdpbkJvdHRvbSA9IGZhbHNlIH0gKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0ISBfX25leHRIYXNOb01hcmdpbkJvdHRvbSAmJlxuXHRcdGNzc2Bcblx0XHRcdG1hcmdpbi1ib3R0b206IHJldmVydDtcblx0XHRgXG5cdCk7XG59O1xuXG5leHBvcnQgY29uc3QgU3R5bGVkSGVscCA9IHN0eWxlZC5wYFxuXHRtYXJnaW4tdG9wOiAkeyBzcGFjZSggMiApIH07XG5cdG1hcmdpbi1ib3R0b206IDA7XG5cdGZvbnQtc2l6ZTogJHsgZm9udCggJ2hlbHBUZXh0LmZvbnRTaXplJyApIH07XG5cdGZvbnQtc3R5bGU6IG5vcm1hbDtcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA3MDAgXSB9O1xuXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5IZWxwIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRWaXN1YWxMYWJlbCA9IHN0eWxlZC5zcGFuYFxuXHQkeyBsYWJlbFN0eWxlcyB9XG5gO1xuIl19 */"));
  var deprecatedMarginField = (_ref22) => {
    let {
      __nextHasNoMarginBottom = false
    } = _ref22;
    return !__nextHasNoMarginBottom && /* @__PURE__ */ (0, import_react79.css)("margin-bottom:", space(2), ";" + (false ? "" : ";label:deprecatedMarginField;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXNCSyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2Jhc2UtY29udHJvbC9zdHlsZXMvYmFzZS1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgYm94U2l6aW5nUmVzZXQsIGZvbnQsIENPTE9SUyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXZgXG5cdGZvbnQtZmFtaWx5OiAkeyBmb250KCAnZGVmYXVsdC5mb250RmFtaWx5JyApIH07XG5cdGZvbnQtc2l6ZTogJHsgZm9udCggJ2RlZmF1bHQuZm9udFNpemUnICkgfTtcblxuXHQkeyBib3hTaXppbmdSZXNldCB9XG5gO1xuXG5jb25zdCBkZXByZWNhdGVkTWFyZ2luRmllbGQgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggMiApIH07XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEZpZWxkID0gc3R5bGVkLmRpdmBcblx0JHsgZGVwcmVjYXRlZE1hcmdpbkZpZWxkIH1cblxuXHQuY29tcG9uZW50cy1wYW5lbF9fcm93ICYge1xuXHRcdG1hcmdpbi1ib3R0b206IGluaGVyaXQ7XG5cdH1cbmA7XG5cbmNvbnN0IGxhYmVsU3R5bGVzID0gY3NzYFxuXHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggMiApIH07XG5cdC8qKlxuXHQgKiBSZW1vdmVzIENocm9tZS9TYWZhcmkvRmlyZWZveCB1c2VyIGFnZW50IHN0eWxlc2hlZXQgcGFkZGluZyBmcm9tXG5cdCAqIFN0eWxlZExhYmVsIHdoZW4gaXQgaXMgcmVuZGVyZWQgYXMgYSBsZWdlbmQuXG5cdCAqL1xuXHRwYWRkaW5nOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZExhYmVsID0gc3R5bGVkLmxhYmVsYFxuXHQkeyBsYWJlbFN0eWxlcyB9XG5gO1xuXG5jb25zdCBkZXByZWNhdGVkTWFyZ2luSGVscCA9ICggeyBfX25leHRIYXNOb01hcmdpbkJvdHRvbSA9IGZhbHNlIH0gKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0ISBfX25leHRIYXNOb01hcmdpbkJvdHRvbSAmJlxuXHRcdGNzc2Bcblx0XHRcdG1hcmdpbi1ib3R0b206IHJldmVydDtcblx0XHRgXG5cdCk7XG59O1xuXG5leHBvcnQgY29uc3QgU3R5bGVkSGVscCA9IHN0eWxlZC5wYFxuXHRtYXJnaW4tdG9wOiAkeyBzcGFjZSggMiApIH07XG5cdG1hcmdpbi1ib3R0b206IDA7XG5cdGZvbnQtc2l6ZTogJHsgZm9udCggJ2hlbHBUZXh0LmZvbnRTaXplJyApIH07XG5cdGZvbnQtc3R5bGU6IG5vcm1hbDtcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA3MDAgXSB9O1xuXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5IZWxwIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRWaXN1YWxMYWJlbCA9IHN0eWxlZC5zcGFuYFxuXHQkeyBsYWJlbFN0eWxlcyB9XG5gO1xuIl19 */");
  };
  var StyledField = (0, import_base4.default)("div", false ? {
    target: "ej5x27r3"
  } : {
    target: "ej5x27r3",
    label: "StyledField"
  })(deprecatedMarginField, " .components-panel__row &{margin-bottom:inherit;}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRCcUMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9iYXNlLWNvbnRyb2wvc3R5bGVzL2Jhc2UtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIGJveFNpemluZ1Jlc2V0LCBmb250LCBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuZXhwb3J0IGNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHRmb250LWZhbWlseTogJHsgZm9udCggJ2RlZmF1bHQuZm9udEZhbWlseScgKSB9O1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdkZWZhdWx0LmZvbnRTaXplJyApIH07XG5cblx0JHsgYm94U2l6aW5nUmVzZXQgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkZpZWxkID0gKCB7IF9fbmV4dEhhc05vTWFyZ2luQm90dG9tID0gZmFsc2UgfSApID0+IHtcblx0cmV0dXJuIChcblx0XHQhIF9fbmV4dEhhc05vTWFyZ2luQm90dG9tICYmXG5cdFx0Y3NzYFxuXHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdGBcblx0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRGaWVsZCA9IHN0eWxlZC5kaXZgXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5GaWVsZCB9XG5cblx0LmNvbXBvbmVudHMtcGFuZWxfX3JvdyAmIHtcblx0XHRtYXJnaW4tYm90dG9tOiBpbmhlcml0O1xuXHR9XG5gO1xuXG5jb25zdCBsYWJlbFN0eWxlcyA9IGNzc2Bcblx0JHsgYmFzZUxhYmVsVHlwb2dyYXBoeSB9O1xuXG5cdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHQvKipcblx0ICogUmVtb3ZlcyBDaHJvbWUvU2FmYXJpL0ZpcmVmb3ggdXNlciBhZ2VudCBzdHlsZXNoZWV0IHBhZGRpbmcgZnJvbVxuXHQgKiBTdHlsZWRMYWJlbCB3aGVuIGl0IGlzIHJlbmRlcmVkIGFzIGEgbGVnZW5kLlxuXHQgKi9cblx0cGFkZGluZzogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRMYWJlbCA9IHN0eWxlZC5sYWJlbGBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkhlbHAgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiByZXZlcnQ7XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEhlbHAgPSBzdHlsZWQucGBcblx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIDIgKSB9O1xuXHRtYXJnaW4tYm90dG9tOiAwO1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdoZWxwVGV4dC5mb250U2l6ZScgKSB9O1xuXHRmb250LXN0eWxlOiBub3JtYWw7XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblxuXHQkeyBkZXByZWNhdGVkTWFyZ2luSGVscCB9XG5gO1xuXG5leHBvcnQgY29uc3QgU3R5bGVkVmlzdWFsTGFiZWwgPSBzdHlsZWQuc3BhbmBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcbiJdfQ== */"));
  var labelStyles = /* @__PURE__ */ (0, import_react79.css)(baseLabelTypography, ";display:inline-block;margin-bottom:", space(2), ";padding:0;" + (false ? "" : ";label:labelStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9DdUIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9iYXNlLWNvbnRyb2wvc3R5bGVzL2Jhc2UtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIGJveFNpemluZ1Jlc2V0LCBmb250LCBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuZXhwb3J0IGNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHRmb250LWZhbWlseTogJHsgZm9udCggJ2RlZmF1bHQuZm9udEZhbWlseScgKSB9O1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdkZWZhdWx0LmZvbnRTaXplJyApIH07XG5cblx0JHsgYm94U2l6aW5nUmVzZXQgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkZpZWxkID0gKCB7IF9fbmV4dEhhc05vTWFyZ2luQm90dG9tID0gZmFsc2UgfSApID0+IHtcblx0cmV0dXJuIChcblx0XHQhIF9fbmV4dEhhc05vTWFyZ2luQm90dG9tICYmXG5cdFx0Y3NzYFxuXHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdGBcblx0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRGaWVsZCA9IHN0eWxlZC5kaXZgXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5GaWVsZCB9XG5cblx0LmNvbXBvbmVudHMtcGFuZWxfX3JvdyAmIHtcblx0XHRtYXJnaW4tYm90dG9tOiBpbmhlcml0O1xuXHR9XG5gO1xuXG5jb25zdCBsYWJlbFN0eWxlcyA9IGNzc2Bcblx0JHsgYmFzZUxhYmVsVHlwb2dyYXBoeSB9O1xuXG5cdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHQvKipcblx0ICogUmVtb3ZlcyBDaHJvbWUvU2FmYXJpL0ZpcmVmb3ggdXNlciBhZ2VudCBzdHlsZXNoZWV0IHBhZGRpbmcgZnJvbVxuXHQgKiBTdHlsZWRMYWJlbCB3aGVuIGl0IGlzIHJlbmRlcmVkIGFzIGEgbGVnZW5kLlxuXHQgKi9cblx0cGFkZGluZzogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRMYWJlbCA9IHN0eWxlZC5sYWJlbGBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkhlbHAgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiByZXZlcnQ7XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEhlbHAgPSBzdHlsZWQucGBcblx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIDIgKSB9O1xuXHRtYXJnaW4tYm90dG9tOiAwO1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdoZWxwVGV4dC5mb250U2l6ZScgKSB9O1xuXHRmb250LXN0eWxlOiBub3JtYWw7XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblxuXHQkeyBkZXByZWNhdGVkTWFyZ2luSGVscCB9XG5gO1xuXG5leHBvcnQgY29uc3QgU3R5bGVkVmlzdWFsTGFiZWwgPSBzdHlsZWQuc3BhbmBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcbiJdfQ== */");
  var StyledLabel = (0, import_base4.default)("label", false ? {
    target: "ej5x27r2"
  } : {
    target: "ej5x27r2",
    label: "StyledLabel"
  })(labelStyles, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdEdUMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9iYXNlLWNvbnRyb2wvc3R5bGVzL2Jhc2UtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIGJveFNpemluZ1Jlc2V0LCBmb250LCBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuZXhwb3J0IGNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHRmb250LWZhbWlseTogJHsgZm9udCggJ2RlZmF1bHQuZm9udEZhbWlseScgKSB9O1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdkZWZhdWx0LmZvbnRTaXplJyApIH07XG5cblx0JHsgYm94U2l6aW5nUmVzZXQgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkZpZWxkID0gKCB7IF9fbmV4dEhhc05vTWFyZ2luQm90dG9tID0gZmFsc2UgfSApID0+IHtcblx0cmV0dXJuIChcblx0XHQhIF9fbmV4dEhhc05vTWFyZ2luQm90dG9tICYmXG5cdFx0Y3NzYFxuXHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdGBcblx0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRGaWVsZCA9IHN0eWxlZC5kaXZgXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5GaWVsZCB9XG5cblx0LmNvbXBvbmVudHMtcGFuZWxfX3JvdyAmIHtcblx0XHRtYXJnaW4tYm90dG9tOiBpbmhlcml0O1xuXHR9XG5gO1xuXG5jb25zdCBsYWJlbFN0eWxlcyA9IGNzc2Bcblx0JHsgYmFzZUxhYmVsVHlwb2dyYXBoeSB9O1xuXG5cdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHQvKipcblx0ICogUmVtb3ZlcyBDaHJvbWUvU2FmYXJpL0ZpcmVmb3ggdXNlciBhZ2VudCBzdHlsZXNoZWV0IHBhZGRpbmcgZnJvbVxuXHQgKiBTdHlsZWRMYWJlbCB3aGVuIGl0IGlzIHJlbmRlcmVkIGFzIGEgbGVnZW5kLlxuXHQgKi9cblx0cGFkZGluZzogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRMYWJlbCA9IHN0eWxlZC5sYWJlbGBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkhlbHAgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiByZXZlcnQ7XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEhlbHAgPSBzdHlsZWQucGBcblx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIDIgKSB9O1xuXHRtYXJnaW4tYm90dG9tOiAwO1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdoZWxwVGV4dC5mb250U2l6ZScgKSB9O1xuXHRmb250LXN0eWxlOiBub3JtYWw7XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblxuXHQkeyBkZXByZWNhdGVkTWFyZ2luSGVscCB9XG5gO1xuXG5leHBvcnQgY29uc3QgU3R5bGVkVmlzdWFsTGFiZWwgPSBzdHlsZWQuc3BhbmBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcbiJdfQ== */"));
  var _ref5 = false ? {
    name: "11yad0w",
    styles: "margin-bottom:revert"
  } : {
    name: "1xen9ob-deprecatedMarginHelp",
    styles: "margin-bottom:revert;label:deprecatedMarginHelp;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVESyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2Jhc2UtY29udHJvbC9zdHlsZXMvYmFzZS1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgYmFzZUxhYmVsVHlwb2dyYXBoeSwgYm94U2l6aW5nUmVzZXQsIGZvbnQsIENPTE9SUyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXZgXG5cdGZvbnQtZmFtaWx5OiAkeyBmb250KCAnZGVmYXVsdC5mb250RmFtaWx5JyApIH07XG5cdGZvbnQtc2l6ZTogJHsgZm9udCggJ2RlZmF1bHQuZm9udFNpemUnICkgfTtcblxuXHQkeyBib3hTaXppbmdSZXNldCB9XG5gO1xuXG5jb25zdCBkZXByZWNhdGVkTWFyZ2luRmllbGQgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggMiApIH07XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEZpZWxkID0gc3R5bGVkLmRpdmBcblx0JHsgZGVwcmVjYXRlZE1hcmdpbkZpZWxkIH1cblxuXHQuY29tcG9uZW50cy1wYW5lbF9fcm93ICYge1xuXHRcdG1hcmdpbi1ib3R0b206IGluaGVyaXQ7XG5cdH1cbmA7XG5cbmNvbnN0IGxhYmVsU3R5bGVzID0gY3NzYFxuXHQkeyBiYXNlTGFiZWxUeXBvZ3JhcGh5IH07XG5cblx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRtYXJnaW4tYm90dG9tOiAkeyBzcGFjZSggMiApIH07XG5cdC8qKlxuXHQgKiBSZW1vdmVzIENocm9tZS9TYWZhcmkvRmlyZWZveCB1c2VyIGFnZW50IHN0eWxlc2hlZXQgcGFkZGluZyBmcm9tXG5cdCAqIFN0eWxlZExhYmVsIHdoZW4gaXQgaXMgcmVuZGVyZWQgYXMgYSBsZWdlbmQuXG5cdCAqL1xuXHRwYWRkaW5nOiAwO1xuYDtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZExhYmVsID0gc3R5bGVkLmxhYmVsYFxuXHQkeyBsYWJlbFN0eWxlcyB9XG5gO1xuXG5jb25zdCBkZXByZWNhdGVkTWFyZ2luSGVscCA9ICggeyBfX25leHRIYXNOb01hcmdpbkJvdHRvbSA9IGZhbHNlIH0gKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0ISBfX25leHRIYXNOb01hcmdpbkJvdHRvbSAmJlxuXHRcdGNzc2Bcblx0XHRcdG1hcmdpbi1ib3R0b206IHJldmVydDtcblx0XHRgXG5cdCk7XG59O1xuXG5leHBvcnQgY29uc3QgU3R5bGVkSGVscCA9IHN0eWxlZC5wYFxuXHRtYXJnaW4tdG9wOiAkeyBzcGFjZSggMiApIH07XG5cdG1hcmdpbi1ib3R0b206IDA7XG5cdGZvbnQtc2l6ZTogJHsgZm9udCggJ2hlbHBUZXh0LmZvbnRTaXplJyApIH07XG5cdGZvbnQtc3R5bGU6IG5vcm1hbDtcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA3MDAgXSB9O1xuXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5IZWxwIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRWaXN1YWxMYWJlbCA9IHN0eWxlZC5zcGFuYFxuXHQkeyBsYWJlbFN0eWxlcyB9XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__9
  };
  var deprecatedMarginHelp = (_ref32) => {
    let {
      __nextHasNoMarginBottom = false
    } = _ref32;
    return !__nextHasNoMarginBottom && _ref5;
  };
  var StyledHelp = (0, import_base4.default)("p", false ? {
    target: "ej5x27r1"
  } : {
    target: "ej5x27r1",
    label: "StyledHelp"
  })("margin-top:", space(2), ";margin-bottom:0;font-size:", font("helpText.fontSize"), ";font-style:normal;color:", COLORS.gray[700], ";", deprecatedMarginHelp, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZEa0MiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9iYXNlLWNvbnRyb2wvc3R5bGVzL2Jhc2UtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIGJveFNpemluZ1Jlc2V0LCBmb250LCBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuZXhwb3J0IGNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHRmb250LWZhbWlseTogJHsgZm9udCggJ2RlZmF1bHQuZm9udEZhbWlseScgKSB9O1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdkZWZhdWx0LmZvbnRTaXplJyApIH07XG5cblx0JHsgYm94U2l6aW5nUmVzZXQgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkZpZWxkID0gKCB7IF9fbmV4dEhhc05vTWFyZ2luQm90dG9tID0gZmFsc2UgfSApID0+IHtcblx0cmV0dXJuIChcblx0XHQhIF9fbmV4dEhhc05vTWFyZ2luQm90dG9tICYmXG5cdFx0Y3NzYFxuXHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdGBcblx0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRGaWVsZCA9IHN0eWxlZC5kaXZgXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5GaWVsZCB9XG5cblx0LmNvbXBvbmVudHMtcGFuZWxfX3JvdyAmIHtcblx0XHRtYXJnaW4tYm90dG9tOiBpbmhlcml0O1xuXHR9XG5gO1xuXG5jb25zdCBsYWJlbFN0eWxlcyA9IGNzc2Bcblx0JHsgYmFzZUxhYmVsVHlwb2dyYXBoeSB9O1xuXG5cdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHQvKipcblx0ICogUmVtb3ZlcyBDaHJvbWUvU2FmYXJpL0ZpcmVmb3ggdXNlciBhZ2VudCBzdHlsZXNoZWV0IHBhZGRpbmcgZnJvbVxuXHQgKiBTdHlsZWRMYWJlbCB3aGVuIGl0IGlzIHJlbmRlcmVkIGFzIGEgbGVnZW5kLlxuXHQgKi9cblx0cGFkZGluZzogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRMYWJlbCA9IHN0eWxlZC5sYWJlbGBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkhlbHAgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiByZXZlcnQ7XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEhlbHAgPSBzdHlsZWQucGBcblx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIDIgKSB9O1xuXHRtYXJnaW4tYm90dG9tOiAwO1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdoZWxwVGV4dC5mb250U2l6ZScgKSB9O1xuXHRmb250LXN0eWxlOiBub3JtYWw7XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblxuXHQkeyBkZXByZWNhdGVkTWFyZ2luSGVscCB9XG5gO1xuXG5leHBvcnQgY29uc3QgU3R5bGVkVmlzdWFsTGFiZWwgPSBzdHlsZWQuc3BhbmBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcbiJdfQ== */"));
  var StyledVisualLabel = (0, import_base4.default)("span", false ? {
    target: "ej5x27r0"
  } : {
    target: "ej5x27r0",
    label: "StyledVisualLabel"
  })(labelStyles, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvYmFzZS1jb250cm9sL3N0eWxlcy9iYXNlLWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVFNEMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9iYXNlLWNvbnRyb2wvc3R5bGVzL2Jhc2UtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGJhc2VMYWJlbFR5cG9ncmFwaHksIGJveFNpemluZ1Jlc2V0LCBmb250LCBDT0xPUlMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBzcGFjZSB9IGZyb20gJy4uLy4uL3VpL3V0aWxzL3NwYWNlJztcblxuZXhwb3J0IGNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHRmb250LWZhbWlseTogJHsgZm9udCggJ2RlZmF1bHQuZm9udEZhbWlseScgKSB9O1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdkZWZhdWx0LmZvbnRTaXplJyApIH07XG5cblx0JHsgYm94U2l6aW5nUmVzZXQgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkZpZWxkID0gKCB7IF9fbmV4dEhhc05vTWFyZ2luQm90dG9tID0gZmFsc2UgfSApID0+IHtcblx0cmV0dXJuIChcblx0XHQhIF9fbmV4dEhhc05vTWFyZ2luQm90dG9tICYmXG5cdFx0Y3NzYFxuXHRcdFx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdGBcblx0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRGaWVsZCA9IHN0eWxlZC5kaXZgXG5cdCR7IGRlcHJlY2F0ZWRNYXJnaW5GaWVsZCB9XG5cblx0LmNvbXBvbmVudHMtcGFuZWxfX3JvdyAmIHtcblx0XHRtYXJnaW4tYm90dG9tOiBpbmhlcml0O1xuXHR9XG5gO1xuXG5jb25zdCBsYWJlbFN0eWxlcyA9IGNzc2Bcblx0JHsgYmFzZUxhYmVsVHlwb2dyYXBoeSB9O1xuXG5cdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0bWFyZ2luLWJvdHRvbTogJHsgc3BhY2UoIDIgKSB9O1xuXHQvKipcblx0ICogUmVtb3ZlcyBDaHJvbWUvU2FmYXJpL0ZpcmVmb3ggdXNlciBhZ2VudCBzdHlsZXNoZWV0IHBhZGRpbmcgZnJvbVxuXHQgKiBTdHlsZWRMYWJlbCB3aGVuIGl0IGlzIHJlbmRlcmVkIGFzIGEgbGVnZW5kLlxuXHQgKi9cblx0cGFkZGluZzogMDtcbmA7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRMYWJlbCA9IHN0eWxlZC5sYWJlbGBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcblxuY29uc3QgZGVwcmVjYXRlZE1hcmdpbkhlbHAgPSAoIHsgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gPSBmYWxzZSB9ICkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdCEgX19uZXh0SGFzTm9NYXJnaW5Cb3R0b20gJiZcblx0XHRjc3NgXG5cdFx0XHRtYXJnaW4tYm90dG9tOiByZXZlcnQ7XG5cdFx0YFxuXHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEhlbHAgPSBzdHlsZWQucGBcblx0bWFyZ2luLXRvcDogJHsgc3BhY2UoIDIgKSB9O1xuXHRtYXJnaW4tYm90dG9tOiAwO1xuXHRmb250LXNpemU6ICR7IGZvbnQoICdoZWxwVGV4dC5mb250U2l6ZScgKSB9O1xuXHRmb250LXN0eWxlOiBub3JtYWw7XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblxuXHQkeyBkZXByZWNhdGVkTWFyZ2luSGVscCB9XG5gO1xuXG5leHBvcnQgY29uc3QgU3R5bGVkVmlzdWFsTGFiZWwgPSBzdHlsZWQuc3BhbmBcblx0JHsgbGFiZWxTdHlsZXMgfVxuYDtcbiJdfQ== */"));

  // node_modules/@wordpress/components/build-module/base-control/index.js
  var BaseControl = (_ref8) => {
    let {
      __nextHasNoMarginBottom = false,
      id: id2,
      label,
      hideLabelFromVision = false,
      help,
      className,
      children
    } = _ref8;
    return (0, import_react.createElement)(Wrapper, {
      className: (0, import_classnames6.default)("components-base-control", className)
    }, (0, import_react.createElement)(StyledField, {
      className: "components-base-control__field",
      __nextHasNoMarginBottom
    }, label && id2 && (hideLabelFromVision ? (0, import_react.createElement)(component_default2, {
      as: "label",
      htmlFor: id2
    }, label) : (0, import_react.createElement)(StyledLabel, {
      className: "components-base-control__label",
      htmlFor: id2
    }, label)), label && !id2 && (hideLabelFromVision ? (0, import_react.createElement)(component_default2, {
      as: "label"
    }, label) : (0, import_react.createElement)(BaseControl.VisualLabel, null, label)), children), !!help && (0, import_react.createElement)(StyledHelp, {
      id: id2 ? id2 + "__help" : void 0,
      className: "components-base-control__help",
      __nextHasNoMarginBottom
    }, help));
  };
  var VisualLabel = (_ref22) => {
    let {
      className,
      children,
      ...props
    } = _ref22;
    return (0, import_react.createElement)(StyledVisualLabel, _extends({}, props, {
      className: (0, import_classnames6.default)("components-base-control__label", className)
    }), children);
  };
  BaseControl.VisualLabel = VisualLabel;
  var base_control_default = BaseControl;

  // node_modules/@wordpress/components/build-module/unit-control/styles/unit-control-styles.js
  var import_base5 = __toESM(require_emotion_styled_base_cjs());
  var import_react80 = __toESM(require_emotion_react_cjs());
  var ValueInput = /* @__PURE__ */ (0, import_base5.default)(number_control_default, false ? {
    target: "e1bagdl32"
  } : {
    target: "e1bagdl32",
    label: "ValueInput"
  })("&&&{input{display:block;width:100%;}", BackdropUI, "{transition:box-shadow 0.1s linear;}}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVCaUQiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91bml0LWNvbnRyb2wvc3R5bGVzL3VuaXQtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IE51bWJlckNvbnRyb2wgZnJvbSAnLi4vLi4vbnVtYmVyLWNvbnRyb2wnO1xuaW1wb3J0IHsgQmFja2Ryb3BVSSB9IGZyb20gJy4uLy4uL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzJztcbmltcG9ydCB0eXBlIHsgU2VsZWN0U2l6ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG4vLyBVc2luZyBgc2VsZWN0U2l6ZWAgaW5zdGVhZCBvZiBgc2l6ZWAgdG8gYXZvaWQgYSB0eXBlIGNvbmZsaWN0IHdpdGggdGhlXG4vLyBgc2l6ZWAgSFRNTCBhdHRyaWJ1dGUgb2YgdGhlIGBzZWxlY3RgIGVsZW1lbnQuXG50eXBlIFNlbGVjdFByb3BzID0ge1xuXHRzZWxlY3RTaXplOiBTZWxlY3RTaXplO1xufTtcblxuLy8gVE9ETzogUmVzb2x2ZSBuZWVkIHRvIHVzZSAmJiYgdG8gaW5jcmVhc2Ugc3BlY2lmaWNpdHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Xb3JkUHJlc3MvZ3V0ZW5iZXJnL2lzc3Vlcy8xODQ4M1xuXG5leHBvcnQgY29uc3QgVmFsdWVJbnB1dCA9IHN0eWxlZCggTnVtYmVyQ29udHJvbCApYFxuXHQmJiYge1xuXHRcdGlucHV0IHtcblx0XHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0fVxuXG5cdFx0JHsgQmFja2Ryb3BVSSB9IHtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXI7XG5cdFx0fVxuXHR9XG5gO1xuXG5jb25zdCBiYXNlVW5pdExhYmVsU3R5bGVzID0gKCB7IHNlbGVjdFNpemUgfTogU2VsZWN0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRwYWRkaW5nOiAycHggMXB4O1xuXHRcdFx0d2lkdGg6IDIwcHg7XG5cdFx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDgwMCBdIH07XG5cdFx0XHRmb250LXNpemU6IDhweDtcblx0XHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdFx0bGV0dGVyLXNwYWNpbmc6IC0wLjVweDtcblx0XHRcdHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0bWluLXdpZHRoOiAyNHB4O1xuXHRcdFx0bWF4LXdpZHRoOiA0OHB4O1xuXHRcdFx0aGVpZ2h0OiAyNHB4O1xuXHRcdFx0bWFyZ2luLWlubGluZS1lbmQ6ICR7IHNwYWNlKCAyICkgfTtcblx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCAxICkgfTtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRcdGZvbnQtc2l6ZTogMTNweDtcblx0XHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdFx0dGV4dC1hbGlnbi1sYXN0OiBjZW50ZXI7XG5cdFx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdGAsXG5cdH07XG5cblx0cmV0dXJuIHNlbGVjdFNpemUgPT09ICdfX3Vuc3RhYmxlLWxhcmdlJyA/IHNpemVzLmxhcmdlIDogc2l6ZXMuZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBVbml0TGFiZWwgPSBzdHlsZWQuZGl2PCBTZWxlY3RQcm9wcyA+YFxuXHQmJiYge1xuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG5cdFx0JHsgYmFzZVVuaXRMYWJlbFN0eWxlcyB9O1xuXG5cdFx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHR9XG5gO1xuXG5jb25zdCB1bml0U2VsZWN0U2l6ZXMgPSAoIHsgc2VsZWN0U2l6ZSA9ICdkZWZhdWx0JyB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHR0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMXMgbGluZWFyLCBib3JkZXIgMC4xcyBsaW5lYXI7XG5cblx0XHRcdCR7IHJ0bCggeyBib3JkZXJUb3BMZWZ0UmFkaXVzOiAwLCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiAwIH0gKSgpIH1cblxuXHRcdFx0Jjpub3QoOmRpc2FibGVkKTpob3ZlciB7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6ICR7IENPTE9SUy5ncmF5WyAxMDAgXSB9O1xuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH07XG5cdFx0XHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwXG5cdFx0XHRcdFx0JHsgQ09ORklHLmJvcmRlcldpZHRoICsgJyAnICsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH07XG5cdFx0XHRcdG91dGxpbmUtb2Zmc2V0OiAwO1xuXHRcdFx0XHRvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHotaW5kZXg6IDE7XG5cdFx0XHR9XG5cdFx0YCxcblx0XHRsYXJnZTogY3NzYFxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdGNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZTogJHsgQ09ORklHLmJvcmRlcldpZHRoIH0gc29saWQgdHJhbnNwYXJlbnQ7IC8vIEZvciBIaWdoIENvbnRyYXN0IE1vZGVcblx0XHRcdH1cblxuXHRcdFx0Jjpmb2N1cyB7XG5cdFx0XHRcdGJveC1zaGFkb3c6IDAgMCAwXG5cdFx0XHRcdFx0JHsgQ09ORklHLmJvcmRlcldpZHRoRm9jdXMgKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZTogJHsgQ09ORklHLmJvcmRlcldpZHRoRm9jdXMgfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXHRcdGAsXG5cdH07XG5cblx0cmV0dXJuIHNlbGVjdFNpemUgPT09ICdfX3Vuc3RhYmxlLWxhcmdlJyA/IHNpemVzLmxhcmdlIDogc2l6ZXMuZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBVbml0U2VsZWN0ID0gc3R5bGVkLnNlbGVjdDwgU2VsZWN0UHJvcHMgPmBcblx0Ly8gVGhlICYmJiBjb3VudGVyYWN0cyA8c2VsZWN0PiBzdHlsZXMgaW4gV1AgZm9ybXMuY3NzXG5cdCYmJiB7XG5cdFx0YXBwZWFyYW5jZTogbm9uZTtcblx0XHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0LyogUmVtb3ZpbmcgbWFyZ2luIGVuc3VyZXMgZm9jdXMgc3R5bGVzIG5lYXRseSBvdmVybGF5IHRoZSB3cmFwcGVyLiAqL1xuXHRcdG1hcmdpbjogMDtcblx0XHRtaW4taGVpZ2h0OiBhdXRvO1xuXHRcdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXG5cdFx0Jjpub3QoIDpkaXNhYmxlZCApIHtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cdFx0JHsgdW5pdFNlbGVjdFNpemVzIH07XG5cdH1cbmA7XG4iXX0= */"));
  var baseUnitLabelStyles = (_ref8) => {
    let {
      selectSize
    } = _ref8;
    const sizes = {
      default: /* @__PURE__ */ (0, import_react80.css)("box-sizing:border-box;padding:2px 1px;width:20px;color:", COLORS.gray[800], ";font-size:8px;line-height:1;letter-spacing:-0.5px;text-transform:uppercase;text-align-last:center;" + (false ? "" : ";label:default;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXNDYyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3VuaXQtY29udHJvbC9zdHlsZXMvdW5pdC1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTE9SUywgQ09ORklHLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgTnVtYmVyQ29udHJvbCBmcm9tICcuLi8uLi9udW1iZXItY29udHJvbCc7XG5pbXBvcnQgeyBCYWNrZHJvcFVJIH0gZnJvbSAnLi4vLi4vaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMnO1xuaW1wb3J0IHR5cGUgeyBTZWxlY3RTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbi8vIFVzaW5nIGBzZWxlY3RTaXplYCBpbnN0ZWFkIG9mIGBzaXplYCB0byBhdm9pZCBhIHR5cGUgY29uZmxpY3Qgd2l0aCB0aGVcbi8vIGBzaXplYCBIVE1MIGF0dHJpYnV0ZSBvZiB0aGUgYHNlbGVjdGAgZWxlbWVudC5cbnR5cGUgU2VsZWN0UHJvcHMgPSB7XG5cdHNlbGVjdFNpemU6IFNlbGVjdFNpemU7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBWYWx1ZUlucHV0ID0gc3R5bGVkKCBOdW1iZXJDb250cm9sIClgXG5cdCYmJiB7XG5cdFx0aW5wdXQge1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHR9XG5cblx0XHQkeyBCYWNrZHJvcFVJIH0ge1xuXHRcdFx0dHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGxpbmVhcjtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VVbml0TGFiZWxTdHlsZXMgPSAoIHsgc2VsZWN0U2l6ZSB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdHBhZGRpbmc6IDJweCAxcHg7XG5cdFx0XHR3aWR0aDogMjBweDtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgODAwIF0gfTtcblx0XHRcdGZvbnQtc2l6ZTogOHB4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHRsZXR0ZXItc3BhY2luZzogLTAuNXB4O1xuXHRcdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcblx0XHRcdHRleHQtYWxpZ24tbGFzdDogY2VudGVyO1xuXHRcdGAsXG5cdFx0bGFyZ2U6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRtaW4td2lkdGg6IDI0cHg7XG5cdFx0XHRtYXgtd2lkdGg6IDQ4cHg7XG5cdFx0XHRoZWlnaHQ6IDI0cHg7XG5cdFx0XHRtYXJnaW4taW5saW5lLWVuZDogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdFx0cGFkZGluZzogJHsgc3BhY2UoIDEgKSB9O1xuXHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdFx0Zm9udC1zaXplOiAxM3B4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRMYWJlbCA9IHN0eWxlZC5kaXY8IFNlbGVjdFByb3BzID5gXG5cdCYmJiB7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdH1cbmA7XG5cbmNvbnN0IHVuaXRTZWxlY3RTaXplcyA9ICggeyBzZWxlY3RTaXplID0gJ2RlZmF1bHQnIH06IFNlbGVjdFByb3BzICkgPT4ge1xuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiBjc3NgXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXIsIGJvcmRlciAwLjFzIGxpbmVhcjtcblxuXHRcdFx0JHsgcnRsKCB7IGJvcmRlclRvcExlZnRSYWRpdXM6IDAsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IDAgfSApKCkgfVxuXG5cdFx0XHQmOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogJHsgQ09MT1JTLmdyYXlbIDEwMCBdIH07XG5cdFx0XHR9XG5cblx0XHRcdCY6Zm9jdXMge1xuXHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZS1vZmZzZXQ6IDA7XG5cdFx0XHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdFx0ei1pbmRleDogMTtcblx0XHRcdH1cblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMFxuXHRcdFx0XHRcdCR7IENPTkZJRy5ib3JkZXJXaWR0aCArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGggfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym94LXNoYWRvdzogMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9IHNvbGlkIHRyYW5zcGFyZW50OyAvLyBGb3IgSGlnaCBDb250cmFzdCBNb2RlXG5cdFx0XHR9XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRTZWxlY3QgPSBzdHlsZWQuc2VsZWN0PCBTZWxlY3RQcm9wcyA+YFxuXHQvLyBUaGUgJiYmIGNvdW50ZXJhY3RzIDxzZWxlY3Q+IHN0eWxlcyBpbiBXUCBmb3Jtcy5jc3Ncblx0JiYmIHtcblx0XHRhcHBlYXJhbmNlOiBub25lO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGJvcmRlci1yYWRpdXM6IDJweDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHQvKiBSZW1vdmluZyBtYXJnaW4gZW5zdXJlcyBmb2N1cyBzdHlsZXMgbmVhdGx5IG92ZXJsYXkgdGhlIHdyYXBwZXIuICovXG5cdFx0bWFyZ2luOiAwO1xuXHRcdG1pbi1oZWlnaHQ6IGF1dG87XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cblx0XHQmOm5vdCggOmRpc2FibGVkICkge1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblxuXHRcdCR7IGJhc2VVbml0TGFiZWxTdHlsZXMgfTtcblx0XHQkeyB1bml0U2VsZWN0U2l6ZXMgfTtcblx0fVxuYDtcbiJdfQ== */"),
      large: /* @__PURE__ */ (0, import_react80.css)("box-sizing:border-box;min-width:24px;max-width:48px;height:24px;margin-inline-end:", space(2), ";padding:", space(1), ";color:", COLORS.ui.theme, ";font-size:13px;line-height:1;text-align-last:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;" + (false ? "" : ";label:large;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlEWSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3VuaXQtY29udHJvbC9zdHlsZXMvdW5pdC1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTE9SUywgQ09ORklHLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgTnVtYmVyQ29udHJvbCBmcm9tICcuLi8uLi9udW1iZXItY29udHJvbCc7XG5pbXBvcnQgeyBCYWNrZHJvcFVJIH0gZnJvbSAnLi4vLi4vaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMnO1xuaW1wb3J0IHR5cGUgeyBTZWxlY3RTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbi8vIFVzaW5nIGBzZWxlY3RTaXplYCBpbnN0ZWFkIG9mIGBzaXplYCB0byBhdm9pZCBhIHR5cGUgY29uZmxpY3Qgd2l0aCB0aGVcbi8vIGBzaXplYCBIVE1MIGF0dHJpYnV0ZSBvZiB0aGUgYHNlbGVjdGAgZWxlbWVudC5cbnR5cGUgU2VsZWN0UHJvcHMgPSB7XG5cdHNlbGVjdFNpemU6IFNlbGVjdFNpemU7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBWYWx1ZUlucHV0ID0gc3R5bGVkKCBOdW1iZXJDb250cm9sIClgXG5cdCYmJiB7XG5cdFx0aW5wdXQge1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHR9XG5cblx0XHQkeyBCYWNrZHJvcFVJIH0ge1xuXHRcdFx0dHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGxpbmVhcjtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VVbml0TGFiZWxTdHlsZXMgPSAoIHsgc2VsZWN0U2l6ZSB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdHBhZGRpbmc6IDJweCAxcHg7XG5cdFx0XHR3aWR0aDogMjBweDtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgODAwIF0gfTtcblx0XHRcdGZvbnQtc2l6ZTogOHB4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHRsZXR0ZXItc3BhY2luZzogLTAuNXB4O1xuXHRcdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcblx0XHRcdHRleHQtYWxpZ24tbGFzdDogY2VudGVyO1xuXHRcdGAsXG5cdFx0bGFyZ2U6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRtaW4td2lkdGg6IDI0cHg7XG5cdFx0XHRtYXgtd2lkdGg6IDQ4cHg7XG5cdFx0XHRoZWlnaHQ6IDI0cHg7XG5cdFx0XHRtYXJnaW4taW5saW5lLWVuZDogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdFx0cGFkZGluZzogJHsgc3BhY2UoIDEgKSB9O1xuXHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdFx0Zm9udC1zaXplOiAxM3B4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRMYWJlbCA9IHN0eWxlZC5kaXY8IFNlbGVjdFByb3BzID5gXG5cdCYmJiB7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdH1cbmA7XG5cbmNvbnN0IHVuaXRTZWxlY3RTaXplcyA9ICggeyBzZWxlY3RTaXplID0gJ2RlZmF1bHQnIH06IFNlbGVjdFByb3BzICkgPT4ge1xuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiBjc3NgXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXIsIGJvcmRlciAwLjFzIGxpbmVhcjtcblxuXHRcdFx0JHsgcnRsKCB7IGJvcmRlclRvcExlZnRSYWRpdXM6IDAsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IDAgfSApKCkgfVxuXG5cdFx0XHQmOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogJHsgQ09MT1JTLmdyYXlbIDEwMCBdIH07XG5cdFx0XHR9XG5cblx0XHRcdCY6Zm9jdXMge1xuXHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZS1vZmZzZXQ6IDA7XG5cdFx0XHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdFx0ei1pbmRleDogMTtcblx0XHRcdH1cblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMFxuXHRcdFx0XHRcdCR7IENPTkZJRy5ib3JkZXJXaWR0aCArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGggfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym94LXNoYWRvdzogMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9IHNvbGlkIHRyYW5zcGFyZW50OyAvLyBGb3IgSGlnaCBDb250cmFzdCBNb2RlXG5cdFx0XHR9XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRTZWxlY3QgPSBzdHlsZWQuc2VsZWN0PCBTZWxlY3RQcm9wcyA+YFxuXHQvLyBUaGUgJiYmIGNvdW50ZXJhY3RzIDxzZWxlY3Q+IHN0eWxlcyBpbiBXUCBmb3Jtcy5jc3Ncblx0JiYmIHtcblx0XHRhcHBlYXJhbmNlOiBub25lO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGJvcmRlci1yYWRpdXM6IDJweDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHQvKiBSZW1vdmluZyBtYXJnaW4gZW5zdXJlcyBmb2N1cyBzdHlsZXMgbmVhdGx5IG92ZXJsYXkgdGhlIHdyYXBwZXIuICovXG5cdFx0bWFyZ2luOiAwO1xuXHRcdG1pbi1oZWlnaHQ6IGF1dG87XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cblx0XHQmOm5vdCggOmRpc2FibGVkICkge1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblxuXHRcdCR7IGJhc2VVbml0TGFiZWxTdHlsZXMgfTtcblx0XHQkeyB1bml0U2VsZWN0U2l6ZXMgfTtcblx0fVxuYDtcbiJdfQ== */")
    };
    return selectSize === "__unstable-large" ? sizes.large : sizes.default;
  };
  var UnitLabel = (0, import_base5.default)("div", false ? {
    target: "e1bagdl31"
  } : {
    target: "e1bagdl31",
    label: "UnitLabel"
  })("&&&{pointer-events:none;", baseUnitLabelStyles, ";color:", COLORS.gray[900], ";}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXFFa0QiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91bml0LWNvbnRyb2wvc3R5bGVzL3VuaXQtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IE51bWJlckNvbnRyb2wgZnJvbSAnLi4vLi4vbnVtYmVyLWNvbnRyb2wnO1xuaW1wb3J0IHsgQmFja2Ryb3BVSSB9IGZyb20gJy4uLy4uL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzJztcbmltcG9ydCB0eXBlIHsgU2VsZWN0U2l6ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG4vLyBVc2luZyBgc2VsZWN0U2l6ZWAgaW5zdGVhZCBvZiBgc2l6ZWAgdG8gYXZvaWQgYSB0eXBlIGNvbmZsaWN0IHdpdGggdGhlXG4vLyBgc2l6ZWAgSFRNTCBhdHRyaWJ1dGUgb2YgdGhlIGBzZWxlY3RgIGVsZW1lbnQuXG50eXBlIFNlbGVjdFByb3BzID0ge1xuXHRzZWxlY3RTaXplOiBTZWxlY3RTaXplO1xufTtcblxuLy8gVE9ETzogUmVzb2x2ZSBuZWVkIHRvIHVzZSAmJiYgdG8gaW5jcmVhc2Ugc3BlY2lmaWNpdHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Xb3JkUHJlc3MvZ3V0ZW5iZXJnL2lzc3Vlcy8xODQ4M1xuXG5leHBvcnQgY29uc3QgVmFsdWVJbnB1dCA9IHN0eWxlZCggTnVtYmVyQ29udHJvbCApYFxuXHQmJiYge1xuXHRcdGlucHV0IHtcblx0XHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0fVxuXG5cdFx0JHsgQmFja2Ryb3BVSSB9IHtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXI7XG5cdFx0fVxuXHR9XG5gO1xuXG5jb25zdCBiYXNlVW5pdExhYmVsU3R5bGVzID0gKCB7IHNlbGVjdFNpemUgfTogU2VsZWN0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRwYWRkaW5nOiAycHggMXB4O1xuXHRcdFx0d2lkdGg6IDIwcHg7XG5cdFx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDgwMCBdIH07XG5cdFx0XHRmb250LXNpemU6IDhweDtcblx0XHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdFx0bGV0dGVyLXNwYWNpbmc6IC0wLjVweDtcblx0XHRcdHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0bWluLXdpZHRoOiAyNHB4O1xuXHRcdFx0bWF4LXdpZHRoOiA0OHB4O1xuXHRcdFx0aGVpZ2h0OiAyNHB4O1xuXHRcdFx0bWFyZ2luLWlubGluZS1lbmQ6ICR7IHNwYWNlKCAyICkgfTtcblx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCAxICkgfTtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRcdGZvbnQtc2l6ZTogMTNweDtcblx0XHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdFx0dGV4dC1hbGlnbi1sYXN0OiBjZW50ZXI7XG5cdFx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdGAsXG5cdH07XG5cblx0cmV0dXJuIHNlbGVjdFNpemUgPT09ICdfX3Vuc3RhYmxlLWxhcmdlJyA/IHNpemVzLmxhcmdlIDogc2l6ZXMuZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBVbml0TGFiZWwgPSBzdHlsZWQuZGl2PCBTZWxlY3RQcm9wcyA+YFxuXHQmJiYge1xuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG5cdFx0JHsgYmFzZVVuaXRMYWJlbFN0eWxlcyB9O1xuXG5cdFx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHR9XG5gO1xuXG5jb25zdCB1bml0U2VsZWN0U2l6ZXMgPSAoIHsgc2VsZWN0U2l6ZSA9ICdkZWZhdWx0JyB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHR0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMXMgbGluZWFyLCBib3JkZXIgMC4xcyBsaW5lYXI7XG5cblx0XHRcdCR7IHJ0bCggeyBib3JkZXJUb3BMZWZ0UmFkaXVzOiAwLCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiAwIH0gKSgpIH1cblxuXHRcdFx0Jjpub3QoOmRpc2FibGVkKTpob3ZlciB7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6ICR7IENPTE9SUy5ncmF5WyAxMDAgXSB9O1xuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH07XG5cdFx0XHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwXG5cdFx0XHRcdFx0JHsgQ09ORklHLmJvcmRlcldpZHRoICsgJyAnICsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH07XG5cdFx0XHRcdG91dGxpbmUtb2Zmc2V0OiAwO1xuXHRcdFx0XHRvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHotaW5kZXg6IDE7XG5cdFx0XHR9XG5cdFx0YCxcblx0XHRsYXJnZTogY3NzYFxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdGNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZTogJHsgQ09ORklHLmJvcmRlcldpZHRoIH0gc29saWQgdHJhbnNwYXJlbnQ7IC8vIEZvciBIaWdoIENvbnRyYXN0IE1vZGVcblx0XHRcdH1cblxuXHRcdFx0Jjpmb2N1cyB7XG5cdFx0XHRcdGJveC1zaGFkb3c6IDAgMCAwXG5cdFx0XHRcdFx0JHsgQ09ORklHLmJvcmRlcldpZHRoRm9jdXMgKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZTogJHsgQ09ORklHLmJvcmRlcldpZHRoRm9jdXMgfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXHRcdGAsXG5cdH07XG5cblx0cmV0dXJuIHNlbGVjdFNpemUgPT09ICdfX3Vuc3RhYmxlLWxhcmdlJyA/IHNpemVzLmxhcmdlIDogc2l6ZXMuZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBVbml0U2VsZWN0ID0gc3R5bGVkLnNlbGVjdDwgU2VsZWN0UHJvcHMgPmBcblx0Ly8gVGhlICYmJiBjb3VudGVyYWN0cyA8c2VsZWN0PiBzdHlsZXMgaW4gV1AgZm9ybXMuY3NzXG5cdCYmJiB7XG5cdFx0YXBwZWFyYW5jZTogbm9uZTtcblx0XHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0LyogUmVtb3ZpbmcgbWFyZ2luIGVuc3VyZXMgZm9jdXMgc3R5bGVzIG5lYXRseSBvdmVybGF5IHRoZSB3cmFwcGVyLiAqL1xuXHRcdG1hcmdpbjogMDtcblx0XHRtaW4taGVpZ2h0OiBhdXRvO1xuXHRcdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXG5cdFx0Jjpub3QoIDpkaXNhYmxlZCApIHtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cdFx0JHsgdW5pdFNlbGVjdFNpemVzIH07XG5cdH1cbmA7XG4iXX0= */"));
  var unitSelectSizes = (_ref22) => {
    let {
      selectSize = "default"
    } = _ref22;
    const sizes = {
      default: /* @__PURE__ */ (0, import_react80.css)("height:100%;border:1px solid transparent;transition:box-shadow 0.1s linear,border 0.1s linear;", rtl({
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      })(), " &:not(:disabled):hover{background-color:", COLORS.gray[100], ";}&:focus{border:1px solid ", COLORS.ui.borderFocus, ";box-shadow:inset 0 0 0 ", config_values_default.borderWidth + " " + COLORS.ui.borderFocus, ";outline-offset:0;outline:2px solid transparent;z-index:1;}" + (false ? "" : ";label:default;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlGYyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3VuaXQtY29udHJvbC9zdHlsZXMvdW5pdC1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTE9SUywgQ09ORklHLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgTnVtYmVyQ29udHJvbCBmcm9tICcuLi8uLi9udW1iZXItY29udHJvbCc7XG5pbXBvcnQgeyBCYWNrZHJvcFVJIH0gZnJvbSAnLi4vLi4vaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMnO1xuaW1wb3J0IHR5cGUgeyBTZWxlY3RTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbi8vIFVzaW5nIGBzZWxlY3RTaXplYCBpbnN0ZWFkIG9mIGBzaXplYCB0byBhdm9pZCBhIHR5cGUgY29uZmxpY3Qgd2l0aCB0aGVcbi8vIGBzaXplYCBIVE1MIGF0dHJpYnV0ZSBvZiB0aGUgYHNlbGVjdGAgZWxlbWVudC5cbnR5cGUgU2VsZWN0UHJvcHMgPSB7XG5cdHNlbGVjdFNpemU6IFNlbGVjdFNpemU7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBWYWx1ZUlucHV0ID0gc3R5bGVkKCBOdW1iZXJDb250cm9sIClgXG5cdCYmJiB7XG5cdFx0aW5wdXQge1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHR9XG5cblx0XHQkeyBCYWNrZHJvcFVJIH0ge1xuXHRcdFx0dHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGxpbmVhcjtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VVbml0TGFiZWxTdHlsZXMgPSAoIHsgc2VsZWN0U2l6ZSB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdHBhZGRpbmc6IDJweCAxcHg7XG5cdFx0XHR3aWR0aDogMjBweDtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgODAwIF0gfTtcblx0XHRcdGZvbnQtc2l6ZTogOHB4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHRsZXR0ZXItc3BhY2luZzogLTAuNXB4O1xuXHRcdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcblx0XHRcdHRleHQtYWxpZ24tbGFzdDogY2VudGVyO1xuXHRcdGAsXG5cdFx0bGFyZ2U6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRtaW4td2lkdGg6IDI0cHg7XG5cdFx0XHRtYXgtd2lkdGg6IDQ4cHg7XG5cdFx0XHRoZWlnaHQ6IDI0cHg7XG5cdFx0XHRtYXJnaW4taW5saW5lLWVuZDogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdFx0cGFkZGluZzogJHsgc3BhY2UoIDEgKSB9O1xuXHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdFx0Zm9udC1zaXplOiAxM3B4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRMYWJlbCA9IHN0eWxlZC5kaXY8IFNlbGVjdFByb3BzID5gXG5cdCYmJiB7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdH1cbmA7XG5cbmNvbnN0IHVuaXRTZWxlY3RTaXplcyA9ICggeyBzZWxlY3RTaXplID0gJ2RlZmF1bHQnIH06IFNlbGVjdFByb3BzICkgPT4ge1xuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiBjc3NgXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXIsIGJvcmRlciAwLjFzIGxpbmVhcjtcblxuXHRcdFx0JHsgcnRsKCB7IGJvcmRlclRvcExlZnRSYWRpdXM6IDAsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IDAgfSApKCkgfVxuXG5cdFx0XHQmOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogJHsgQ09MT1JTLmdyYXlbIDEwMCBdIH07XG5cdFx0XHR9XG5cblx0XHRcdCY6Zm9jdXMge1xuXHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZS1vZmZzZXQ6IDA7XG5cdFx0XHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdFx0ei1pbmRleDogMTtcblx0XHRcdH1cblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMFxuXHRcdFx0XHRcdCR7IENPTkZJRy5ib3JkZXJXaWR0aCArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGggfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym94LXNoYWRvdzogMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9IHNvbGlkIHRyYW5zcGFyZW50OyAvLyBGb3IgSGlnaCBDb250cmFzdCBNb2RlXG5cdFx0XHR9XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRTZWxlY3QgPSBzdHlsZWQuc2VsZWN0PCBTZWxlY3RQcm9wcyA+YFxuXHQvLyBUaGUgJiYmIGNvdW50ZXJhY3RzIDxzZWxlY3Q+IHN0eWxlcyBpbiBXUCBmb3Jtcy5jc3Ncblx0JiYmIHtcblx0XHRhcHBlYXJhbmNlOiBub25lO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGJvcmRlci1yYWRpdXM6IDJweDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHQvKiBSZW1vdmluZyBtYXJnaW4gZW5zdXJlcyBmb2N1cyBzdHlsZXMgbmVhdGx5IG92ZXJsYXkgdGhlIHdyYXBwZXIuICovXG5cdFx0bWFyZ2luOiAwO1xuXHRcdG1pbi1oZWlnaHQ6IGF1dG87XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cblx0XHQmOm5vdCggOmRpc2FibGVkICkge1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblxuXHRcdCR7IGJhc2VVbml0TGFiZWxTdHlsZXMgfTtcblx0XHQkeyB1bml0U2VsZWN0U2l6ZXMgfTtcblx0fVxuYDtcbiJdfQ== */"),
      large: /* @__PURE__ */ (0, import_react80.css)("display:flex;justify-content:center;align-items:center;&:hover{color:", COLORS.ui.borderFocus, ";box-shadow:inset 0 0 0 ", config_values_default.borderWidth + " " + COLORS.ui.borderFocus, ";outline:", config_values_default.borderWidth, " solid transparent;}&:focus{box-shadow:0 0 0 ", config_values_default.borderWidthFocus + " " + COLORS.ui.borderFocus, ";outline:", config_values_default.borderWidthFocus, " solid transparent;}" + (false ? "" : ";label:large;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXFHWSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3VuaXQtY29udHJvbC9zdHlsZXMvdW5pdC1jb250cm9sLXN0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTE9SUywgQ09ORklHLCBydGwgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgTnVtYmVyQ29udHJvbCBmcm9tICcuLi8uLi9udW1iZXItY29udHJvbCc7XG5pbXBvcnQgeyBCYWNrZHJvcFVJIH0gZnJvbSAnLi4vLi4vaW5wdXQtY29udHJvbC9zdHlsZXMvaW5wdXQtY29udHJvbC1zdHlsZXMnO1xuaW1wb3J0IHR5cGUgeyBTZWxlY3RTaXplIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3BhY2UgfSBmcm9tICcuLi8uLi91aS91dGlscy9zcGFjZSc7XG5cbi8vIFVzaW5nIGBzZWxlY3RTaXplYCBpbnN0ZWFkIG9mIGBzaXplYCB0byBhdm9pZCBhIHR5cGUgY29uZmxpY3Qgd2l0aCB0aGVcbi8vIGBzaXplYCBIVE1MIGF0dHJpYnV0ZSBvZiB0aGUgYHNlbGVjdGAgZWxlbWVudC5cbnR5cGUgU2VsZWN0UHJvcHMgPSB7XG5cdHNlbGVjdFNpemU6IFNlbGVjdFNpemU7XG59O1xuXG4vLyBUT0RPOiBSZXNvbHZlIG5lZWQgdG8gdXNlICYmJiB0byBpbmNyZWFzZSBzcGVjaWZpY2l0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dvcmRQcmVzcy9ndXRlbmJlcmcvaXNzdWVzLzE4NDgzXG5cbmV4cG9ydCBjb25zdCBWYWx1ZUlucHV0ID0gc3R5bGVkKCBOdW1iZXJDb250cm9sIClgXG5cdCYmJiB7XG5cdFx0aW5wdXQge1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHR9XG5cblx0XHQkeyBCYWNrZHJvcFVJIH0ge1xuXHRcdFx0dHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjFzIGxpbmVhcjtcblx0XHR9XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VVbml0TGFiZWxTdHlsZXMgPSAoIHsgc2VsZWN0U2l6ZSB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdHBhZGRpbmc6IDJweCAxcHg7XG5cdFx0XHR3aWR0aDogMjBweDtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgODAwIF0gfTtcblx0XHRcdGZvbnQtc2l6ZTogOHB4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHRsZXR0ZXItc3BhY2luZzogLTAuNXB4O1xuXHRcdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcblx0XHRcdHRleHQtYWxpZ24tbGFzdDogY2VudGVyO1xuXHRcdGAsXG5cdFx0bGFyZ2U6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRtaW4td2lkdGg6IDI0cHg7XG5cdFx0XHRtYXgtd2lkdGg6IDQ4cHg7XG5cdFx0XHRoZWlnaHQ6IDI0cHg7XG5cdFx0XHRtYXJnaW4taW5saW5lLWVuZDogJHsgc3BhY2UoIDIgKSB9O1xuXHRcdFx0cGFkZGluZzogJHsgc3BhY2UoIDEgKSB9O1xuXHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdFx0Zm9udC1zaXplOiAxM3B4O1xuXHRcdFx0bGluZS1oZWlnaHQ6IDE7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRMYWJlbCA9IHN0eWxlZC5kaXY8IFNlbGVjdFByb3BzID5gXG5cdCYmJiB7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cblx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdH1cbmA7XG5cbmNvbnN0IHVuaXRTZWxlY3RTaXplcyA9ICggeyBzZWxlY3RTaXplID0gJ2RlZmF1bHQnIH06IFNlbGVjdFByb3BzICkgPT4ge1xuXHRjb25zdCBzaXplcyA9IHtcblx0XHRkZWZhdWx0OiBjc3NgXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXIsIGJvcmRlciAwLjFzIGxpbmVhcjtcblxuXHRcdFx0JHsgcnRsKCB7IGJvcmRlclRvcExlZnRSYWRpdXM6IDAsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IDAgfSApKCkgfVxuXG5cdFx0XHQmOm5vdCg6ZGlzYWJsZWQpOmhvdmVyIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogJHsgQ09MT1JTLmdyYXlbIDEwMCBdIH07XG5cdFx0XHR9XG5cblx0XHRcdCY6Zm9jdXMge1xuXHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZS1vZmZzZXQ6IDA7XG5cdFx0XHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdFx0ei1pbmRleDogMTtcblx0XHRcdH1cblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Y29sb3I6ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMFxuXHRcdFx0XHRcdCR7IENPTkZJRy5ib3JkZXJXaWR0aCArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGggfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym94LXNoYWRvdzogMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyArICcgJyArIENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdFx0XHRvdXRsaW5lOiAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9IHNvbGlkIHRyYW5zcGFyZW50OyAvLyBGb3IgSGlnaCBDb250cmFzdCBNb2RlXG5cdFx0XHR9XG5cdFx0YCxcblx0fTtcblxuXHRyZXR1cm4gc2VsZWN0U2l6ZSA9PT0gJ19fdW5zdGFibGUtbGFyZ2UnID8gc2l6ZXMubGFyZ2UgOiBzaXplcy5kZWZhdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IFVuaXRTZWxlY3QgPSBzdHlsZWQuc2VsZWN0PCBTZWxlY3RQcm9wcyA+YFxuXHQvLyBUaGUgJiYmIGNvdW50ZXJhY3RzIDxzZWxlY3Q+IHN0eWxlcyBpbiBXUCBmb3Jtcy5jc3Ncblx0JiYmIHtcblx0XHRhcHBlYXJhbmNlOiBub25lO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGJvcmRlci1yYWRpdXM6IDJweDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHQvKiBSZW1vdmluZyBtYXJnaW4gZW5zdXJlcyBmb2N1cyBzdHlsZXMgbmVhdGx5IG92ZXJsYXkgdGhlIHdyYXBwZXIuICovXG5cdFx0bWFyZ2luOiAwO1xuXHRcdG1pbi1oZWlnaHQ6IGF1dG87XG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cblx0XHQmOm5vdCggOmRpc2FibGVkICkge1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblxuXHRcdCR7IGJhc2VVbml0TGFiZWxTdHlsZXMgfTtcblx0XHQkeyB1bml0U2VsZWN0U2l6ZXMgfTtcblx0fVxuYDtcbiJdfQ== */")
    };
    return selectSize === "__unstable-large" ? sizes.large : sizes.default;
  };
  var UnitSelect = (0, import_base5.default)("select", false ? {
    target: "e1bagdl30"
  } : {
    target: "e1bagdl30",
    label: "UnitSelect"
  })("&&&{appearance:none;background:transparent;border-radius:2px;border:none;display:block;outline:none;margin:0;min-height:auto;font-family:inherit;", baseUnitLabelStyles, ";", unitSelectSizes, ";&:not( :disabled ){cursor:pointer;}}" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdW5pdC1jb250cm9sL3N0eWxlcy91bml0LWNvbnRyb2wtc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRIc0QiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy91bml0LWNvbnRyb2wvc3R5bGVzL3VuaXQtY29udHJvbC1zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT0xPUlMsIENPTkZJRywgcnRsIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IE51bWJlckNvbnRyb2wgZnJvbSAnLi4vLi4vbnVtYmVyLWNvbnRyb2wnO1xuaW1wb3J0IHsgQmFja2Ryb3BVSSB9IGZyb20gJy4uLy4uL2lucHV0LWNvbnRyb2wvc3R5bGVzL2lucHV0LWNvbnRyb2wtc3R5bGVzJztcbmltcG9ydCB0eXBlIHsgU2VsZWN0U2l6ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG4vLyBVc2luZyBgc2VsZWN0U2l6ZWAgaW5zdGVhZCBvZiBgc2l6ZWAgdG8gYXZvaWQgYSB0eXBlIGNvbmZsaWN0IHdpdGggdGhlXG4vLyBgc2l6ZWAgSFRNTCBhdHRyaWJ1dGUgb2YgdGhlIGBzZWxlY3RgIGVsZW1lbnQuXG50eXBlIFNlbGVjdFByb3BzID0ge1xuXHRzZWxlY3RTaXplOiBTZWxlY3RTaXplO1xufTtcblxuLy8gVE9ETzogUmVzb2x2ZSBuZWVkIHRvIHVzZSAmJiYgdG8gaW5jcmVhc2Ugc3BlY2lmaWNpdHlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Xb3JkUHJlc3MvZ3V0ZW5iZXJnL2lzc3Vlcy8xODQ4M1xuXG5leHBvcnQgY29uc3QgVmFsdWVJbnB1dCA9IHN0eWxlZCggTnVtYmVyQ29udHJvbCApYFxuXHQmJiYge1xuXHRcdGlucHV0IHtcblx0XHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0fVxuXG5cdFx0JHsgQmFja2Ryb3BVSSB9IHtcblx0XHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4xcyBsaW5lYXI7XG5cdFx0fVxuXHR9XG5gO1xuXG5jb25zdCBiYXNlVW5pdExhYmVsU3R5bGVzID0gKCB7IHNlbGVjdFNpemUgfTogU2VsZWN0UHJvcHMgKSA9PiB7XG5cdGNvbnN0IHNpemVzID0ge1xuXHRcdGRlZmF1bHQ6IGNzc2Bcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRwYWRkaW5nOiAycHggMXB4O1xuXHRcdFx0d2lkdGg6IDIwcHg7XG5cdFx0XHRjb2xvcjogJHsgQ09MT1JTLmdyYXlbIDgwMCBdIH07XG5cdFx0XHRmb250LXNpemU6IDhweDtcblx0XHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdFx0bGV0dGVyLXNwYWNpbmc6IC0wLjVweDtcblx0XHRcdHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdFx0XHR0ZXh0LWFsaWduLWxhc3Q6IGNlbnRlcjtcblx0XHRgLFxuXHRcdGxhcmdlOiBjc3NgXG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0bWluLXdpZHRoOiAyNHB4O1xuXHRcdFx0bWF4LXdpZHRoOiA0OHB4O1xuXHRcdFx0aGVpZ2h0OiAyNHB4O1xuXHRcdFx0bWFyZ2luLWlubGluZS1lbmQ6ICR7IHNwYWNlKCAyICkgfTtcblx0XHRcdHBhZGRpbmc6ICR7IHNwYWNlKCAxICkgfTtcblx0XHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRcdGZvbnQtc2l6ZTogMTNweDtcblx0XHRcdGxpbmUtaGVpZ2h0OiAxO1xuXHRcdFx0dGV4dC1hbGlnbi1sYXN0OiBjZW50ZXI7XG5cdFx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdGAsXG5cdH07XG5cblx0cmV0dXJuIHNlbGVjdFNpemUgPT09ICdfX3Vuc3RhYmxlLWxhcmdlJyA/IHNpemVzLmxhcmdlIDogc2l6ZXMuZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBVbml0TGFiZWwgPSBzdHlsZWQuZGl2PCBTZWxlY3RQcm9wcyA+YFxuXHQmJiYge1xuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG5cdFx0JHsgYmFzZVVuaXRMYWJlbFN0eWxlcyB9O1xuXG5cdFx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHR9XG5gO1xuXG5jb25zdCB1bml0U2VsZWN0U2l6ZXMgPSAoIHsgc2VsZWN0U2l6ZSA9ICdkZWZhdWx0JyB9OiBTZWxlY3RQcm9wcyApID0+IHtcblx0Y29uc3Qgc2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogY3NzYFxuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHR0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMXMgbGluZWFyLCBib3JkZXIgMC4xcyBsaW5lYXI7XG5cblx0XHRcdCR7IHJ0bCggeyBib3JkZXJUb3BMZWZ0UmFkaXVzOiAwLCBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiAwIH0gKSgpIH1cblxuXHRcdFx0Jjpub3QoOmRpc2FibGVkKTpob3ZlciB7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6ICR7IENPTE9SUy5ncmF5WyAxMDAgXSB9O1xuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH07XG5cdFx0XHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwXG5cdFx0XHRcdFx0JHsgQ09ORklHLmJvcmRlcldpZHRoICsgJyAnICsgQ09MT1JTLnVpLmJvcmRlckZvY3VzIH07XG5cdFx0XHRcdG91dGxpbmUtb2Zmc2V0OiAwO1xuXHRcdFx0XHRvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHotaW5kZXg6IDE7XG5cdFx0XHR9XG5cdFx0YCxcblx0XHRsYXJnZTogY3NzYFxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdGNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0Ym94LXNoYWRvdzogaW5zZXQgMCAwIDBcblx0XHRcdFx0XHQkeyBDT05GSUcuYm9yZGVyV2lkdGggKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZTogJHsgQ09ORklHLmJvcmRlcldpZHRoIH0gc29saWQgdHJhbnNwYXJlbnQ7IC8vIEZvciBIaWdoIENvbnRyYXN0IE1vZGVcblx0XHRcdH1cblxuXHRcdFx0Jjpmb2N1cyB7XG5cdFx0XHRcdGJveC1zaGFkb3c6IDAgMCAwXG5cdFx0XHRcdFx0JHsgQ09ORklHLmJvcmRlcldpZHRoRm9jdXMgKyAnICcgKyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRcdFx0b3V0bGluZTogJHsgQ09ORklHLmJvcmRlcldpZHRoRm9jdXMgfSBzb2xpZCB0cmFuc3BhcmVudDsgLy8gRm9yIEhpZ2ggQ29udHJhc3QgTW9kZVxuXHRcdFx0fVxuXHRcdGAsXG5cdH07XG5cblx0cmV0dXJuIHNlbGVjdFNpemUgPT09ICdfX3Vuc3RhYmxlLWxhcmdlJyA/IHNpemVzLmxhcmdlIDogc2l6ZXMuZGVmYXVsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBVbml0U2VsZWN0ID0gc3R5bGVkLnNlbGVjdDwgU2VsZWN0UHJvcHMgPmBcblx0Ly8gVGhlICYmJiBjb3VudGVyYWN0cyA8c2VsZWN0PiBzdHlsZXMgaW4gV1AgZm9ybXMuY3NzXG5cdCYmJiB7XG5cdFx0YXBwZWFyYW5jZTogbm9uZTtcblx0XHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0LyogUmVtb3ZpbmcgbWFyZ2luIGVuc3VyZXMgZm9jdXMgc3R5bGVzIG5lYXRseSBvdmVybGF5IHRoZSB3cmFwcGVyLiAqL1xuXHRcdG1hcmdpbjogMDtcblx0XHRtaW4taGVpZ2h0OiBhdXRvO1xuXHRcdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXG5cdFx0Jjpub3QoIDpkaXNhYmxlZCApIHtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQkeyBiYXNlVW5pdExhYmVsU3R5bGVzIH07XG5cdFx0JHsgdW5pdFNlbGVjdFNpemVzIH07XG5cdH1cbmA7XG4iXX0= */"));

  // node_modules/@wordpress/components/build-module/dropdown/index.js
  var import_classnames7 = __toESM(require_classnames());
  function useObservableState(initialState, onStateChange) {
    const [state, setState] = (0, import_react.useState)(initialState);
    return [state, (value) => {
      setState(value);
      if (onStateChange) {
        onStateChange(value);
      }
    }];
  }
  function Dropdown(props) {
    const {
      renderContent,
      renderToggle,
      className,
      contentClassName,
      expandOnMobile,
      headerTitle,
      focusOnMount,
      position,
      popoverProps,
      onClose,
      onToggle,
      style
    } = props;
    const [fallbackPopoverAnchor, setFallbackPopoverAnchor] = (0, import_react.useState)(null);
    const containerRef = (0, import_react.useRef)();
    const [isOpen, setIsOpen] = useObservableState(false, onToggle);
    (0, import_react.useEffect)(() => () => {
      if (onToggle && isOpen) {
        onToggle(false);
      }
    }, [onToggle, isOpen]);
    function toggle() {
      setIsOpen(!isOpen);
    }
    function closeIfFocusOutside() {
      const {
        ownerDocument
      } = containerRef.current;
      const dialog = ownerDocument.activeElement.closest('[role="dialog"]');
      if (!containerRef.current.contains(ownerDocument.activeElement) && (!dialog || dialog.contains(containerRef.current))) {
        close2();
      }
    }
    function close2() {
      if (onClose) {
        onClose();
      }
      setIsOpen(false);
    }
    const args = {
      isOpen,
      onToggle: toggle,
      onClose: close2
    };
    const popoverPropsHaveAnchor = !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.anchor) || !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.anchorRef) || !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.getAnchorRect) || !!(popoverProps !== null && popoverProps !== void 0 && popoverProps.anchorRect);
    return (0, import_react.createElement)("div", {
      className: (0, import_classnames7.default)("components-dropdown", className),
      ref: useMergeRefs([setFallbackPopoverAnchor, containerRef]),
      tabIndex: "-1",
      style
    }, renderToggle(args), isOpen && (0, import_react.createElement)(popover_default, _extends({
      position,
      onClose: close2,
      onFocusOutside: closeIfFocusOutside,
      expandOnMobile,
      headerTitle,
      focusOnMount,
      offset: 13,
      anchor: !popoverPropsHaveAnchor ? fallbackPopoverAnchor : void 0
    }, popoverProps, {
      className: (0, import_classnames7.default)("components-dropdown__content", popoverProps ? popoverProps.className : void 0, contentClassName)
    }), renderContent(args)));
  }

  // node_modules/@wordpress/components/build-module/heading/hook.js
  function useHeading(props) {
    const {
      as: asProp,
      level = 2,
      ...otherProps
    } = useContextSystem(props, "Heading");
    const as = asProp || `h${level}`;
    const a11yProps = {};
    if (typeof as === "string" && as[0] !== "h") {
      a11yProps.role = "heading";
      a11yProps["aria-level"] = typeof level === "string" ? parseInt(level) : level;
    }
    const textProps = useText({
      color: COLORS.gray[900],
      size: getHeadingFontSize(level),
      isBlock: true,
      weight: config_values_default.fontWeightHeading,
      ...otherProps
    });
    return {
      ...textProps,
      ...a11yProps,
      as
    };
  }

  // node_modules/@wordpress/components/build-module/heading/component.js
  function UnconnectedHeading(props, forwardedRef) {
    const headerProps = useHeading(props);
    return (0, import_react.createElement)(component_default, _extends({}, headerProps, {
      ref: forwardedRef
    }));
  }
  var Heading = contextConnect(UnconnectedHeading, "Heading");
  var component_default10 = Heading;

  // node_modules/@wordpress/components/build-module/unit-control/utils.js
  var isWeb = platform_default.OS === "web";
  var allUnits = {
    px: {
      value: "px",
      label: isWeb ? "px" : __("Pixels (px)"),
      a11yLabel: __("Pixels (px)"),
      step: 1
    },
    "%": {
      value: "%",
      label: isWeb ? "%" : __("Percentage (%)"),
      a11yLabel: __("Percent (%)"),
      step: 0.1
    },
    em: {
      value: "em",
      label: isWeb ? "em" : __("Relative to parent font size (em)"),
      a11yLabel: _x("ems", "Relative to parent font size (em)"),
      step: 0.01
    },
    rem: {
      value: "rem",
      label: isWeb ? "rem" : __("Relative to root font size (rem)"),
      a11yLabel: _x("rems", "Relative to root font size (rem)"),
      step: 0.01
    },
    vw: {
      value: "vw",
      label: isWeb ? "vw" : __("Viewport width (vw)"),
      a11yLabel: __("Viewport width (vw)"),
      step: 0.1
    },
    vh: {
      value: "vh",
      label: isWeb ? "vh" : __("Viewport height (vh)"),
      a11yLabel: __("Viewport height (vh)"),
      step: 0.1
    },
    vmin: {
      value: "vmin",
      label: isWeb ? "vmin" : __("Viewport smallest dimension (vmin)"),
      a11yLabel: __("Viewport smallest dimension (vmin)"),
      step: 0.1
    },
    vmax: {
      value: "vmax",
      label: isWeb ? "vmax" : __("Viewport largest dimension (vmax)"),
      a11yLabel: __("Viewport largest dimension (vmax)"),
      step: 0.1
    },
    ch: {
      value: "ch",
      label: isWeb ? "ch" : __("Width of the zero (0) character (ch)"),
      a11yLabel: __("Width of the zero (0) character (ch)"),
      step: 0.01
    },
    ex: {
      value: "ex",
      label: isWeb ? "ex" : __("x-height of the font (ex)"),
      a11yLabel: __("x-height of the font (ex)"),
      step: 0.01
    },
    cm: {
      value: "cm",
      label: isWeb ? "cm" : __("Centimeters (cm)"),
      a11yLabel: __("Centimeters (cm)"),
      step: 1e-3
    },
    mm: {
      value: "mm",
      label: isWeb ? "mm" : __("Millimeters (mm)"),
      a11yLabel: __("Millimeters (mm)"),
      step: 0.1
    },
    in: {
      value: "in",
      label: isWeb ? "in" : __("Inches (in)"),
      a11yLabel: __("Inches (in)"),
      step: 1e-3
    },
    pc: {
      value: "pc",
      label: isWeb ? "pc" : __("Picas (pc)"),
      a11yLabel: __("Picas (pc)"),
      step: 1
    },
    pt: {
      value: "pt",
      label: isWeb ? "pt" : __("Points (pt)"),
      a11yLabel: __("Points (pt)"),
      step: 1
    }
  };
  var ALL_CSS_UNITS = Object.values(allUnits);
  var CSS_UNITS = [allUnits.px, allUnits["%"], allUnits.em, allUnits.rem, allUnits.vw, allUnits.vh];
  var DEFAULT_UNIT = allUnits.px;
  function getParsedQuantityAndUnit(rawValue, fallbackUnit, allowedUnits) {
    const initialValue = fallbackUnit ? `${rawValue !== null && rawValue !== void 0 ? rawValue : ""}${fallbackUnit}` : rawValue;
    return parseQuantityAndUnitFromRawValue(initialValue, allowedUnits);
  }
  function hasUnits(units) {
    return Array.isArray(units) && !!units.length;
  }
  function parseQuantityAndUnitFromRawValue(rawValue) {
    var _trimmedValue, _unitMatch$;
    let allowedUnits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ALL_CSS_UNITS;
    let trimmedValue;
    let quantityToReturn;
    if (typeof rawValue !== "undefined" || rawValue === null) {
      trimmedValue = `${rawValue}`.trim();
      const parsedQuantity = parseFloat(trimmedValue);
      quantityToReturn = !isFinite(parsedQuantity) ? void 0 : parsedQuantity;
    }
    const unitMatch = (_trimmedValue = trimmedValue) === null || _trimmedValue === void 0 ? void 0 : _trimmedValue.match(/[\d.\-\+]*\s*(.*)/);
    const matchedUnit = unitMatch === null || unitMatch === void 0 ? void 0 : (_unitMatch$ = unitMatch[1]) === null || _unitMatch$ === void 0 ? void 0 : _unitMatch$.toLowerCase();
    let unitToReturn;
    if (hasUnits(allowedUnits)) {
      const match = allowedUnits.find((item2) => item2.value === matchedUnit);
      unitToReturn = match === null || match === void 0 ? void 0 : match.value;
    } else {
      unitToReturn = DEFAULT_UNIT.value;
    }
    return [quantityToReturn, unitToReturn];
  }
  function getValidParsedQuantityAndUnit(rawValue, allowedUnits, fallbackQuantity, fallbackUnit) {
    const [parsedQuantity, parsedUnit] = parseQuantityAndUnitFromRawValue(rawValue, allowedUnits);
    const quantityToReturn = parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : fallbackQuantity;
    let unitToReturn = parsedUnit || fallbackUnit;
    if (!unitToReturn && hasUnits(allowedUnits)) {
      unitToReturn = allowedUnits[0].value;
    }
    return [quantityToReturn, unitToReturn];
  }
  function filterUnitsWithSettings() {
    let allowedUnitValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let availableUnits = arguments.length > 1 ? arguments[1] : void 0;
    return Array.isArray(availableUnits) ? availableUnits.filter((unit) => allowedUnitValues.includes(unit.value)) : [];
  }
  var useCustomUnits = (_ref8) => {
    let {
      units = ALL_CSS_UNITS,
      availableUnits = [],
      defaultValues
    } = _ref8;
    const customUnitsToReturn = filterUnitsWithSettings(availableUnits, units);
    if (defaultValues) {
      customUnitsToReturn.forEach((unit, i5) => {
        if (defaultValues[unit.value]) {
          const [parsedDefaultValue] = parseQuantityAndUnitFromRawValue(defaultValues[unit.value]);
          customUnitsToReturn[i5].default = parsedDefaultValue;
        }
      });
    }
    return customUnitsToReturn;
  };
  function getUnitsWithCurrentUnit(rawValue, legacyUnit) {
    let units = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ALL_CSS_UNITS;
    const unitsToReturn = Array.isArray(units) ? [...units] : [];
    const [, currentUnit] = getParsedQuantityAndUnit(rawValue, legacyUnit, ALL_CSS_UNITS);
    if (currentUnit && !unitsToReturn.some((unit) => unit.value === currentUnit)) {
      if (allUnits[currentUnit]) {
        unitsToReturn.unshift(allUnits[currentUnit]);
      }
    }
    return unitsToReturn;
  }

  // node_modules/@wordpress/components/build-module/unit-control/index.js
  var import_classnames9 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/unit-control/unit-select-control.js
  var import_classnames8 = __toESM(require_classnames());
  function UnitSelectControl(_ref8) {
    let {
      className,
      isUnitSelectTabbable: isTabbable = true,
      onChange,
      size = "default",
      unit = "px",
      units = CSS_UNITS,
      ...props
    } = _ref8;
    if (!hasUnits(units) || (units === null || units === void 0 ? void 0 : units.length) === 1) {
      return (0, import_react.createElement)(UnitLabel, {
        className: "components-unit-control__unit-label",
        selectSize: size
      }, unit);
    }
    const handleOnChange = (event) => {
      const {
        value: unitValue
      } = event.target;
      const data = units.find((option) => option.value === unitValue);
      onChange === null || onChange === void 0 ? void 0 : onChange(unitValue, {
        event,
        data
      });
    };
    const classes = (0, import_classnames8.default)("components-unit-control__select", className);
    return (0, import_react.createElement)(UnitSelect, _extends({
      className: classes,
      onChange: handleOnChange,
      selectSize: size,
      tabIndex: isTabbable ? void 0 : -1,
      value: unit
    }, props), units.map((option) => (0, import_react.createElement)("option", {
      value: option.value,
      key: option.value
    }, option.label)));
  }

  // node_modules/@wordpress/components/build-module/unit-control/index.js
  function UnforwardedUnitControl(unitControlProps, forwardedRef) {
    const {
      __unstableStateReducer: stateReducerProp,
      autoComplete = "off",
      children,
      className,
      disabled = false,
      disableUnits = false,
      isPressEnterToChange = false,
      isResetValueOnUnitChange = false,
      isUnitSelectTabbable = true,
      label,
      onChange: onChangeProp,
      onUnitChange,
      size = "default",
      unit: unitProp,
      units: unitsProp = CSS_UNITS,
      value: valueProp,
      onBlur: onBlurProp,
      ...props
    } = unitControlProps;
    if ("unit" in unitControlProps) {
      deprecated("UnitControl unit prop", {
        since: "5.6",
        hint: "The unit should be provided within the `value` prop.",
        version: "6.2"
      });
    }
    const nonNullValueProp = valueProp !== null && valueProp !== void 0 ? valueProp : void 0;
    const units = (0, import_react.useMemo)(() => getUnitsWithCurrentUnit(nonNullValueProp, unitProp, unitsProp), [nonNullValueProp, unitProp, unitsProp]);
    const [parsedQuantity, parsedUnit] = getParsedQuantityAndUnit(nonNullValueProp, unitProp, units);
    const [unit, setUnit] = use_controlled_state_default(units.length === 1 ? units[0].value : unitProp, {
      initial: parsedUnit,
      fallback: ""
    });
    (0, import_react.useEffect)(() => {
      if (parsedUnit !== void 0) {
        setUnit(parsedUnit);
      }
    }, [parsedUnit, setUnit]);
    const refParsedQuantity = (0, import_react.useRef)(void 0);
    const classes = (0, import_classnames9.default)(
      "components-unit-control",
      "components-unit-control-wrapper",
      className
    );
    const handleOnQuantityChange = (nextQuantityValue, changeProps) => {
      if (nextQuantityValue === "" || typeof nextQuantityValue === "undefined" || nextQuantityValue === null) {
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp("", changeProps);
        return;
      }
      const onChangeValue = getValidParsedQuantityAndUnit(nextQuantityValue, units, parsedQuantity, unit).join("");
      onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(onChangeValue, changeProps);
    };
    const handleOnUnitChange = (nextUnitValue, changeProps) => {
      const {
        data
      } = changeProps;
      let nextValue = `${parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : ""}${nextUnitValue}`;
      if (isResetValueOnUnitChange && (data === null || data === void 0 ? void 0 : data.default) !== void 0) {
        nextValue = `${data.default}${nextUnitValue}`;
      }
      onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(nextValue, changeProps);
      onUnitChange === null || onUnitChange === void 0 ? void 0 : onUnitChange(nextUnitValue, changeProps);
      setUnit(nextUnitValue);
    };
    const mayUpdateUnit = (event) => {
      if (!isNaN(Number(event.currentTarget.value))) {
        refParsedQuantity.current = void 0;
        return;
      }
      const [validParsedQuantity, validParsedUnit] = getValidParsedQuantityAndUnit(event.currentTarget.value, units, parsedQuantity, unit);
      refParsedQuantity.current = validParsedQuantity;
      if (isPressEnterToChange && validParsedUnit !== unit) {
        const data = Array.isArray(units) ? units.find((option) => option.value === validParsedUnit) : void 0;
        const changeProps = {
          event,
          data
        };
        onUnitChange === null || onUnitChange === void 0 ? void 0 : onUnitChange(validParsedUnit, changeProps);
        setUnit(validParsedUnit);
      }
    };
    const handleOnBlur = (event) => {
      mayUpdateUnit(event);
      onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(event);
    };
    const handleOnKeyDown = (event) => {
      const {
        key
      } = event;
      if (key === "Enter") {
        mayUpdateUnit(event);
      }
    };
    const unitControlStateReducer = (state, action) => {
      const nextState = {
        ...state
      };
      if (action.type === COMMIT) {
        if (refParsedQuantity.current !== void 0) {
          var _refParsedQuantity$cu;
          nextState.value = ((_refParsedQuantity$cu = refParsedQuantity.current) !== null && _refParsedQuantity$cu !== void 0 ? _refParsedQuantity$cu : "").toString();
          refParsedQuantity.current = void 0;
        }
      }
      return nextState;
    };
    let stateReducer = unitControlStateReducer;
    if (stateReducerProp) {
      stateReducer = (state, action) => {
        const baseState = unitControlStateReducer(state, action);
        return stateReducerProp(baseState, action);
      };
    }
    const inputSuffix = !disableUnits ? (0, import_react.createElement)(UnitSelectControl, {
      "aria-label": __("Select unit"),
      disabled,
      isUnitSelectTabbable,
      onChange: handleOnUnitChange,
      size,
      unit,
      units,
      onBlur: onBlurProp
    }) : null;
    let step = props.step;
    if (!step && units) {
      var _activeUnit$step;
      const activeUnit = units.find((option) => option.value === unit);
      step = (_activeUnit$step = activeUnit === null || activeUnit === void 0 ? void 0 : activeUnit.step) !== null && _activeUnit$step !== void 0 ? _activeUnit$step : 1;
    }
    return (0, import_react.createElement)(ValueInput, _extends({
      type: isPressEnterToChange ? "text" : "number"
    }, props, {
      autoComplete,
      className: classes,
      disabled,
      spinControls: "none",
      isPressEnterToChange,
      label,
      onBlur: handleOnBlur,
      onKeyDown: handleOnKeyDown,
      onChange: handleOnQuantityChange,
      ref: forwardedRef,
      size,
      suffix: inputSuffix,
      value: parsedQuantity !== null && parsedQuantity !== void 0 ? parsedQuantity : "",
      step,
      __unstableStateReducer: stateReducer
    }));
  }
  var UnitControl = (0, import_react.forwardRef)(UnforwardedUnitControl);
  var unit_control_default = UnitControl;

  // node_modules/@wordpress/components/build-module/checkbox-control/index.js
  var import_classnames10 = __toESM(require_classnames());
  function CheckboxControl(props) {
    const {
      __nextHasNoMarginBottom,
      label,
      className,
      heading,
      checked,
      indeterminate,
      help,
      onChange,
      ...additionalProps
    } = props;
    if (heading) {
      deprecated("`heading` prop in `CheckboxControl`", {
        alternative: "a separate element to implement a heading",
        since: "5.8"
      });
    }
    const [showCheckedIcon, setShowCheckedIcon] = (0, import_react.useState)(false);
    const [showIndeterminateIcon, setShowIndeterminateIcon] = (0, import_react.useState)(false);
    const ref2 = useRefEffect((node) => {
      if (!node) {
        return;
      }
      node.indeterminate = !!indeterminate;
      setShowCheckedIcon(node.matches(":checked"));
      setShowIndeterminateIcon(node.matches(":indeterminate"));
    }, [checked, indeterminate]);
    const instanceId = use_instance_id_default(CheckboxControl);
    const id2 = `inspector-checkbox-control-${instanceId}`;
    const onChangeValue = (event) => onChange(event.target.checked);
    return (0, import_react.createElement)(base_control_default, {
      __nextHasNoMarginBottom,
      label: heading,
      id: id2,
      help,
      className: (0, import_classnames10.default)("components-checkbox-control", className)
    }, (0, import_react.createElement)("span", {
      className: "components-checkbox-control__input-container"
    }, (0, import_react.createElement)("input", _extends({
      ref: ref2,
      id: id2,
      className: "components-checkbox-control__input",
      type: "checkbox",
      value: "1",
      onChange: onChangeValue,
      checked,
      "aria-describedby": !!help ? id2 + "__help" : void 0
    }, additionalProps)), showIndeterminateIcon ? (0, import_react.createElement)(icon_default, {
      icon: reset_default,
      className: "components-checkbox-control__indeterminate",
      role: "presentation"
    }) : null, showCheckedIcon ? (0, import_react.createElement)(icon_default, {
      icon: check_default,
      className: "components-checkbox-control__checked",
      role: "presentation"
    }) : null), (0, import_react.createElement)("label", {
      className: "components-checkbox-control__label",
      htmlFor: id2
    }, label));
  }
  var checkbox_control_default = CheckboxControl;

  // node_modules/@wordpress/components/build-module/item-group/styles.js
  var import_react81 = __toESM(require_emotion_react_cjs());
  function _EMOTION_STRINGIFIED_CSS_ERROR__10() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var unstyledButton = /* @__PURE__ */ (0, import_react81.css)("appearance:none;border:1px solid transparent;cursor:pointer;background:none;text-align:start;&:hover{color:", COLORS.ui.theme, ";}&:focus{background-color:transparent;color:", COLORS.ui.theme, ";border-color:", COLORS.ui.theme, ";outline:3px solid transparent;}" + (false ? "" : ";label:unstyledButton;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVWlDIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdW5zdHlsZWRCdXR0b24gPSBjc3NgXG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGJhY2tncm91bmQ6IG5vbmU7XG5cdHRleHQtYWxpZ246IHN0YXJ0O1xuXG5cdCY6aG92ZXIge1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0fVxuXG5cdCY6Zm9jdXMge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRib3JkZXItY29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDNweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW1XcmFwcGVyID0gY3NzYFxuXHR3aWR0aDogMTAwJTtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgaXRlbSA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXJnaW46IDA7XG5cdGNvbG9yOiBpbmhlcml0O1xuYDtcblxuZXhwb3J0IGNvbnN0IGJvcmRlcmVkID0gY3NzYFxuXHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT05GSUcuc3VyZmFjZUJvcmRlckNvbG9yIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgc2VwYXJhdGVkID0gY3NzYFxuXHQ+ICo6bm90KCBtYXJxdWVlICkgPiAqIHtcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuXHR9XG5cblx0PiAqOmxhc3Qtb2YtdHlwZSA+ICo6bm90KCA6Zm9jdXMgKSB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGJvcmRlclJhZGl1cyA9IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VkQXJvdW5kID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcbmA7XG5cbmV4cG9ydCBjb25zdCByb3VuZGVkID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblxuXHQ+ICo6Zmlyc3Qtb2YtdHlwZSA+ICoge1xuXHRcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHRcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VGb250SGVpZ2h0ID0gYGNhbGMoJHsgQ09ORklHLmZvbnRTaXplIH0gKiAkeyBDT05GSUcuZm9udExpbmVIZWlnaHRCYXNlIH0pYDtcblxuLypcbiAqIE1hdGg6XG4gKiAtIFVzZSB0aGUgZGVzaXJlZCBoZWlnaHQgYXMgdGhlIGJhc2UgdmFsdWVcbiAqIC0gU3VidHJhY3QgdGhlIGNvbXB1dGVkIGhlaWdodCBvZiAoZGVmYXVsdCkgdGV4dFxuICogLSBTdWJ0cmFjdCB0aGUgZWZmZWN0cyBvZiBib3JkZXJcbiAqIC0gRGl2aWRlIHRoZSBjYWxjdWxhdGVkIG51bWJlciBieSAyLCBpbiBvcmRlciB0byBnZXQgYW4gaW5kaXZpZHVhbCB0b3AvYm90dG9tIHBhZGRpbmdcbiAqL1xuY29uc3QgcGFkZGluZ1kgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHQgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuY29uc3QgcGFkZGluZ1lTbWFsbCA9IGBjYWxjKCgkeyBDT05GSUcuY29udHJvbEhlaWdodFNtYWxsIH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZTGFyZ2UgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRMYXJnZSB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5cbmV4cG9ydCBjb25zdCBpdGVtU2l6ZXMgPSB7XG5cdHNtYWxsOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lTbWFsbCB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hTbWFsbCB9O1xuXHRgLFxuXHRtZWRpdW06IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1ggfTtcblx0YCxcblx0bGFyZ2U6IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWUxhcmdlIH0gJHsgQ09ORklHLmNvbnRyb2xQYWRkaW5nWExhcmdlIH07XG5cdGAsXG59O1xuIl19 */");
  var itemWrapper = false ? {
    name: "1bcj5ek",
    styles: "width:100%;display:block"
  } : {
    name: "dcjs67-itemWrapper",
    styles: "width:100%;display:block;label:itemWrapper;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNkI4QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2l0ZW0tZ3JvdXAvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHVuc3R5bGVkQnV0dG9uID0gY3NzYFxuXHRhcHBlYXJhbmNlOiBub25lO1xuXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHRiYWNrZ3JvdW5kOiBub25lO1xuXHR0ZXh0LWFsaWduOiBzdGFydDtcblxuXHQmOmhvdmVyIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdH1cblxuXHQmOmZvY3VzIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRvdXRsaW5lOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBpdGVtV3JhcHBlciA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW0gPSBjc3NgXG5cdHdpZHRoOiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0bWFyZ2luOiAwO1xuXHRjb2xvcjogaW5oZXJpdDtcbmA7XG5cbmV4cG9ydCBjb25zdCBib3JkZXJlZCA9IGNzc2Bcblx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IHNlcGFyYXRlZCA9IGNzc2Bcblx0PiAqOm5vdCggbWFycXVlZSApID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7IENPTkZJRy5zdXJmYWNlQm9yZGVyQ29sb3IgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqOm5vdCggOmZvY3VzICkge1xuXHRcdGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBib3JkZXJSYWRpdXMgPSBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cztcblxuZXhwb3J0IGNvbnN0IHNwYWNlZEFyb3VuZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cblx0PiAqOmZpcnN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cblxuXHQ+ICo6bGFzdC1vZi10eXBlID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHR9XG5gO1xuXG5jb25zdCBiYXNlRm9udEhlaWdodCA9IGBjYWxjKCR7IENPTkZJRy5mb250U2l6ZSB9ICogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9KWA7XG5cbi8qXG4gKiBNYXRoOlxuICogLSBVc2UgdGhlIGRlc2lyZWQgaGVpZ2h0IGFzIHRoZSBiYXNlIHZhbHVlXG4gKiAtIFN1YnRyYWN0IHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgKGRlZmF1bHQpIHRleHRcbiAqIC0gU3VidHJhY3QgdGhlIGVmZmVjdHMgb2YgYm9yZGVyXG4gKiAtIERpdmlkZSB0aGUgY2FsY3VsYXRlZCBudW1iZXIgYnkgMiwgaW4gb3JkZXIgdG8gZ2V0IGFuIGluZGl2aWR1YWwgdG9wL2JvdHRvbSBwYWRkaW5nXG4gKi9cbmNvbnN0IHBhZGRpbmdZID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0IH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZU21hbGwgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRTbWFsbCB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5jb25zdCBwYWRkaW5nWUxhcmdlID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0TGFyZ2UgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuXG5leHBvcnQgY29uc3QgaXRlbVNpemVzID0ge1xuXHRzbWFsbDogY3NzYFxuXHRcdHBhZGRpbmc6ICR7IHBhZGRpbmdZU21hbGwgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYU21hbGwgfTtcblx0YCxcblx0bWVkaXVtOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1kgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYIH07XG5cdGAsXG5cdGxhcmdlOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lMYXJnZSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hMYXJnZSB9O1xuXHRgLFxufTtcbiJdfQ== */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__10
  };
  var item = false ? {
    name: "a5hqs6",
    styles: "width:100%;display:block;margin:0;color:inherit"
  } : {
    name: "1edl69e-item",
    styles: "width:100%;display:block;margin:0;color:inherit;label:item;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0N1QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2l0ZW0tZ3JvdXAvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHVuc3R5bGVkQnV0dG9uID0gY3NzYFxuXHRhcHBlYXJhbmNlOiBub25lO1xuXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHRiYWNrZ3JvdW5kOiBub25lO1xuXHR0ZXh0LWFsaWduOiBzdGFydDtcblxuXHQmOmhvdmVyIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdH1cblxuXHQmOmZvY3VzIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRvdXRsaW5lOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBpdGVtV3JhcHBlciA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW0gPSBjc3NgXG5cdHdpZHRoOiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0bWFyZ2luOiAwO1xuXHRjb2xvcjogaW5oZXJpdDtcbmA7XG5cbmV4cG9ydCBjb25zdCBib3JkZXJlZCA9IGNzc2Bcblx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IHNlcGFyYXRlZCA9IGNzc2Bcblx0PiAqOm5vdCggbWFycXVlZSApID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7IENPTkZJRy5zdXJmYWNlQm9yZGVyQ29sb3IgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqOm5vdCggOmZvY3VzICkge1xuXHRcdGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBib3JkZXJSYWRpdXMgPSBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cztcblxuZXhwb3J0IGNvbnN0IHNwYWNlZEFyb3VuZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cblx0PiAqOmZpcnN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cblxuXHQ+ICo6bGFzdC1vZi10eXBlID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHR9XG5gO1xuXG5jb25zdCBiYXNlRm9udEhlaWdodCA9IGBjYWxjKCR7IENPTkZJRy5mb250U2l6ZSB9ICogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9KWA7XG5cbi8qXG4gKiBNYXRoOlxuICogLSBVc2UgdGhlIGRlc2lyZWQgaGVpZ2h0IGFzIHRoZSBiYXNlIHZhbHVlXG4gKiAtIFN1YnRyYWN0IHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgKGRlZmF1bHQpIHRleHRcbiAqIC0gU3VidHJhY3QgdGhlIGVmZmVjdHMgb2YgYm9yZGVyXG4gKiAtIERpdmlkZSB0aGUgY2FsY3VsYXRlZCBudW1iZXIgYnkgMiwgaW4gb3JkZXIgdG8gZ2V0IGFuIGluZGl2aWR1YWwgdG9wL2JvdHRvbSBwYWRkaW5nXG4gKi9cbmNvbnN0IHBhZGRpbmdZID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0IH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZU21hbGwgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRTbWFsbCB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5jb25zdCBwYWRkaW5nWUxhcmdlID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0TGFyZ2UgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuXG5leHBvcnQgY29uc3QgaXRlbVNpemVzID0ge1xuXHRzbWFsbDogY3NzYFxuXHRcdHBhZGRpbmc6ICR7IHBhZGRpbmdZU21hbGwgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYU21hbGwgfTtcblx0YCxcblx0bWVkaXVtOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1kgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYIH07XG5cdGAsXG5cdGxhcmdlOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lMYXJnZSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hMYXJnZSB9O1xuXHRgLFxufTtcbiJdfQ== */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__10
  };
  var bordered = /* @__PURE__ */ (0, import_react81.css)("border:1px solid ", config_values_default.surfaceBorderColor, ";" + (false ? "" : ";label:bordered;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeUMyQiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2l0ZW0tZ3JvdXAvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHVuc3R5bGVkQnV0dG9uID0gY3NzYFxuXHRhcHBlYXJhbmNlOiBub25lO1xuXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHRiYWNrZ3JvdW5kOiBub25lO1xuXHR0ZXh0LWFsaWduOiBzdGFydDtcblxuXHQmOmhvdmVyIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdH1cblxuXHQmOmZvY3VzIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRvdXRsaW5lOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBpdGVtV3JhcHBlciA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW0gPSBjc3NgXG5cdHdpZHRoOiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0bWFyZ2luOiAwO1xuXHRjb2xvcjogaW5oZXJpdDtcbmA7XG5cbmV4cG9ydCBjb25zdCBib3JkZXJlZCA9IGNzc2Bcblx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IHNlcGFyYXRlZCA9IGNzc2Bcblx0PiAqOm5vdCggbWFycXVlZSApID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7IENPTkZJRy5zdXJmYWNlQm9yZGVyQ29sb3IgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqOm5vdCggOmZvY3VzICkge1xuXHRcdGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBib3JkZXJSYWRpdXMgPSBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cztcblxuZXhwb3J0IGNvbnN0IHNwYWNlZEFyb3VuZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cblx0PiAqOmZpcnN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cblxuXHQ+ICo6bGFzdC1vZi10eXBlID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHR9XG5gO1xuXG5jb25zdCBiYXNlRm9udEhlaWdodCA9IGBjYWxjKCR7IENPTkZJRy5mb250U2l6ZSB9ICogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9KWA7XG5cbi8qXG4gKiBNYXRoOlxuICogLSBVc2UgdGhlIGRlc2lyZWQgaGVpZ2h0IGFzIHRoZSBiYXNlIHZhbHVlXG4gKiAtIFN1YnRyYWN0IHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgKGRlZmF1bHQpIHRleHRcbiAqIC0gU3VidHJhY3QgdGhlIGVmZmVjdHMgb2YgYm9yZGVyXG4gKiAtIERpdmlkZSB0aGUgY2FsY3VsYXRlZCBudW1iZXIgYnkgMiwgaW4gb3JkZXIgdG8gZ2V0IGFuIGluZGl2aWR1YWwgdG9wL2JvdHRvbSBwYWRkaW5nXG4gKi9cbmNvbnN0IHBhZGRpbmdZID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0IH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZU21hbGwgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRTbWFsbCB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5jb25zdCBwYWRkaW5nWUxhcmdlID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0TGFyZ2UgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuXG5leHBvcnQgY29uc3QgaXRlbVNpemVzID0ge1xuXHRzbWFsbDogY3NzYFxuXHRcdHBhZGRpbmc6ICR7IHBhZGRpbmdZU21hbGwgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYU21hbGwgfTtcblx0YCxcblx0bWVkaXVtOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1kgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYIH07XG5cdGAsXG5cdGxhcmdlOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lMYXJnZSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hMYXJnZSB9O1xuXHRgLFxufTtcbiJdfQ== */");
  var separated = /* @__PURE__ */ (0, import_react81.css)(">*:not( marquee )>*{border-bottom:1px solid ", config_values_default.surfaceBorderColor, ";}>*:last-of-type>*:not( :focus ){border-bottom-color:transparent;}" + (false ? "" : ";label:separated;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNkM0QiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2l0ZW0tZ3JvdXAvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHVuc3R5bGVkQnV0dG9uID0gY3NzYFxuXHRhcHBlYXJhbmNlOiBub25lO1xuXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHRiYWNrZ3JvdW5kOiBub25lO1xuXHR0ZXh0LWFsaWduOiBzdGFydDtcblxuXHQmOmhvdmVyIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdH1cblxuXHQmOmZvY3VzIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRvdXRsaW5lOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBpdGVtV3JhcHBlciA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW0gPSBjc3NgXG5cdHdpZHRoOiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0bWFyZ2luOiAwO1xuXHRjb2xvcjogaW5oZXJpdDtcbmA7XG5cbmV4cG9ydCBjb25zdCBib3JkZXJlZCA9IGNzc2Bcblx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IHNlcGFyYXRlZCA9IGNzc2Bcblx0PiAqOm5vdCggbWFycXVlZSApID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7IENPTkZJRy5zdXJmYWNlQm9yZGVyQ29sb3IgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqOm5vdCggOmZvY3VzICkge1xuXHRcdGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBib3JkZXJSYWRpdXMgPSBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cztcblxuZXhwb3J0IGNvbnN0IHNwYWNlZEFyb3VuZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cblx0PiAqOmZpcnN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cblxuXHQ+ICo6bGFzdC1vZi10eXBlID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHR9XG5gO1xuXG5jb25zdCBiYXNlRm9udEhlaWdodCA9IGBjYWxjKCR7IENPTkZJRy5mb250U2l6ZSB9ICogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9KWA7XG5cbi8qXG4gKiBNYXRoOlxuICogLSBVc2UgdGhlIGRlc2lyZWQgaGVpZ2h0IGFzIHRoZSBiYXNlIHZhbHVlXG4gKiAtIFN1YnRyYWN0IHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgKGRlZmF1bHQpIHRleHRcbiAqIC0gU3VidHJhY3QgdGhlIGVmZmVjdHMgb2YgYm9yZGVyXG4gKiAtIERpdmlkZSB0aGUgY2FsY3VsYXRlZCBudW1iZXIgYnkgMiwgaW4gb3JkZXIgdG8gZ2V0IGFuIGluZGl2aWR1YWwgdG9wL2JvdHRvbSBwYWRkaW5nXG4gKi9cbmNvbnN0IHBhZGRpbmdZID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0IH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZU21hbGwgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRTbWFsbCB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5jb25zdCBwYWRkaW5nWUxhcmdlID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0TGFyZ2UgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuXG5leHBvcnQgY29uc3QgaXRlbVNpemVzID0ge1xuXHRzbWFsbDogY3NzYFxuXHRcdHBhZGRpbmc6ICR7IHBhZGRpbmdZU21hbGwgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYU21hbGwgfTtcblx0YCxcblx0bWVkaXVtOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1kgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYIH07XG5cdGAsXG5cdGxhcmdlOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lMYXJnZSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hMYXJnZSB9O1xuXHRgLFxufTtcbiJdfQ== */");
  var borderRadius = config_values_default.controlBorderRadius;
  var spacedAround = /* @__PURE__ */ (0, import_react81.css)("border-radius:", borderRadius, ";" + (false ? "" : ";label:spacedAround;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeUQrQiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2l0ZW0tZ3JvdXAvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHVuc3R5bGVkQnV0dG9uID0gY3NzYFxuXHRhcHBlYXJhbmNlOiBub25lO1xuXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHRiYWNrZ3JvdW5kOiBub25lO1xuXHR0ZXh0LWFsaWduOiBzdGFydDtcblxuXHQmOmhvdmVyIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdH1cblxuXHQmOmZvY3VzIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRvdXRsaW5lOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBpdGVtV3JhcHBlciA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW0gPSBjc3NgXG5cdHdpZHRoOiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0bWFyZ2luOiAwO1xuXHRjb2xvcjogaW5oZXJpdDtcbmA7XG5cbmV4cG9ydCBjb25zdCBib3JkZXJlZCA9IGNzc2Bcblx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IHNlcGFyYXRlZCA9IGNzc2Bcblx0PiAqOm5vdCggbWFycXVlZSApID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7IENPTkZJRy5zdXJmYWNlQm9yZGVyQ29sb3IgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqOm5vdCggOmZvY3VzICkge1xuXHRcdGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBib3JkZXJSYWRpdXMgPSBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cztcblxuZXhwb3J0IGNvbnN0IHNwYWNlZEFyb3VuZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cblx0PiAqOmZpcnN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cblxuXHQ+ICo6bGFzdC1vZi10eXBlID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHR9XG5gO1xuXG5jb25zdCBiYXNlRm9udEhlaWdodCA9IGBjYWxjKCR7IENPTkZJRy5mb250U2l6ZSB9ICogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9KWA7XG5cbi8qXG4gKiBNYXRoOlxuICogLSBVc2UgdGhlIGRlc2lyZWQgaGVpZ2h0IGFzIHRoZSBiYXNlIHZhbHVlXG4gKiAtIFN1YnRyYWN0IHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgKGRlZmF1bHQpIHRleHRcbiAqIC0gU3VidHJhY3QgdGhlIGVmZmVjdHMgb2YgYm9yZGVyXG4gKiAtIERpdmlkZSB0aGUgY2FsY3VsYXRlZCBudW1iZXIgYnkgMiwgaW4gb3JkZXIgdG8gZ2V0IGFuIGluZGl2aWR1YWwgdG9wL2JvdHRvbSBwYWRkaW5nXG4gKi9cbmNvbnN0IHBhZGRpbmdZID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0IH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZU21hbGwgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRTbWFsbCB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5jb25zdCBwYWRkaW5nWUxhcmdlID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0TGFyZ2UgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuXG5leHBvcnQgY29uc3QgaXRlbVNpemVzID0ge1xuXHRzbWFsbDogY3NzYFxuXHRcdHBhZGRpbmc6ICR7IHBhZGRpbmdZU21hbGwgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYU21hbGwgfTtcblx0YCxcblx0bWVkaXVtOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1kgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYIH07XG5cdGAsXG5cdGxhcmdlOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lMYXJnZSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hMYXJnZSB9O1xuXHRgLFxufTtcbiJdfQ== */");
  var rounded = /* @__PURE__ */ (0, import_react81.css)("border-radius:", borderRadius, ";>*:first-of-type>*{border-top-left-radius:", borderRadius, ";border-top-right-radius:", borderRadius, ";}>*:last-of-type>*{border-bottom-left-radius:", borderRadius, ";border-bottom-right-radius:", borderRadius, ";}" + (false ? "" : ";label:rounded;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNkQwQiIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL2l0ZW0tZ3JvdXAvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBDT05GSUcsIENPTE9SUyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IHVuc3R5bGVkQnV0dG9uID0gY3NzYFxuXHRhcHBlYXJhbmNlOiBub25lO1xuXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0Y3Vyc29yOiBwb2ludGVyO1xuXHRiYWNrZ3JvdW5kOiBub25lO1xuXHR0ZXh0LWFsaWduOiBzdGFydDtcblxuXHQmOmhvdmVyIHtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdH1cblxuXHQmOmZvY3VzIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRvdXRsaW5lOiAzcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCBpdGVtV3JhcHBlciA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW0gPSBjc3NgXG5cdHdpZHRoOiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0bWFyZ2luOiAwO1xuXHRjb2xvcjogaW5oZXJpdDtcbmA7XG5cbmV4cG9ydCBjb25zdCBib3JkZXJlZCA9IGNzc2Bcblx0Ym9yZGVyOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuYDtcblxuZXhwb3J0IGNvbnN0IHNlcGFyYXRlZCA9IGNzc2Bcblx0PiAqOm5vdCggbWFycXVlZSApID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7IENPTkZJRy5zdXJmYWNlQm9yZGVyQ29sb3IgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqOm5vdCggOmZvY3VzICkge1xuXHRcdGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBib3JkZXJSYWRpdXMgPSBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cztcblxuZXhwb3J0IGNvbnN0IHNwYWNlZEFyb3VuZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGNzc2Bcblx0Ym9yZGVyLXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cblx0PiAqOmZpcnN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cblxuXHQ+ICo6bGFzdC1vZi10eXBlID4gKiB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHR9XG5gO1xuXG5jb25zdCBiYXNlRm9udEhlaWdodCA9IGBjYWxjKCR7IENPTkZJRy5mb250U2l6ZSB9ICogJHsgQ09ORklHLmZvbnRMaW5lSGVpZ2h0QmFzZSB9KWA7XG5cbi8qXG4gKiBNYXRoOlxuICogLSBVc2UgdGhlIGRlc2lyZWQgaGVpZ2h0IGFzIHRoZSBiYXNlIHZhbHVlXG4gKiAtIFN1YnRyYWN0IHRoZSBjb21wdXRlZCBoZWlnaHQgb2YgKGRlZmF1bHQpIHRleHRcbiAqIC0gU3VidHJhY3QgdGhlIGVmZmVjdHMgb2YgYm9yZGVyXG4gKiAtIERpdmlkZSB0aGUgY2FsY3VsYXRlZCBudW1iZXIgYnkgMiwgaW4gb3JkZXIgdG8gZ2V0IGFuIGluZGl2aWR1YWwgdG9wL2JvdHRvbSBwYWRkaW5nXG4gKi9cbmNvbnN0IHBhZGRpbmdZID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0IH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZU21hbGwgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRTbWFsbCB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5jb25zdCBwYWRkaW5nWUxhcmdlID0gYGNhbGMoKCR7IENPTkZJRy5jb250cm9sSGVpZ2h0TGFyZ2UgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuXG5leHBvcnQgY29uc3QgaXRlbVNpemVzID0ge1xuXHRzbWFsbDogY3NzYFxuXHRcdHBhZGRpbmc6ICR7IHBhZGRpbmdZU21hbGwgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYU21hbGwgfTtcblx0YCxcblx0bWVkaXVtOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1kgfSAkeyBDT05GSUcuY29udHJvbFBhZGRpbmdYIH07XG5cdGAsXG5cdGxhcmdlOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lMYXJnZSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hMYXJnZSB9O1xuXHRgLFxufTtcbiJdfQ== */");
  var baseFontHeight = `calc(${config_values_default.fontSize} * ${config_values_default.fontLineHeightBase})`;
  var paddingY = `calc((${config_values_default.controlHeight} - ${baseFontHeight} - 2px) / 2)`;
  var paddingYSmall = `calc((${config_values_default.controlHeightSmall} - ${baseFontHeight} - 2px) / 2)`;
  var paddingYLarge = `calc((${config_values_default.controlHeightLarge} - ${baseFontHeight} - 2px) / 2)`;
  var itemSizes = {
    small: /* @__PURE__ */ (0, import_react81.css)("padding:", paddingYSmall, " ", config_values_default.controlPaddingXSmall, ";" + (false ? "" : ";label:small;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeUZXIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdW5zdHlsZWRCdXR0b24gPSBjc3NgXG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGJhY2tncm91bmQ6IG5vbmU7XG5cdHRleHQtYWxpZ246IHN0YXJ0O1xuXG5cdCY6aG92ZXIge1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0fVxuXG5cdCY6Zm9jdXMge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRib3JkZXItY29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDNweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW1XcmFwcGVyID0gY3NzYFxuXHR3aWR0aDogMTAwJTtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgaXRlbSA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXJnaW46IDA7XG5cdGNvbG9yOiBpbmhlcml0O1xuYDtcblxuZXhwb3J0IGNvbnN0IGJvcmRlcmVkID0gY3NzYFxuXHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT05GSUcuc3VyZmFjZUJvcmRlckNvbG9yIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgc2VwYXJhdGVkID0gY3NzYFxuXHQ+ICo6bm90KCBtYXJxdWVlICkgPiAqIHtcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuXHR9XG5cblx0PiAqOmxhc3Qtb2YtdHlwZSA+ICo6bm90KCA6Zm9jdXMgKSB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGJvcmRlclJhZGl1cyA9IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VkQXJvdW5kID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcbmA7XG5cbmV4cG9ydCBjb25zdCByb3VuZGVkID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblxuXHQ+ICo6Zmlyc3Qtb2YtdHlwZSA+ICoge1xuXHRcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHRcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VGb250SGVpZ2h0ID0gYGNhbGMoJHsgQ09ORklHLmZvbnRTaXplIH0gKiAkeyBDT05GSUcuZm9udExpbmVIZWlnaHRCYXNlIH0pYDtcblxuLypcbiAqIE1hdGg6XG4gKiAtIFVzZSB0aGUgZGVzaXJlZCBoZWlnaHQgYXMgdGhlIGJhc2UgdmFsdWVcbiAqIC0gU3VidHJhY3QgdGhlIGNvbXB1dGVkIGhlaWdodCBvZiAoZGVmYXVsdCkgdGV4dFxuICogLSBTdWJ0cmFjdCB0aGUgZWZmZWN0cyBvZiBib3JkZXJcbiAqIC0gRGl2aWRlIHRoZSBjYWxjdWxhdGVkIG51bWJlciBieSAyLCBpbiBvcmRlciB0byBnZXQgYW4gaW5kaXZpZHVhbCB0b3AvYm90dG9tIHBhZGRpbmdcbiAqL1xuY29uc3QgcGFkZGluZ1kgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHQgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuY29uc3QgcGFkZGluZ1lTbWFsbCA9IGBjYWxjKCgkeyBDT05GSUcuY29udHJvbEhlaWdodFNtYWxsIH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZTGFyZ2UgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRMYXJnZSB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5cbmV4cG9ydCBjb25zdCBpdGVtU2l6ZXMgPSB7XG5cdHNtYWxsOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lTbWFsbCB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hTbWFsbCB9O1xuXHRgLFxuXHRtZWRpdW06IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1ggfTtcblx0YCxcblx0bGFyZ2U6IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWUxhcmdlIH0gJHsgQ09ORklHLmNvbnRyb2xQYWRkaW5nWExhcmdlIH07XG5cdGAsXG59O1xuIl19 */"),
    medium: /* @__PURE__ */ (0, import_react81.css)("padding:", paddingY, " ", config_values_default.controlPaddingX, ";" + (false ? "" : ";label:medium;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNEZZIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdW5zdHlsZWRCdXR0b24gPSBjc3NgXG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGJhY2tncm91bmQ6IG5vbmU7XG5cdHRleHQtYWxpZ246IHN0YXJ0O1xuXG5cdCY6aG92ZXIge1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0fVxuXG5cdCY6Zm9jdXMge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRib3JkZXItY29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDNweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW1XcmFwcGVyID0gY3NzYFxuXHR3aWR0aDogMTAwJTtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgaXRlbSA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXJnaW46IDA7XG5cdGNvbG9yOiBpbmhlcml0O1xuYDtcblxuZXhwb3J0IGNvbnN0IGJvcmRlcmVkID0gY3NzYFxuXHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT05GSUcuc3VyZmFjZUJvcmRlckNvbG9yIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgc2VwYXJhdGVkID0gY3NzYFxuXHQ+ICo6bm90KCBtYXJxdWVlICkgPiAqIHtcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuXHR9XG5cblx0PiAqOmxhc3Qtb2YtdHlwZSA+ICo6bm90KCA6Zm9jdXMgKSB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGJvcmRlclJhZGl1cyA9IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VkQXJvdW5kID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcbmA7XG5cbmV4cG9ydCBjb25zdCByb3VuZGVkID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblxuXHQ+ICo6Zmlyc3Qtb2YtdHlwZSA+ICoge1xuXHRcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHRcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VGb250SGVpZ2h0ID0gYGNhbGMoJHsgQ09ORklHLmZvbnRTaXplIH0gKiAkeyBDT05GSUcuZm9udExpbmVIZWlnaHRCYXNlIH0pYDtcblxuLypcbiAqIE1hdGg6XG4gKiAtIFVzZSB0aGUgZGVzaXJlZCBoZWlnaHQgYXMgdGhlIGJhc2UgdmFsdWVcbiAqIC0gU3VidHJhY3QgdGhlIGNvbXB1dGVkIGhlaWdodCBvZiAoZGVmYXVsdCkgdGV4dFxuICogLSBTdWJ0cmFjdCB0aGUgZWZmZWN0cyBvZiBib3JkZXJcbiAqIC0gRGl2aWRlIHRoZSBjYWxjdWxhdGVkIG51bWJlciBieSAyLCBpbiBvcmRlciB0byBnZXQgYW4gaW5kaXZpZHVhbCB0b3AvYm90dG9tIHBhZGRpbmdcbiAqL1xuY29uc3QgcGFkZGluZ1kgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHQgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuY29uc3QgcGFkZGluZ1lTbWFsbCA9IGBjYWxjKCgkeyBDT05GSUcuY29udHJvbEhlaWdodFNtYWxsIH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZTGFyZ2UgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRMYXJnZSB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5cbmV4cG9ydCBjb25zdCBpdGVtU2l6ZXMgPSB7XG5cdHNtYWxsOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lTbWFsbCB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hTbWFsbCB9O1xuXHRgLFxuXHRtZWRpdW06IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1ggfTtcblx0YCxcblx0bGFyZ2U6IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWUxhcmdlIH0gJHsgQ09ORklHLmNvbnRyb2xQYWRkaW5nWExhcmdlIH07XG5cdGAsXG59O1xuIl19 */"),
    large: /* @__PURE__ */ (0, import_react81.css)("padding:", paddingYLarge, " ", config_values_default.controlPaddingXLarge, ";" + (false ? "" : ";label:large;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBK0ZXIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvaXRlbS1ncm91cC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgdW5zdHlsZWRCdXR0b24gPSBjc3NgXG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGJhY2tncm91bmQ6IG5vbmU7XG5cdHRleHQtYWxpZ246IHN0YXJ0O1xuXG5cdCY6aG92ZXIge1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0fVxuXG5cdCY6Zm9jdXMge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdGNvbG9yOiAkeyBDT0xPUlMudWkudGhlbWUgfTtcblx0XHRib3JkZXItY29sb3I6ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDNweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IGl0ZW1XcmFwcGVyID0gY3NzYFxuXHR3aWR0aDogMTAwJTtcblx0ZGlzcGxheTogYmxvY2s7XG5gO1xuXG5leHBvcnQgY29uc3QgaXRlbSA9IGNzc2Bcblx0d2lkdGg6IDEwMCU7XG5cdGRpc3BsYXk6IGJsb2NrO1xuXHRtYXJnaW46IDA7XG5cdGNvbG9yOiBpbmhlcml0O1xuYDtcblxuZXhwb3J0IGNvbnN0IGJvcmRlcmVkID0gY3NzYFxuXHRib3JkZXI6IDFweCBzb2xpZCAkeyBDT05GSUcuc3VyZmFjZUJvcmRlckNvbG9yIH07XG5gO1xuXG5leHBvcnQgY29uc3Qgc2VwYXJhdGVkID0gY3NzYFxuXHQ+ICo6bm90KCBtYXJxdWVlICkgPiAqIHtcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgJHsgQ09ORklHLnN1cmZhY2VCb3JkZXJDb2xvciB9O1xuXHR9XG5cblx0PiAqOmxhc3Qtb2YtdHlwZSA+ICo6bm90KCA6Zm9jdXMgKSB7XG5cdFx0Ym9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGJvcmRlclJhZGl1cyA9IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzO1xuXG5leHBvcnQgY29uc3Qgc3BhY2VkQXJvdW5kID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcbmA7XG5cbmV4cG9ydCBjb25zdCByb3VuZGVkID0gY3NzYFxuXHRib3JkZXItcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblxuXHQ+ICo6Zmlyc3Qtb2YtdHlwZSA+ICoge1xuXHRcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6ICR7IGJvcmRlclJhZGl1cyB9O1xuXHRcdGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0fVxuXG5cdD4gKjpsYXN0LW9mLXR5cGUgPiAqIHtcblx0XHRib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAkeyBib3JkZXJSYWRpdXMgfTtcblx0XHRib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogJHsgYm9yZGVyUmFkaXVzIH07XG5cdH1cbmA7XG5cbmNvbnN0IGJhc2VGb250SGVpZ2h0ID0gYGNhbGMoJHsgQ09ORklHLmZvbnRTaXplIH0gKiAkeyBDT05GSUcuZm9udExpbmVIZWlnaHRCYXNlIH0pYDtcblxuLypcbiAqIE1hdGg6XG4gKiAtIFVzZSB0aGUgZGVzaXJlZCBoZWlnaHQgYXMgdGhlIGJhc2UgdmFsdWVcbiAqIC0gU3VidHJhY3QgdGhlIGNvbXB1dGVkIGhlaWdodCBvZiAoZGVmYXVsdCkgdGV4dFxuICogLSBTdWJ0cmFjdCB0aGUgZWZmZWN0cyBvZiBib3JkZXJcbiAqIC0gRGl2aWRlIHRoZSBjYWxjdWxhdGVkIG51bWJlciBieSAyLCBpbiBvcmRlciB0byBnZXQgYW4gaW5kaXZpZHVhbCB0b3AvYm90dG9tIHBhZGRpbmdcbiAqL1xuY29uc3QgcGFkZGluZ1kgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHQgfSAtICR7IGJhc2VGb250SGVpZ2h0IH0gLSAycHgpIC8gMilgO1xuY29uc3QgcGFkZGluZ1lTbWFsbCA9IGBjYWxjKCgkeyBDT05GSUcuY29udHJvbEhlaWdodFNtYWxsIH0gLSAkeyBiYXNlRm9udEhlaWdodCB9IC0gMnB4KSAvIDIpYDtcbmNvbnN0IHBhZGRpbmdZTGFyZ2UgPSBgY2FsYygoJHsgQ09ORklHLmNvbnRyb2xIZWlnaHRMYXJnZSB9IC0gJHsgYmFzZUZvbnRIZWlnaHQgfSAtIDJweCkgLyAyKWA7XG5cbmV4cG9ydCBjb25zdCBpdGVtU2l6ZXMgPSB7XG5cdHNtYWxsOiBjc3NgXG5cdFx0cGFkZGluZzogJHsgcGFkZGluZ1lTbWFsbCB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1hTbWFsbCB9O1xuXHRgLFxuXHRtZWRpdW06IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWSB9ICR7IENPTkZJRy5jb250cm9sUGFkZGluZ1ggfTtcblx0YCxcblx0bGFyZ2U6IGNzc2Bcblx0XHRwYWRkaW5nOiAkeyBwYWRkaW5nWUxhcmdlIH0gJHsgQ09ORklHLmNvbnRyb2xQYWRkaW5nWExhcmdlIH07XG5cdGAsXG59O1xuIl19 */")
  };

  // node_modules/@wordpress/components/build-module/item-group/context.js
  var ItemGroupContext = (0, import_react.createContext)({
    size: "medium"
  });
  var useItemGroupContext = () => (0, import_react.useContext)(ItemGroupContext);

  // node_modules/@wordpress/components/build-module/item-group/item/hook.js
  function useItem2(props) {
    const {
      as: asProp,
      className,
      onClick,
      role = "listitem",
      size: sizeProp,
      ...otherProps
    } = useContextSystem(props, "Item");
    const {
      spacedAround: spacedAround2,
      size: contextSize
    } = useItemGroupContext();
    const size = sizeProp || contextSize;
    const as = asProp || (typeof onClick !== "undefined" ? "button" : "div");
    const cx = useCx();
    const classes = (0, import_react.useMemo)(() => cx(as === "button" && unstyledButton, itemSizes[size] || itemSizes.medium, item, spacedAround2 && spacedAround, className), [as, className, cx, size, spacedAround2]);
    const wrapperClassName = cx(itemWrapper);
    return {
      as,
      className: classes,
      onClick,
      wrapperClassName,
      role,
      ...otherProps
    };
  }

  // node_modules/@wordpress/components/build-module/item-group/item/component.js
  function Item2(props, forwardedRef) {
    const {
      role,
      wrapperClassName,
      ...otherProps
    } = useItem2(props);
    return (0, import_react.createElement)("div", {
      role,
      className: wrapperClassName
    }, (0, import_react.createElement)(component_default, _extends({}, otherProps, {
      ref: forwardedRef
    })));
  }
  var component_default11 = contextConnect(Item2, "Item");

  // node_modules/@wordpress/components/build-module/item-group/item-group/hook.js
  function useItemGroup(props) {
    const {
      className,
      isBordered = false,
      isRounded = true,
      isSeparated = false,
      role = "list",
      ...otherProps
    } = useContextSystem(props, "ItemGroup");
    const cx = useCx();
    const classes = cx(isBordered && bordered, isSeparated && separated, isRounded && rounded, className);
    return {
      isBordered,
      className: classes,
      role,
      isSeparated,
      ...otherProps
    };
  }

  // node_modules/@wordpress/components/build-module/item-group/item-group/component.js
  function ItemGroup(props, forwardedRef) {
    const {
      isBordered,
      isSeparated,
      size: sizeProp,
      ...otherProps
    } = useItemGroup(props);
    const {
      size: contextSize
    } = useItemGroupContext();
    const spacedAround2 = !isBordered && !isSeparated;
    const size = sizeProp || contextSize;
    const contextValue = {
      spacedAround: spacedAround2,
      size
    };
    return (0, import_react.createElement)(ItemGroupContext.Provider, {
      value: contextValue
    }, (0, import_react.createElement)(component_default, _extends({}, otherProps, {
      ref: forwardedRef
    })));
  }
  var component_default12 = contextConnect(ItemGroup, "ItemGroup");

  // node_modules/@wordpress/components/build-module/dropdown-menu/index.js
  var import_classnames11 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/navigable-container/container.js
  var noop7 = () => {
  };
  var MENU_ITEM_ROLES = ["menuitem", "menuitemradio", "menuitemcheckbox"];
  function cycleValue(value, total, offset4) {
    const nextValue = value + offset4;
    if (nextValue < 0) {
      return total + nextValue;
    } else if (nextValue >= total) {
      return nextValue - total;
    }
    return nextValue;
  }
  var NavigableContainer = class extends import_react.Component {
    constructor() {
      super(...arguments);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.bindContainer = this.bindContainer.bind(this);
      this.getFocusableContext = this.getFocusableContext.bind(this);
      this.getFocusableIndex = this.getFocusableIndex.bind(this);
    }
    componentDidMount() {
      this.container.addEventListener("keydown", this.onKeyDown);
      this.container.addEventListener("focus", this.onFocus);
    }
    componentWillUnmount() {
      this.container.removeEventListener("keydown", this.onKeyDown);
      this.container.removeEventListener("focus", this.onFocus);
    }
    bindContainer(ref2) {
      const {
        forwardedRef
      } = this.props;
      this.container = ref2;
      if (typeof forwardedRef === "function") {
        forwardedRef(ref2);
      } else if (forwardedRef && "current" in forwardedRef) {
        forwardedRef.current = ref2;
      }
    }
    getFocusableContext(target) {
      const {
        onlyBrowserTabstops
      } = this.props;
      const finder = onlyBrowserTabstops ? focus.tabbable : focus.focusable;
      const focusables = finder.find(this.container);
      const index2 = this.getFocusableIndex(focusables, target);
      if (index2 > -1 && target) {
        return {
          index: index2,
          target,
          focusables
        };
      }
      return null;
    }
    getFocusableIndex(focusables, target) {
      const directIndex = focusables.indexOf(target);
      if (directIndex !== -1) {
        return directIndex;
      }
    }
    onKeyDown(event) {
      if (this.props.onKeyDown) {
        this.props.onKeyDown(event);
      }
      const {
        getFocusableContext
      } = this;
      const {
        cycle = true,
        eventToOffset,
        onNavigate = noop7,
        stopNavigationEvents
      } = this.props;
      const offset4 = eventToOffset(event);
      if (offset4 !== void 0 && stopNavigationEvents) {
        event.stopImmediatePropagation();
        const targetRole = event.target.getAttribute("role");
        const targetHasMenuItemRole = MENU_ITEM_ROLES.includes(targetRole);
        const isTab = event.code === "Tab";
        if (targetHasMenuItemRole || isTab) {
          event.preventDefault();
        }
      }
      if (!offset4) {
        return;
      }
      const context2 = getFocusableContext(event.target.ownerDocument.activeElement);
      if (!context2) {
        return;
      }
      const {
        index: index2,
        focusables
      } = context2;
      const nextIndex = cycle ? cycleValue(index2, focusables.length, offset4) : index2 + offset4;
      if (nextIndex >= 0 && nextIndex < focusables.length) {
        focusables[nextIndex].focus();
        onNavigate(nextIndex, focusables[nextIndex]);
      }
    }
    render() {
      const {
        children,
        stopNavigationEvents,
        eventToOffset,
        onNavigate,
        onKeyDown,
        cycle,
        onlyBrowserTabstops,
        forwardedRef,
        ...restProps
      } = this.props;
      return (0, import_react.createElement)("div", _extends({
        ref: this.bindContainer
      }, restProps), children);
    }
  };
  var forwardedNavigableContainer = (props, ref2) => {
    return (0, import_react.createElement)(NavigableContainer, _extends({}, props, {
      forwardedRef: ref2
    }));
  };
  forwardedNavigableContainer.displayName = "NavigableContainer";
  var container_default = (0, import_react.forwardRef)(forwardedNavigableContainer);

  // node_modules/@wordpress/components/build-module/navigable-container/menu.js
  function NavigableMenu(_ref8, ref2) {
    let {
      role = "menu",
      orientation = "vertical",
      ...rest
    } = _ref8;
    const eventToOffset = (evt) => {
      const {
        code
      } = evt;
      let next2 = ["ArrowDown"];
      let previous = ["ArrowUp"];
      if (orientation === "horizontal") {
        next2 = ["ArrowRight"];
        previous = ["ArrowLeft"];
      }
      if (orientation === "both") {
        next2 = ["ArrowRight", "ArrowDown"];
        previous = ["ArrowLeft", "ArrowUp"];
      }
      if (next2.includes(code)) {
        return 1;
      } else if (previous.includes(code)) {
        return -1;
      } else if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(code)) {
        return 0;
      }
    };
    return (0, import_react.createElement)(container_default, _extends({
      ref: ref2,
      stopNavigationEvents: true,
      onlyBrowserTabstops: false,
      role,
      "aria-orientation": role === "presentation" ? null : orientation,
      eventToOffset
    }, rest));
  }
  var menu_default2 = (0, import_react.forwardRef)(NavigableMenu);

  // node_modules/@wordpress/components/build-module/dropdown-menu/index.js
  function mergeProps() {
    let defaultProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const mergedProps = {
      ...defaultProps,
      ...props
    };
    if (props.className && defaultProps.className) {
      mergedProps.className = (0, import_classnames11.default)(props.className, defaultProps.className);
    }
    return mergedProps;
  }
  function isFunction3(maybeFunc) {
    return typeof maybeFunc === "function";
  }
  function DropdownMenu(dropdownMenuProps) {
    const {
      children,
      className,
      controls,
      icon = menu_default,
      label,
      popoverProps,
      toggleProps,
      menuProps,
      disableOpenOnArrowDown = false,
      text: text3,
      noIcons
    } = dropdownMenuProps;
    if (!(controls !== null && controls !== void 0 && controls.length) && !isFunction3(children)) {
      return null;
    }
    let controlSets;
    if (controls !== null && controls !== void 0 && controls.length) {
      controlSets = controls;
      if (!Array.isArray(controlSets[0])) {
        controlSets = [controlSets];
      }
    }
    const mergedPopoverProps = mergeProps({
      className: "components-dropdown-menu__popover"
    }, popoverProps);
    return (0, import_react.createElement)(Dropdown, {
      className: (0, import_classnames11.default)("components-dropdown-menu", className),
      popoverProps: mergedPopoverProps,
      renderToggle: (_ref8) => {
        var _toggleProps$showTool;
        let {
          isOpen,
          onToggle
        } = _ref8;
        const openOnArrowDown = (event) => {
          if (disableOpenOnArrowDown) {
            return;
          }
          if (!isOpen && event.code === "ArrowDown") {
            event.preventDefault();
            onToggle();
          }
        };
        const mergedToggleProps = mergeProps({
          className: (0, import_classnames11.default)("components-dropdown-menu__toggle", {
            "is-opened": isOpen
          })
        }, toggleProps);
        return (0, import_react.createElement)(button_default, _extends({}, mergedToggleProps, {
          icon,
          onClick: (event) => {
            onToggle(event);
            if (mergedToggleProps.onClick) {
              mergedToggleProps.onClick(event);
            }
          },
          onKeyDown: (event) => {
            openOnArrowDown(event);
            if (mergedToggleProps.onKeyDown) {
              mergedToggleProps.onKeyDown(event);
            }
          },
          "aria-haspopup": "true",
          "aria-expanded": isOpen,
          label,
          text: text3,
          showTooltip: (_toggleProps$showTool = toggleProps === null || toggleProps === void 0 ? void 0 : toggleProps.showTooltip) !== null && _toggleProps$showTool !== void 0 ? _toggleProps$showTool : true
        }), mergedToggleProps.children);
      },
      renderContent: (props) => {
        var _controlSets;
        const mergedMenuProps = mergeProps({
          "aria-label": label,
          className: (0, import_classnames11.default)("components-dropdown-menu__menu", {
            "no-icons": noIcons
          })
        }, menuProps);
        return (0, import_react.createElement)(menu_default2, _extends({}, mergedMenuProps, {
          role: "menu"
        }), isFunction3(children) ? children(props) : null, (_controlSets = controlSets) === null || _controlSets === void 0 ? void 0 : _controlSets.flatMap((controlSet, indexOfSet) => controlSet.map((control, indexOfControl) => (0, import_react.createElement)(button_default, {
          key: [indexOfSet, indexOfControl].join(),
          onClick: (event) => {
            event.stopPropagation();
            props.onClose();
            if (control.onClick) {
              control.onClick();
            }
          },
          className: (0, import_classnames11.default)("components-dropdown-menu__menu-item", {
            "has-separator": indexOfSet > 0 && indexOfControl === 0,
            "is-active": control.isActive,
            "is-icon-only": !control.title
          }),
          icon: control.icon,
          label: control.label,
          "aria-checked": control.role === "menuitemcheckbox" || control.role === "menuitemradio" ? control.isActive : void 0,
          role: control.role === "menuitemcheckbox" || control.role === "menuitemradio" ? control.role : "menuitem",
          disabled: control.isDisabled
        }, control.title))));
      }
    });
  }
  var dropdown_menu_default = DropdownMenu;

  // node_modules/@wordpress/components/build-module/modal/index.js
  var import_classnames12 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/modal/aria-helper.js
  var LIVE_REGION_ARIA_ROLES = /* @__PURE__ */ new Set(["alert", "status", "log", "marquee", "timer"]);
  var hiddenElements = [];
  var isHidden = false;
  function hideApp(unhiddenElement) {
    if (isHidden) {
      return;
    }
    const elements = Array.from(document.body.children);
    elements.forEach((element) => {
      if (element === unhiddenElement) {
        return;
      }
      if (elementShouldBeHidden(element)) {
        element.setAttribute("aria-hidden", "true");
        hiddenElements.push(element);
      }
    });
    isHidden = true;
  }
  function elementShouldBeHidden(element) {
    const role = element.getAttribute("role");
    return !(element.tagName === "SCRIPT" || element.hasAttribute("aria-hidden") || element.hasAttribute("aria-live") || role && LIVE_REGION_ARIA_ROLES.has(role));
  }
  function showApp() {
    if (!isHidden) {
      return;
    }
    hiddenElements.forEach((element) => {
      element.removeAttribute("aria-hidden");
    });
    hiddenElements = [];
    isHidden = false;
  }

  // node_modules/@wordpress/components/build-module/modal/index.js
  var openModalCount = 0;
  function UnforwardedModal(props, forwardedRef) {
    const {
      bodyOpenClassName = "modal-open",
      role = "dialog",
      title = null,
      focusOnMount = true,
      shouldCloseOnEsc = true,
      shouldCloseOnClickOutside = true,
      isDismissible = true,
      aria = {
        labelledby: void 0,
        describedby: void 0
      },
      onRequestClose,
      icon,
      closeButtonLabel,
      children,
      style,
      overlayClassName,
      className,
      contentLabel,
      onKeyDown,
      isFullScreen = false,
      __experimentalHideHeader = false
    } = props;
    const ref2 = (0, import_react.useRef)();
    const instanceId = use_instance_id_default(Modal);
    const headingId = title ? `components-modal-header-${instanceId}` : aria.labelledby;
    const focusOnMountRef = useFocusOnMount(focusOnMount);
    const constrainedTabbingRef = use_constrained_tabbing_default();
    const focusReturnRef = use_focus_return_default();
    const focusOutsideProps = useFocusOutside(onRequestClose);
    const [hasScrolledContent, setHasScrolledContent] = (0, import_react.useState)(false);
    (0, import_react.useEffect)(() => {
      openModalCount++;
      if (openModalCount === 1) {
        hideApp(ref2.current);
        document.body.classList.add(bodyOpenClassName);
      }
      return () => {
        openModalCount--;
        if (openModalCount === 0) {
          document.body.classList.remove(bodyOpenClassName);
          showApp();
        }
      };
    }, [bodyOpenClassName]);
    function handleEscapeKeyDown(event) {
      if (shouldCloseOnEsc && event.code === "Escape" && !event.defaultPrevented) {
        event.preventDefault();
        if (onRequestClose) {
          onRequestClose(event);
        }
      }
    }
    const onContentContainerScroll = (0, import_react.useCallback)((e4) => {
      var _e$currentTarget$scro, _e$currentTarget;
      const scrollY = (_e$currentTarget$scro = e4 === null || e4 === void 0 ? void 0 : (_e$currentTarget = e4.currentTarget) === null || _e$currentTarget === void 0 ? void 0 : _e$currentTarget.scrollTop) !== null && _e$currentTarget$scro !== void 0 ? _e$currentTarget$scro : -1;
      if (!hasScrolledContent && scrollY > 0) {
        setHasScrolledContent(true);
      } else if (hasScrolledContent && scrollY <= 0) {
        setHasScrolledContent(false);
      }
    }, [hasScrolledContent]);
    return (0, import_react_dom.createPortal)(
      (0, import_react.createElement)("div", {
        ref: useMergeRefs([ref2, forwardedRef]),
        className: (0, import_classnames12.default)("components-modal__screen-overlay", overlayClassName),
        onKeyDown: handleEscapeKeyDown
      }, (0, import_react.createElement)(style_provider_default, {
        document
      }, (0, import_react.createElement)("div", _extends({
        className: (0, import_classnames12.default)("components-modal__frame", className, {
          "is-full-screen": isFullScreen
        }),
        style,
        ref: useMergeRefs([constrainedTabbingRef, focusReturnRef, focusOnMountRef]),
        role,
        "aria-label": contentLabel,
        "aria-labelledby": contentLabel ? void 0 : headingId,
        "aria-describedby": aria.describedby,
        tabIndex: -1
      }, shouldCloseOnClickOutside ? focusOutsideProps : {}, {
        onKeyDown
      }), (0, import_react.createElement)("div", {
        className: (0, import_classnames12.default)("components-modal__content", {
          "hide-header": __experimentalHideHeader,
          "has-scrolled-content": hasScrolledContent
        }),
        role: "document",
        onScroll: onContentContainerScroll
      }, !__experimentalHideHeader && (0, import_react.createElement)("div", {
        className: "components-modal__header"
      }, (0, import_react.createElement)("div", {
        className: "components-modal__header-heading-container"
      }, icon && (0, import_react.createElement)("span", {
        className: "components-modal__icon-container",
        "aria-hidden": true
      }, icon), title && (0, import_react.createElement)("h1", {
        id: headingId,
        className: "components-modal__header-heading"
      }, title)), isDismissible && (0, import_react.createElement)(button_default, {
        onClick: onRequestClose,
        icon: close_default,
        label: closeButtonLabel || __("Close dialog")
      })), children)))),
      document.body
    );
  }
  var Modal = (0, import_react.forwardRef)(UnforwardedModal);
  var modal_default = Modal;

  // node_modules/@wordpress/components/build-module/disabled/styles/disabled-styles.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__11() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var disabledStyles2 = false ? {
    name: "u2jump",
    styles: "position:relative;pointer-events:none;&::after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;}*{pointer-events:none;}"
  } : {
    name: "iqemdn-disabledStyles",
    styles: "position:relative;pointer-events:none;&::after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;}*{pointer-events:none;};label:disabledStyles;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZGlzYWJsZWQvc3R5bGVzL2Rpc2FibGVkLXN0eWxlcy50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS2lDIiwiZmlsZSI6IkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvZGlzYWJsZWQvc3R5bGVzL2Rpc2FibGVkLXN0eWxlcy50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBkaXNhYmxlZFN0eWxlcyA9IGNzc2Bcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRwb2ludGVyLWV2ZW50czogbm9uZTtcblxuXHQmOjphZnRlciB7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRyaWdodDogMDtcblx0XHRib3R0b206IDA7XG5cdFx0bGVmdDogMDtcblx0fVxuXG5cdC8vIEFsc28gbWFrZSBuZXN0ZWQgYmxvY2tzIHVuc2VsZWN0YWJsZS5cblx0KiB7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdH1cbmA7XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__11
  };

  // node_modules/@wordpress/components/build-module/disabled/index.js
  var Context3 = (0, import_react.createContext)(false);
  var {
    Consumer: Consumer4,
    Provider: Provider4
  } = Context3;
  function Disabled(_ref8) {
    let {
      className,
      children,
      isDisabled = true,
      ...props
    } = _ref8;
    const cx = useCx();
    return (0, import_react.createElement)(Provider4, {
      value: isDisabled
    }, (0, import_react.createElement)("div", _extends({
      inert: isDisabled ? "true" : void 0,
      className: isDisabled ? cx(disabledStyles2, className, "components-disabled") : void 0
    }, props), children));
  }
  Disabled.Context = Context3;
  Disabled.Consumer = Consumer4;
  var disabled_default = Disabled;

  // node_modules/@wordpress/components/build-module/draggable/index.js
  var dragImageClass = "components-draggable__invisible-drag-image";
  var cloneWrapperClass = "components-draggable__clone";
  var clonePadding = 0;
  var bodyClass = "is-dragging-components-draggable";
  function Draggable(_ref8) {
    let {
      children,
      onDragStart,
      onDragOver,
      onDragEnd,
      cloneClassname,
      elementId,
      transferData,
      __experimentalTransferDataType: transferDataType = "text",
      __experimentalDragComponent: dragComponent
    } = _ref8;
    const dragComponentRef = (0, import_react.useRef)(null);
    const cleanup = (0, import_react.useRef)(() => {
    });
    function end(event) {
      event.preventDefault();
      cleanup.current();
      if (onDragEnd) {
        onDragEnd(event);
      }
    }
    function start2(event) {
      const {
        ownerDocument
      } = event.target;
      event.dataTransfer.setData(transferDataType, JSON.stringify(transferData));
      const cloneWrapper = ownerDocument.createElement("div");
      cloneWrapper.style.top = 0;
      cloneWrapper.style.left = 0;
      const dragImage = ownerDocument.createElement("div");
      if ("function" === typeof event.dataTransfer.setDragImage) {
        dragImage.classList.add(dragImageClass);
        ownerDocument.body.appendChild(dragImage);
        event.dataTransfer.setDragImage(dragImage, 0, 0);
      }
      cloneWrapper.classList.add(cloneWrapperClass);
      if (cloneClassname) {
        cloneWrapper.classList.add(cloneClassname);
      }
      let x4 = 0;
      let y5 = 0;
      if (dragComponentRef.current) {
        x4 = event.clientX;
        y5 = event.clientY;
        cloneWrapper.style.transform = `translate( ${x4}px, ${y5}px )`;
        const clonedDragComponent = ownerDocument.createElement("div");
        clonedDragComponent.innerHTML = dragComponentRef.current.innerHTML;
        cloneWrapper.appendChild(clonedDragComponent);
        ownerDocument.body.appendChild(cloneWrapper);
      } else {
        const element = ownerDocument.getElementById(elementId);
        const elementRect = element.getBoundingClientRect();
        const elementWrapper = element.parentNode;
        const elementTopOffset = parseInt(elementRect.top, 10);
        const elementLeftOffset = parseInt(elementRect.left, 10);
        cloneWrapper.style.width = `${elementRect.width + clonePadding * 2}px`;
        const clone2 = element.cloneNode(true);
        clone2.id = `clone-${elementId}`;
        x4 = elementLeftOffset - clonePadding;
        y5 = elementTopOffset - clonePadding;
        cloneWrapper.style.transform = `translate( ${x4}px, ${y5}px )`;
        Array.from(clone2.querySelectorAll("iframe")).forEach((child) => child.parentNode.removeChild(child));
        cloneWrapper.appendChild(clone2);
        elementWrapper.appendChild(cloneWrapper);
      }
      let cursorLeft = event.clientX;
      let cursorTop = event.clientY;
      function over(e4) {
        if (cursorLeft === e4.clientX && cursorTop === e4.clientY) {
          return;
        }
        const nextX = x4 + e4.clientX - cursorLeft;
        const nextY = y5 + e4.clientY - cursorTop;
        cloneWrapper.style.transform = `translate( ${nextX}px, ${nextY}px )`;
        cursorLeft = e4.clientX;
        cursorTop = e4.clientY;
        x4 = nextX;
        y5 = nextY;
        if (onDragOver) {
          onDragOver(e4);
        }
      }
      const throttledDragOver = throttle(over, 16);
      ownerDocument.addEventListener("dragover", throttledDragOver);
      ownerDocument.body.classList.add(bodyClass);
      event.persist();
      let timerId;
      if (onDragStart) {
        timerId = setTimeout(() => onDragStart(event));
      }
      cleanup.current = () => {
        if (cloneWrapper && cloneWrapper.parentNode) {
          cloneWrapper.parentNode.removeChild(cloneWrapper);
        }
        if (dragImage && dragImage.parentNode) {
          dragImage.parentNode.removeChild(dragImage);
        }
        ownerDocument.body.classList.remove(bodyClass);
        ownerDocument.removeEventListener("dragover", throttledDragOver);
        clearTimeout(timerId);
      };
    }
    (0, import_react.useEffect)(() => () => {
      cleanup.current();
    }, []);
    return (0, import_react.createElement)(import_react.Fragment, null, children({
      onDraggableStart: start2,
      onDraggableEnd: end
    }), dragComponent && (0, import_react.createElement)("div", {
      className: "components-draggable-drag-component-root",
      style: {
        display: "none"
      },
      ref: dragComponentRef
    }, dragComponent));
  }

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/styles.js
  var import_base6 = __toESM(require_emotion_styled_base_cjs());
  var import_react82 = __toESM(require_emotion_react_cjs());
  function _EMOTION_STRINGIFIED_CSS_ERROR__12() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var ToggleGroupControl = (_ref8) => {
    let {
      isDeselectable,
      size
    } = _ref8;
    return /* @__PURE__ */ (0, import_react82.css)("background:", COLORS.ui.background, ";border:1px solid transparent;display:inline-flex;min-width:0;padding:2px;position:relative;transition:transform ", config_values_default.transitionDurationFastest, " linear;", reduceMotion("transition"), " ", toggleGroupControlSize(size), " ", !isDeselectable && enclosingBorder, ";" + (false ? "" : ";label:ToggleGroupControl;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtCVSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RvZ2dsZS1ncm91cC1jb250cm9sL3RvZ2dsZS1ncm91cC1jb250cm9sL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgQ09ORklHLCBDT0xPUlMsIHJlZHVjZU1vdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBUb2dnbGVHcm91cENvbnRyb2wgPSAoIHtcblx0aXNEZXNlbGVjdGFibGUsXG5cdHNpemUsXG59OiB7XG5cdGlzRGVzZWxlY3RhYmxlPzogYm9vbGVhbjtcblx0c2l6ZTogTm9uTnVsbGFibGU8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzWyAnc2l6ZScgXSA+O1xufSApID0+IGNzc2Bcblx0YmFja2dyb3VuZDogJHsgQ09MT1JTLnVpLmJhY2tncm91bmQgfTtcblx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRtaW4td2lkdGg6IDA7XG5cdHBhZGRpbmc6IDJweDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJHsgQ09ORklHLnRyYW5zaXRpb25EdXJhdGlvbkZhc3Rlc3QgfSBsaW5lYXI7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXG5cdCR7IHRvZ2dsZUdyb3VwQ29udHJvbFNpemUoIHNpemUgKSB9XG5cdCR7ICEgaXNEZXNlbGVjdGFibGUgJiYgZW5jbG9zaW5nQm9yZGVyIH1cbmA7XG5cbmNvbnN0IGVuY2xvc2luZ0JvcmRlciA9IGNzc2Bcblx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyIH07XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cblx0Jjpob3ZlciB7XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVySG92ZXIgfTtcblx0fVxuXG5cdCY6Zm9jdXMtd2l0aGluIHtcblx0XHRib3JkZXItY29sb3I6ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdGJveC1zaGFkb3c6ICR7IENPTkZJRy5jb250cm9sQm94U2hhZG93Rm9jdXMgfTtcblx0XHRvdXRsaW5lOiBub25lO1xuXHRcdHotaW5kZXg6IDE7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVHcm91cENvbnRyb2xTaXplID0gKFxuXHRzaXplOiBOb25OdWxsYWJsZTwgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHNbICdzaXplJyBdID5cbikgPT4ge1xuXHRjb25zdCBoZWlnaHRzID0ge1xuXHRcdGRlZmF1bHQ6ICczNnB4Jyxcblx0XHQnX191bnN0YWJsZS1sYXJnZSc6ICc0MHB4Jyxcblx0fTtcblxuXHRyZXR1cm4gY3NzYFxuXHRcdG1pbi1oZWlnaHQ6ICR7IGhlaWdodHNbIHNpemUgXSB9O1xuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBmbGV4O1xuXHR3aWR0aDogMTAwJTtcbmA7XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFZpZXcgPSBzdHlsZWQuZGl2YFxuXHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0Ym9yZGVyLXJhZGl1czogJHsgQ09ORklHLmNvbnRyb2xCb3JkZXJSYWRpdXMgfTtcblx0bGVmdDogMDtcblx0cG9zaXRpb246IGFic29sdXRlO1xuXHR0b3A6IDJweDtcblx0Ym90dG9tOiAycHg7XG5cdHRyYW5zaXRpb246IHRyYW5zZm9ybSAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGVhc2U7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXHR6LWluZGV4OiAxO1xuYDtcblxuZXhwb3J0IGNvbnN0IFZpc3VhbExhYmVsV3JhcHBlciA9IHN0eWxlZC5kaXZgXG5cdC8vIE1ha2VzIHRoZSBpbmxpbmUgbGFiZWwgYmUgdGhlIGNvcnJlY3QgaGVpZ2h0LCBlcXVpdmFsZW50IHRvIHNldHRpbmcgbGluZS1oZWlnaHQ6IDBcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var enclosingBorder = /* @__PURE__ */ (0, import_react82.css)("border-color:", COLORS.ui.border, ";border-radius:", config_values_default.controlBorderRadius, ";&:hover{border-color:", COLORS.ui.borderHover, ";}&:focus-within{border-color:", COLORS.ui.borderFocus, ";box-shadow:", config_values_default.controlBoxShadowFocus, ";outline:none;z-index:1;}" + (false ? "" : ";label:enclosingBorder;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdDMkIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgVG9nZ2xlR3JvdXBDb250cm9sID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRzaXplLFxufToge1xuXHRpc0Rlc2VsZWN0YWJsZT86IGJvb2xlYW47XG5cdHNpemU6IE5vbk51bGxhYmxlPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wc1sgJ3NpemUnIF0gPjtcbn0gKSA9PiBjc3NgXG5cdGJhY2tncm91bmQ6ICR7IENPTE9SUy51aS5iYWNrZ3JvdW5kIH07XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0bWluLXdpZHRoOiAwO1xuXHRwYWRkaW5nOiAycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dHJhbnNpdGlvbjogdHJhbnNmb3JtICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0ZXN0IH0gbGluZWFyO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblxuXHQkeyB0b2dnbGVHcm91cENvbnRyb2xTaXplKCBzaXplICkgfVxuXHQkeyAhIGlzRGVzZWxlY3RhYmxlICYmIGVuY2xvc2luZ0JvcmRlciB9XG5gO1xuXG5jb25zdCBlbmNsb3NpbmdCb3JkZXIgPSBjc3NgXG5cdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlciB9O1xuXHRib3JkZXItcmFkaXVzOiAkeyBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cyB9O1xuXG5cdCY6aG92ZXIge1xuXHRcdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlckhvdmVyIH07XG5cdH1cblxuXHQmOmZvY3VzLXdpdGhpbiB7XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRib3gtc2hhZG93OiAkeyBDT05GSUcuY29udHJvbEJveFNoYWRvd0ZvY3VzIH07XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR6LWluZGV4OiAxO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlR3JvdXBDb250cm9sU2l6ZSA9IChcblx0c2l6ZTogTm9uTnVsbGFibGU8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzWyAnc2l6ZScgXSA+XG4pID0+IHtcblx0Y29uc3QgaGVpZ2h0cyA9IHtcblx0XHRkZWZhdWx0OiAnMzZweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnNDBweCcsXG5cdH07XG5cblx0cmV0dXJuIGNzc2Bcblx0XHRtaW4taGVpZ2h0OiAkeyBoZWlnaHRzWyBzaXplIF0gfTtcblx0YDtcbn07XG5cbmV4cG9ydCBjb25zdCBibG9jayA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcblx0d2lkdGg6IDEwMCU7XG5gO1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BWaWV3ID0gc3R5bGVkLmRpdmBcblx0YmFja2dyb3VuZDogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGxlZnQ6IDA7XG5cdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0dG9wOiAycHg7XG5cdGJvdHRvbTogMnB4O1xuXHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJHsgQ09ORklHLnRyYW5zaXRpb25EdXJhdGlvbkZhc3QgfSBlYXNlO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblx0ei1pbmRleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBWaXN1YWxMYWJlbFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHQvLyBNYWtlcyB0aGUgaW5saW5lIGxhYmVsIGJlIHRoZSBjb3JyZWN0IGhlaWdodCwgZXF1aXZhbGVudCB0byBzZXR0aW5nIGxpbmUtaGVpZ2h0OiAwXG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */");
  var toggleGroupControlSize = (size) => {
    const heights = {
      default: "36px",
      "__unstable-large": "40px"
    };
    return /* @__PURE__ */ (0, import_react82.css)("min-height:", heights[size], ";" + (false ? "" : ";label:toggleGroupControlSize;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdEVyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RvZ2dsZS1ncm91cC1jb250cm9sL3RvZ2dsZS1ncm91cC1jb250cm9sL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgQ09ORklHLCBDT0xPUlMsIHJlZHVjZU1vdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBUb2dnbGVHcm91cENvbnRyb2wgPSAoIHtcblx0aXNEZXNlbGVjdGFibGUsXG5cdHNpemUsXG59OiB7XG5cdGlzRGVzZWxlY3RhYmxlPzogYm9vbGVhbjtcblx0c2l6ZTogTm9uTnVsbGFibGU8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzWyAnc2l6ZScgXSA+O1xufSApID0+IGNzc2Bcblx0YmFja2dyb3VuZDogJHsgQ09MT1JTLnVpLmJhY2tncm91bmQgfTtcblx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRtaW4td2lkdGg6IDA7XG5cdHBhZGRpbmc6IDJweDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJHsgQ09ORklHLnRyYW5zaXRpb25EdXJhdGlvbkZhc3Rlc3QgfSBsaW5lYXI7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXG5cdCR7IHRvZ2dsZUdyb3VwQ29udHJvbFNpemUoIHNpemUgKSB9XG5cdCR7ICEgaXNEZXNlbGVjdGFibGUgJiYgZW5jbG9zaW5nQm9yZGVyIH1cbmA7XG5cbmNvbnN0IGVuY2xvc2luZ0JvcmRlciA9IGNzc2Bcblx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyIH07XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cblx0Jjpob3ZlciB7XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVySG92ZXIgfTtcblx0fVxuXG5cdCY6Zm9jdXMtd2l0aGluIHtcblx0XHRib3JkZXItY29sb3I6ICR7IENPTE9SUy51aS5ib3JkZXJGb2N1cyB9O1xuXHRcdGJveC1zaGFkb3c6ICR7IENPTkZJRy5jb250cm9sQm94U2hhZG93Rm9jdXMgfTtcblx0XHRvdXRsaW5lOiBub25lO1xuXHRcdHotaW5kZXg6IDE7XG5cdH1cbmA7XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVHcm91cENvbnRyb2xTaXplID0gKFxuXHRzaXplOiBOb25OdWxsYWJsZTwgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHNbICdzaXplJyBdID5cbikgPT4ge1xuXHRjb25zdCBoZWlnaHRzID0ge1xuXHRcdGRlZmF1bHQ6ICczNnB4Jyxcblx0XHQnX191bnN0YWJsZS1sYXJnZSc6ICc0MHB4Jyxcblx0fTtcblxuXHRyZXR1cm4gY3NzYFxuXHRcdG1pbi1oZWlnaHQ6ICR7IGhlaWdodHNbIHNpemUgXSB9O1xuXHRgO1xufTtcblxuZXhwb3J0IGNvbnN0IGJsb2NrID0gY3NzYFxuXHRkaXNwbGF5OiBmbGV4O1xuXHR3aWR0aDogMTAwJTtcbmA7XG5cbmV4cG9ydCBjb25zdCBCYWNrZHJvcFZpZXcgPSBzdHlsZWQuZGl2YFxuXHRiYWNrZ3JvdW5kOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0Ym9yZGVyLXJhZGl1czogJHsgQ09ORklHLmNvbnRyb2xCb3JkZXJSYWRpdXMgfTtcblx0bGVmdDogMDtcblx0cG9zaXRpb246IGFic29sdXRlO1xuXHR0b3A6IDJweDtcblx0Ym90dG9tOiAycHg7XG5cdHRyYW5zaXRpb246IHRyYW5zZm9ybSAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGVhc2U7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXHR6LWluZGV4OiAxO1xuYDtcblxuZXhwb3J0IGNvbnN0IFZpc3VhbExhYmVsV3JhcHBlciA9IHN0eWxlZC5kaXZgXG5cdC8vIE1ha2VzIHRoZSBpbmxpbmUgbGFiZWwgYmUgdGhlIGNvcnJlY3QgaGVpZ2h0LCBlcXVpdmFsZW50IHRvIHNldHRpbmcgbGluZS1oZWlnaHQ6IDBcblx0ZGlzcGxheTogZmxleDtcbmA7XG4iXX0= */");
  };
  var block3 = false ? {
    name: "7whenc",
    styles: "display:flex;width:100%"
  } : {
    name: "2dfrl8-block",
    styles: "display:flex;width:100%;label:block;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZEd0IiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgVG9nZ2xlR3JvdXBDb250cm9sID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRzaXplLFxufToge1xuXHRpc0Rlc2VsZWN0YWJsZT86IGJvb2xlYW47XG5cdHNpemU6IE5vbk51bGxhYmxlPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wc1sgJ3NpemUnIF0gPjtcbn0gKSA9PiBjc3NgXG5cdGJhY2tncm91bmQ6ICR7IENPTE9SUy51aS5iYWNrZ3JvdW5kIH07XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0bWluLXdpZHRoOiAwO1xuXHRwYWRkaW5nOiAycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dHJhbnNpdGlvbjogdHJhbnNmb3JtICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0ZXN0IH0gbGluZWFyO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblxuXHQkeyB0b2dnbGVHcm91cENvbnRyb2xTaXplKCBzaXplICkgfVxuXHQkeyAhIGlzRGVzZWxlY3RhYmxlICYmIGVuY2xvc2luZ0JvcmRlciB9XG5gO1xuXG5jb25zdCBlbmNsb3NpbmdCb3JkZXIgPSBjc3NgXG5cdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlciB9O1xuXHRib3JkZXItcmFkaXVzOiAkeyBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cyB9O1xuXG5cdCY6aG92ZXIge1xuXHRcdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlckhvdmVyIH07XG5cdH1cblxuXHQmOmZvY3VzLXdpdGhpbiB7XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRib3gtc2hhZG93OiAkeyBDT05GSUcuY29udHJvbEJveFNoYWRvd0ZvY3VzIH07XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR6LWluZGV4OiAxO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlR3JvdXBDb250cm9sU2l6ZSA9IChcblx0c2l6ZTogTm9uTnVsbGFibGU8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzWyAnc2l6ZScgXSA+XG4pID0+IHtcblx0Y29uc3QgaGVpZ2h0cyA9IHtcblx0XHRkZWZhdWx0OiAnMzZweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnNDBweCcsXG5cdH07XG5cblx0cmV0dXJuIGNzc2Bcblx0XHRtaW4taGVpZ2h0OiAkeyBoZWlnaHRzWyBzaXplIF0gfTtcblx0YDtcbn07XG5cbmV4cG9ydCBjb25zdCBibG9jayA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcblx0d2lkdGg6IDEwMCU7XG5gO1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BWaWV3ID0gc3R5bGVkLmRpdmBcblx0YmFja2dyb3VuZDogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGxlZnQ6IDA7XG5cdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0dG9wOiAycHg7XG5cdGJvdHRvbTogMnB4O1xuXHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJHsgQ09ORklHLnRyYW5zaXRpb25EdXJhdGlvbkZhc3QgfSBlYXNlO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblx0ei1pbmRleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBWaXN1YWxMYWJlbFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHQvLyBNYWtlcyB0aGUgaW5saW5lIGxhYmVsIGJlIHRoZSBjb3JyZWN0IGhlaWdodCwgZXF1aXZhbGVudCB0byBzZXR0aW5nIGxpbmUtaGVpZ2h0OiAwXG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__12
  };
  var BackdropView = (0, import_base6.default)("div", false ? {
    target: "eakva831"
  } : {
    target: "eakva831",
    label: "BackdropView"
  })("background:", COLORS.gray[900], ";border-radius:", config_values_default.controlBorderRadius, ";left:0;position:absolute;top:2px;bottom:2px;transition:transform ", config_values_default.transitionDurationFast, " ease;", reduceMotion("transition"), " z-index:1;" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtFc0MiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgVG9nZ2xlR3JvdXBDb250cm9sID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRzaXplLFxufToge1xuXHRpc0Rlc2VsZWN0YWJsZT86IGJvb2xlYW47XG5cdHNpemU6IE5vbk51bGxhYmxlPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wc1sgJ3NpemUnIF0gPjtcbn0gKSA9PiBjc3NgXG5cdGJhY2tncm91bmQ6ICR7IENPTE9SUy51aS5iYWNrZ3JvdW5kIH07XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0bWluLXdpZHRoOiAwO1xuXHRwYWRkaW5nOiAycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dHJhbnNpdGlvbjogdHJhbnNmb3JtICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0ZXN0IH0gbGluZWFyO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblxuXHQkeyB0b2dnbGVHcm91cENvbnRyb2xTaXplKCBzaXplICkgfVxuXHQkeyAhIGlzRGVzZWxlY3RhYmxlICYmIGVuY2xvc2luZ0JvcmRlciB9XG5gO1xuXG5jb25zdCBlbmNsb3NpbmdCb3JkZXIgPSBjc3NgXG5cdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlciB9O1xuXHRib3JkZXItcmFkaXVzOiAkeyBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cyB9O1xuXG5cdCY6aG92ZXIge1xuXHRcdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlckhvdmVyIH07XG5cdH1cblxuXHQmOmZvY3VzLXdpdGhpbiB7XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRib3gtc2hhZG93OiAkeyBDT05GSUcuY29udHJvbEJveFNoYWRvd0ZvY3VzIH07XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR6LWluZGV4OiAxO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlR3JvdXBDb250cm9sU2l6ZSA9IChcblx0c2l6ZTogTm9uTnVsbGFibGU8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzWyAnc2l6ZScgXSA+XG4pID0+IHtcblx0Y29uc3QgaGVpZ2h0cyA9IHtcblx0XHRkZWZhdWx0OiAnMzZweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnNDBweCcsXG5cdH07XG5cblx0cmV0dXJuIGNzc2Bcblx0XHRtaW4taGVpZ2h0OiAkeyBoZWlnaHRzWyBzaXplIF0gfTtcblx0YDtcbn07XG5cbmV4cG9ydCBjb25zdCBibG9jayA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcblx0d2lkdGg6IDEwMCU7XG5gO1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BWaWV3ID0gc3R5bGVkLmRpdmBcblx0YmFja2dyb3VuZDogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGxlZnQ6IDA7XG5cdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0dG9wOiAycHg7XG5cdGJvdHRvbTogMnB4O1xuXHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJHsgQ09ORklHLnRyYW5zaXRpb25EdXJhdGlvbkZhc3QgfSBlYXNlO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblx0ei1pbmRleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBWaXN1YWxMYWJlbFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHQvLyBNYWtlcyB0aGUgaW5saW5lIGxhYmVsIGJlIHRoZSBjb3JyZWN0IGhlaWdodCwgZXF1aXZhbGVudCB0byBzZXR0aW5nIGxpbmUtaGVpZ2h0OiAwXG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */"));
  var VisualLabelWrapper = (0, import_base6.default)("div", false ? {
    target: "eakva830"
  } : {
    target: "eakva830",
    label: "VisualLabelWrapper"
  })(false ? {
    name: "zjik7",
    styles: "display:flex"
  } : {
    name: "zjik7",
    styles: "display:flex",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThFNEMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgVG9nZ2xlR3JvdXBDb250cm9sID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRzaXplLFxufToge1xuXHRpc0Rlc2VsZWN0YWJsZT86IGJvb2xlYW47XG5cdHNpemU6IE5vbk51bGxhYmxlPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wc1sgJ3NpemUnIF0gPjtcbn0gKSA9PiBjc3NgXG5cdGJhY2tncm91bmQ6ICR7IENPTE9SUy51aS5iYWNrZ3JvdW5kIH07XG5cdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0bWluLXdpZHRoOiAwO1xuXHRwYWRkaW5nOiAycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dHJhbnNpdGlvbjogdHJhbnNmb3JtICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0ZXN0IH0gbGluZWFyO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblxuXHQkeyB0b2dnbGVHcm91cENvbnRyb2xTaXplKCBzaXplICkgfVxuXHQkeyAhIGlzRGVzZWxlY3RhYmxlICYmIGVuY2xvc2luZ0JvcmRlciB9XG5gO1xuXG5jb25zdCBlbmNsb3NpbmdCb3JkZXIgPSBjc3NgXG5cdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlciB9O1xuXHRib3JkZXItcmFkaXVzOiAkeyBDT05GSUcuY29udHJvbEJvcmRlclJhZGl1cyB9O1xuXG5cdCY6aG92ZXIge1xuXHRcdGJvcmRlci1jb2xvcjogJHsgQ09MT1JTLnVpLmJvcmRlckhvdmVyIH07XG5cdH1cblxuXHQmOmZvY3VzLXdpdGhpbiB7XG5cdFx0Ym9yZGVyLWNvbG9yOiAkeyBDT0xPUlMudWkuYm9yZGVyRm9jdXMgfTtcblx0XHRib3gtc2hhZG93OiAkeyBDT05GSUcuY29udHJvbEJveFNoYWRvd0ZvY3VzIH07XG5cdFx0b3V0bGluZTogbm9uZTtcblx0XHR6LWluZGV4OiAxO1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgdG9nZ2xlR3JvdXBDb250cm9sU2l6ZSA9IChcblx0c2l6ZTogTm9uTnVsbGFibGU8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzWyAnc2l6ZScgXSA+XG4pID0+IHtcblx0Y29uc3QgaGVpZ2h0cyA9IHtcblx0XHRkZWZhdWx0OiAnMzZweCcsXG5cdFx0J19fdW5zdGFibGUtbGFyZ2UnOiAnNDBweCcsXG5cdH07XG5cblx0cmV0dXJuIGNzc2Bcblx0XHRtaW4taGVpZ2h0OiAkeyBoZWlnaHRzWyBzaXplIF0gfTtcblx0YDtcbn07XG5cbmV4cG9ydCBjb25zdCBibG9jayA9IGNzc2Bcblx0ZGlzcGxheTogZmxleDtcblx0d2lkdGg6IDEwMCU7XG5gO1xuXG5leHBvcnQgY29uc3QgQmFja2Ryb3BWaWV3ID0gc3R5bGVkLmRpdmBcblx0YmFja2dyb3VuZDogJHsgQ09MT1JTLmdyYXlbIDkwMCBdIH07XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGxlZnQ6IDA7XG5cdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0dG9wOiAycHg7XG5cdGJvdHRvbTogMnB4O1xuXHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJHsgQ09ORklHLnRyYW5zaXRpb25EdXJhdGlvbkZhc3QgfSBlYXNlO1xuXHQkeyByZWR1Y2VNb3Rpb24oICd0cmFuc2l0aW9uJyApIH1cblx0ei1pbmRleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBWaXN1YWxMYWJlbFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuXHQvLyBNYWtlcyB0aGUgaW5saW5lIGxhYmVsIGJlIHRoZSBjb3JyZWN0IGhlaWdodCwgZXF1aXZhbGVudCB0byBzZXR0aW5nIGxpbmUtaGVpZ2h0OiAwXG5cdGRpc3BsYXk6IGZsZXg7XG5gO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__12
  });

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/toggle-group-control-backdrop.js
  function ToggleGroupControlBackdrop(_ref8) {
    let {
      containerRef,
      containerWidth,
      isAdaptiveWidth,
      state
    } = _ref8;
    const [left, setLeft] = (0, import_react.useState)(0);
    const [width3, setWidth] = (0, import_react.useState)(0);
    const [canAnimate, setCanAnimate] = (0, import_react.useState)(false);
    const [renderBackdrop, setRenderBackdrop] = (0, import_react.useState)(false);
    (0, import_react.useEffect)(() => {
      const containerNode = containerRef === null || containerRef === void 0 ? void 0 : containerRef.current;
      if (!containerNode)
        return;
      const targetNode = containerNode.querySelector(`[data-value="${state}"]`);
      setRenderBackdrop(!!targetNode);
      if (!targetNode) {
        return;
      }
      const computeDimensions = () => {
        const {
          width: offsetWidth,
          x: x4
        } = targetNode.getBoundingClientRect();
        const {
          x: parentX
        } = containerNode.getBoundingClientRect();
        const borderWidth = 1;
        const offsetLeft = x4 - parentX - borderWidth;
        setLeft(offsetLeft);
        setWidth(offsetWidth);
      };
      const dimensionsRequestId = window.setTimeout(computeDimensions, 100);
      let animationRequestId;
      if (!canAnimate) {
        animationRequestId = window.requestAnimationFrame(() => {
          setCanAnimate(true);
        });
      }
      return () => {
        window.clearTimeout(dimensionsRequestId);
        window.cancelAnimationFrame(animationRequestId);
      };
    }, [canAnimate, containerRef, containerWidth, state, isAdaptiveWidth]);
    if (!renderBackdrop) {
      return null;
    }
    return (0, import_react.createElement)(BackdropView, {
      role: "presentation",
      style: {
        transform: `translateX(${left}px)`,
        transition: canAnimate ? void 0 : "none",
        width: width3
      }
    });
  }
  var toggle_group_control_backdrop_default = (0, import_react.memo)(ToggleGroupControlBackdrop);

  // node_modules/@wordpress/components/build-module/toggle-group-control/context.js
  var ToggleGroupControlContext = (0, import_react.createContext)({});
  var useToggleGroupControlContext = () => (0, import_react.useContext)(ToggleGroupControlContext);
  var context_default4 = ToggleGroupControlContext;

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/as-radio-group.js
  function UnforwardedToggleGroupControlAsRadioGroup(_ref8, forwardedRef) {
    let {
      children,
      isAdaptiveWidth,
      label,
      onChange,
      size,
      value,
      ...otherProps
    } = _ref8;
    const containerRef = (0, import_react.useRef)();
    const [resizeListener, sizes] = useResizeAware();
    const baseId = use_instance_id_default(ToggleGroupControlAsRadioGroup, "toggle-group-control-as-radio-group").toString();
    const radio = useRadioState({
      baseId,
      state: value
    });
    const previousValue = usePrevious(value);
    use_update_effect_default(() => {
      if (previousValue !== radio.state) {
        onChange(radio.state);
      }
    }, [radio.state]);
    use_update_effect_default(() => {
      if (value !== radio.state) {
        radio.setState(value);
      }
    }, [value]);
    return (0, import_react.createElement)(context_default4.Provider, {
      value: {
        ...radio,
        isBlock: !isAdaptiveWidth,
        size
      }
    }, (0, import_react.createElement)(RadioGroup, _extends({}, radio, {
      "aria-label": label,
      as: component_default
    }, otherProps, {
      ref: useMergeRefs([containerRef, forwardedRef])
    }), resizeListener, (0, import_react.createElement)(toggle_group_control_backdrop_default, {
      state: radio.state,
      containerRef,
      containerWidth: sizes.width,
      isAdaptiveWidth
    }), children));
  }
  var ToggleGroupControlAsRadioGroup = (0, import_react.forwardRef)(UnforwardedToggleGroupControlAsRadioGroup);

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/as-button-group.js
  function UnforwardedToggleGroupControlAsButtonGroup(_ref8, forwardedRef) {
    let {
      children,
      isAdaptiveWidth,
      label,
      onChange,
      size,
      value,
      ...otherProps
    } = _ref8;
    const containerRef = (0, import_react.useRef)();
    const [resizeListener, sizes] = useResizeAware();
    const baseId = use_instance_id_default(ToggleGroupControlAsButtonGroup, "toggle-group-control-as-button-group").toString();
    const [selectedValue, setSelectedValue] = (0, import_react.useState)(value);
    const groupContext = {
      baseId,
      state: selectedValue,
      setState: setSelectedValue
    };
    const previousValue = usePrevious(value);
    use_update_effect_default(() => {
      if (previousValue !== groupContext.state) {
        onChange(groupContext.state);
      }
    }, [groupContext.state]);
    use_update_effect_default(() => {
      if (value !== groupContext.state) {
        groupContext.setState(value);
      }
    }, [value]);
    return (0, import_react.createElement)(context_default4.Provider, {
      value: {
        ...groupContext,
        isBlock: !isAdaptiveWidth,
        isDeselectable: true,
        size
      }
    }, (0, import_react.createElement)(component_default, _extends({
      "aria-label": label
    }, otherProps, {
      ref: useMergeRefs([containerRef, forwardedRef]),
      role: "group"
    }), resizeListener, (0, import_react.createElement)(toggle_group_control_backdrop_default, {
      state: groupContext.state,
      containerRef,
      containerWidth: sizes.width,
      isAdaptiveWidth
    }), children));
  }
  var ToggleGroupControlAsButtonGroup = (0, import_react.forwardRef)(UnforwardedToggleGroupControlAsButtonGroup);

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control/component.js
  var noop8 = () => {
  };
  function UnconnectedToggleGroupControl(props, forwardedRef) {
    const {
      __nextHasNoMarginBottom = false,
      className,
      isAdaptiveWidth = false,
      isBlock = false,
      isDeselectable = false,
      label,
      hideLabelFromVision = false,
      help,
      onChange = noop8,
      size = "default",
      value,
      children,
      ...otherProps
    } = useContextSystem(props, "ToggleGroupControl");
    const cx = useCx();
    const classes = (0, import_react.useMemo)(() => cx(ToggleGroupControl({
      isDeselectable,
      size
    }), isBlock && block3, className), [className, cx, isBlock, isDeselectable, size]);
    const MainControl = isDeselectable ? ToggleGroupControlAsButtonGroup : ToggleGroupControlAsRadioGroup;
    return (0, import_react.createElement)(base_control_default, {
      help,
      __nextHasNoMarginBottom
    }, !hideLabelFromVision && (0, import_react.createElement)(VisualLabelWrapper, null, (0, import_react.createElement)(base_control_default.VisualLabel, null, label)), (0, import_react.createElement)(MainControl, _extends({}, otherProps, {
      children,
      className: classes,
      isAdaptiveWidth,
      label,
      onChange,
      ref: forwardedRef,
      size,
      value
    })));
  }
  var ToggleGroupControl2 = contextConnect(UnconnectedToggleGroupControl, "ToggleGroupControl");
  var component_default13 = ToggleGroupControl2;

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/styles.js
  var styles_exports6 = {};
  __export(styles_exports6, {
    ButtonContentView: () => ButtonContentView,
    LabelView: () => LabelView,
    buttonView: () => buttonView,
    labelBlock: () => labelBlock
  });
  var import_base7 = __toESM(require_emotion_styled_base_cjs());
  var import_react83 = __toESM(require_emotion_react_cjs());
  function _EMOTION_STRINGIFIED_CSS_ERROR__13() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var LabelView = (0, import_base7.default)("div", false ? {
    target: "et6ln9s1"
  } : {
    target: "et6ln9s1",
    label: "LabelView"
  })(false ? {
    name: "sln1fl",
    styles: "display:inline-flex;max-width:100%;min-width:0;position:relative"
  } : {
    name: "sln1fl",
    styles: "display:inline-flex;max-width:100%;min-width:0;position:relative",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWVtQyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RvZ2dsZS1ncm91cC1jb250cm9sL3RvZ2dsZS1ncm91cC1jb250cm9sLW9wdGlvbi1iYXNlL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgQ09ORklHLCBDT0xPUlMsIHJlZHVjZU1vdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHtcblx0VG9nZ2xlR3JvdXBDb250cm9sUHJvcHMsXG5cdFRvZ2dsZUdyb3VwQ29udHJvbE9wdGlvbkJhc2VQcm9wcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgTGFiZWxWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdG1heC13aWR0aDogMTAwJTtcblx0bWluLXdpZHRoOiAwO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5gO1xuXG5leHBvcnQgY29uc3QgbGFiZWxCbG9jayA9IGNzc2Bcblx0ZmxleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBidXR0b25WaWV3ID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRpc0ljb24sXG5cdGlzUHJlc3NlZCxcblx0c2l6ZSxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnaXNEZXNlbGVjdGFibGUnIHwgJ3NpemUnID4gJlxuXHRQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsICdpc0ljb24nID4gJiB7XG5cdFx0aXNQcmVzc2VkPzogYm9vbGVhbjtcblx0fSApID0+IGNzc2Bcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YXBwZWFyYW5jZTogbm9uZTtcblx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdGJvcmRlcjogbm9uZTtcblx0Ym9yZGVyLXJhZGl1czogJHsgQ09ORklHLmNvbnRyb2xCb3JkZXJSYWRpdXMgfTtcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA3MDAgXSB9O1xuXHRmaWxsOiBjdXJyZW50Q29sb3I7XG5cdGN1cnNvcjogcG9pbnRlcjtcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdGhlaWdodDogMTAwJTtcblx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdGxpbmUtaGVpZ2h0OiAxMDAlO1xuXHRvdXRsaW5lOiBub25lO1xuXHRwYWRkaW5nOiAwIDEycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0IH0gbGluZWFyLFxuXHRcdGNvbG9yICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0IH0gbGluZWFyLCBmb250LXdlaWdodCA2MG1zIGxpbmVhcjtcblx0JHsgcmVkdWNlTW90aW9uKCAndHJhbnNpdGlvbicgKSB9XG5cdHVzZXItc2VsZWN0OiBub25lO1xuXHR3aWR0aDogMTAwJTtcblx0ei1pbmRleDogMjtcblxuXHQmOjotbW96LWZvY3VzLWlubmVyIHtcblx0XHRib3JkZXI6IDA7XG5cdH1cblxuXHQmOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogJHsgQ09ORklHLnRvZ2dsZUdyb3VwQ29udHJvbEJhY2tncm91bmRDb2xvciB9O1xuXHR9XG5cblx0JHsgaXNEZXNlbGVjdGFibGUgJiYgZGVzZWxlY3RhYmxlIH1cblx0JHsgaXNJY29uICYmIGlzSWNvblN0eWxlcyggeyBzaXplIH0gKSB9XG5cdCR7IGlzUHJlc3NlZCAmJiBwcmVzc2VkIH1cbmA7XG5cbmNvbnN0IHByZXNzZWQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMud2hpdGUgfTtcblxuXHQmOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGRlc2VsZWN0YWJsZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXG5cdCY6Zm9jdXMge1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCAkeyBDT0xPUlMud2hpdGUgfSxcblx0XHRcdDAgMCAwICR7IENPTkZJRy5ib3JkZXJXaWR0aEZvY3VzIH0gJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0b3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgQnV0dG9uQ29udGVudFZpZXcgPSBzdHlsZWQuZGl2YFxuXHRkaXNwbGF5OiBmbGV4O1xuXHRmb250LXNpemU6ICR7IENPTkZJRy5mb250U2l6ZSB9O1xuXHRsaW5lLWhlaWdodDogMTtcbmA7XG5cbmNvbnN0IGlzSWNvblN0eWxlcyA9ICgge1xuXHRzaXplID0gJ2RlZmF1bHQnLFxufTogUGljazwgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHMsICdzaXplJyA+ICkgPT4ge1xuXHRjb25zdCBpY29uQnV0dG9uU2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzMwcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzM0cHgnLFxuXHR9O1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHRcdHdpZHRoOiAkeyBpY29uQnV0dG9uU2l6ZXNbIHNpemUgXSB9O1xuXHRcdHBhZGRpbmctbGVmdDogMDtcblx0XHRwYWRkaW5nLXJpZ2h0OiAwO1xuXHRgO1xufTtcbiJdfQ== */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__13
  });
  var labelBlock = false ? {
    name: "82a6rk",
    styles: "flex:1"
  } : {
    name: "1sypmw-labelBlock",
    styles: "flex:1;label:labelBlock;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXNCNkIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC1vcHRpb24tYmFzZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG5cdFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLFxuXHRUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IExhYmVsVmlldyA9IHN0eWxlZC5kaXZgXG5cdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRtYXgtd2lkdGg6IDEwMCU7XG5cdG1pbi13aWR0aDogMDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuYDtcblxuZXhwb3J0IGNvbnN0IGxhYmVsQmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG5leHBvcnQgY29uc3QgYnV0dG9uVmlldyA9ICgge1xuXHRpc0Rlc2VsZWN0YWJsZSxcblx0aXNJY29uLFxuXHRpc1ByZXNzZWQsXG5cdHNpemUsXG59OiBQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wcywgJ2lzRGVzZWxlY3RhYmxlJyB8ICdzaXplJyA+ICZcblx0UGljazwgVG9nZ2xlR3JvdXBDb250cm9sT3B0aW9uQmFzZVByb3BzLCAnaXNJY29uJyA+ICYge1xuXHRcdGlzUHJlc3NlZD86IGJvb2xlYW47XG5cdH0gKSA9PiBjc3NgXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRib3JkZXI6IG5vbmU7XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblx0ZmlsbDogY3VycmVudENvbG9yO1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGRpc3BsYXk6IGZsZXg7XG5cdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXHRoZWlnaHQ6IDEwMCU7XG5cdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRsaW5lLWhlaWdodDogMTAwJTtcblx0b3V0bGluZTogbm9uZTtcblx0cGFkZGluZzogMCAxMnB4O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdHRleHQtYWxpZ246IGNlbnRlcjtcblx0dHJhbnNpdGlvbjogYmFja2dyb3VuZCAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhcixcblx0XHRjb2xvciAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhciwgZm9udC13ZWlnaHQgNjBtcyBsaW5lYXI7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXHR1c2VyLXNlbGVjdDogbm9uZTtcblx0d2lkdGg6IDEwMCU7XG5cdHotaW5kZXg6IDI7XG5cblx0Jjo6LW1vei1mb2N1cy1pbm5lciB7XG5cdFx0Ym9yZGVyOiAwO1xuXHR9XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6ICR7IENPTkZJRy50b2dnbGVHcm91cENvbnRyb2xCYWNrZ3JvdW5kQ29sb3IgfTtcblx0fVxuXG5cdCR7IGlzRGVzZWxlY3RhYmxlICYmIGRlc2VsZWN0YWJsZSB9XG5cdCR7IGlzSWNvbiAmJiBpc0ljb25TdHlsZXMoIHsgc2l6ZSB9ICkgfVxuXHQkeyBpc1ByZXNzZWQgJiYgcHJlc3NlZCB9XG5gO1xuXG5jb25zdCBwcmVzc2VkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLndoaXRlIH07XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBkZXNlbGVjdGFibGUgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblxuXHQmOmZvY3VzIHtcblx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggJHsgQ09MT1JTLndoaXRlIH0sXG5cdFx0XHQwIDAgMCAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IEJ1dHRvbkNvbnRlbnRWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1zaXplOiAkeyBDT05GSUcuZm9udFNpemUgfTtcblx0bGluZS1oZWlnaHQ6IDE7XG5gO1xuXG5jb25zdCBpc0ljb25TdHlsZXMgPSAoIHtcblx0c2l6ZSA9ICdkZWZhdWx0Jyxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnc2l6ZScgPiApID0+IHtcblx0Y29uc3QgaWNvbkJ1dHRvblNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICczMHB4Jyxcblx0XHQnX191bnN0YWJsZS1sYXJnZSc6ICczNHB4Jyxcblx0fTtcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHR3aWR0aDogJHsgaWNvbkJ1dHRvblNpemVzWyBzaXplIF0gfTtcblx0XHRwYWRkaW5nLWxlZnQ6IDA7XG5cdFx0cGFkZGluZy1yaWdodDogMDtcblx0YDtcbn07XG4iXX0= */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__13
  };
  var buttonView = (_ref8) => {
    let {
      isDeselectable,
      isIcon,
      isPressed,
      size
    } = _ref8;
    return /* @__PURE__ */ (0, import_react83.css)("align-items:center;appearance:none;background:transparent;border:none;border-radius:", config_values_default.controlBorderRadius, ";color:", COLORS.gray[700], ";fill:currentColor;cursor:pointer;display:flex;font-family:inherit;height:100%;justify-content:center;line-height:100%;outline:none;padding:0 12px;position:relative;text-align:center;transition:background ", config_values_default.transitionDurationFast, " linear,color ", config_values_default.transitionDurationFast, " linear,font-weight 60ms linear;", reduceMotion("transition"), " user-select:none;width:100%;z-index:2;&::-moz-focus-inner{border:0;}&:active{background:", config_values_default.toggleGroupControlBackgroundColor, ";}", isDeselectable && deselectable, " ", isIcon && isIconStyles({
      size
    }), " ", isPressed && pressed, ";" + (false ? "" : ";label:buttonView;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtDVyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RvZ2dsZS1ncm91cC1jb250cm9sL3RvZ2dsZS1ncm91cC1jb250cm9sLW9wdGlvbi1iYXNlL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgQ09ORklHLCBDT0xPUlMsIHJlZHVjZU1vdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHtcblx0VG9nZ2xlR3JvdXBDb250cm9sUHJvcHMsXG5cdFRvZ2dsZUdyb3VwQ29udHJvbE9wdGlvbkJhc2VQcm9wcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgTGFiZWxWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdG1heC13aWR0aDogMTAwJTtcblx0bWluLXdpZHRoOiAwO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5gO1xuXG5leHBvcnQgY29uc3QgbGFiZWxCbG9jayA9IGNzc2Bcblx0ZmxleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBidXR0b25WaWV3ID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRpc0ljb24sXG5cdGlzUHJlc3NlZCxcblx0c2l6ZSxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnaXNEZXNlbGVjdGFibGUnIHwgJ3NpemUnID4gJlxuXHRQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsICdpc0ljb24nID4gJiB7XG5cdFx0aXNQcmVzc2VkPzogYm9vbGVhbjtcblx0fSApID0+IGNzc2Bcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YXBwZWFyYW5jZTogbm9uZTtcblx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdGJvcmRlcjogbm9uZTtcblx0Ym9yZGVyLXJhZGl1czogJHsgQ09ORklHLmNvbnRyb2xCb3JkZXJSYWRpdXMgfTtcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA3MDAgXSB9O1xuXHRmaWxsOiBjdXJyZW50Q29sb3I7XG5cdGN1cnNvcjogcG9pbnRlcjtcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdGhlaWdodDogMTAwJTtcblx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdGxpbmUtaGVpZ2h0OiAxMDAlO1xuXHRvdXRsaW5lOiBub25lO1xuXHRwYWRkaW5nOiAwIDEycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0IH0gbGluZWFyLFxuXHRcdGNvbG9yICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0IH0gbGluZWFyLCBmb250LXdlaWdodCA2MG1zIGxpbmVhcjtcblx0JHsgcmVkdWNlTW90aW9uKCAndHJhbnNpdGlvbicgKSB9XG5cdHVzZXItc2VsZWN0OiBub25lO1xuXHR3aWR0aDogMTAwJTtcblx0ei1pbmRleDogMjtcblxuXHQmOjotbW96LWZvY3VzLWlubmVyIHtcblx0XHRib3JkZXI6IDA7XG5cdH1cblxuXHQmOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogJHsgQ09ORklHLnRvZ2dsZUdyb3VwQ29udHJvbEJhY2tncm91bmRDb2xvciB9O1xuXHR9XG5cblx0JHsgaXNEZXNlbGVjdGFibGUgJiYgZGVzZWxlY3RhYmxlIH1cblx0JHsgaXNJY29uICYmIGlzSWNvblN0eWxlcyggeyBzaXplIH0gKSB9XG5cdCR7IGlzUHJlc3NlZCAmJiBwcmVzc2VkIH1cbmA7XG5cbmNvbnN0IHByZXNzZWQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMud2hpdGUgfTtcblxuXHQmOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGRlc2VsZWN0YWJsZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXG5cdCY6Zm9jdXMge1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCAkeyBDT0xPUlMud2hpdGUgfSxcblx0XHRcdDAgMCAwICR7IENPTkZJRy5ib3JkZXJXaWR0aEZvY3VzIH0gJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0b3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgQnV0dG9uQ29udGVudFZpZXcgPSBzdHlsZWQuZGl2YFxuXHRkaXNwbGF5OiBmbGV4O1xuXHRmb250LXNpemU6ICR7IENPTkZJRy5mb250U2l6ZSB9O1xuXHRsaW5lLWhlaWdodDogMTtcbmA7XG5cbmNvbnN0IGlzSWNvblN0eWxlcyA9ICgge1xuXHRzaXplID0gJ2RlZmF1bHQnLFxufTogUGljazwgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHMsICdzaXplJyA+ICkgPT4ge1xuXHRjb25zdCBpY29uQnV0dG9uU2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzMwcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzM0cHgnLFxuXHR9O1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHRcdHdpZHRoOiAkeyBpY29uQnV0dG9uU2l6ZXNbIHNpemUgXSB9O1xuXHRcdHBhZGRpbmctbGVmdDogMDtcblx0XHRwYWRkaW5nLXJpZ2h0OiAwO1xuXHRgO1xufTtcbiJdfQ== */");
  };
  var pressed = /* @__PURE__ */ (0, import_react83.css)("color:", COLORS.white, ";&:active{background:transparent;}" + (false ? "" : ";label:pressed;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdFbUIiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC1vcHRpb24tYmFzZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG5cdFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLFxuXHRUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IExhYmVsVmlldyA9IHN0eWxlZC5kaXZgXG5cdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRtYXgtd2lkdGg6IDEwMCU7XG5cdG1pbi13aWR0aDogMDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuYDtcblxuZXhwb3J0IGNvbnN0IGxhYmVsQmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG5leHBvcnQgY29uc3QgYnV0dG9uVmlldyA9ICgge1xuXHRpc0Rlc2VsZWN0YWJsZSxcblx0aXNJY29uLFxuXHRpc1ByZXNzZWQsXG5cdHNpemUsXG59OiBQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wcywgJ2lzRGVzZWxlY3RhYmxlJyB8ICdzaXplJyA+ICZcblx0UGljazwgVG9nZ2xlR3JvdXBDb250cm9sT3B0aW9uQmFzZVByb3BzLCAnaXNJY29uJyA+ICYge1xuXHRcdGlzUHJlc3NlZD86IGJvb2xlYW47XG5cdH0gKSA9PiBjc3NgXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRib3JkZXI6IG5vbmU7XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblx0ZmlsbDogY3VycmVudENvbG9yO1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGRpc3BsYXk6IGZsZXg7XG5cdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXHRoZWlnaHQ6IDEwMCU7XG5cdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRsaW5lLWhlaWdodDogMTAwJTtcblx0b3V0bGluZTogbm9uZTtcblx0cGFkZGluZzogMCAxMnB4O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdHRleHQtYWxpZ246IGNlbnRlcjtcblx0dHJhbnNpdGlvbjogYmFja2dyb3VuZCAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhcixcblx0XHRjb2xvciAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhciwgZm9udC13ZWlnaHQgNjBtcyBsaW5lYXI7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXHR1c2VyLXNlbGVjdDogbm9uZTtcblx0d2lkdGg6IDEwMCU7XG5cdHotaW5kZXg6IDI7XG5cblx0Jjo6LW1vei1mb2N1cy1pbm5lciB7XG5cdFx0Ym9yZGVyOiAwO1xuXHR9XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6ICR7IENPTkZJRy50b2dnbGVHcm91cENvbnRyb2xCYWNrZ3JvdW5kQ29sb3IgfTtcblx0fVxuXG5cdCR7IGlzRGVzZWxlY3RhYmxlICYmIGRlc2VsZWN0YWJsZSB9XG5cdCR7IGlzSWNvbiAmJiBpc0ljb25TdHlsZXMoIHsgc2l6ZSB9ICkgfVxuXHQkeyBpc1ByZXNzZWQgJiYgcHJlc3NlZCB9XG5gO1xuXG5jb25zdCBwcmVzc2VkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLndoaXRlIH07XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBkZXNlbGVjdGFibGUgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblxuXHQmOmZvY3VzIHtcblx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggJHsgQ09MT1JTLndoaXRlIH0sXG5cdFx0XHQwIDAgMCAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IEJ1dHRvbkNvbnRlbnRWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1zaXplOiAkeyBDT05GSUcuZm9udFNpemUgfTtcblx0bGluZS1oZWlnaHQ6IDE7XG5gO1xuXG5jb25zdCBpc0ljb25TdHlsZXMgPSAoIHtcblx0c2l6ZSA9ICdkZWZhdWx0Jyxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnc2l6ZScgPiApID0+IHtcblx0Y29uc3QgaWNvbkJ1dHRvblNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICczMHB4Jyxcblx0XHQnX191bnN0YWJsZS1sYXJnZSc6ICczNHB4Jyxcblx0fTtcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHR3aWR0aDogJHsgaWNvbkJ1dHRvblNpemVzWyBzaXplIF0gfTtcblx0XHRwYWRkaW5nLWxlZnQ6IDA7XG5cdFx0cGFkZGluZy1yaWdodDogMDtcblx0YDtcbn07XG4iXX0= */");
  var deselectable = /* @__PURE__ */ (0, import_react83.css)("color:", COLORS.gray[900], ";&:focus{box-shadow:inset 0 0 0 1px ", COLORS.white, ",0 0 0 ", config_values_default.borderWidthFocus, " ", COLORS.ui.theme, ";outline:2px solid transparent;}" + (false ? "" : ";label:deselectable;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdGd0IiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC1vcHRpb24tYmFzZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG5cdFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLFxuXHRUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IExhYmVsVmlldyA9IHN0eWxlZC5kaXZgXG5cdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRtYXgtd2lkdGg6IDEwMCU7XG5cdG1pbi13aWR0aDogMDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuYDtcblxuZXhwb3J0IGNvbnN0IGxhYmVsQmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG5leHBvcnQgY29uc3QgYnV0dG9uVmlldyA9ICgge1xuXHRpc0Rlc2VsZWN0YWJsZSxcblx0aXNJY29uLFxuXHRpc1ByZXNzZWQsXG5cdHNpemUsXG59OiBQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wcywgJ2lzRGVzZWxlY3RhYmxlJyB8ICdzaXplJyA+ICZcblx0UGljazwgVG9nZ2xlR3JvdXBDb250cm9sT3B0aW9uQmFzZVByb3BzLCAnaXNJY29uJyA+ICYge1xuXHRcdGlzUHJlc3NlZD86IGJvb2xlYW47XG5cdH0gKSA9PiBjc3NgXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRib3JkZXI6IG5vbmU7XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblx0ZmlsbDogY3VycmVudENvbG9yO1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGRpc3BsYXk6IGZsZXg7XG5cdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXHRoZWlnaHQ6IDEwMCU7XG5cdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRsaW5lLWhlaWdodDogMTAwJTtcblx0b3V0bGluZTogbm9uZTtcblx0cGFkZGluZzogMCAxMnB4O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdHRleHQtYWxpZ246IGNlbnRlcjtcblx0dHJhbnNpdGlvbjogYmFja2dyb3VuZCAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhcixcblx0XHRjb2xvciAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhciwgZm9udC13ZWlnaHQgNjBtcyBsaW5lYXI7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXHR1c2VyLXNlbGVjdDogbm9uZTtcblx0d2lkdGg6IDEwMCU7XG5cdHotaW5kZXg6IDI7XG5cblx0Jjo6LW1vei1mb2N1cy1pbm5lciB7XG5cdFx0Ym9yZGVyOiAwO1xuXHR9XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6ICR7IENPTkZJRy50b2dnbGVHcm91cENvbnRyb2xCYWNrZ3JvdW5kQ29sb3IgfTtcblx0fVxuXG5cdCR7IGlzRGVzZWxlY3RhYmxlICYmIGRlc2VsZWN0YWJsZSB9XG5cdCR7IGlzSWNvbiAmJiBpc0ljb25TdHlsZXMoIHsgc2l6ZSB9ICkgfVxuXHQkeyBpc1ByZXNzZWQgJiYgcHJlc3NlZCB9XG5gO1xuXG5jb25zdCBwcmVzc2VkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLndoaXRlIH07XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBkZXNlbGVjdGFibGUgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblxuXHQmOmZvY3VzIHtcblx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggJHsgQ09MT1JTLndoaXRlIH0sXG5cdFx0XHQwIDAgMCAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IEJ1dHRvbkNvbnRlbnRWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1zaXplOiAkeyBDT05GSUcuZm9udFNpemUgfTtcblx0bGluZS1oZWlnaHQ6IDE7XG5gO1xuXG5jb25zdCBpc0ljb25TdHlsZXMgPSAoIHtcblx0c2l6ZSA9ICdkZWZhdWx0Jyxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnc2l6ZScgPiApID0+IHtcblx0Y29uc3QgaWNvbkJ1dHRvblNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICczMHB4Jyxcblx0XHQnX191bnN0YWJsZS1sYXJnZSc6ICczNHB4Jyxcblx0fTtcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHR3aWR0aDogJHsgaWNvbkJ1dHRvblNpemVzWyBzaXplIF0gfTtcblx0XHRwYWRkaW5nLWxlZnQ6IDA7XG5cdFx0cGFkZGluZy1yaWdodDogMDtcblx0YDtcbn07XG4iXX0= */");
  var ButtonContentView = (0, import_base7.default)("div", false ? {
    target: "et6ln9s0"
  } : {
    target: "et6ln9s0",
    label: "ButtonContentView"
  })("display:flex;font-size:", config_values_default.fontSize, ";line-height:1;" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTBGMkMiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtZ3JvdXAtY29udHJvbC90b2dnbGUtZ3JvdXAtY29udHJvbC1vcHRpb24tYmFzZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IENPTkZJRywgQ09MT1JTLCByZWR1Y2VNb3Rpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG5cdFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLFxuXHRUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IExhYmVsVmlldyA9IHN0eWxlZC5kaXZgXG5cdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRtYXgtd2lkdGg6IDEwMCU7XG5cdG1pbi13aWR0aDogMDtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuYDtcblxuZXhwb3J0IGNvbnN0IGxhYmVsQmxvY2sgPSBjc3NgXG5cdGZsZXg6IDE7XG5gO1xuXG5leHBvcnQgY29uc3QgYnV0dG9uVmlldyA9ICgge1xuXHRpc0Rlc2VsZWN0YWJsZSxcblx0aXNJY29uLFxuXHRpc1ByZXNzZWQsXG5cdHNpemUsXG59OiBQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xQcm9wcywgJ2lzRGVzZWxlY3RhYmxlJyB8ICdzaXplJyA+ICZcblx0UGljazwgVG9nZ2xlR3JvdXBDb250cm9sT3B0aW9uQmFzZVByb3BzLCAnaXNJY29uJyA+ICYge1xuXHRcdGlzUHJlc3NlZD86IGJvb2xlYW47XG5cdH0gKSA9PiBjc3NgXG5cdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdGFwcGVhcmFuY2U6IG5vbmU7XG5cdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRib3JkZXI6IG5vbmU7XG5cdGJvcmRlci1yYWRpdXM6ICR7IENPTkZJRy5jb250cm9sQm9yZGVyUmFkaXVzIH07XG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgNzAwIF0gfTtcblx0ZmlsbDogY3VycmVudENvbG9yO1xuXHRjdXJzb3I6IHBvaW50ZXI7XG5cdGRpc3BsYXk6IGZsZXg7XG5cdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xuXHRoZWlnaHQ6IDEwMCU7XG5cdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRsaW5lLWhlaWdodDogMTAwJTtcblx0b3V0bGluZTogbm9uZTtcblx0cGFkZGluZzogMCAxMnB4O1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdHRleHQtYWxpZ246IGNlbnRlcjtcblx0dHJhbnNpdGlvbjogYmFja2dyb3VuZCAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhcixcblx0XHRjb2xvciAkeyBDT05GSUcudHJhbnNpdGlvbkR1cmF0aW9uRmFzdCB9IGxpbmVhciwgZm9udC13ZWlnaHQgNjBtcyBsaW5lYXI7XG5cdCR7IHJlZHVjZU1vdGlvbiggJ3RyYW5zaXRpb24nICkgfVxuXHR1c2VyLXNlbGVjdDogbm9uZTtcblx0d2lkdGg6IDEwMCU7XG5cdHotaW5kZXg6IDI7XG5cblx0Jjo6LW1vei1mb2N1cy1pbm5lciB7XG5cdFx0Ym9yZGVyOiAwO1xuXHR9XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6ICR7IENPTkZJRy50b2dnbGVHcm91cENvbnRyb2xCYWNrZ3JvdW5kQ29sb3IgfTtcblx0fVxuXG5cdCR7IGlzRGVzZWxlY3RhYmxlICYmIGRlc2VsZWN0YWJsZSB9XG5cdCR7IGlzSWNvbiAmJiBpc0ljb25TdHlsZXMoIHsgc2l6ZSB9ICkgfVxuXHQkeyBpc1ByZXNzZWQgJiYgcHJlc3NlZCB9XG5gO1xuXG5jb25zdCBwcmVzc2VkID0gY3NzYFxuXHRjb2xvcjogJHsgQ09MT1JTLndoaXRlIH07XG5cblx0JjphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5jb25zdCBkZXNlbGVjdGFibGUgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblxuXHQmOmZvY3VzIHtcblx0XHRib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggJHsgQ09MT1JTLndoaXRlIH0sXG5cdFx0XHQwIDAgMCAkeyBDT05GSUcuYm9yZGVyV2lkdGhGb2N1cyB9ICR7IENPTE9SUy51aS50aGVtZSB9O1xuXHRcdG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0fVxuYDtcblxuZXhwb3J0IGNvbnN0IEJ1dHRvbkNvbnRlbnRWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1zaXplOiAkeyBDT05GSUcuZm9udFNpemUgfTtcblx0bGluZS1oZWlnaHQ6IDE7XG5gO1xuXG5jb25zdCBpc0ljb25TdHlsZXMgPSAoIHtcblx0c2l6ZSA9ICdkZWZhdWx0Jyxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnc2l6ZScgPiApID0+IHtcblx0Y29uc3QgaWNvbkJ1dHRvblNpemVzID0ge1xuXHRcdGRlZmF1bHQ6ICczMHB4Jyxcblx0XHQnX191bnN0YWJsZS1sYXJnZSc6ICczNHB4Jyxcblx0fTtcblxuXHRyZXR1cm4gY3NzYFxuXHRcdGNvbG9yOiAkeyBDT0xPUlMuZ3JheVsgOTAwIF0gfTtcblx0XHR3aWR0aDogJHsgaWNvbkJ1dHRvblNpemVzWyBzaXplIF0gfTtcblx0XHRwYWRkaW5nLWxlZnQ6IDA7XG5cdFx0cGFkZGluZy1yaWdodDogMDtcblx0YDtcbn07XG4iXX0= */"));
  var isIconStyles = (_ref22) => {
    let {
      size = "default"
    } = _ref22;
    const iconButtonSizes = {
      default: "30px",
      "__unstable-large": "34px"
    };
    return /* @__PURE__ */ (0, import_react83.css)("color:", COLORS.gray[900], ";width:", iconButtonSizes[size], ";padding-left:0;padding-right:0;" + (false ? "" : ";label:isIconStyles;"), false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWdyb3VwLWNvbnRyb2wvdG9nZ2xlLWdyb3VwLWNvbnRyb2wtb3B0aW9uLWJhc2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdHVyIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL3RvZ2dsZS1ncm91cC1jb250cm9sL3RvZ2dsZS1ncm91cC1jb250cm9sLW9wdGlvbi1iYXNlL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnQGVtb3Rpb24vc3R5bGVkJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgQ09ORklHLCBDT0xPUlMsIHJlZHVjZU1vdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHtcblx0VG9nZ2xlR3JvdXBDb250cm9sUHJvcHMsXG5cdFRvZ2dsZUdyb3VwQ29udHJvbE9wdGlvbkJhc2VQcm9wcyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgTGFiZWxWaWV3ID0gc3R5bGVkLmRpdmBcblx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdG1heC13aWR0aDogMTAwJTtcblx0bWluLXdpZHRoOiAwO1xuXHRwb3NpdGlvbjogcmVsYXRpdmU7XG5gO1xuXG5leHBvcnQgY29uc3QgbGFiZWxCbG9jayA9IGNzc2Bcblx0ZmxleDogMTtcbmA7XG5cbmV4cG9ydCBjb25zdCBidXR0b25WaWV3ID0gKCB7XG5cdGlzRGVzZWxlY3RhYmxlLFxuXHRpc0ljb24sXG5cdGlzUHJlc3NlZCxcblx0c2l6ZSxcbn06IFBpY2s8IFRvZ2dsZUdyb3VwQ29udHJvbFByb3BzLCAnaXNEZXNlbGVjdGFibGUnIHwgJ3NpemUnID4gJlxuXHRQaWNrPCBUb2dnbGVHcm91cENvbnRyb2xPcHRpb25CYXNlUHJvcHMsICdpc0ljb24nID4gJiB7XG5cdFx0aXNQcmVzc2VkPzogYm9vbGVhbjtcblx0fSApID0+IGNzc2Bcblx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0YXBwZWFyYW5jZTogbm9uZTtcblx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdGJvcmRlcjogbm9uZTtcblx0Ym9yZGVyLXJhZGl1czogJHsgQ09ORklHLmNvbnRyb2xCb3JkZXJSYWRpdXMgfTtcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA3MDAgXSB9O1xuXHRmaWxsOiBjdXJyZW50Q29sb3I7XG5cdGN1cnNvcjogcG9pbnRlcjtcblx0ZGlzcGxheTogZmxleDtcblx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdGhlaWdodDogMTAwJTtcblx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdGxpbmUtaGVpZ2h0OiAxMDAlO1xuXHRvdXRsaW5lOiBub25lO1xuXHRwYWRkaW5nOiAwIDEycHg7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0IH0gbGluZWFyLFxuXHRcdGNvbG9yICR7IENPTkZJRy50cmFuc2l0aW9uRHVyYXRpb25GYXN0IH0gbGluZWFyLCBmb250LXdlaWdodCA2MG1zIGxpbmVhcjtcblx0JHsgcmVkdWNlTW90aW9uKCAndHJhbnNpdGlvbicgKSB9XG5cdHVzZXItc2VsZWN0OiBub25lO1xuXHR3aWR0aDogMTAwJTtcblx0ei1pbmRleDogMjtcblxuXHQmOjotbW96LWZvY3VzLWlubmVyIHtcblx0XHRib3JkZXI6IDA7XG5cdH1cblxuXHQmOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogJHsgQ09ORklHLnRvZ2dsZUdyb3VwQ29udHJvbEJhY2tncm91bmRDb2xvciB9O1xuXHR9XG5cblx0JHsgaXNEZXNlbGVjdGFibGUgJiYgZGVzZWxlY3RhYmxlIH1cblx0JHsgaXNJY29uICYmIGlzSWNvblN0eWxlcyggeyBzaXplIH0gKSB9XG5cdCR7IGlzUHJlc3NlZCAmJiBwcmVzc2VkIH1cbmA7XG5cbmNvbnN0IHByZXNzZWQgPSBjc3NgXG5cdGNvbG9yOiAkeyBDT0xPUlMud2hpdGUgfTtcblxuXHQmOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cdH1cbmA7XG5cbmNvbnN0IGRlc2VsZWN0YWJsZSA9IGNzc2Bcblx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXG5cdCY6Zm9jdXMge1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCAkeyBDT0xPUlMud2hpdGUgfSxcblx0XHRcdDAgMCAwICR7IENPTkZJRy5ib3JkZXJXaWR0aEZvY3VzIH0gJHsgQ09MT1JTLnVpLnRoZW1lIH07XG5cdFx0b3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHR9XG5gO1xuXG5leHBvcnQgY29uc3QgQnV0dG9uQ29udGVudFZpZXcgPSBzdHlsZWQuZGl2YFxuXHRkaXNwbGF5OiBmbGV4O1xuXHRmb250LXNpemU6ICR7IENPTkZJRy5mb250U2l6ZSB9O1xuXHRsaW5lLWhlaWdodDogMTtcbmA7XG5cbmNvbnN0IGlzSWNvblN0eWxlcyA9ICgge1xuXHRzaXplID0gJ2RlZmF1bHQnLFxufTogUGljazwgVG9nZ2xlR3JvdXBDb250cm9sUHJvcHMsICdzaXplJyA+ICkgPT4ge1xuXHRjb25zdCBpY29uQnV0dG9uU2l6ZXMgPSB7XG5cdFx0ZGVmYXVsdDogJzMwcHgnLFxuXHRcdCdfX3Vuc3RhYmxlLWxhcmdlJzogJzM0cHgnLFxuXHR9O1xuXG5cdHJldHVybiBjc3NgXG5cdFx0Y29sb3I6ICR7IENPTE9SUy5ncmF5WyA5MDAgXSB9O1xuXHRcdHdpZHRoOiAkeyBpY29uQnV0dG9uU2l6ZXNbIHNpemUgXSB9O1xuXHRcdHBhZGRpbmctbGVmdDogMDtcblx0XHRwYWRkaW5nLXJpZ2h0OiAwO1xuXHRgO1xufTtcbiJdfQ== */");
  };

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-base/component.js
  var {
    ButtonContentView: ButtonContentView2,
    LabelView: LabelView2
  } = styles_exports6;
  var WithToolTip = (_ref8) => {
    let {
      showTooltip,
      text: text3,
      children
    } = _ref8;
    if (showTooltip && text3) {
      return (0, import_react.createElement)(tooltip_default, {
        text: text3,
        position: "top center"
      }, children);
    }
    return (0, import_react.createElement)(import_react.Fragment, null, children);
  };
  function ToggleGroupControlOptionBase(props, forwardedRef) {
    const toggleGroupControlContext = useToggleGroupControlContext();
    const id2 = use_instance_id_default(ToggleGroupControlOptionBase, toggleGroupControlContext.baseId || "toggle-group-control-option-base");
    const buttonProps = useContextSystem({
      ...props,
      id: id2
    }, "ToggleGroupControlOptionBase");
    const {
      isBlock = false,
      isDeselectable = false,
      size = "default",
      ...otherContextProps
    } = toggleGroupControlContext;
    const {
      className,
      isIcon = false,
      value,
      children,
      showTooltip = false,
      ...otherButtonProps
    } = buttonProps;
    const isPressed = otherContextProps.state === value;
    const cx = useCx();
    const labelViewClasses = cx(isBlock && labelBlock);
    const classes = cx(buttonView({
      isDeselectable,
      isIcon,
      isPressed,
      size
    }), className);
    const buttonOnClick = () => {
      if (isDeselectable && isPressed) {
        otherContextProps.setState(void 0);
      } else {
        otherContextProps.setState(value);
      }
    };
    const commonProps = {
      ...otherButtonProps,
      className: classes,
      "data-value": value,
      ref: forwardedRef
    };
    return (0, import_react.createElement)(LabelView2, {
      className: labelViewClasses
    }, (0, import_react.createElement)(WithToolTip, {
      showTooltip,
      text: otherButtonProps["aria-label"]
    }, isDeselectable ? (0, import_react.createElement)("button", _extends({}, commonProps, {
      "aria-pressed": isPressed,
      type: "button",
      onClick: buttonOnClick
    }), (0, import_react.createElement)(ButtonContentView2, null, children)) : (0, import_react.createElement)(Radio, _extends(
      {},
      commonProps,
      otherContextProps,
      {
        as: "button",
        value
      }
    ), (0, import_react.createElement)(ButtonContentView2, null, children))));
  }
  var ConnectedToggleGroupControlOptionBase = contextConnect(ToggleGroupControlOptionBase, "ToggleGroupControlOptionBase");
  var component_default14 = ConnectedToggleGroupControlOptionBase;

  // node_modules/@wordpress/components/build-module/toggle-group-control/toggle-group-control-option-icon/component.js
  function UnforwardedToggleGroupControlOptionIcon(props, ref2) {
    const {
      icon,
      label,
      ...restProps
    } = props;
    return (0, import_react.createElement)(component_default14, _extends({}, restProps, {
      isIcon: true,
      "aria-label": label,
      showTooltip: true,
      ref: ref2
    }), (0, import_react.createElement)(icon_default2, {
      icon
    }));
  }
  var ToggleGroupControlOptionIcon = (0, import_react.forwardRef)(UnforwardedToggleGroupControlOptionIcon);
  var component_default15 = ToggleGroupControlOptionIcon;

  // node_modules/@wordpress/components/build-module/form-toggle/index.js
  var import_classnames13 = __toESM(require_classnames());
  var noop9 = () => {
  };
  function FormToggle(props) {
    const {
      className,
      checked,
      id: id2,
      disabled,
      onChange = noop9,
      ...additionalProps
    } = props;
    const wrapperClasses = (0, import_classnames13.default)("components-form-toggle", className, {
      "is-checked": checked,
      "is-disabled": disabled
    });
    return (0, import_react.createElement)("span", {
      className: wrapperClasses
    }, (0, import_react.createElement)("input", _extends({
      className: "components-form-toggle__input",
      id: id2,
      type: "checkbox",
      checked,
      onChange,
      disabled
    }, additionalProps)), (0, import_react.createElement)("span", {
      className: "components-form-toggle__track"
    }), (0, import_react.createElement)("span", {
      className: "components-form-toggle__thumb"
    }));
  }
  var form_toggle_default = FormToggle;

  // node_modules/@wordpress/components/build-module/menu-group/index.js
  var import_classnames14 = __toESM(require_classnames());
  function MenuGroup(props) {
    const {
      children,
      className = "",
      label,
      hideSeparator
    } = props;
    const instanceId = use_instance_id_default(MenuGroup);
    if (!import_react.Children.count(children)) {
      return null;
    }
    const labelId = `components-menu-group-label-${instanceId}`;
    const classNames4 = (0, import_classnames14.default)(className, "components-menu-group", {
      "has-hidden-separator": hideSeparator
    });
    return (0, import_react.createElement)("div", {
      className: classNames4
    }, label && (0, import_react.createElement)("div", {
      className: "components-menu-group__label",
      id: labelId,
      "aria-hidden": "true"
    }, label), (0, import_react.createElement)("div", {
      role: "group",
      "aria-labelledby": label ? labelId : null
    }, children));
  }
  var menu_group_default = MenuGroup;

  // node_modules/@wordpress/components/build-module/menu-item/index.js
  var import_classnames15 = __toESM(require_classnames());
  function MenuItem(props, ref2) {
    let {
      children,
      info,
      className,
      icon,
      iconPosition = "right",
      shortcut,
      isSelected,
      role = "menuitem",
      suffix,
      ...buttonProps
    } = props;
    className = (0, import_classnames15.default)("components-menu-item__button", className);
    if (info) {
      children = (0, import_react.createElement)("span", {
        className: "components-menu-item__info-wrapper"
      }, (0, import_react.createElement)("span", {
        className: "components-menu-item__item"
      }, children), (0, import_react.createElement)("span", {
        className: "components-menu-item__info"
      }, info));
    }
    if (icon && typeof icon !== "string") {
      icon = (0, import_react.cloneElement)(icon, {
        className: (0, import_classnames15.default)("components-menu-items__item-icon", {
          "has-icon-right": iconPosition === "right"
        })
      });
    }
    return (0, import_react.createElement)(button_default, _extends({
      ref: ref2,
      "aria-checked": role === "menuitemcheckbox" || role === "menuitemradio" ? isSelected : void 0,
      role,
      icon: iconPosition === "left" ? icon : void 0,
      className
    }, buttonProps), (0, import_react.createElement)("span", {
      className: "components-menu-item__item"
    }, children), !suffix && (0, import_react.createElement)(shortcut_default, {
      className: "components-menu-item__shortcut",
      shortcut
    }), !suffix && icon && iconPosition === "right" && (0, import_react.createElement)(icon_default2, {
      icon
    }), suffix);
  }
  var menu_item_default = (0, import_react.forwardRef)(MenuItem);

  // node_modules/@wordpress/components/build-module/search-control/index.js
  var import_classnames16 = __toESM(require_classnames());
  function UnforwardedSearchControl(_ref8, forwardedRef) {
    let {
      __nextHasNoMarginBottom,
      className,
      onChange,
      onKeyDown,
      value,
      label,
      placeholder = __("Search"),
      hideLabelFromVision = true,
      help,
      onClose,
      ...restProps
    } = _ref8;
    const searchRef = (0, import_react.useRef)();
    const instanceId = use_instance_id_default(SearchControl);
    const id2 = `components-search-control-${instanceId}`;
    const renderRightButton = () => {
      if (onClose) {
        return (0, import_react.createElement)(button_default, {
          icon: close_small_default,
          label: __("Close search"),
          onClick: onClose
        });
      }
      if (!!value) {
        return (0, import_react.createElement)(button_default, {
          icon: close_small_default,
          label: __("Reset search"),
          onClick: () => {
            var _searchRef$current;
            onChange("");
            (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 ? void 0 : _searchRef$current.focus();
          }
        });
      }
      return (0, import_react.createElement)(icon_default, {
        icon: search_default
      });
    };
    return (0, import_react.createElement)(base_control_default, {
      __nextHasNoMarginBottom,
      label,
      id: id2,
      hideLabelFromVision,
      help,
      className: (0, import_classnames16.default)(className, "components-search-control")
    }, (0, import_react.createElement)("div", {
      className: "components-search-control__input-wrapper"
    }, (0, import_react.createElement)("input", _extends({}, restProps, {
      ref: useMergeRefs([searchRef, forwardedRef]),
      className: "components-search-control__input",
      id: id2,
      type: "search",
      placeholder,
      onChange: (event) => onChange(event.target.value),
      onKeyDown,
      autoComplete: "off",
      value: value || ""
    })), (0, import_react.createElement)("div", {
      className: "components-search-control__icon"
    }, renderRightButton())));
  }
  var SearchControl = (0, import_react.forwardRef)(UnforwardedSearchControl);
  var search_control_default = SearchControl;

  // node_modules/@wordpress/components/build-module/navigator/context.js
  var initialContextValue = {
    location: {},
    goTo: () => {
    },
    goBack: () => {
    }
  };
  var NavigatorContext = (0, import_react.createContext)(initialContextValue);

  // node_modules/@wordpress/components/build-module/navigator/navigator-provider/component.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__14() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var _ref6 = false ? {
    name: "15bx5k",
    styles: "overflow-x:hidden"
  } : {
    name: "192ebb7-classes",
    styles: "overflow-x:hidden;label:classes;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbmF2aWdhdG9yL25hdmlnYXRvci1wcm92aWRlci9jb21wb25lbnQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXNGWSIsImZpbGUiOiJAd29yZHByZXNzL2NvbXBvbmVudHMvc3JjL25hdmlnYXRvci9uYXZpZ2F0b3ItcHJvdmlkZXIvY29tcG9uZW50LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCB0eXBlIHsgRm9yd2FyZGVkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIFdvcmRQcmVzcyBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHtcblx0Y29udGV4dENvbm5lY3QsXG5cdHVzZUNvbnRleHRTeXN0ZW0sXG5cdFdvcmRQcmVzc0NvbXBvbmVudFByb3BzLFxufSBmcm9tICcuLi8uLi91aS9jb250ZXh0JztcbmltcG9ydCB7IHVzZUN4IH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9va3MvdXNlLWN4JztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi8uLi92aWV3JztcbmltcG9ydCB7IE5hdmlnYXRvckNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB0eXBlIHtcblx0TmF2aWdhdG9yUHJvdmlkZXJQcm9wcyxcblx0TmF2aWdhdG9yTG9jYXRpb24sXG5cdE5hdmlnYXRvckNvbnRleHQgYXMgTmF2aWdhdG9yQ29udGV4dFR5cGUsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZnVuY3Rpb24gVW5jb25uZWN0ZWROYXZpZ2F0b3JQcm92aWRlcihcblx0cHJvcHM6IFdvcmRQcmVzc0NvbXBvbmVudFByb3BzPCBOYXZpZ2F0b3JQcm92aWRlclByb3BzLCAnZGl2JyA+LFxuXHRmb3J3YXJkZWRSZWY6IEZvcndhcmRlZFJlZjwgYW55ID5cbikge1xuXHRjb25zdCB7IGluaXRpYWxQYXRoLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5vdGhlclByb3BzIH0gPVxuXHRcdHVzZUNvbnRleHRTeXN0ZW0oIHByb3BzLCAnTmF2aWdhdG9yUHJvdmlkZXInICk7XG5cblx0Y29uc3QgWyBsb2NhdGlvbkhpc3RvcnksIHNldExvY2F0aW9uSGlzdG9yeSBdID0gdXNlU3RhdGU8XG5cdFx0TmF2aWdhdG9yTG9jYXRpb25bXVxuXHQ+KCBbXG5cdFx0e1xuXHRcdFx0cGF0aDogaW5pdGlhbFBhdGgsXG5cdFx0fSxcblx0XSApO1xuXG5cdGNvbnN0IGdvVG86IE5hdmlnYXRvckNvbnRleHRUeXBlWyAnZ29UbycgXSA9IHVzZUNhbGxiYWNrKFxuXHRcdCggcGF0aCwgb3B0aW9ucyA9IHt9ICkgPT4ge1xuXHRcdFx0c2V0TG9jYXRpb25IaXN0b3J5KCBbXG5cdFx0XHRcdC4uLmxvY2F0aW9uSGlzdG9yeSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRpc0JhY2s6IGZhbHNlLFxuXHRcdFx0XHRcdGhhc1Jlc3RvcmVkRm9jdXM6IGZhbHNlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XSApO1xuXHRcdH0sXG5cdFx0WyBsb2NhdGlvbkhpc3RvcnkgXVxuXHQpO1xuXG5cdGNvbnN0IGdvQmFjazogTmF2aWdhdG9yQ29udGV4dFR5cGVbICdnb0JhY2snIF0gPSB1c2VDYWxsYmFjayggKCkgPT4ge1xuXHRcdGlmICggbG9jYXRpb25IaXN0b3J5Lmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRzZXRMb2NhdGlvbkhpc3RvcnkoIFtcblx0XHRcdFx0Li4ubG9jYXRpb25IaXN0b3J5LnNsaWNlKCAwLCAtMiApLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Li4ubG9jYXRpb25IaXN0b3J5WyBsb2NhdGlvbkhpc3RvcnkubGVuZ3RoIC0gMiBdLFxuXHRcdFx0XHRcdGlzQmFjazogdHJ1ZSxcblx0XHRcdFx0XHRoYXNSZXN0b3JlZEZvY3VzOiBmYWxzZSxcblx0XHRcdFx0fSxcblx0XHRcdF0gKTtcblx0XHR9XG5cdH0sIFsgbG9jYXRpb25IaXN0b3J5IF0gKTtcblxuXHRjb25zdCBuYXZpZ2F0b3JDb250ZXh0VmFsdWU6IE5hdmlnYXRvckNvbnRleHRUeXBlID0gdXNlTWVtbyhcblx0XHQoKSA9PiAoIHtcblx0XHRcdGxvY2F0aW9uOiB7XG5cdFx0XHRcdC4uLmxvY2F0aW9uSGlzdG9yeVsgbG9jYXRpb25IaXN0b3J5Lmxlbmd0aCAtIDEgXSxcblx0XHRcdFx0aXNJbml0aWFsOiBsb2NhdGlvbkhpc3RvcnkubGVuZ3RoID09PSAxLFxuXHRcdFx0fSxcblx0XHRcdGdvVG8sXG5cdFx0XHRnb0JhY2ssXG5cdFx0fSApLFxuXHRcdFsgbG9jYXRpb25IaXN0b3J5LCBnb1RvLCBnb0JhY2sgXVxuXHQpO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblx0Y29uc3QgY2xhc3NlcyA9IHVzZU1lbW8oXG5cdFx0Ly8gUHJldmVudHMgaG9yaXpvbnRhbCBvdmVyZmxvdyB3aGlsZSBhbmltYXRpbmcgc2NyZWVuIHRyYW5zaXRpb25zLlxuXHRcdCgpID0+IGN4KCBjc3MoIHsgb3ZlcmZsb3dYOiAnaGlkZGVuJyB9ICksIGNsYXNzTmFtZSApLFxuXHRcdFsgY2xhc3NOYW1lLCBjeCBdXG5cdCk7XG5cblx0cmV0dXJuIChcblx0XHQ8VmlldyByZWY9eyBmb3J3YXJkZWRSZWYgfSBjbGFzc05hbWU9eyBjbGFzc2VzIH0geyAuLi5vdGhlclByb3BzIH0+XG5cdFx0XHQ8TmF2aWdhdG9yQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IG5hdmlnYXRvckNvbnRleHRWYWx1ZSB9PlxuXHRcdFx0XHR7IGNoaWxkcmVuIH1cblx0XHRcdDwvTmF2aWdhdG9yQ29udGV4dC5Qcm92aWRlcj5cblx0XHQ8L1ZpZXc+XG5cdCk7XG59XG5cbi8qKlxuICogVGhlIGBOYXZpZ2F0b3JQcm92aWRlcmAgY29tcG9uZW50IGFsbG93cyByZW5kZXJpbmcgbmVzdGVkIHZpZXdzL3BhbmVscy9tZW51c1xuICogKHZpYSB0aGUgYE5hdmlnYXRvclNjcmVlbmAgY29tcG9uZW50IGFuZCBuYXZpZ2F0ZSBiZXR3ZWVuIHRoZXNlIGRpZmZlcmVudFxuICogdmlldyAodmlhIHRoZSBgTmF2aWdhdG9yQnV0dG9uYCBhbmQgYE5hdmlnYXRvckJhY2tCdXR0b25gIGNvbXBvbmVudHMgb3IgdGhlXG4gKiBgdXNlTmF2aWdhdG9yYCBob29rKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQge1xuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvclByb3ZpZGVyIGFzIE5hdmlnYXRvclByb3ZpZGVyLFxuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvclNjcmVlbiBhcyBOYXZpZ2F0b3JTY3JlZW4sXG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yQnV0dG9uIGFzIE5hdmlnYXRvckJ1dHRvbixcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JCYWNrQnV0dG9uIGFzIE5hdmlnYXRvckJhY2tCdXR0b24sXG4gKiB9IGZyb20gJ0B3b3JkcHJlc3MvY29tcG9uZW50cyc7XG4gKlxuICogY29uc3QgTXlOYXZpZ2F0aW9uID0gKCkgPT4gKFxuICogICA8TmF2aWdhdG9yUHJvdmlkZXIgaW5pdGlhbFBhdGg9XCIvXCI+XG4gKiAgICAgPE5hdmlnYXRvclNjcmVlbiBwYXRoPVwiL1wiPlxuICogICAgICAgPHA+VGhpcyBpcyB0aGUgaG9tZSBzY3JlZW4uPC9wPlxuICogICAgICAgIDxOYXZpZ2F0b3JCdXR0b24gcGF0aD1cIi9jaGlsZFwiPlxuICogICAgICAgICAgTmF2aWdhdGUgdG8gY2hpbGQgc2NyZWVuLlxuICogICAgICAgPC9OYXZpZ2F0b3JCdXR0b24+XG4gKiAgICAgPC9OYXZpZ2F0b3JTY3JlZW4+XG4gKlxuICogICAgIDxOYXZpZ2F0b3JTY3JlZW4gcGF0aD1cIi9jaGlsZFwiPlxuICogICAgICAgPHA+VGhpcyBpcyB0aGUgY2hpbGQgc2NyZWVuLjwvcD5cbiAqICAgICAgIDxOYXZpZ2F0b3JCYWNrQnV0dG9uPlxuICogICAgICAgICBHbyBiYWNrXG4gKiAgICAgICA8L05hdmlnYXRvckJhY2tCdXR0b24+XG4gKiAgICAgPC9OYXZpZ2F0b3JTY3JlZW4+XG4gKiAgIDwvTmF2aWdhdG9yUHJvdmlkZXI+XG4gKiApO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZpZ2F0b3JQcm92aWRlciA9IGNvbnRleHRDb25uZWN0KFxuXHRVbmNvbm5lY3RlZE5hdmlnYXRvclByb3ZpZGVyLFxuXHQnTmF2aWdhdG9yUHJvdmlkZXInXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0b3JQcm92aWRlcjtcbiJdfQ== */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__14
  };
  function UnconnectedNavigatorProvider(props, forwardedRef) {
    const {
      initialPath,
      children,
      className,
      ...otherProps
    } = useContextSystem(props, "NavigatorProvider");
    const [locationHistory, setLocationHistory] = (0, import_react.useState)([{
      path: initialPath
    }]);
    const goTo = (0, import_react.useCallback)(function(path) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      setLocationHistory([...locationHistory, {
        ...options,
        path,
        isBack: false,
        hasRestoredFocus: false
      }]);
    }, [locationHistory]);
    const goBack = (0, import_react.useCallback)(() => {
      if (locationHistory.length > 1) {
        setLocationHistory([...locationHistory.slice(0, -2), {
          ...locationHistory[locationHistory.length - 2],
          isBack: true,
          hasRestoredFocus: false
        }]);
      }
    }, [locationHistory]);
    const navigatorContextValue = (0, import_react.useMemo)(() => ({
      location: {
        ...locationHistory[locationHistory.length - 1],
        isInitial: locationHistory.length === 1
      },
      goTo,
      goBack
    }), [locationHistory, goTo, goBack]);
    const cx = useCx();
    const classes = (0, import_react.useMemo)(
      () => cx(_ref6, className),
      [className, cx]
    );
    return (0, import_react.createElement)(component_default, _extends({
      ref: forwardedRef,
      className: classes
    }, otherProps), (0, import_react.createElement)(NavigatorContext.Provider, {
      value: navigatorContextValue
    }, children));
  }
  var NavigatorProvider = contextConnect(UnconnectedNavigatorProvider, "NavigatorProvider");
  var component_default16 = NavigatorProvider;

  // node_modules/@wordpress/components/build-module/navigator/navigator-screen/component.js
  function _EMOTION_STRINGIFIED_CSS_ERROR__15() {
    return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
  }
  var animationEnterDelay = 0;
  var animationEnterDuration = 0.14;
  var animationExitDuration = 0.14;
  var animationExitDelay = 0;
  var _ref7 = false ? {
    name: "14x3t6z",
    styles: "overflow-x:auto;max-height:100%"
  } : {
    name: "1ulogbc-classes",
    styles: "overflow-x:auto;max-height:100%;label:classes;",
    map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbmF2aWdhdG9yL25hdmlnYXRvci1zY3JlZW4vY29tcG9uZW50LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrRUkiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9uYXZpZ2F0b3IvbmF2aWdhdG9yLXNjcmVlbi9jb21wb25lbnQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBGb3J3YXJkZWRSZWYgfSBmcm9tICdyZWFjdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgeyBtb3Rpb24sIE1vdGlvblByb3BzIH0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBmb2N1cyB9IGZyb20gJ0B3b3JkcHJlc3MvZG9tJztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcbmltcG9ydCB7XG5cdHVzZVJlZHVjZWRNb3Rpb24sXG5cdHVzZU1lcmdlUmVmcyxcblx0dXNlUHJldmlvdXMsXG59IGZyb20gJ0B3b3JkcHJlc3MvY29tcG9zZSc7XG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5pbXBvcnQgeyBlc2NhcGVBdHRyaWJ1dGUgfSBmcm9tICdAd29yZHByZXNzL2VzY2FwZS1odG1sJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHtcblx0Y29udGV4dENvbm5lY3QsXG5cdHVzZUNvbnRleHRTeXN0ZW0sXG5cdFdvcmRQcmVzc0NvbXBvbmVudFByb3BzLFxufSBmcm9tICcuLi8uLi91aS9jb250ZXh0JztcbmltcG9ydCB7IHVzZUN4IH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9va3MvdXNlLWN4JztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi8uLi92aWV3JztcbmltcG9ydCB7IE5hdmlnYXRvckNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB0eXBlIHsgTmF2aWdhdG9yU2NyZWVuUHJvcHMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGFuaW1hdGlvbkVudGVyRGVsYXkgPSAwO1xuY29uc3QgYW5pbWF0aW9uRW50ZXJEdXJhdGlvbiA9IDAuMTQ7XG5jb25zdCBhbmltYXRpb25FeGl0RHVyYXRpb24gPSAwLjE0O1xuY29uc3QgYW5pbWF0aW9uRXhpdERlbGF5ID0gMDtcblxuLy8gUHJvcHMgc3BlY2lmaWMgdG8gYGZyYW1lci1tb3Rpb25gIGNhbid0IGJlIGN1cnJlbnRseSBwYXNzZWQgdG8gYE5hdmlnYXRvclNjcmVlbmAsXG4vLyBhcyBzb21lIG9mIHRoZW0gd291bGQgb3ZlcmxhcCB3aXRoIEhUTUwgcHJvcHMgKGUuZy4gYG9uQW5pbWF0aW9uU3RhcnRgLCAuLi4pXG50eXBlIFByb3BzID0gT21pdDxcblx0V29yZFByZXNzQ29tcG9uZW50UHJvcHM8IE5hdmlnYXRvclNjcmVlblByb3BzLCAnZGl2JywgZmFsc2UgPixcblx0a2V5b2YgTW90aW9uUHJvcHNcbj47XG5cbmZ1bmN0aW9uIFVuY29ubmVjdGVkTmF2aWdhdG9yU2NyZWVuKFxuXHRwcm9wczogUHJvcHMsXG5cdGZvcndhcmRlZFJlZjogRm9yd2FyZGVkUmVmPCBhbnkgPlxuKSB7XG5cdGNvbnN0IHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgcGF0aCwgLi4ub3RoZXJQcm9wcyB9ID0gdXNlQ29udGV4dFN5c3RlbShcblx0XHRwcm9wcyxcblx0XHQnTmF2aWdhdG9yU2NyZWVuJ1xuXHQpO1xuXG5cdGNvbnN0IHByZWZlcnNSZWR1Y2VkTW90aW9uID0gdXNlUmVkdWNlZE1vdGlvbigpO1xuXHRjb25zdCB7IGxvY2F0aW9uIH0gPSB1c2VDb250ZXh0KCBOYXZpZ2F0b3JDb250ZXh0ICk7XG5cdGNvbnN0IGlzTWF0Y2ggPSBsb2NhdGlvbi5wYXRoID09PSBlc2NhcGVBdHRyaWJ1dGUoIHBhdGggKTtcblx0Y29uc3Qgd3JhcHBlclJlZiA9IHVzZVJlZjwgSFRNTERpdkVsZW1lbnQgPiggbnVsbCApO1xuXG5cdGNvbnN0IHByZXZpb3VzTG9jYXRpb24gPSB1c2VQcmV2aW91cyggbG9jYXRpb24gKTtcblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cdGNvbnN0IGNsYXNzZXMgPSB1c2VNZW1vKFxuXHRcdCgpID0+XG5cdFx0XHRjeChcblx0XHRcdFx0Y3NzKCB7XG5cdFx0XHRcdFx0Ly8gRW5zdXJlcyBob3Jpem9udGFsIG92ZXJmbG93IGlzIHZpc3VhbGx5IGFjY2Vzc2libGUuXG5cdFx0XHRcdFx0b3ZlcmZsb3dYOiAnYXV0bycsXG5cdFx0XHRcdFx0Ly8gSW4gY2FzZSB0aGUgcm9vdCBoYXMgYSBoZWlnaHQsIGl0IHNob3VsZCBub3QgYmUgZXhjZWVkZWQuXG5cdFx0XHRcdFx0bWF4SGVpZ2h0OiAnMTAwJScsXG5cdFx0XHRcdH0gKSxcblx0XHRcdFx0Y2xhc3NOYW1lXG5cdFx0XHQpLFxuXHRcdFsgY2xhc3NOYW1lLCBjeCBdXG5cdCk7XG5cblx0Ly8gRm9jdXMgcmVzdG9yYXRpb25cblx0Y29uc3QgaXNJbml0aWFsTG9jYXRpb24gPSBsb2NhdGlvbi5pc0luaXRpYWwgJiYgISBsb2NhdGlvbi5pc0JhY2s7XG5cdHVzZUVmZmVjdCggKCkgPT4ge1xuXHRcdC8vIE9ubHkgYXR0ZW1wdCB0byByZXN0b3JlIGZvY3VzOlxuXHRcdC8vIC0gaWYgdGhlIGN1cnJlbnQgbG9jYXRpb24gaXMgbm90IHRoZSBpbml0aWFsIG9uZSAodG8gYXZvaWQgbW92aW5nIGZvY3VzIG9uIHBhZ2UgbG9hZClcblx0XHQvLyAtIHdoZW4gdGhlIHNjcmVlbiBiZWNvbWVzIHZpc2libGVcblx0XHQvLyAtIGlmIHRoZSB3cmFwcGVyIHJlZiBoYXMgYmVlbiBhc3NpZ25lZFxuXHRcdC8vIC0gaWYgZm9jdXMgaGFzbid0IGFscmVhZHkgYmVlbiByZXN0b3JlZCBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb25cblx0XHRpZiAoXG5cdFx0XHRpc0luaXRpYWxMb2NhdGlvbiB8fFxuXHRcdFx0ISBpc01hdGNoIHx8XG5cdFx0XHQhIHdyYXBwZXJSZWYuY3VycmVudCB8fFxuXHRcdFx0bG9jYXRpb24uaGFzUmVzdG9yZWRGb2N1c1xuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB3cmFwcGVyUmVmLmN1cnJlbnQub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0Ly8gSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQgd2l0aGluIHRoZSB3cmFwcGVyIGRvIG5vdCBmb2N1cyB0aGVcblx0XHQvLyBlbGVtZW50LiBUaGlzIHByZXZlbnRzIGlucHV0cyBvciBidXR0b25zIGZyb20gbG9zaW5nIGZvY3VzIHVubmVjZXNzYXJpbHkuXG5cdFx0aWYgKCB3cmFwcGVyUmVmLmN1cnJlbnQuY29udGFpbnMoIGFjdGl2ZUVsZW1lbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgZWxlbWVudFRvRm9jdXM6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0XHQvLyBXaGVuIG5hdmlnYXRpbmcgYmFjaywgaWYgYSBzZWxlY3RvciBpcyBwcm92aWRlZCwgdXNlIGl0IHRvIGxvb2sgZm9yIHRoZVxuXHRcdC8vIHRhcmdldCBlbGVtZW50IChhc3N1bWVkIHRvIGJlIGEgbm9kZSBpbnNpZGUgdGhlIGN1cnJlbnQgTmF2aWdhdG9yU2NyZWVuKVxuXHRcdGlmICggbG9jYXRpb24uaXNCYWNrICYmIHByZXZpb3VzTG9jYXRpb24/LmZvY3VzVGFyZ2V0U2VsZWN0b3IgKSB7XG5cdFx0XHRlbGVtZW50VG9Gb2N1cyA9IHdyYXBwZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKFxuXHRcdFx0XHRwcmV2aW91c0xvY2F0aW9uLmZvY3VzVGFyZ2V0U2VsZWN0b3Jcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHByZXZpb3VzIHF1ZXJ5IGRpZG4ndCBydW4gb3IgZmluZCBhbnkgZWxlbWVudCB0byBmb2N1cywgZmFsbGJhY2tcblx0XHQvLyB0byB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBpbiB0aGUgc2NyZWVuIChvciB0aGUgc2NyZWVuIGl0c2VsZikuXG5cdFx0aWYgKCAhIGVsZW1lbnRUb0ZvY3VzICkge1xuXHRcdFx0Y29uc3QgZmlyc3RUYWJiYWJsZSA9IChcblx0XHRcdFx0Zm9jdXMudGFiYmFibGUuZmluZCggd3JhcHBlclJlZi5jdXJyZW50ICkgYXMgSFRNTEVsZW1lbnRbXVxuXHRcdFx0IClbIDAgXTtcblx0XHRcdGVsZW1lbnRUb0ZvY3VzID0gZmlyc3RUYWJiYWJsZSA/PyB3cmFwcGVyUmVmLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0bG9jYXRpb24uaGFzUmVzdG9yZWRGb2N1cyA9IHRydWU7XG5cdFx0ZWxlbWVudFRvRm9jdXMuZm9jdXMoKTtcblx0fSwgW1xuXHRcdGlzSW5pdGlhbExvY2F0aW9uLFxuXHRcdGlzTWF0Y2gsXG5cdFx0bG9jYXRpb24uaGFzUmVzdG9yZWRGb2N1cyxcblx0XHRsb2NhdGlvbi5pc0JhY2ssXG5cdFx0cHJldmlvdXNMb2NhdGlvbj8uZm9jdXNUYXJnZXRTZWxlY3Rvcixcblx0XSApO1xuXG5cdGNvbnN0IG1lcmdlZFdyYXBwZXJSZWYgPSB1c2VNZXJnZVJlZnMoIFsgZm9yd2FyZGVkUmVmLCB3cmFwcGVyUmVmIF0gKTtcblxuXHRpZiAoICEgaXNNYXRjaCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICggcHJlZmVyc1JlZHVjZWRNb3Rpb24gKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxWaWV3XG5cdFx0XHRcdHJlZj17IG1lcmdlZFdyYXBwZXJSZWYgfVxuXHRcdFx0XHRjbGFzc05hbWU9eyBjbGFzc2VzIH1cblx0XHRcdFx0eyAuLi5vdGhlclByb3BzIH1cblx0XHRcdD5cblx0XHRcdFx0eyBjaGlsZHJlbiB9XG5cdFx0XHQ8L1ZpZXc+XG5cdFx0KTtcblx0fVxuXG5cdGNvbnN0IGFuaW1hdGUgPSB7XG5cdFx0b3BhY2l0eTogMSxcblx0XHR0cmFuc2l0aW9uOiB7XG5cdFx0XHRkZWxheTogYW5pbWF0aW9uRW50ZXJEZWxheSxcblx0XHRcdGR1cmF0aW9uOiBhbmltYXRpb25FbnRlckR1cmF0aW9uLFxuXHRcdFx0ZWFzZTogJ2Vhc2VJbk91dCcsXG5cdFx0fSxcblx0XHR4OiAwLFxuXHR9O1xuXHRjb25zdCBpbml0aWFsID0ge1xuXHRcdG9wYWNpdHk6IDAsXG5cdFx0eDpcblx0XHRcdCggaXNSVEwoKSAmJiBsb2NhdGlvbi5pc0JhY2sgKSB8fCAoICEgaXNSVEwoKSAmJiAhIGxvY2F0aW9uLmlzQmFjayApXG5cdFx0XHRcdD8gNTBcblx0XHRcdFx0OiAtNTAsXG5cdH07XG5cdGNvbnN0IGV4aXQgPSB7XG5cdFx0ZGVsYXk6IGFuaW1hdGlvbkV4aXREZWxheSxcblx0XHRvcGFjaXR5OiAwLFxuXHRcdHg6XG5cdFx0XHQoICEgaXNSVEwoKSAmJiBsb2NhdGlvbi5pc0JhY2sgKSB8fCAoIGlzUlRMKCkgJiYgISBsb2NhdGlvbi5pc0JhY2sgKVxuXHRcdFx0XHQ/IDUwXG5cdFx0XHRcdDogLTUwLFxuXHRcdHRyYW5zaXRpb246IHtcblx0XHRcdGR1cmF0aW9uOiBhbmltYXRpb25FeGl0RHVyYXRpb24sXG5cdFx0XHRlYXNlOiAnZWFzZUluT3V0Jyxcblx0XHR9LFxuXHR9O1xuXG5cdGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB7XG5cdFx0YW5pbWF0ZSxcblx0XHRleGl0LFxuXHRcdGluaXRpYWwsXG5cdH07XG5cblx0cmV0dXJuIChcblx0XHQ8bW90aW9uLmRpdlxuXHRcdFx0cmVmPXsgbWVyZ2VkV3JhcHBlclJlZiB9XG5cdFx0XHRjbGFzc05hbWU9eyBjbGFzc2VzIH1cblx0XHRcdHsgLi4ub3RoZXJQcm9wcyB9XG5cdFx0XHR7IC4uLmFuaW1hdGVkUHJvcHMgfVxuXHRcdD5cblx0XHRcdHsgY2hpbGRyZW4gfVxuXHRcdDwvbW90aW9uLmRpdj5cblx0KTtcbn1cblxuLyoqXG4gKiBUaGUgYE5hdmlnYXRvclNjcmVlbmAgY29tcG9uZW50IHJlcHJlc2VudHMgYSBzaW5nbGUgdmlldy9zY3JlZW4vcGFuZWwgYW5kXG4gKiBzaG91bGQgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBgTmF2aWdhdG9yUHJvdmlkZXJgLCB0aGVcbiAqIGBOYXZpZ2F0b3JCdXR0b25gIGFuZCB0aGUgYE5hdmlnYXRvckJhY2tCdXR0b25gIGNvbXBvbmVudHMgKG9yIHRoZSBgdXNlTmF2aWdhdG9yYFxuICogaG9vaykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHtcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JQcm92aWRlciBhcyBOYXZpZ2F0b3JQcm92aWRlcixcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JTY3JlZW4gYXMgTmF2aWdhdG9yU2NyZWVuLFxuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvckJ1dHRvbiBhcyBOYXZpZ2F0b3JCdXR0b24sXG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yQmFja0J1dHRvbiBhcyBOYXZpZ2F0b3JCYWNrQnV0dG9uLFxuICogfSBmcm9tICdAd29yZHByZXNzL2NvbXBvbmVudHMnO1xuICpcbiAqIGNvbnN0IE15TmF2aWdhdGlvbiA9ICgpID0+IChcbiAqICAgPE5hdmlnYXRvclByb3ZpZGVyIGluaXRpYWxQYXRoPVwiL1wiPlxuICogICAgIDxOYXZpZ2F0b3JTY3JlZW4gcGF0aD1cIi9cIj5cbiAqICAgICAgIDxwPlRoaXMgaXMgdGhlIGhvbWUgc2NyZWVuLjwvcD5cbiAqICAgICAgICA8TmF2aWdhdG9yQnV0dG9uIHBhdGg9XCIvY2hpbGRcIj5cbiAqICAgICAgICAgIE5hdmlnYXRlIHRvIGNoaWxkIHNjcmVlbi5cbiAqICAgICAgIDwvTmF2aWdhdG9yQnV0dG9uPlxuICogICAgIDwvTmF2aWdhdG9yU2NyZWVuPlxuICpcbiAqICAgICA8TmF2aWdhdG9yU2NyZWVuIHBhdGg9XCIvY2hpbGRcIj5cbiAqICAgICAgIDxwPlRoaXMgaXMgdGhlIGNoaWxkIHNjcmVlbi48L3A+XG4gKiAgICAgICA8TmF2aWdhdG9yQmFja0J1dHRvbj5cbiAqICAgICAgICAgR28gYmFja1xuICogICAgICAgPC9OYXZpZ2F0b3JCYWNrQnV0dG9uPlxuICogICAgIDwvTmF2aWdhdG9yU2NyZWVuPlxuICogICA8L05hdmlnYXRvclByb3ZpZGVyPlxuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgTmF2aWdhdG9yU2NyZWVuID0gY29udGV4dENvbm5lY3QoXG5cdFVuY29ubmVjdGVkTmF2aWdhdG9yU2NyZWVuLFxuXHQnTmF2aWdhdG9yU2NyZWVuJ1xuKTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdG9yU2NyZWVuO1xuIl19 */",
    toString: _EMOTION_STRINGIFIED_CSS_ERROR__15
  };
  function UnconnectedNavigatorScreen(props, forwardedRef) {
    const {
      children,
      className,
      path,
      ...otherProps
    } = useContextSystem(props, "NavigatorScreen");
    const prefersReducedMotion2 = use_reduced_motion_default();
    const {
      location
    } = (0, import_react.useContext)(NavigatorContext);
    const isMatch = location.path === escapeAttribute(path);
    const wrapperRef = (0, import_react.useRef)(null);
    const previousLocation = usePrevious(location);
    const cx = useCx();
    const classes = (0, import_react.useMemo)(() => cx(_ref7, className), [className, cx]);
    const isInitialLocation = location.isInitial && !location.isBack;
    (0, import_react.useEffect)(() => {
      if (isInitialLocation || !isMatch || !wrapperRef.current || location.hasRestoredFocus) {
        return;
      }
      const activeElement = wrapperRef.current.ownerDocument.activeElement;
      if (wrapperRef.current.contains(activeElement)) {
        return;
      }
      let elementToFocus = null;
      if (location.isBack && previousLocation !== null && previousLocation !== void 0 && previousLocation.focusTargetSelector) {
        elementToFocus = wrapperRef.current.querySelector(previousLocation.focusTargetSelector);
      }
      if (!elementToFocus) {
        const firstTabbable = focus.tabbable.find(wrapperRef.current)[0];
        elementToFocus = firstTabbable !== null && firstTabbable !== void 0 ? firstTabbable : wrapperRef.current;
      }
      location.hasRestoredFocus = true;
      elementToFocus.focus();
    }, [isInitialLocation, isMatch, location.hasRestoredFocus, location.isBack, previousLocation === null || previousLocation === void 0 ? void 0 : previousLocation.focusTargetSelector]);
    const mergedWrapperRef = useMergeRefs([forwardedRef, wrapperRef]);
    if (!isMatch) {
      return null;
    }
    if (prefersReducedMotion2) {
      return (0, import_react.createElement)(component_default, _extends({
        ref: mergedWrapperRef,
        className: classes
      }, otherProps), children);
    }
    const animate3 = {
      opacity: 1,
      transition: {
        delay: animationEnterDelay,
        duration: animationEnterDuration,
        ease: "easeInOut"
      },
      x: 0
    };
    const initial = {
      opacity: 0,
      x: isRTL() && location.isBack || !isRTL() && !location.isBack ? 50 : -50
    };
    const exit = {
      delay: animationExitDelay,
      opacity: 0,
      x: !isRTL() && location.isBack || isRTL() && !location.isBack ? 50 : -50,
      transition: {
        duration: animationExitDuration,
        ease: "easeInOut"
      }
    };
    const animatedProps = {
      animate: animate3,
      exit,
      initial
    };
    return (0, import_react.createElement)(motion.div, _extends({
      ref: mergedWrapperRef,
      className: classes
    }, otherProps, animatedProps), children);
  }
  var NavigatorScreen = contextConnect(UnconnectedNavigatorScreen, "NavigatorScreen");
  var component_default17 = NavigatorScreen;

  // node_modules/@wordpress/components/build-module/navigator/use-navigator.js
  function useNavigator() {
    const {
      location,
      goTo,
      goBack
    } = (0, import_react.useContext)(NavigatorContext);
    return {
      location,
      goTo,
      goBack
    };
  }
  var use_navigator_default = useNavigator;

  // node_modules/@wordpress/components/build-module/navigator/navigator-button/hook.js
  var cssSelectorForAttribute = (attrName, attrValue) => `[${attrName}="${attrValue}"]`;
  function useNavigatorButton(props) {
    const {
      path,
      onClick,
      as = button_default,
      attributeName = "id",
      ...otherProps
    } = useContextSystem(props, "NavigatorButton");
    const escapedPath = escapeAttribute(path);
    const {
      goTo
    } = use_navigator_default();
    const handleClick = (0, import_react.useCallback)((e4) => {
      e4.preventDefault();
      goTo(escapedPath, {
        focusTargetSelector: cssSelectorForAttribute(attributeName, escapedPath)
      });
      onClick === null || onClick === void 0 ? void 0 : onClick(e4);
    }, [goTo, onClick, attributeName, escapedPath]);
    return {
      as,
      onClick: handleClick,
      ...otherProps,
      [attributeName]: escapedPath
    };
  }

  // node_modules/@wordpress/components/build-module/navigator/navigator-button/component.js
  function UnconnectedNavigatorButton(props, forwardedRef) {
    const navigatorButtonProps = useNavigatorButton(props);
    return (0, import_react.createElement)(component_default, _extends({
      ref: forwardedRef
    }, navigatorButtonProps));
  }
  var NavigatorButton = contextConnect(UnconnectedNavigatorButton, "NavigatorButton");
  var component_default18 = NavigatorButton;

  // node_modules/@wordpress/components/build-module/navigator/navigator-back-button/hook.js
  function useNavigatorBackButton(props) {
    const {
      onClick,
      as = button_default,
      ...otherProps
    } = useContextSystem(props, "NavigatorBackButton");
    const {
      goBack
    } = use_navigator_default();
    const handleClick = (0, import_react.useCallback)((e4) => {
      e4.preventDefault();
      goBack();
      onClick === null || onClick === void 0 ? void 0 : onClick(e4);
    }, [goBack, onClick]);
    return {
      as,
      onClick: handleClick,
      ...otherProps
    };
  }

  // node_modules/@wordpress/components/build-module/navigator/navigator-back-button/component.js
  function UnconnectedNavigatorBackButton(props, forwardedRef) {
    const navigatorBackButtonProps = useNavigatorBackButton(props);
    return (0, import_react.createElement)(component_default, _extends({
      ref: forwardedRef
    }, navigatorBackButtonProps));
  }
  var NavigatorBackButton = contextConnect(UnconnectedNavigatorBackButton, "NavigatorBackButton");
  var component_default19 = NavigatorBackButton;

  // node_modules/@wordpress/components/build-module/tab-panel/index.js
  var import_classnames17 = __toESM(require_classnames());
  var import_lodash17 = __toESM(require_lodash());
  var TabButton = (_ref8) => {
    let {
      tabId,
      onClick,
      children,
      selected,
      ...rest
    } = _ref8;
    return (0, import_react.createElement)(button_default, _extends({
      role: "tab",
      tabIndex: selected ? null : -1,
      "aria-selected": selected,
      id: tabId,
      onClick
    }, rest), children);
  };
  function TabPanel(_ref22) {
    var _selectedTab$name;
    let {
      className,
      children,
      tabs,
      initialTabName,
      orientation = "horizontal",
      activeClass = "is-active",
      onSelect
    } = _ref22;
    const instanceId = use_instance_id_default(TabPanel, "tab-panel");
    const [selected, setSelected] = (0, import_react.useState)();
    const handleTabSelection = (tabKey) => {
      setSelected(tabKey);
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(tabKey);
    };
    const onNavigate = (_childIndex, child) => {
      child.click();
    };
    const selectedTab = (0, import_lodash17.find)(tabs, {
      name: selected
    });
    const selectedId = `${instanceId}-${(_selectedTab$name = selectedTab === null || selectedTab === void 0 ? void 0 : selectedTab.name) !== null && _selectedTab$name !== void 0 ? _selectedTab$name : "none"}`;
    (0, import_react.useEffect)(() => {
      if (!(selectedTab !== null && selectedTab !== void 0 && selectedTab.name) && tabs.length > 0) {
        handleTabSelection(initialTabName || tabs[0].name);
      }
    }, [tabs, selectedTab === null || selectedTab === void 0 ? void 0 : selectedTab.name, initialTabName]);
    return (0, import_react.createElement)("div", {
      className
    }, (0, import_react.createElement)(menu_default2, {
      role: "tablist",
      orientation,
      onNavigate,
      className: "components-tab-panel__tabs"
    }, tabs.map((tab) => (0, import_react.createElement)(TabButton, {
      className: (0, import_classnames17.default)("components-tab-panel__tabs-item", tab.className, {
        [activeClass]: tab.name === selected
      }),
      tabId: `${instanceId}-${tab.name}`,
      "aria-controls": `${instanceId}-${tab.name}-view`,
      selected: tab.name === selected,
      key: tab.name,
      onClick: () => handleTabSelection(tab.name)
    }, tab.title))), selectedTab && (0, import_react.createElement)("div", {
      key: selectedId,
      "aria-labelledby": selectedId,
      role: "tabpanel",
      id: `${selectedId}-view`,
      className: "components-tab-panel__tab-content"
    }, children(selectedTab)));
  }
  var tab_panel_default = TabPanel;

  // node_modules/@wordpress/components/build-module/tip/index.js
  function Tip(props) {
    const {
      children
    } = props;
    return (0, import_react.createElement)("div", {
      className: "components-tip"
    }, (0, import_react.createElement)(icon_default, {
      icon: tip_default
    }), (0, import_react.createElement)("p", null, children));
  }
  var tip_default2 = Tip;

  // node_modules/@wordpress/components/build-module/toggle-control/index.js
  var import_react84 = __toESM(require_emotion_react_cjs());
  function ToggleControl(_ref8) {
    let {
      __nextHasNoMarginBottom,
      label,
      checked,
      help,
      className,
      onChange,
      disabled
    } = _ref8;
    function onChangeToggle(event) {
      onChange(event.target.checked);
    }
    const instanceId = use_instance_id_default(ToggleControl);
    const id2 = `inspector-toggle-control-${instanceId}`;
    const cx = useCx();
    const classes = cx("components-toggle-control", className, !__nextHasNoMarginBottom && /* @__PURE__ */ (0, import_react84.css)({
      marginBottom: space(3)
    }, false ? "" : ";label:classes;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvdG9nZ2xlLWNvbnRyb2wvaW5kZXgudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZEK0IiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy90b2dnbGUtY29udHJvbC9pbmRleC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4dGVybmFsIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgdHlwZSB7IENoYW5nZUV2ZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vKipcbiAqIFdvcmRQcmVzcyBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHsgdXNlSW5zdGFuY2VJZCB9IGZyb20gJ0B3b3JkcHJlc3MvY29tcG9zZSc7XG5cbi8qKlxuICogSW50ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBGb3JtVG9nZ2xlIGZyb20gJy4uL2Zvcm0tdG9nZ2xlJztcbmltcG9ydCBCYXNlQ29udHJvbCBmcm9tICcuLi9iYXNlLWNvbnRyb2wnO1xuaW1wb3J0IHR5cGUgeyBXb3JkUHJlc3NDb21wb25lbnRQcm9wcyB9IGZyb20gJy4uL3VpL2NvbnRleHQvd29yZHByZXNzLWNvbXBvbmVudCc7XG5pbXBvcnQgdHlwZSB7IFRvZ2dsZUNvbnRyb2xQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgSFN0YWNrIH0gZnJvbSAnLi4vaC1zdGFjayc7XG5pbXBvcnQgeyB1c2VDeCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHNwYWNlIH0gZnJvbSAnLi4vdWkvdXRpbHMvc3BhY2UnO1xuXG4vKipcbiAqIFRvZ2dsZUNvbnRyb2wgaXMgdXNlZCB0byBnZW5lcmF0ZSBhIHRvZ2dsZSB1c2VyIGludGVyZmFjZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IFRvZ2dsZUNvbnRyb2wgfSBmcm9tICdAd29yZHByZXNzL2NvbXBvbmVudHMnO1xuICogaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdAd29yZHByZXNzL2VsZW1lbnQnO1xuICpcbiAqIGNvbnN0IE15VG9nZ2xlQ29udHJvbCA9ICgpID0+IHtcbiAqICAgY29uc3QgWyB2YWx1ZSwgc2V0VmFsdWUgXSA9IHVzZVN0YXRlKCBmYWxzZSApO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8VG9nZ2xlQ29udHJvbFxuICogICAgICAgbGFiZWw9XCJGaXhlZCBCYWNrZ3JvdW5kXCJcbiAqICAgICAgIGNoZWNrZWQ9eyB2YWx1ZSB9XG4gKiAgICAgICBvbkNoYW5nZT17ICgpID0+IHNldFZhbHVlKCAoIHN0YXRlICkgPT4gISBzdGF0ZSApIH1cbiAqICAgICAvPlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gVG9nZ2xlQ29udHJvbCgge1xuXHRfX25leHRIYXNOb01hcmdpbkJvdHRvbSxcblx0bGFiZWwsXG5cdGNoZWNrZWQsXG5cdGhlbHAsXG5cdGNsYXNzTmFtZSxcblx0b25DaGFuZ2UsXG5cdGRpc2FibGVkLFxufTogV29yZFByZXNzQ29tcG9uZW50UHJvcHM8IFRvZ2dsZUNvbnRyb2xQcm9wcywgJ2lucHV0JywgZmFsc2UgPiApIHtcblx0ZnVuY3Rpb24gb25DaGFuZ2VUb2dnbGUoIGV2ZW50OiBDaGFuZ2VFdmVudDwgSFRNTElucHV0RWxlbWVudCA+ICkge1xuXHRcdG9uQ2hhbmdlKCBldmVudC50YXJnZXQuY2hlY2tlZCApO1xuXHR9XG5cdGNvbnN0IGluc3RhbmNlSWQgPSB1c2VJbnN0YW5jZUlkKCBUb2dnbGVDb250cm9sICk7XG5cdGNvbnN0IGlkID0gYGluc3BlY3Rvci10b2dnbGUtY29udHJvbC0keyBpbnN0YW5jZUlkIH1gO1xuXG5cdGNvbnN0IGN4ID0gdXNlQ3goKTtcblx0Y29uc3QgY2xhc3NlcyA9IGN4KFxuXHRcdCdjb21wb25lbnRzLXRvZ2dsZS1jb250cm9sJyxcblx0XHRjbGFzc05hbWUsXG5cdFx0ISBfX25leHRIYXNOb01hcmdpbkJvdHRvbSAmJiBjc3MoIHsgbWFyZ2luQm90dG9tOiBzcGFjZSggMyApIH0gKVxuXHQpO1xuXG5cdGxldCBkZXNjcmliZWRCeSwgaGVscExhYmVsO1xuXHRpZiAoIGhlbHAgKSB7XG5cdFx0aWYgKCB0eXBlb2YgaGVscCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIGBoZWxwYCBhcyBhIGZ1bmN0aW9uIHdvcmtzIG9ubHkgZm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aGVyZVxuXHRcdFx0Ly8gYGNoZWNrZWRgIGlzIHBhc3NlZCBkb3duIGZyb20gcGFyZW50IGNvbXBvbmVudC4gVW5jb250cm9sbGVkXG5cdFx0XHQvLyBjb21wb25lbnQgY2FuIHNob3cgb25seSBhIHN0YXRpYyBoZWxwIGxhYmVsLlxuXHRcdFx0aWYgKCBjaGVja2VkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGhlbHBMYWJlbCA9IGhlbHAoIGNoZWNrZWQgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVscExhYmVsID0gaGVscDtcblx0XHR9XG5cdFx0aWYgKCBoZWxwTGFiZWwgKSB7XG5cdFx0XHRkZXNjcmliZWRCeSA9IGlkICsgJ19faGVscCc7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChcblx0XHQ8QmFzZUNvbnRyb2xcblx0XHRcdGlkPXsgaWQgfVxuXHRcdFx0aGVscD17IGhlbHBMYWJlbCB9XG5cdFx0XHRjbGFzc05hbWU9eyBjbGFzc2VzIH1cblx0XHRcdF9fbmV4dEhhc05vTWFyZ2luQm90dG9tXG5cdFx0PlxuXHRcdFx0PEhTdGFjayBqdXN0aWZ5PVwiZmxleC1zdGFydFwiIHNwYWNpbmc9eyAzIH0+XG5cdFx0XHRcdDxGb3JtVG9nZ2xlXG5cdFx0XHRcdFx0aWQ9eyBpZCB9XG5cdFx0XHRcdFx0Y2hlY2tlZD17IGNoZWNrZWQgfVxuXHRcdFx0XHRcdG9uQ2hhbmdlPXsgb25DaGFuZ2VUb2dnbGUgfVxuXHRcdFx0XHRcdGFyaWEtZGVzY3JpYmVkYnk9eyBkZXNjcmliZWRCeSB9XG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyBkaXNhYmxlZCB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxsYWJlbFxuXHRcdFx0XHRcdGh0bWxGb3I9eyBpZCB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiY29tcG9uZW50cy10b2dnbGUtY29udHJvbF9fbGFiZWxcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyBsYWJlbCB9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQ8L0hTdGFjaz5cblx0XHQ8L0Jhc2VDb250cm9sPlxuXHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGVDb250cm9sO1xuIl19 */"));
    let describedBy, helpLabel;
    if (help) {
      if (typeof help === "function") {
        if (checked !== void 0) {
          helpLabel = help(checked);
        }
      } else {
        helpLabel = help;
      }
      if (helpLabel) {
        describedBy = id2 + "__help";
      }
    }
    return (0, import_react.createElement)(base_control_default, {
      id: id2,
      help: helpLabel,
      className: classes,
      __nextHasNoMarginBottom: true
    }, (0, import_react.createElement)(component_default8, {
      justify: "flex-start",
      spacing: 3
    }, (0, import_react.createElement)(form_toggle_default, {
      id: id2,
      checked,
      onChange: onChangeToggle,
      "aria-describedby": describedBy,
      disabled
    }), (0, import_react.createElement)("label", {
      htmlFor: id2,
      className: "components-toggle-control__label"
    }, label)));
  }
  var toggle_control_default = ToggleControl;

  // node_modules/@wordpress/components/build-module/toolbar/index.js
  var import_classnames20 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/toolbar-group/index.js
  var import_classnames19 = __toESM(require_classnames());

  // node_modules/@wordpress/components/build-module/toolbar-button/index.js
  var import_classnames18 = __toESM(require_classnames());

  // node_modules/reakit/es/Toolbar/index.js
  var import_react85 = __toESM(require_react());

  // node_modules/@wordpress/components/build-module/toolbar-context/index.js
  var ToolbarContext = (0, import_react.createContext)();
  var toolbar_context_default = ToolbarContext;

  // node_modules/@wordpress/components/build-module/toolbar-item/index.js
  function ToolbarItem2(_ref8, ref2) {
    let {
      children,
      as: Component2,
      ...props
    } = _ref8;
    const accessibleToolbarState = (0, import_react.useContext)(toolbar_context_default);
    if (typeof children !== "function" && !Component2) {
      typeof process !== "undefined" && process.env && true ? warning4("`ToolbarItem` is a generic headless component. You must pass either a `children` prop as a function or an `as` prop as a component. See https://developer.wordpress.org/block-editor/components/toolbar-item/") : void 0;
      return null;
    }
    const allProps = {
      ...props,
      ref: ref2,
      "data-toolbar-item": true
    };
    if (!accessibleToolbarState) {
      if (Component2) {
        return (0, import_react.createElement)(Component2, allProps, children);
      }
      return children(allProps);
    }
    return (0, import_react.createElement)(ToolbarItem, _extends({}, accessibleToolbarState, allProps, {
      as: Component2
    }), children);
  }
  var toolbar_item_default = (0, import_react.forwardRef)(ToolbarItem2);

  // node_modules/@wordpress/components/build-module/toolbar-button/toolbar-button-container.js
  var ToolbarButtonContainer = (props) => (0, import_react.createElement)("div", {
    className: props.className
  }, props.children);
  var toolbar_button_container_default = ToolbarButtonContainer;

  // node_modules/@wordpress/components/build-module/toolbar-button/index.js
  function ToolbarButton(_ref8, ref2) {
    let {
      containerClassName,
      className,
      extraProps,
      children,
      title,
      isActive,
      isDisabled,
      ...props
    } = _ref8;
    const accessibleToolbarState = (0, import_react.useContext)(toolbar_context_default);
    if (!accessibleToolbarState) {
      return (0, import_react.createElement)(toolbar_button_container_default, {
        className: containerClassName
      }, (0, import_react.createElement)(button_default, _extends({
        ref: ref2,
        icon: props.icon,
        label: title,
        shortcut: props.shortcut,
        "data-subscript": props.subscript,
        onClick: (event) => {
          event.stopPropagation();
          if (props.onClick) {
            props.onClick(event);
          }
        },
        className: (0, import_classnames18.default)("components-toolbar__control", className),
        isPressed: isActive,
        disabled: isDisabled,
        "data-toolbar-item": true
      }, extraProps, props), children));
    }
    return (0, import_react.createElement)(toolbar_item_default, _extends({
      className: (0, import_classnames18.default)("components-toolbar-button", className)
    }, extraProps, props, {
      ref: ref2
    }), (toolbarItemProps) => (0, import_react.createElement)(button_default, _extends({
      label: title,
      isPressed: isActive,
      disabled: isDisabled
    }, toolbarItemProps), children));
  }
  var toolbar_button_default = (0, import_react.forwardRef)(ToolbarButton);

  // node_modules/@wordpress/components/build-module/toolbar-group/toolbar-group-container.js
  var ToolbarGroupContainer = (_ref8) => {
    let {
      className,
      children,
      ...props
    } = _ref8;
    return (0, import_react.createElement)("div", _extends({
      className
    }, props), children);
  };
  var toolbar_group_container_default = ToolbarGroupContainer;

  // node_modules/@wordpress/components/build-module/toolbar-group/toolbar-group-collapsed.js
  function ToolbarGroupCollapsed(_ref8) {
    let {
      controls = [],
      toggleProps,
      ...props
    } = _ref8;
    const accessibleToolbarState = (0, import_react.useContext)(toolbar_context_default);
    const renderDropdownMenu = (internalToggleProps) => (0, import_react.createElement)(dropdown_menu_default, _extends({
      controls,
      toggleProps: {
        ...internalToggleProps,
        "data-toolbar-item": true
      }
    }, props));
    if (accessibleToolbarState) {
      return (0, import_react.createElement)(toolbar_item_default, toggleProps, renderDropdownMenu);
    }
    return renderDropdownMenu(toggleProps);
  }
  var toolbar_group_collapsed_default = ToolbarGroupCollapsed;

  // node_modules/@wordpress/components/build-module/toolbar-group/index.js
  function ToolbarGroup(_ref8) {
    var _controlSets;
    let {
      controls = [],
      children,
      className,
      isCollapsed,
      title,
      ...props
    } = _ref8;
    const accessibleToolbarState = (0, import_react.useContext)(toolbar_context_default);
    if ((!controls || !controls.length) && !children) {
      return null;
    }
    const finalClassName = (0, import_classnames19.default)(
      accessibleToolbarState ? "components-toolbar-group" : "components-toolbar",
      className
    );
    let controlSets = controls;
    if (!Array.isArray(controlSets[0])) {
      controlSets = [controlSets];
    }
    if (isCollapsed) {
      return (0, import_react.createElement)(toolbar_group_collapsed_default, _extends({
        label: title,
        controls: controlSets,
        className: finalClassName,
        children
      }, props));
    }
    return (0, import_react.createElement)(toolbar_group_container_default, _extends({
      className: finalClassName
    }, props), (_controlSets = controlSets) === null || _controlSets === void 0 ? void 0 : _controlSets.flatMap((controlSet, indexOfSet) => controlSet.map((control, indexOfControl) => (0, import_react.createElement)(toolbar_button_default, _extends({
      key: [indexOfSet, indexOfControl].join(),
      containerClassName: indexOfSet > 0 && indexOfControl === 0 ? "has-left-divider" : null
    }, control)))), children);
  }
  var toolbar_group_default = ToolbarGroup;

  // node_modules/@wordpress/components/build-module/toolbar/toolbar-container.js
  function ToolbarContainer(_ref8, ref2) {
    let {
      label,
      ...props
    } = _ref8;
    const toolbarState = useToolbarState({
      loop: true,
      baseId: props.id,
      rtl: isRTL()
    });
    return (0, import_react.createElement)(toolbar_context_default.Provider, {
      value: toolbarState
    }, (0, import_react.createElement)(Toolbar, _extends({
      ref: ref2,
      "aria-label": label
    }, toolbarState, props)));
  }
  var toolbar_container_default = (0, import_react.forwardRef)(ToolbarContainer);

  // node_modules/@wordpress/components/build-module/toolbar/index.js
  function Toolbar2(_ref8, ref2) {
    let {
      className,
      label,
      ...props
    } = _ref8;
    if (!label) {
      deprecated("Using Toolbar without label prop", {
        since: "5.6",
        alternative: "ToolbarGroup component",
        link: "https://developer.wordpress.org/block-editor/components/toolbar/"
      });
      return (0, import_react.createElement)(toolbar_group_default, _extends({}, props, {
        className
      }));
    }
    const finalClassName = (0, import_classnames20.default)("components-accessible-toolbar", className);
    return (0, import_react.createElement)(toolbar_container_default, _extends({
      className: finalClassName,
      label,
      ref: ref2
    }, props));
  }
  var toolbar_default = (0, import_react.forwardRef)(Toolbar2);

  // node_modules/@wordpress/components/build-module/toolbar-dropdown-menu/index.js
  function ToolbarDropdownMenu(props, ref2) {
    const accessibleToolbarState = (0, import_react.useContext)(toolbar_context_default);
    if (!accessibleToolbarState) {
      return (0, import_react.createElement)(dropdown_menu_default, props);
    }
    return (0, import_react.createElement)(toolbar_item_default, _extends({
      ref: ref2
    }, props.toggleProps), (toolbarItemProps) => (0, import_react.createElement)(dropdown_menu_default, _extends({}, props, {
      popoverProps: {
        variant: "toolbar",
        ...props.popoverProps
      },
      toggleProps: toolbarItemProps
    })));
  }
  var toolbar_dropdown_menu_default = (0, import_react.forwardRef)(ToolbarDropdownMenu);

  // node_modules/@wordpress/components/build-module/higher-order/with-filters/index.js
  var ANIMATION_FRAME_PERIOD = 16;
  function withFilters(hookName) {
    return createHigherOrderComponent((OriginalComponent) => {
      const namespace = "core/with-filters/" + hookName;
      let FilteredComponent;
      function ensureFilteredComponent() {
        if (FilteredComponent === void 0) {
          FilteredComponent = applyFilters(hookName, OriginalComponent);
        }
      }
      class FilteredComponentRenderer extends import_react.Component {
        constructor() {
          super(...arguments);
          ensureFilteredComponent();
        }
        componentDidMount() {
          FilteredComponentRenderer.instances.push(this);
          if (FilteredComponentRenderer.instances.length === 1) {
            addAction("hookRemoved", namespace, onHooksUpdated);
            addAction("hookAdded", namespace, onHooksUpdated);
          }
        }
        componentWillUnmount() {
          FilteredComponentRenderer.instances = FilteredComponentRenderer.instances.filter((instance) => instance !== this);
          if (FilteredComponentRenderer.instances.length === 0) {
            removeAction("hookRemoved", namespace);
            removeAction("hookAdded", namespace);
          }
        }
        render() {
          return (0, import_react.createElement)(FilteredComponent, this.props);
        }
      }
      FilteredComponentRenderer.instances = [];
      const throttledForceUpdate = debounce(() => {
        FilteredComponent = applyFilters(hookName, OriginalComponent);
        FilteredComponentRenderer.instances.forEach((instance) => {
          instance.forceUpdate();
        });
      }, ANIMATION_FRAME_PERIOD);
      function onHooksUpdated(updatedHookName) {
        if (updatedHookName === hookName) {
          throttledForceUpdate();
        }
      }
      return FilteredComponentRenderer;
    }, "withFilters");
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-context/index.js
  var Context4 = (0, import_react.createContext)({});
  function BlockContextProvider(_ref8) {
    let {
      value,
      children
    } = _ref8;
    const context2 = (0, import_react.useContext)(Context4);
    const nextValue = (0, import_react.useMemo)(() => ({
      ...context2,
      ...value
    }), [context2, value]);
    return (0, import_react.createElement)(Context4.Provider, {
      value: nextValue,
      children
    });
  }
  var block_context_default = Context4;

  // node_modules/@wordpress/block-editor/build-module/components/block-edit/edit.js
  var DEFAULT_BLOCK_CONTEXT = {};
  var Edit = (props) => {
    const {
      attributes = {},
      name
    } = props;
    const blockType = getBlockType(name);
    const blockContext = (0, import_react.useContext)(block_context_default);
    const context2 = (0, import_react.useMemo)(() => {
      return blockType && blockType.usesContext ? (0, import_lodash18.pick)(blockContext, blockType.usesContext) : DEFAULT_BLOCK_CONTEXT;
    }, [blockType, blockContext]);
    if (!blockType) {
      return null;
    }
    const Component2 = blockType.edit || blockType.save;
    if (blockType.apiVersion > 1) {
      return (0, import_react.createElement)(Component2, _extends({}, props, {
        context: context2
      }));
    }
    const generatedClassName = hasBlockSupport(blockType, "className", true) ? getBlockDefaultClassName(name) : null;
    const className = (0, import_classnames21.default)(generatedClassName, attributes.className, props.className);
    return (0, import_react.createElement)(Component2, _extends({}, props, {
      context: context2,
      className
    }));
  };
  var edit_default = withFilters("editor.BlockEdit")(Edit);

  // node_modules/@wordpress/block-editor/build-module/components/block-edit/context.js
  var DEFAULT_BLOCK_EDIT_CONTEXT = {
    name: "",
    isSelected: false
  };
  var Context5 = (0, import_react.createContext)(DEFAULT_BLOCK_EDIT_CONTEXT);
  var {
    Provider: Provider6
  } = Context5;
  function useBlockEditContext() {
    return (0, import_react.useContext)(Context5);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-edit/index.js
  function BlockEdit(props) {
    const {
      name,
      isSelected,
      clientId,
      __unstableLayoutClassNames
    } = props;
    const context2 = {
      name,
      isSelected,
      clientId,
      __unstableLayoutClassNames
    };
    return (0, import_react.createElement)(
      Provider6,
      {
        value: (0, import_react.useMemo)(() => context2, Object.values(context2))
      },
      (0, import_react.createElement)(edit_default, props)
    );
  }

  // node_modules/@wordpress/block-editor/build-module/store/reducer.js
  var import_lodash19 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/store/defaults.js
  var PREFERENCES_DEFAULTS = {
    insertUsage: {}
  };
  var SETTINGS_DEFAULTS = {
    alignWide: false,
    supportsLayout: true,
    colors: [{
      name: __("Black"),
      slug: "black",
      color: "#000000"
    }, {
      name: __("Cyan bluish gray"),
      slug: "cyan-bluish-gray",
      color: "#abb8c3"
    }, {
      name: __("White"),
      slug: "white",
      color: "#ffffff"
    }, {
      name: __("Pale pink"),
      slug: "pale-pink",
      color: "#f78da7"
    }, {
      name: __("Vivid red"),
      slug: "vivid-red",
      color: "#cf2e2e"
    }, {
      name: __("Luminous vivid orange"),
      slug: "luminous-vivid-orange",
      color: "#ff6900"
    }, {
      name: __("Luminous vivid amber"),
      slug: "luminous-vivid-amber",
      color: "#fcb900"
    }, {
      name: __("Light green cyan"),
      slug: "light-green-cyan",
      color: "#7bdcb5"
    }, {
      name: __("Vivid green cyan"),
      slug: "vivid-green-cyan",
      color: "#00d084"
    }, {
      name: __("Pale cyan blue"),
      slug: "pale-cyan-blue",
      color: "#8ed1fc"
    }, {
      name: __("Vivid cyan blue"),
      slug: "vivid-cyan-blue",
      color: "#0693e3"
    }, {
      name: __("Vivid purple"),
      slug: "vivid-purple",
      color: "#9b51e0"
    }],
    fontSizes: [{
      name: _x("Small", "font size name"),
      size: 13,
      slug: "small"
    }, {
      name: _x("Normal", "font size name"),
      size: 16,
      slug: "normal"
    }, {
      name: _x("Medium", "font size name"),
      size: 20,
      slug: "medium"
    }, {
      name: _x("Large", "font size name"),
      size: 36,
      slug: "large"
    }, {
      name: _x("Huge", "font size name"),
      size: 42,
      slug: "huge"
    }],
    imageDefaultSize: "large",
    imageSizes: [{
      slug: "thumbnail",
      name: __("Thumbnail")
    }, {
      slug: "medium",
      name: __("Medium")
    }, {
      slug: "large",
      name: __("Large")
    }, {
      slug: "full",
      name: __("Full Size")
    }],
    imageEditing: true,
    maxWidth: 580,
    allowedBlockTypes: true,
    maxUploadFileSize: 0,
    allowedMimeTypes: null,
    canLockBlocks: true,
    __experimentalCanUserUseUnfilteredHTML: false,
    __experimentalClearBlockSelection: true,
    __experimentalBlockDirectory: false,
    __mobileEnablePageTemplates: false,
    __experimentalBlockPatterns: [],
    __experimentalBlockPatternCategories: [],
    __unstableGalleryWithImageBlocks: false,
    __unstableIsPreviewMode: false,
    generateAnchors: false,
    gradients: [{
      name: __("Vivid cyan blue to vivid purple"),
      gradient: "linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)",
      slug: "vivid-cyan-blue-to-vivid-purple"
    }, {
      name: __("Light green cyan to vivid green cyan"),
      gradient: "linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)",
      slug: "light-green-cyan-to-vivid-green-cyan"
    }, {
      name: __("Luminous vivid amber to luminous vivid orange"),
      gradient: "linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)",
      slug: "luminous-vivid-amber-to-luminous-vivid-orange"
    }, {
      name: __("Luminous vivid orange to vivid red"),
      gradient: "linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)",
      slug: "luminous-vivid-orange-to-vivid-red"
    }, {
      name: __("Very light gray to cyan bluish gray"),
      gradient: "linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)",
      slug: "very-light-gray-to-cyan-bluish-gray"
    }, {
      name: __("Cool to warm spectrum"),
      gradient: "linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)",
      slug: "cool-to-warm-spectrum"
    }, {
      name: __("Blush light purple"),
      gradient: "linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)",
      slug: "blush-light-purple"
    }, {
      name: __("Blush bordeaux"),
      gradient: "linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)",
      slug: "blush-bordeaux"
    }, {
      name: __("Luminous dusk"),
      gradient: "linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)",
      slug: "luminous-dusk"
    }, {
      name: __("Pale ocean"),
      gradient: "linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)",
      slug: "pale-ocean"
    }, {
      name: __("Electric grass"),
      gradient: "linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)",
      slug: "electric-grass"
    }, {
      name: __("Midnight"),
      gradient: "linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)",
      slug: "midnight"
    }],
    __unstableResolvedAssets: {
      styles: [],
      scripts: []
    }
  };

  // node_modules/@wordpress/block-editor/build-module/store/array.js
  function insertAt(array, elements, index2) {
    return [...array.slice(0, index2), ...Array.isArray(elements) ? elements : [elements], ...array.slice(index2)];
  }
  function moveTo(array, from, to2) {
    let count = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    const withoutMovedElements = [...array];
    withoutMovedElements.splice(from, count);
    return insertAt(withoutMovedElements, array.slice(from, from + count), to2);
  }

  // node_modules/@wordpress/block-editor/build-module/store/reducer.js
  var identity3 = (x4) => x4;
  function mapBlockOrder(blocks2) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const result = {
      [rootClientId]: []
    };
    blocks2.forEach((block4) => {
      const {
        clientId,
        innerBlocks
      } = block4;
      result[rootClientId].push(clientId);
      Object.assign(result, mapBlockOrder(innerBlocks, clientId));
    });
    return result;
  }
  function mapBlockParents(blocks2) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return blocks2.reduce((result, block4) => Object.assign(result, {
      [block4.clientId]: rootClientId
    }, mapBlockParents(block4.innerBlocks, block4.clientId)), {});
  }
  function flattenBlocks(blocks2) {
    let transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity3;
    const result = {};
    const stack4 = [...blocks2];
    while (stack4.length) {
      const {
        innerBlocks,
        ...block4
      } = stack4.shift();
      stack4.push(...innerBlocks);
      result[block4.clientId] = transform(block4);
    }
    return result;
  }
  function getFlattenedBlocksWithoutAttributes(blocks2) {
    return flattenBlocks(blocks2, (block4) => (0, import_lodash19.omit)(block4, "attributes"));
  }
  function getFlattenedBlockAttributes(blocks2) {
    return flattenBlocks(blocks2, (block4) => block4.attributes);
  }
  function getMutateSafeObject(original, working) {
    if (original === working) {
      return {
        ...original
      };
    }
    return working;
  }
  function hasSameKeys(a6, b6) {
    return (0, import_lodash19.isEqual)(Object.keys(a6), Object.keys(b6));
  }
  function isUpdatingSameBlockAttribute(action, lastAction) {
    return action.type === "UPDATE_BLOCK_ATTRIBUTES" && lastAction !== void 0 && lastAction.type === "UPDATE_BLOCK_ATTRIBUTES" && (0, import_lodash19.isEqual)(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
  }
  function buildBlockTree(state, blocks2) {
    const result = {};
    const stack4 = [...blocks2];
    const flattenedBlocks = [...blocks2];
    while (stack4.length) {
      const block4 = stack4.shift();
      stack4.push(...block4.innerBlocks);
      flattenedBlocks.push(...block4.innerBlocks);
    }
    for (const block4 of flattenedBlocks) {
      result[block4.clientId] = {};
    }
    for (const block4 of flattenedBlocks) {
      result[block4.clientId] = Object.assign(result[block4.clientId], {
        ...state.byClientId[block4.clientId],
        attributes: state.attributes[block4.clientId],
        innerBlocks: block4.innerBlocks.map((subBlock) => result[subBlock.clientId])
      });
    }
    return result;
  }
  function updateParentInnerBlocksInTree(state, tree, updatedClientIds) {
    let updateChildrenOfUpdatedClientIds = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const uncontrolledParents = /* @__PURE__ */ new Set([]);
    const controlledParents = /* @__PURE__ */ new Set();
    for (const clientId of updatedClientIds) {
      let current = updateChildrenOfUpdatedClientIds ? clientId : state.parents[clientId];
      do {
        if (state.controlledInnerBlocks[current]) {
          controlledParents.add(current);
          break;
        } else {
          uncontrolledParents.add(current);
          current = state.parents[current];
        }
      } while (current !== void 0);
    }
    for (const clientId of uncontrolledParents) {
      tree[clientId] = {
        ...tree[clientId]
      };
    }
    for (const clientId of uncontrolledParents) {
      tree[clientId].innerBlocks = (state.order[clientId] || []).map((subClientId) => tree[subClientId]);
    }
    for (const clientId of controlledParents) {
      tree["controlled||" + clientId] = {
        innerBlocks: (state.order[clientId] || []).map((subClientId) => tree[subClientId])
      };
    }
    return tree;
  }
  var withBlockTree = (reducer3) => function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    const newState = reducer3(state, action);
    if (newState === state) {
      return state;
    }
    newState.tree = state.tree ? state.tree : {};
    switch (action.type) {
      case "RECEIVE_BLOCKS":
      case "INSERT_BLOCKS": {
        const subTree = buildBlockTree(newState, action.blocks);
        newState.tree = updateParentInnerBlocksInTree(newState, {
          ...newState.tree,
          ...subTree
        }, action.rootClientId ? [action.rootClientId] : [""], true);
        break;
      }
      case "UPDATE_BLOCK":
        newState.tree = updateParentInnerBlocksInTree(newState, {
          ...newState.tree,
          [action.clientId]: {
            ...newState.tree[action.clientId],
            ...newState.byClientId[action.clientId],
            attributes: newState.attributes[action.clientId]
          }
        }, [action.clientId], false);
        break;
      case "UPDATE_BLOCK_ATTRIBUTES": {
        const newSubTree = action.clientIds.reduce((result, clientId) => {
          result[clientId] = {
            ...newState.tree[clientId],
            attributes: newState.attributes[clientId]
          };
          return result;
        }, {});
        newState.tree = updateParentInnerBlocksInTree(newState, {
          ...newState.tree,
          ...newSubTree
        }, action.clientIds, false);
        break;
      }
      case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
        const subTree = buildBlockTree(newState, action.blocks);
        newState.tree = updateParentInnerBlocksInTree(newState, {
          ...(0, import_lodash19.omit)(newState.tree, action.replacedClientIds.concat(
            action.replacedClientIds.filter((clientId) => !subTree[clientId]).map((clientId) => "controlled||" + clientId)
          )),
          ...subTree
        }, action.blocks.map((b6) => b6.clientId), false);
        const parentsOfRemovedBlocks2 = [];
        for (const clientId of action.clientIds) {
          if (state.parents[clientId] !== void 0 && (state.parents[clientId] === "" || newState.byClientId[state.parents[clientId]])) {
            parentsOfRemovedBlocks2.push(state.parents[clientId]);
          }
        }
        newState.tree = updateParentInnerBlocksInTree(newState, newState.tree, parentsOfRemovedBlocks2, true);
        break;
      }
      case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
        const parentsOfRemovedBlocks = [];
        for (const clientId of action.clientIds) {
          if (state.parents[clientId] !== void 0 && (state.parents[clientId] === "" || newState.byClientId[state.parents[clientId]])) {
            parentsOfRemovedBlocks.push(state.parents[clientId]);
          }
        }
        newState.tree = updateParentInnerBlocksInTree(newState, (0, import_lodash19.omit)(newState.tree, action.removedClientIds.concat(action.removedClientIds.map((clientId) => "controlled||" + clientId))), parentsOfRemovedBlocks, true);
        break;
      case "MOVE_BLOCKS_TO_POSITION": {
        const updatedBlockUids = [];
        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        } else {
          updatedBlockUids.push("");
        }
        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }
        newState.tree = updateParentInnerBlocksInTree(newState, newState.tree, updatedBlockUids, true);
        break;
      }
      case "MOVE_BLOCKS_UP":
      case "MOVE_BLOCKS_DOWN": {
        const updatedBlockUids = [action.rootClientId ? action.rootClientId : ""];
        newState.tree = updateParentInnerBlocksInTree(newState, newState.tree, updatedBlockUids, true);
        break;
      }
      case "SAVE_REUSABLE_BLOCK_SUCCESS": {
        const updatedBlockUids = Object.entries(newState.attributes).filter((_ref8) => {
          let [clientId, attributes] = _ref8;
          return newState.byClientId[clientId].name === "core/block" && attributes.ref === action.updatedId;
        }).map((_ref22) => {
          let [clientId] = _ref22;
          return clientId;
        });
        newState.tree = updateParentInnerBlocksInTree(newState, {
          ...newState.tree,
          ...updatedBlockUids.reduce((result, clientId) => {
            result[clientId] = {
              ...newState.byClientId[clientId],
              attributes: newState.attributes[clientId],
              innerBlocks: newState.tree[clientId].innerBlocks
            };
            return result;
          }, {})
        }, updatedBlockUids, false);
      }
    }
    return newState;
  };
  function withPersistentBlockChange(reducer3) {
    let lastAction;
    let markNextChangeAsNotPersistent = false;
    return (state, action) => {
      let nextState = reducer3(state, action);
      const isExplicitPersistentChange = action.type === "MARK_LAST_CHANGE_AS_PERSISTENT" || markNextChangeAsNotPersistent;
      if (state === nextState && !isExplicitPersistentChange) {
        var _state$isPersistentCh;
        markNextChangeAsNotPersistent = action.type === "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT";
        const nextIsPersistentChange = (_state$isPersistentCh = state === null || state === void 0 ? void 0 : state.isPersistentChange) !== null && _state$isPersistentCh !== void 0 ? _state$isPersistentCh : true;
        if (state.isPersistentChange === nextIsPersistentChange) {
          return state;
        }
        return {
          ...nextState,
          isPersistentChange: nextIsPersistentChange
        };
      }
      nextState = {
        ...nextState,
        isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
      };
      lastAction = action;
      markNextChangeAsNotPersistent = action.type === "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT";
      return nextState;
    };
  }
  function withIgnoredBlockChange(reducer3) {
    const IGNORED_ACTION_TYPES = /* @__PURE__ */ new Set(["RECEIVE_BLOCKS"]);
    return (state, action) => {
      const nextState = reducer3(state, action);
      if (nextState !== state) {
        nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
      }
      return nextState;
    };
  }
  var withInnerBlocksRemoveCascade = (reducer3) => (state, action) => {
    const getAllChildren = (clientIds) => {
      let result = clientIds;
      for (let i5 = 0; i5 < result.length; i5++) {
        if (!state.order[result[i5]] || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i5]]) {
          continue;
        }
        if (result === clientIds) {
          result = [...result];
        }
        result.push(...state.order[result[i5]]);
      }
      return result;
    };
    if (state) {
      switch (action.type) {
        case "REMOVE_BLOCKS":
          action = {
            ...action,
            type: "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN",
            removedClientIds: getAllChildren(action.clientIds)
          };
          break;
        case "REPLACE_BLOCKS":
          action = {
            ...action,
            type: "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN",
            replacedClientIds: getAllChildren(action.clientIds)
          };
          break;
      }
    }
    return reducer3(state, action);
  };
  var withBlockReset = (reducer3) => (state, action) => {
    if (action.type === "RESET_BLOCKS") {
      const newState = {
        ...state,
        byClientId: getFlattenedBlocksWithoutAttributes(action.blocks),
        attributes: getFlattenedBlockAttributes(action.blocks),
        order: mapBlockOrder(action.blocks),
        parents: mapBlockParents(action.blocks),
        controlledInnerBlocks: {}
      };
      const subTree = buildBlockTree(newState, action.blocks);
      newState.tree = {
        ...subTree,
        "": {
          innerBlocks: action.blocks.map((subBlock) => subTree[subBlock.clientId])
        }
      };
      return newState;
    }
    return reducer3(state, action);
  };
  var withReplaceInnerBlocks = (reducer3) => (state, action) => {
    if (action.type !== "REPLACE_INNER_BLOCKS") {
      return reducer3(state, action);
    }
    const nestedControllers = {};
    if (Object.keys(state.controlledInnerBlocks).length) {
      const stack4 = [...action.blocks];
      while (stack4.length) {
        const {
          innerBlocks,
          ...block4
        } = stack4.shift();
        stack4.push(...innerBlocks);
        if (!!state.controlledInnerBlocks[block4.clientId]) {
          nestedControllers[block4.clientId] = true;
        }
      }
    }
    let stateAfterBlocksRemoval = state;
    if (state.order[action.rootClientId]) {
      stateAfterBlocksRemoval = reducer3(stateAfterBlocksRemoval, {
        type: "REMOVE_BLOCKS",
        keepControlledInnerBlocks: nestedControllers,
        clientIds: state.order[action.rootClientId]
      });
    }
    let stateAfterInsert = stateAfterBlocksRemoval;
    if (action.blocks.length) {
      stateAfterInsert = reducer3(stateAfterInsert, {
        ...action,
        type: "INSERT_BLOCKS",
        index: 0
      });
      stateAfterInsert.order = {
        ...stateAfterInsert.order,
        ...(0, import_lodash19.reduce)(nestedControllers, (result, value, key) => {
          if (state.order[key]) {
            result[key] = state.order[key];
          }
          return result;
        }, {})
      };
      stateAfterInsert.tree = {
        ...stateAfterInsert.tree,
        ...(0, import_lodash19.reduce)(nestedControllers, (result, value, _key) => {
          const key = `controlled||${_key}`;
          if (state.tree[key]) {
            result[key] = state.tree[key];
          }
          return result;
        }, {})
      };
    }
    return stateAfterInsert;
  };
  var withSaveReusableBlock = (reducer3) => (state, action) => {
    if (state && action.type === "SAVE_REUSABLE_BLOCK_SUCCESS") {
      const {
        id: id2,
        updatedId
      } = action;
      if (id2 === updatedId) {
        return state;
      }
      state = {
        ...state
      };
      state.attributes = (0, import_lodash19.mapValues)(state.attributes, (attributes, clientId) => {
        const {
          name
        } = state.byClientId[clientId];
        if (name === "core/block" && attributes.ref === id2) {
          return {
            ...attributes,
            ref: updatedId
          };
        }
        return attributes;
      });
    }
    return reducer3(state, action);
  };
  var withResetControlledBlocks = (reducer3) => (state, action) => {
    if (action.type === "SET_HAS_CONTROLLED_INNER_BLOCKS") {
      const tempState = reducer3(state, {
        type: "REPLACE_INNER_BLOCKS",
        rootClientId: action.clientId,
        blocks: []
      });
      return reducer3(tempState, action);
    }
    return reducer3(state, action);
  };
  var blocks = pipe_default(
    combineReducers2,
    withSaveReusableBlock,
    withBlockTree,
    withInnerBlocksRemoveCascade,
    withReplaceInnerBlocks,
    withBlockReset,
    withPersistentBlockChange,
    withIgnoredBlockChange,
    withResetControlledBlocks
  )({
    byClientId() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let action = arguments.length > 1 ? arguments[1] : void 0;
      switch (action.type) {
        case "RECEIVE_BLOCKS":
        case "INSERT_BLOCKS":
          return {
            ...state,
            ...getFlattenedBlocksWithoutAttributes(action.blocks)
          };
        case "UPDATE_BLOCK":
          if (!state[action.clientId]) {
            return state;
          }
          const changes = (0, import_lodash19.omit)(action.updates, "attributes");
          if ((0, import_lodash19.isEmpty)(changes)) {
            return state;
          }
          return {
            ...state,
            [action.clientId]: {
              ...state[action.clientId],
              ...changes
            }
          };
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          if (!action.blocks) {
            return state;
          }
          return {
            ...(0, import_lodash19.omit)(state, action.replacedClientIds),
            ...getFlattenedBlocksWithoutAttributes(action.blocks)
          };
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          return (0, import_lodash19.omit)(state, action.removedClientIds);
      }
      return state;
    },
    attributes() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let action = arguments.length > 1 ? arguments[1] : void 0;
      switch (action.type) {
        case "RECEIVE_BLOCKS":
        case "INSERT_BLOCKS":
          return {
            ...state,
            ...getFlattenedBlockAttributes(action.blocks)
          };
        case "UPDATE_BLOCK":
          if (!state[action.clientId] || !action.updates.attributes) {
            return state;
          }
          return {
            ...state,
            [action.clientId]: {
              ...state[action.clientId],
              ...action.updates.attributes
            }
          };
        case "UPDATE_BLOCK_ATTRIBUTES": {
          if (action.clientIds.every((id2) => !state[id2])) {
            return state;
          }
          const next2 = action.clientIds.reduce((accumulator, id2) => ({
            ...accumulator,
            [id2]: (0, import_lodash19.reduce)(action.uniqueByBlock ? action.attributes[id2] : action.attributes, (result, value, key) => {
              if (value !== result[key]) {
                result = getMutateSafeObject(state[id2], result);
                result[key] = value;
              }
              return result;
            }, state[id2])
          }), {});
          if (action.clientIds.every((id2) => next2[id2] === state[id2])) {
            return state;
          }
          return {
            ...state,
            ...next2
          };
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          if (!action.blocks) {
            return state;
          }
          return {
            ...(0, import_lodash19.omit)(state, action.replacedClientIds),
            ...getFlattenedBlockAttributes(action.blocks)
          };
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          return (0, import_lodash19.omit)(state, action.removedClientIds);
      }
      return state;
    },
    order() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let action = arguments.length > 1 ? arguments[1] : void 0;
      switch (action.type) {
        case "RECEIVE_BLOCKS": {
          const blockOrder = mapBlockOrder(action.blocks);
          return {
            ...state,
            ...(0, import_lodash19.omit)(blockOrder, ""),
            "": ((state === null || state === void 0 ? void 0 : state[""]) || []).concat(blockOrder[""])
          };
        }
        case "INSERT_BLOCKS": {
          const {
            rootClientId = ""
          } = action;
          const subState = state[rootClientId] || [];
          const mappedBlocks = mapBlockOrder(action.blocks, rootClientId);
          const {
            index: index2 = subState.length
          } = action;
          return {
            ...state,
            ...mappedBlocks,
            [rootClientId]: insertAt(subState, mappedBlocks[rootClientId], index2)
          };
        }
        case "MOVE_BLOCKS_TO_POSITION": {
          var _state$fromRootClient, _state$fromRootClient2;
          const {
            fromRootClientId = "",
            toRootClientId = "",
            clientIds
          } = action;
          const {
            index: index2 = state[toRootClientId].length
          } = action;
          if (fromRootClientId === toRootClientId) {
            const subState = state[toRootClientId];
            const fromIndex = subState.indexOf(clientIds[0]);
            return {
              ...state,
              [toRootClientId]: moveTo(state[toRootClientId], fromIndex, index2, clientIds.length)
            };
          }
          return {
            ...state,
            [fromRootClientId]: (_state$fromRootClient = (_state$fromRootClient2 = state[fromRootClientId]) === null || _state$fromRootClient2 === void 0 ? void 0 : _state$fromRootClient2.filter((id2) => !clientIds.includes(id2))) !== null && _state$fromRootClient !== void 0 ? _state$fromRootClient : [],
            [toRootClientId]: insertAt(state[toRootClientId], clientIds, index2)
          };
        }
        case "MOVE_BLOCKS_UP": {
          const {
            clientIds,
            rootClientId = ""
          } = action;
          const firstClientId = clientIds[0];
          const subState = state[rootClientId];
          if (!subState.length || firstClientId === subState[0]) {
            return state;
          }
          const firstIndex = subState.indexOf(firstClientId);
          return {
            ...state,
            [rootClientId]: moveTo(subState, firstIndex, firstIndex - 1, clientIds.length)
          };
        }
        case "MOVE_BLOCKS_DOWN": {
          const {
            clientIds,
            rootClientId = ""
          } = action;
          const firstClientId = clientIds[0];
          const lastClientId = clientIds[clientIds.length - 1];
          const subState = state[rootClientId];
          if (!subState.length || lastClientId === subState[subState.length - 1]) {
            return state;
          }
          const firstIndex = subState.indexOf(firstClientId);
          return {
            ...state,
            [rootClientId]: moveTo(subState, firstIndex, firstIndex + 1, clientIds.length)
          };
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN": {
          const {
            clientIds
          } = action;
          if (!action.blocks) {
            return state;
          }
          const mappedBlocks = mapBlockOrder(action.blocks);
          return pipe_default([(nextState) => (0, import_lodash19.omit)(nextState, action.replacedClientIds), (nextState) => ({
            ...nextState,
            ...(0, import_lodash19.omit)(mappedBlocks, "")
          }), (nextState) => (0, import_lodash19.mapValues)(nextState, (subState) => (0, import_lodash19.reduce)(subState, (result, clientId) => {
            if (clientId === clientIds[0]) {
              return [...result, ...mappedBlocks[""]];
            }
            if (clientIds.indexOf(clientId) === -1) {
              result.push(clientId);
            }
            return result;
          }, []))])(state);
        }
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          return pipe_default([
            (nextState) => (0, import_lodash19.omit)(nextState, action.removedClientIds),
            (nextState) => (0, import_lodash19.mapValues)(nextState, (subState) => {
              var _subState$filter;
              return (_subState$filter = subState === null || subState === void 0 ? void 0 : subState.filter((id2) => !action.removedClientIds.includes(id2))) !== null && _subState$filter !== void 0 ? _subState$filter : [];
            })
          ])(state);
      }
      return state;
    },
    parents() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let action = arguments.length > 1 ? arguments[1] : void 0;
      switch (action.type) {
        case "RECEIVE_BLOCKS":
          return {
            ...state,
            ...mapBlockParents(action.blocks)
          };
        case "INSERT_BLOCKS":
          return {
            ...state,
            ...mapBlockParents(action.blocks, action.rootClientId || "")
          };
        case "MOVE_BLOCKS_TO_POSITION": {
          return {
            ...state,
            ...action.clientIds.reduce((accumulator, id2) => {
              accumulator[id2] = action.toRootClientId || "";
              return accumulator;
            }, {})
          };
        }
        case "REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          return {
            ...(0, import_lodash19.omit)(state, action.replacedClientIds),
            ...mapBlockParents(action.blocks, state[action.clientIds[0]])
          };
        case "REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN":
          return (0, import_lodash19.omit)(state, action.removedClientIds);
      }
      return state;
    },
    controlledInnerBlocks() {
      let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let {
        type,
        clientId,
        hasControlledInnerBlocks
      } = arguments.length > 1 ? arguments[1] : void 0;
      if (type === "SET_HAS_CONTROLLED_INNER_BLOCKS") {
        return {
          ...state,
          [clientId]: hasControlledInnerBlocks
        };
      }
      return state;
    }
  });
  function isTyping() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "START_TYPING":
        return true;
      case "STOP_TYPING":
        return false;
    }
    return state;
  }
  function draggedBlocks() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "START_DRAGGING_BLOCKS":
        return action.clientIds;
      case "STOP_DRAGGING_BLOCKS":
        return [];
    }
    return state;
  }
  function blockVisibility() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    if (action.type === "SET_BLOCK_VISIBILITY") {
      return {
        ...state,
        ...action.updates
      };
    }
    return state;
  }
  function selectionHelper() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "CLEAR_SELECTED_BLOCK": {
        if (state.clientId) {
          return {};
        }
        return state;
      }
      case "SELECT_BLOCK":
        if (action.clientId === state.clientId) {
          return state;
        }
        return {
          clientId: action.clientId
        };
      case "REPLACE_INNER_BLOCKS":
      case "INSERT_BLOCKS": {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }
        return {
          clientId: action.blocks[0].clientId
        };
      }
      case "REMOVE_BLOCKS":
        if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }
        return {};
      case "REPLACE_BLOCKS": {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }
        const blockToSelect = action.blocks[action.indexToSelect] || action.blocks[action.blocks.length - 1];
        if (!blockToSelect) {
          return {};
        }
        if (blockToSelect.clientId === state.clientId) {
          return state;
        }
        return {
          clientId: blockToSelect.clientId
        };
      }
    }
    return state;
  }
  function selection() {
    var _state$selectionStart, _state$selectionEnd, _state$selectionStart2, _state$selectionEnd2;
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "SELECTION_CHANGE":
        if (action.clientId) {
          return {
            selectionStart: {
              clientId: action.clientId,
              attributeKey: action.attributeKey,
              offset: action.startOffset
            },
            selectionEnd: {
              clientId: action.clientId,
              attributeKey: action.attributeKey,
              offset: action.endOffset
            }
          };
        }
        return {
          selectionStart: action.start || state.selectionStart,
          selectionEnd: action.end || state.selectionEnd
        };
      case "RESET_SELECTION":
        const {
          selectionStart,
          selectionEnd
        } = action;
        return {
          selectionStart,
          selectionEnd
        };
      case "MULTI_SELECT":
        const {
          start: start2,
          end
        } = action;
        if (start2 === ((_state$selectionStart = state.selectionStart) === null || _state$selectionStart === void 0 ? void 0 : _state$selectionStart.clientId) && end === ((_state$selectionEnd = state.selectionEnd) === null || _state$selectionEnd === void 0 ? void 0 : _state$selectionEnd.clientId)) {
          return state;
        }
        return {
          selectionStart: {
            clientId: start2
          },
          selectionEnd: {
            clientId: end
          }
        };
      case "RESET_BLOCKS":
        const startClientId = state === null || state === void 0 ? void 0 : (_state$selectionStart2 = state.selectionStart) === null || _state$selectionStart2 === void 0 ? void 0 : _state$selectionStart2.clientId;
        const endClientId = state === null || state === void 0 ? void 0 : (_state$selectionEnd2 = state.selectionEnd) === null || _state$selectionEnd2 === void 0 ? void 0 : _state$selectionEnd2.clientId;
        if (!startClientId && !endClientId) {
          return state;
        }
        if (!action.blocks.some((block4) => block4.clientId === startClientId)) {
          return {
            selectionStart: {},
            selectionEnd: {}
          };
        }
        if (!action.blocks.some((block4) => block4.clientId === endClientId)) {
          return {
            ...state,
            selectionEnd: state.selectionStart
          };
        }
    }
    return {
      selectionStart: selectionHelper(state.selectionStart, action),
      selectionEnd: selectionHelper(state.selectionEnd, action)
    };
  }
  function isMultiSelecting() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "START_MULTI_SELECT":
        return true;
      case "STOP_MULTI_SELECT":
        return false;
    }
    return state;
  }
  function isSelectionEnabled() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "TOGGLE_SELECTION":
        return action.isSelectionEnabled;
    }
    return state;
  }
  function initialPosition() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    if (action.type === "REPLACE_BLOCKS" && action.initialPosition !== void 0) {
      return action.initialPosition;
    } else if (["MULTI_SELECT", "SELECT_BLOCK", "RESET_SELECTION", "INSERT_BLOCKS", "REPLACE_INNER_BLOCKS"].includes(action.type)) {
      return action.initialPosition;
    }
    return state;
  }
  function blocksMode() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    if (action.type === "TOGGLE_BLOCK_MODE") {
      const {
        clientId
      } = action;
      return {
        ...state,
        [clientId]: state[clientId] && state[clientId] === "html" ? "visual" : "html"
      };
    }
    return state;
  }
  function insertionPoint() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "SHOW_INSERTION_POINT": {
        const {
          rootClientId,
          index: index2,
          __unstableWithInserter,
          operation
        } = action;
        const nextState = {
          rootClientId,
          index: index2,
          __unstableWithInserter,
          operation
        };
        return (0, import_lodash19.isEqual)(state, nextState) ? state : nextState;
      }
      case "HIDE_INSERTION_POINT":
        return null;
    }
    return state;
  }
  function template() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      isValid: true
    };
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "SET_TEMPLATE_VALIDITY":
        return {
          ...state,
          isValid: action.isValid
        };
    }
    return state;
  }
  function settings() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : SETTINGS_DEFAULTS;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "UPDATE_SETTINGS":
        return {
          ...state,
          ...action.settings
        };
    }
    return state;
  }
  function preferences() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : PREFERENCES_DEFAULTS;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "INSERT_BLOCKS":
      case "REPLACE_BLOCKS":
        return action.blocks.reduce((prevState, block4) => {
          const {
            attributes,
            name: blockName
          } = block4;
          const match = select(store).getActiveBlockVariation(blockName, attributes);
          let id2 = match !== null && match !== void 0 && match.name ? `${blockName}/${match.name}` : blockName;
          const insert2 = {
            name: id2
          };
          if (blockName === "core/block") {
            insert2.ref = attributes.ref;
            id2 += "/" + attributes.ref;
          }
          return {
            ...prevState,
            insertUsage: {
              ...prevState.insertUsage,
              [id2]: {
                time: action.time,
                count: prevState.insertUsage[id2] ? prevState.insertUsage[id2].count + 1 : 1,
                insert: insert2
              }
            }
          };
        }, state);
    }
    return state;
  }
  var blockListSettings = function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "REPLACE_BLOCKS":
      case "REMOVE_BLOCKS": {
        return (0, import_lodash19.omit)(state, action.clientIds);
      }
      case "UPDATE_BLOCK_LIST_SETTINGS": {
        const {
          clientId
        } = action;
        if (!action.settings) {
          if (state.hasOwnProperty(clientId)) {
            return (0, import_lodash19.omit)(state, clientId);
          }
          return state;
        }
        if ((0, import_lodash19.isEqual)(state[clientId], action.settings)) {
          return state;
        }
        return {
          ...state,
          [clientId]: action.settings
        };
      }
    }
    return state;
  };
  function editorMode() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "edit";
    let action = arguments.length > 1 ? arguments[1] : void 0;
    if (action.type === "INSERT_BLOCKS" && state === "navigation") {
      return "edit";
    }
    if (action.type === "SET_EDITOR_MODE") {
      return action.mode;
    }
    return state;
  }
  function hasBlockMovingClientId() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    if (action.type === "SET_BLOCK_MOVING_MODE") {
      return action.hasBlockMovingClientId;
    }
    if (action.type === "SET_EDITOR_MODE") {
      return null;
    }
    return state;
  }
  function lastBlockAttributesChange() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "UPDATE_BLOCK":
        if (!action.updates.attributes) {
          break;
        }
        return {
          [action.clientId]: action.updates.attributes
        };
      case "UPDATE_BLOCK_ATTRIBUTES":
        return action.clientIds.reduce((accumulator, id2) => ({
          ...accumulator,
          [id2]: action.uniqueByBlock ? action.attributes[id2] : action.attributes
        }), {});
    }
    return state;
  }
  function automaticChangeStatus(state, action) {
    switch (action.type) {
      case "MARK_AUTOMATIC_CHANGE":
        return "pending";
      case "MARK_AUTOMATIC_CHANGE_FINAL":
        if (state === "pending") {
          return "final";
        }
        return;
      case "SELECTION_CHANGE":
        if (state !== "final") {
          return state;
        }
        return;
      case "SET_BLOCK_VISIBILITY":
      case "START_TYPING":
      case "STOP_TYPING":
      case "UPDATE_BLOCK_LIST_SETTINGS":
        return state;
    }
  }
  function highlightedBlock(state, action) {
    switch (action.type) {
      case "TOGGLE_BLOCK_HIGHLIGHT":
        const {
          clientId,
          isHighlighted
        } = action;
        if (isHighlighted) {
          return clientId;
        } else if (state === clientId) {
          return null;
        }
        return state;
      case "SELECT_BLOCK":
        if (action.clientId !== state) {
          return null;
        }
    }
    return state;
  }
  function lastBlockInserted() {
    var _action$meta;
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "INSERT_BLOCKS":
        if (!action.blocks.length) {
          return state;
        }
        const clientId = action.blocks[0].clientId;
        const source = (_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : _action$meta.source;
        return {
          clientId,
          source
        };
      case "RESET_BLOCKS":
        return {};
    }
    return state;
  }
  function temporarilyEditingAsBlocks() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let action = arguments.length > 1 ? arguments[1] : void 0;
    if (action.type === "SET_TEMPORARILY_EDITING_AS_BLOCKS") {
      return action.temporarilyEditingAsBlocks;
    }
    return state;
  }
  var reducer_default4 = combineReducers2({
    blocks,
    isTyping,
    draggedBlocks,
    selection,
    isMultiSelecting,
    isSelectionEnabled,
    initialPosition,
    blocksMode,
    blockListSettings,
    insertionPoint,
    template,
    settings,
    preferences,
    lastBlockAttributesChange,
    editorMode,
    hasBlockMovingClientId,
    automaticChangeStatus,
    highlightedBlock,
    lastBlockInserted,
    temporarilyEditingAsBlocks,
    blockVisibility
  });

  // node_modules/@wordpress/block-editor/build-module/store/selectors.js
  var selectors_exports4 = {};
  __export(selectors_exports4, {
    __experimentalGetActiveBlockIdByBlockNames: () => __experimentalGetActiveBlockIdByBlockNames,
    __experimentalGetAllowedBlocks: () => __experimentalGetAllowedBlocks,
    __experimentalGetAllowedPatterns: () => __experimentalGetAllowedPatterns,
    __experimentalGetBlockListSettingsForBlocks: () => __experimentalGetBlockListSettingsForBlocks,
    __experimentalGetDirectInsertBlock: () => __experimentalGetDirectInsertBlock,
    __experimentalGetGlobalBlocksByName: () => __experimentalGetGlobalBlocksByName,
    __experimentalGetLastBlockAttributeChanges: () => __experimentalGetLastBlockAttributeChanges,
    __experimentalGetParsedPattern: () => __experimentalGetParsedPattern,
    __experimentalGetPatternTransformItems: () => __experimentalGetPatternTransformItems,
    __experimentalGetPatternsByBlockTypes: () => __experimentalGetPatternsByBlockTypes,
    __experimentalGetReusableBlockTitle: () => __experimentalGetReusableBlockTitle,
    __unstableGetBlockWithoutInnerBlocks: () => __unstableGetBlockWithoutInnerBlocks,
    __unstableGetClientIdWithClientIdsTree: () => __unstableGetClientIdWithClientIdsTree,
    __unstableGetClientIdsTree: () => __unstableGetClientIdsTree,
    __unstableGetContentLockingParent: () => __unstableGetContentLockingParent,
    __unstableGetEditorMode: () => __unstableGetEditorMode,
    __unstableGetSelectedBlocksWithPartialSelection: () => __unstableGetSelectedBlocksWithPartialSelection,
    __unstableGetTemporarilyEditingAsBlocks: () => __unstableGetTemporarilyEditingAsBlocks,
    __unstableGetVisibleBlocks: () => __unstableGetVisibleBlocks,
    __unstableHasActiveBlockOverlayActive: () => __unstableHasActiveBlockOverlayActive,
    __unstableIsFullySelected: () => __unstableIsFullySelected,
    __unstableIsLastBlockChangeIgnored: () => __unstableIsLastBlockChangeIgnored,
    __unstableIsSelectionCollapsed: () => __unstableIsSelectionCollapsed,
    __unstableIsSelectionMergeable: () => __unstableIsSelectionMergeable,
    __unstableIsWithinBlockOverlay: () => __unstableIsWithinBlockOverlay,
    __unstableSelectionHasUnmergeableBlock: () => __unstableSelectionHasUnmergeableBlock,
    areInnerBlocksControlled: () => areInnerBlocksControlled,
    canEditBlock: () => canEditBlock,
    canInsertBlockType: () => canInsertBlockType,
    canInsertBlocks: () => canInsertBlocks,
    canLockBlockType: () => canLockBlockType,
    canMoveBlock: () => canMoveBlock,
    canMoveBlocks: () => canMoveBlocks,
    canRemoveBlock: () => canRemoveBlock,
    canRemoveBlocks: () => canRemoveBlocks,
    didAutomaticChange: () => didAutomaticChange,
    getAdjacentBlockClientId: () => getAdjacentBlockClientId,
    getBlock: () => getBlock,
    getBlockAttributes: () => getBlockAttributes2,
    getBlockCount: () => getBlockCount,
    getBlockHierarchyRootClientId: () => getBlockHierarchyRootClientId,
    getBlockIndex: () => getBlockIndex,
    getBlockInsertionPoint: () => getBlockInsertionPoint,
    getBlockListSettings: () => getBlockListSettings,
    getBlockMode: () => getBlockMode,
    getBlockName: () => getBlockName,
    getBlockOrder: () => getBlockOrder,
    getBlockParents: () => getBlockParents,
    getBlockParentsByBlockName: () => getBlockParentsByBlockName,
    getBlockRootClientId: () => getBlockRootClientId,
    getBlockSelectionEnd: () => getBlockSelectionEnd,
    getBlockSelectionStart: () => getBlockSelectionStart,
    getBlockTransformItems: () => getBlockTransformItems,
    getBlocks: () => getBlocks,
    getBlocksByClientId: () => getBlocksByClientId,
    getClientIdsOfDescendants: () => getClientIdsOfDescendants,
    getClientIdsWithDescendants: () => getClientIdsWithDescendants,
    getDraggedBlockClientIds: () => getDraggedBlockClientIds,
    getFirstMultiSelectedBlockClientId: () => getFirstMultiSelectedBlockClientId,
    getGlobalBlockCount: () => getGlobalBlockCount,
    getInserterItems: () => getInserterItems,
    getLastMultiSelectedBlockClientId: () => getLastMultiSelectedBlockClientId,
    getLowestCommonAncestorWithSelectedBlock: () => getLowestCommonAncestorWithSelectedBlock,
    getMultiSelectedBlockClientIds: () => getMultiSelectedBlockClientIds,
    getMultiSelectedBlocks: () => getMultiSelectedBlocks,
    getMultiSelectedBlocksEndClientId: () => getMultiSelectedBlocksEndClientId,
    getMultiSelectedBlocksStartClientId: () => getMultiSelectedBlocksStartClientId,
    getNextBlockClientId: () => getNextBlockClientId,
    getPreviousBlockClientId: () => getPreviousBlockClientId,
    getSelectedBlock: () => getSelectedBlock,
    getSelectedBlockClientId: () => getSelectedBlockClientId,
    getSelectedBlockClientIds: () => getSelectedBlockClientIds,
    getSelectedBlockCount: () => getSelectedBlockCount,
    getSelectedBlocksInitialCaretPosition: () => getSelectedBlocksInitialCaretPosition,
    getSelectionEnd: () => getSelectionEnd,
    getSelectionStart: () => getSelectionStart,
    getSettings: () => getSettings,
    getTemplate: () => getTemplate,
    getTemplateLock: () => getTemplateLock,
    hasBlockMovingClientId: () => hasBlockMovingClientId2,
    hasInserterItems: () => hasInserterItems,
    hasMultiSelection: () => hasMultiSelection,
    hasSelectedBlock: () => hasSelectedBlock,
    hasSelectedInnerBlock: () => hasSelectedInnerBlock,
    isAncestorBeingDragged: () => isAncestorBeingDragged,
    isAncestorMultiSelected: () => isAncestorMultiSelected,
    isBlockBeingDragged: () => isBlockBeingDragged,
    isBlockHighlighted: () => isBlockHighlighted,
    isBlockInsertionPointVisible: () => isBlockInsertionPointVisible,
    isBlockMultiSelected: () => isBlockMultiSelected,
    isBlockSelected: () => isBlockSelected,
    isBlockValid: () => isBlockValid,
    isBlockVisible: () => isBlockVisible,
    isBlockWithinSelection: () => isBlockWithinSelection,
    isCaretWithinFormattedText: () => isCaretWithinFormattedText,
    isDraggingBlocks: () => isDraggingBlocks,
    isFirstMultiSelectedBlock: () => isFirstMultiSelectedBlock,
    isLastBlockChangePersistent: () => isLastBlockChangePersistent,
    isMultiSelecting: () => isMultiSelecting2,
    isNavigationMode: () => isNavigationMode,
    isSelectionEnabled: () => isSelectionEnabled2,
    isTyping: () => isTyping2,
    isValidTemplate: () => isValidTemplate,
    wasBlockJustInserted: () => wasBlockJustInserted
  });
  var import_lodash20 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/store/utils.js
  function mapRichTextSettings(attributeDefinition) {
    const {
      multiline: multilineTag,
      __unstableMultilineWrapperTags: multilineWrapperTags,
      __unstablePreserveWhiteSpace: preserveWhiteSpace
    } = attributeDefinition;
    return {
      multilineTag,
      multilineWrapperTags,
      preserveWhiteSpace
    };
  }

  // node_modules/@wordpress/block-editor/build-module/store/selectors.js
  var MILLISECONDS_PER_HOUR = 3600 * 1e3;
  var MILLISECONDS_PER_DAY = 24 * 3600 * 1e3;
  var MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1e3;
  var EMPTY_ARRAY = [];
  function getBlockName(state, clientId) {
    const block4 = state.blocks.byClientId[clientId];
    const socialLinkName = "core/social-link";
    if (platform_default.OS !== "web" && (block4 === null || block4 === void 0 ? void 0 : block4.name) === socialLinkName) {
      const attributes = state.blocks.attributes[clientId];
      const {
        service
      } = attributes;
      return service ? `${socialLinkName}-${service}` : socialLinkName;
    }
    return block4 ? block4.name : null;
  }
  function isBlockValid(state, clientId) {
    const block4 = state.blocks.byClientId[clientId];
    return !!block4 && block4.isValid;
  }
  function getBlockAttributes2(state, clientId) {
    const block4 = state.blocks.byClientId[clientId];
    if (!block4) {
      return null;
    }
    return state.blocks.attributes[clientId];
  }
  function getBlock(state, clientId) {
    const block4 = state.blocks.byClientId[clientId];
    if (!block4) {
      return null;
    }
    return state.blocks.tree[clientId];
  }
  var __unstableGetBlockWithoutInnerBlocks = rememo_default((state, clientId) => {
    const block4 = state.blocks.byClientId[clientId];
    if (!block4) {
      return null;
    }
    return {
      ...block4,
      attributes: getBlockAttributes2(state, clientId)
    };
  }, (state, clientId) => [state.blocks.byClientId[clientId], state.blocks.attributes[clientId]]);
  function getBlocks(state, rootClientId) {
    var _state$blocks$tree$tr;
    const treeKey = !rootClientId || !areInnerBlocksControlled(state, rootClientId) ? rootClientId || "" : "controlled||" + rootClientId;
    return ((_state$blocks$tree$tr = state.blocks.tree[treeKey]) === null || _state$blocks$tree$tr === void 0 ? void 0 : _state$blocks$tree$tr.innerBlocks) || EMPTY_ARRAY;
  }
  var __unstableGetClientIdWithClientIdsTree = rememo_default((state, clientId) => ({
    clientId,
    innerBlocks: __unstableGetClientIdsTree(state, clientId)
  }), (state) => [state.blocks.order]);
  var __unstableGetClientIdsTree = rememo_default(function(state) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return (0, import_lodash20.map)(getBlockOrder(state, rootClientId), (clientId) => __unstableGetClientIdWithClientIdsTree(state, clientId));
  }, (state) => [state.blocks.order]);
  var getClientIdsOfDescendants = rememo_default((state, clientIds) => {
    const collectedIds = [];
    for (const givenId of clientIds) {
      for (const descendantId of getBlockOrder(state, givenId)) {
        collectedIds.push(descendantId, ...getClientIdsOfDescendants(state, [descendantId]));
      }
    }
    return collectedIds;
  }, (state) => [state.blocks.order]);
  var getClientIdsWithDescendants = rememo_default((state) => {
    const collectedIds = [];
    for (const topLevelId of getBlockOrder(state)) {
      collectedIds.push(topLevelId, ...getClientIdsOfDescendants(state, [topLevelId]));
    }
    return collectedIds;
  }, (state) => [state.blocks.order]);
  var getGlobalBlockCount = rememo_default((state, blockName) => {
    const clientIds = getClientIdsWithDescendants(state);
    if (!blockName) {
      return clientIds.length;
    }
    return (0, import_lodash20.reduce)(clientIds, (accumulator, clientId) => {
      const block4 = state.blocks.byClientId[clientId];
      return block4.name === blockName ? accumulator + 1 : accumulator;
    }, 0);
  }, (state) => [state.blocks.order, state.blocks.byClientId]);
  var __experimentalGetGlobalBlocksByName = rememo_default((state, blockName) => {
    if (!blockName) {
      return EMPTY_ARRAY;
    }
    const clientIds = getClientIdsWithDescendants(state);
    const foundBlocks = clientIds.filter((clientId) => {
      const block4 = state.blocks.byClientId[clientId];
      return block4.name === blockName;
    });
    return foundBlocks.length > 0 ? foundBlocks : EMPTY_ARRAY;
  }, (state) => [state.blocks.order, state.blocks.byClientId]);
  var getBlocksByClientId = rememo_default((state, clientIds) => (0, import_lodash20.map)(Array.isArray(clientIds) ? clientIds : [clientIds], (clientId) => getBlock(state, clientId)), (state, clientIds) => (0, import_lodash20.map)(Array.isArray(clientIds) ? clientIds : [clientIds], (clientId) => state.blocks.tree[clientId]));
  function getBlockCount(state, rootClientId) {
    return getBlockOrder(state, rootClientId).length;
  }
  function getSelectionStart(state) {
    return state.selection.selectionStart;
  }
  function getSelectionEnd(state) {
    return state.selection.selectionEnd;
  }
  function getBlockSelectionStart(state) {
    return state.selection.selectionStart.clientId;
  }
  function getBlockSelectionEnd(state) {
    return state.selection.selectionEnd.clientId;
  }
  function getSelectedBlockCount(state) {
    const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;
    if (multiSelectedBlockCount) {
      return multiSelectedBlockCount;
    }
    return state.selection.selectionStart.clientId ? 1 : 0;
  }
  function hasSelectedBlock(state) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
  }
  function getSelectedBlockClientId(state) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    const {
      clientId
    } = selectionStart;
    if (!clientId || clientId !== selectionEnd.clientId) {
      return null;
    }
    return clientId;
  }
  function getSelectedBlock(state) {
    const clientId = getSelectedBlockClientId(state);
    return clientId ? getBlock(state, clientId) : null;
  }
  function getBlockRootClientId(state, clientId) {
    return state.blocks.parents[clientId] !== void 0 ? state.blocks.parents[clientId] : null;
  }
  var getBlockParents = rememo_default(function(state, clientId) {
    let ascending = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const parents = [];
    let current = clientId;
    while (!!state.blocks.parents[current]) {
      current = state.blocks.parents[current];
      parents.push(current);
    }
    return ascending ? parents : parents.reverse();
  }, (state) => [state.blocks.parents]);
  var getBlockParentsByBlockName = rememo_default(function(state, clientId, blockName) {
    let ascending = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const parents = getBlockParents(state, clientId, ascending);
    return (0, import_lodash20.map)((0, import_lodash20.filter)((0, import_lodash20.map)(parents, (id2) => ({
      id: id2,
      name: getBlockName(state, id2)
    })), (_ref8) => {
      let {
        name
      } = _ref8;
      if (Array.isArray(blockName)) {
        return blockName.includes(name);
      }
      return name === blockName;
    }), (_ref22) => {
      let {
        id: id2
      } = _ref22;
      return id2;
    });
  }, (state) => [state.blocks.parents]);
  function getBlockHierarchyRootClientId(state, clientId) {
    let current = clientId;
    let parent;
    do {
      parent = current;
      current = state.blocks.parents[current];
    } while (current);
    return parent;
  }
  function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
    const selectedId = getSelectedBlockClientId(state);
    const clientParents = [...getBlockParents(state, clientId), clientId];
    const selectedParents = [...getBlockParents(state, selectedId), selectedId];
    let lowestCommonAncestor;
    const maxDepth2 = Math.min(clientParents.length, selectedParents.length);
    for (let index2 = 0; index2 < maxDepth2; index2++) {
      if (clientParents[index2] === selectedParents[index2]) {
        lowestCommonAncestor = clientParents[index2];
      } else {
        break;
      }
    }
    return lowestCommonAncestor;
  }
  function getAdjacentBlockClientId(state, startClientId) {
    let modifier = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (startClientId === void 0) {
      startClientId = getSelectedBlockClientId(state);
    }
    if (startClientId === void 0) {
      if (modifier < 0) {
        startClientId = getFirstMultiSelectedBlockClientId(state);
      } else {
        startClientId = getLastMultiSelectedBlockClientId(state);
      }
    }
    if (!startClientId) {
      return null;
    }
    const rootClientId = getBlockRootClientId(state, startClientId);
    if (rootClientId === null) {
      return null;
    }
    const {
      order: order2
    } = state.blocks;
    const orderSet = order2[rootClientId];
    const index2 = orderSet.indexOf(startClientId);
    const nextIndex = index2 + 1 * modifier;
    if (nextIndex < 0) {
      return null;
    }
    if (nextIndex === orderSet.length) {
      return null;
    }
    return orderSet[nextIndex];
  }
  function getPreviousBlockClientId(state, startClientId) {
    return getAdjacentBlockClientId(state, startClientId, -1);
  }
  function getNextBlockClientId(state, startClientId) {
    return getAdjacentBlockClientId(state, startClientId, 1);
  }
  function getSelectedBlocksInitialCaretPosition(state) {
    return state.initialPosition;
  }
  var getSelectedBlockClientIds = rememo_default((state) => {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    if (!selectionStart.clientId || !selectionEnd.clientId) {
      return EMPTY_ARRAY;
    }
    if (selectionStart.clientId === selectionEnd.clientId) {
      return [selectionStart.clientId];
    }
    const rootClientId = getBlockRootClientId(state, selectionStart.clientId);
    if (rootClientId === null) {
      return EMPTY_ARRAY;
    }
    const blockOrder = getBlockOrder(state, rootClientId);
    const startIndex = blockOrder.indexOf(selectionStart.clientId);
    const endIndex = blockOrder.indexOf(selectionEnd.clientId);
    if (startIndex > endIndex) {
      return blockOrder.slice(endIndex, startIndex + 1);
    }
    return blockOrder.slice(startIndex, endIndex + 1);
  }, (state) => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
  function getMultiSelectedBlockClientIds(state) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    if (selectionStart.clientId === selectionEnd.clientId) {
      return EMPTY_ARRAY;
    }
    return getSelectedBlockClientIds(state);
  }
  var getMultiSelectedBlocks = rememo_default((state) => {
    const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
    if (!multiSelectedBlockClientIds.length) {
      return EMPTY_ARRAY;
    }
    return multiSelectedBlockClientIds.map((clientId) => getBlock(state, clientId));
  }, (state) => [...getSelectedBlockClientIds.getDependants(state), state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
  function getFirstMultiSelectedBlockClientId(state) {
    return getMultiSelectedBlockClientIds(state)[0] || null;
  }
  function getLastMultiSelectedBlockClientId(state) {
    const selectedClientIds = getMultiSelectedBlockClientIds(state);
    return selectedClientIds[selectedClientIds.length - 1] || null;
  }
  function isFirstMultiSelectedBlock(state, clientId) {
    return getFirstMultiSelectedBlockClientId(state) === clientId;
  }
  function isBlockMultiSelected(state, clientId) {
    return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
  }
  var isAncestorMultiSelected = rememo_default((state, clientId) => {
    let ancestorClientId = clientId;
    let isMultiSelected = false;
    while (ancestorClientId && !isMultiSelected) {
      ancestorClientId = getBlockRootClientId(state, ancestorClientId);
      isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
    }
    return isMultiSelected;
  }, (state) => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
  function getMultiSelectedBlocksStartClientId(state) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    if (selectionStart.clientId === selectionEnd.clientId) {
      return null;
    }
    return selectionStart.clientId || null;
  }
  function getMultiSelectedBlocksEndClientId(state) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    if (selectionStart.clientId === selectionEnd.clientId) {
      return null;
    }
    return selectionEnd.clientId || null;
  }
  function __unstableIsFullySelected(state) {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    return !selectionAnchor.attributeKey && !selectionFocus.attributeKey && typeof selectionAnchor.offset === "undefined" && typeof selectionFocus.offset === "undefined";
  }
  function __unstableIsSelectionCollapsed(state) {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    return !!selectionAnchor && !!selectionFocus && selectionAnchor.clientId === selectionFocus.clientId && selectionAnchor.attributeKey === selectionFocus.attributeKey && selectionAnchor.offset === selectionFocus.offset;
  }
  function __unstableSelectionHasUnmergeableBlock(state) {
    return getSelectedBlockClientIds(state).some((clientId) => {
      const blockName = getBlockName(state, clientId);
      const blockType = getBlockType(blockName);
      return !blockType.merge;
    });
  }
  function __unstableIsSelectionMergeable(state, isForward) {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    if (selectionAnchor.clientId === selectionFocus.clientId)
      return false;
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined")
      return false;
    const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
    const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId);
    if (anchorRootClientId !== focusRootClientId) {
      return false;
    }
    const blockOrder = getBlockOrder(state, anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    let selectionStart, selectionEnd;
    if (anchorIndex > focusIndex) {
      selectionStart = selectionFocus;
      selectionEnd = selectionAnchor;
    } else {
      selectionStart = selectionAnchor;
      selectionEnd = selectionFocus;
    }
    const targetBlockClientId = isForward ? selectionEnd.clientId : selectionStart.clientId;
    const blockToMergeClientId = isForward ? selectionStart.clientId : selectionEnd.clientId;
    const targetBlockName = getBlockName(state, targetBlockClientId);
    const targetBlockType = getBlockType(targetBlockName);
    if (!targetBlockType.merge)
      return false;
    const blockToMerge = getBlock(state, blockToMergeClientId);
    if (blockToMerge.name === targetBlockName)
      return true;
    const blocksToMerge = switchToBlockType(blockToMerge, targetBlockName);
    return blocksToMerge && blocksToMerge.length;
  }
  var __unstableGetSelectedBlocksWithPartialSelection = (state) => {
    const selectionAnchor = getSelectionStart(state);
    const selectionFocus = getSelectionEnd(state);
    if (selectionAnchor.clientId === selectionFocus.clientId) {
      return EMPTY_ARRAY;
    }
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined") {
      return EMPTY_ARRAY;
    }
    const anchorRootClientId = getBlockRootClientId(state, selectionAnchor.clientId);
    const focusRootClientId = getBlockRootClientId(state, selectionFocus.clientId);
    if (anchorRootClientId !== focusRootClientId) {
      return EMPTY_ARRAY;
    }
    const blockOrder = getBlockOrder(state, anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    const [selectionStart, selectionEnd] = anchorIndex > focusIndex ? [selectionFocus, selectionAnchor] : [selectionAnchor, selectionFocus];
    const blockA = getBlock(state, selectionStart.clientId);
    const blockAType = getBlockType(blockA.name);
    const blockB = getBlock(state, selectionEnd.clientId);
    const blockBType = getBlockType(blockB.name);
    const htmlA = blockA.attributes[selectionStart.attributeKey];
    const htmlB = blockB.attributes[selectionEnd.attributeKey];
    const attributeDefinitionA = blockAType.attributes[selectionStart.attributeKey];
    const attributeDefinitionB = blockBType.attributes[selectionEnd.attributeKey];
    let valueA = create2({
      html: htmlA,
      ...mapRichTextSettings(attributeDefinitionA)
    });
    let valueB = create2({
      html: htmlB,
      ...mapRichTextSettings(attributeDefinitionB)
    });
    valueA = remove2(valueA, 0, selectionStart.offset);
    valueB = remove2(valueB, selectionEnd.offset, valueB.text.length);
    return [{
      ...blockA,
      attributes: {
        ...blockA.attributes,
        [selectionStart.attributeKey]: toHTMLString({
          value: valueA,
          ...mapRichTextSettings(attributeDefinitionA)
        })
      }
    }, {
      ...blockB,
      attributes: {
        ...blockB.attributes,
        [selectionEnd.attributeKey]: toHTMLString({
          value: valueB,
          ...mapRichTextSettings(attributeDefinitionB)
        })
      }
    }];
  };
  function getBlockOrder(state, rootClientId) {
    return state.blocks.order[rootClientId || ""] || EMPTY_ARRAY;
  }
  function getBlockIndex(state, clientId) {
    const rootClientId = getBlockRootClientId(state, clientId);
    return getBlockOrder(state, rootClientId).indexOf(clientId);
  }
  function isBlockSelected(state, clientId) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    if (selectionStart.clientId !== selectionEnd.clientId) {
      return false;
    }
    return selectionStart.clientId === clientId;
  }
  function hasSelectedInnerBlock(state, clientId) {
    let deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return getBlockOrder(state, clientId).some((innerClientId) => isBlockSelected(state, innerClientId) || isBlockMultiSelected(state, innerClientId) || deep && hasSelectedInnerBlock(state, innerClientId, deep));
  }
  function isBlockWithinSelection(state, clientId) {
    if (!clientId) {
      return false;
    }
    const clientIds = getMultiSelectedBlockClientIds(state);
    const index2 = clientIds.indexOf(clientId);
    return index2 > -1 && index2 < clientIds.length - 1;
  }
  function hasMultiSelection(state) {
    const {
      selectionStart,
      selectionEnd
    } = state.selection;
    return selectionStart.clientId !== selectionEnd.clientId;
  }
  function isMultiSelecting2(state) {
    return state.isMultiSelecting;
  }
  function isSelectionEnabled2(state) {
    return state.isSelectionEnabled;
  }
  function getBlockMode(state, clientId) {
    return state.blocksMode[clientId] || "visual";
  }
  function isTyping2(state) {
    return state.isTyping;
  }
  function isDraggingBlocks(state) {
    return !!state.draggedBlocks.length;
  }
  function getDraggedBlockClientIds(state) {
    return state.draggedBlocks;
  }
  function isBlockBeingDragged(state, clientId) {
    return state.draggedBlocks.includes(clientId);
  }
  function isAncestorBeingDragged(state, clientId) {
    if (!isDraggingBlocks(state)) {
      return false;
    }
    const parents = getBlockParents(state, clientId);
    return parents.some((parentClientId) => isBlockBeingDragged(state, parentClientId));
  }
  function isCaretWithinFormattedText() {
    deprecated('wp.data.select( "core/block-editor" ).isCaretWithinFormattedText', {
      since: "6.1",
      version: "6.3"
    });
    return false;
  }
  function getBlockInsertionPoint(state) {
    let rootClientId, index2;
    const {
      insertionPoint: insertionPoint2,
      selection: {
        selectionEnd
      }
    } = state;
    if (insertionPoint2 !== null) {
      return insertionPoint2;
    }
    const {
      clientId
    } = selectionEnd;
    if (clientId) {
      rootClientId = getBlockRootClientId(state, clientId) || void 0;
      index2 = getBlockIndex(state, selectionEnd.clientId) + 1;
    } else {
      index2 = getBlockOrder(state).length;
    }
    return {
      rootClientId,
      index: index2
    };
  }
  function isBlockInsertionPointVisible(state) {
    return state.insertionPoint !== null;
  }
  function isValidTemplate(state) {
    return state.template.isValid;
  }
  function getTemplate(state) {
    return state.settings.template;
  }
  function getTemplateLock(state, rootClientId) {
    if (!rootClientId) {
      return state.settings.templateLock;
    }
    const blockListSettings2 = getBlockListSettings(state, rootClientId);
    if (!blockListSettings2) {
      return void 0;
    }
    return blockListSettings2.templateLock;
  }
  var checkAllowList = function(list, item2) {
    let defaultResult = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (typeof list === "boolean") {
      return list;
    }
    if (Array.isArray(list)) {
      if (list.includes("core/post-content") && item2 === null) {
        return true;
      }
      return list.includes(item2);
    }
    return defaultResult;
  };
  var canInsertBlockTypeUnmemoized = function(state, blockName) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    let blockType;
    if (blockName && "object" === typeof blockName) {
      blockType = blockName;
      blockName = blockType.name;
    } else {
      blockType = getBlockType(blockName);
    }
    if (!blockType) {
      return false;
    }
    const {
      allowedBlockTypes
    } = getSettings(state);
    const isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);
    if (!isBlockAllowedInEditor) {
      return false;
    }
    const isLocked = !!getTemplateLock(state, rootClientId);
    if (isLocked) {
      return false;
    }
    const parentBlockListSettings = getBlockListSettings(state, rootClientId);
    if (rootClientId && parentBlockListSettings === void 0) {
      return false;
    }
    const parentAllowedBlocks = parentBlockListSettings === null || parentBlockListSettings === void 0 ? void 0 : parentBlockListSettings.allowedBlocks;
    const hasParentAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
    const blockAllowedParentBlocks = blockType.parent;
    const parentName = getBlockName(state, rootClientId);
    const hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);
    let hasBlockAllowedAncestor = true;
    const blockAllowedAncestorBlocks = blockType.ancestor;
    if (blockAllowedAncestorBlocks) {
      const ancestors = [rootClientId, ...getBlockParents(state, rootClientId)];
      hasBlockAllowedAncestor = ancestors.some((ancestorClientId) => checkAllowList(blockAllowedAncestorBlocks, getBlockName(state, ancestorClientId)));
    }
    const canInsert = hasBlockAllowedAncestor && (hasParentAllowedBlock === null && hasBlockAllowedParent === null || hasParentAllowedBlock === true || hasBlockAllowedParent === true);
    if (!canInsert) {
      return canInsert;
    }
    return applyFilters("blockEditor.__unstableCanInsertBlockType", canInsert, blockType, rootClientId, {
      getBlock: getBlock.bind(null, state),
      getBlockParentsByBlockName: getBlockParentsByBlockName.bind(null, state)
    });
  };
  var canInsertBlockType = rememo_default(canInsertBlockTypeUnmemoized, (state, blockName, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId], state.settings.allowedBlockTypes, state.settings.templateLock]);
  function canInsertBlocks(state, clientIds) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return clientIds.every((id2) => canInsertBlockType(state, getBlockName(state, id2), rootClientId));
  }
  function canRemoveBlock(state, clientId) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const attributes = getBlockAttributes2(state, clientId);
    if (attributes === null) {
      return true;
    }
    const {
      lock: lock2
    } = attributes;
    const parentIsLocked = !!getTemplateLock(state, rootClientId);
    if (lock2 === void 0 || (lock2 === null || lock2 === void 0 ? void 0 : lock2.remove) === void 0) {
      return !parentIsLocked;
    }
    return !(lock2 !== null && lock2 !== void 0 && lock2.remove);
  }
  function canRemoveBlocks(state, clientIds) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return clientIds.every((clientId) => canRemoveBlock(state, clientId, rootClientId));
  }
  function canMoveBlock(state, clientId) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const attributes = getBlockAttributes2(state, clientId);
    if (attributes === null) {
      return;
    }
    const {
      lock: lock2
    } = attributes;
    const parentIsLocked = getTemplateLock(state, rootClientId) === "all";
    if (lock2 === void 0 || (lock2 === null || lock2 === void 0 ? void 0 : lock2.move) === void 0) {
      return !parentIsLocked;
    }
    return !(lock2 !== null && lock2 !== void 0 && lock2.move);
  }
  function canMoveBlocks(state, clientIds) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return clientIds.every((clientId) => canMoveBlock(state, clientId, rootClientId));
  }
  function canEditBlock(state, clientId) {
    const attributes = getBlockAttributes2(state, clientId);
    if (attributes === null) {
      return true;
    }
    const {
      lock: lock2
    } = attributes;
    return !(lock2 !== null && lock2 !== void 0 && lock2.edit);
  }
  function canLockBlockType(state, nameOrType) {
    var _state$settings;
    if (!hasBlockSupport(nameOrType, "lock", true)) {
      return false;
    }
    return !!((_state$settings = state.settings) !== null && _state$settings !== void 0 && _state$settings.canLockBlocks);
  }
  function getInsertUsage(state, id2) {
    var _state$preferences$in, _state$preferences$in2;
    return (_state$preferences$in = (_state$preferences$in2 = state.preferences.insertUsage) === null || _state$preferences$in2 === void 0 ? void 0 : _state$preferences$in2[id2]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
  }
  var canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
    if (!hasBlockSupport(blockType, "inserter", true)) {
      return false;
    }
    return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
  };
  var getItemFromVariation = (state, item2) => (variation) => {
    const variationId = `${item2.id}/${variation.name}`;
    const {
      time,
      count = 0
    } = getInsertUsage(state, variationId) || {};
    return {
      ...item2,
      id: variationId,
      icon: variation.icon || item2.icon,
      title: variation.title || item2.title,
      description: variation.description || item2.description,
      category: variation.category || item2.category,
      example: variation.hasOwnProperty("example") ? variation.example : item2.example,
      initialAttributes: {
        ...item2.initialAttributes,
        ...variation.attributes
      },
      innerBlocks: variation.innerBlocks,
      keywords: variation.keywords || item2.keywords,
      frecency: calculateFrecency(time, count)
    };
  };
  var calculateFrecency = (time, count) => {
    if (!time) {
      return count;
    }
    const duration = Date.now() - time;
    switch (true) {
      case duration < MILLISECONDS_PER_HOUR:
        return count * 4;
      case duration < MILLISECONDS_PER_DAY:
        return count * 2;
      case duration < MILLISECONDS_PER_WEEK:
        return count / 2;
      default:
        return count / 4;
    }
  };
  var buildBlockTypeItem = (state, _ref32) => {
    let {
      buildScope = "inserter"
    } = _ref32;
    return (blockType) => {
      const id2 = blockType.name;
      let isDisabled = false;
      if (!hasBlockSupport(blockType.name, "multiple", true)) {
        isDisabled = getBlocksByClientId(state, getClientIdsWithDescendants(state)).some((_ref42) => {
          let {
            name
          } = _ref42;
          return name === blockType.name;
        });
      }
      const {
        time,
        count = 0
      } = getInsertUsage(state, id2) || {};
      const blockItemBase = {
        id: id2,
        name: blockType.name,
        title: blockType.title,
        icon: blockType.icon,
        isDisabled,
        frecency: calculateFrecency(time, count)
      };
      if (buildScope === "transform")
        return blockItemBase;
      const inserterVariations = getBlockVariations(blockType.name, "inserter");
      return {
        ...blockItemBase,
        initialAttributes: {},
        description: blockType.description,
        category: blockType.category,
        keywords: blockType.keywords,
        variations: inserterVariations,
        example: blockType.example,
        utility: 1
      };
    };
  };
  var getInserterItems = rememo_default(function(state) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
      buildScope: "inserter"
    });
    const blockParserTokenizer = /^\s*<!--\s+(\/)?wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/;
    const buildReusableBlockInserterItem = (reusableBlock) => {
      let icon = symbol_default;
      if (platform_default.OS === "web") {
        const content = typeof reusableBlock.content.raw === "string" ? reusableBlock.content.raw : reusableBlock.content;
        const rawBlockMatch = content.match(blockParserTokenizer);
        if (rawBlockMatch) {
          const [, , namespace = "core/", blockName] = rawBlockMatch;
          const referencedBlockType = getBlockType(namespace + blockName);
          if (referencedBlockType) {
            icon = referencedBlockType.icon;
          }
        }
      }
      const id2 = `core/block/${reusableBlock.id}`;
      const {
        time,
        count = 0
      } = getInsertUsage(state, id2) || {};
      const frecency = calculateFrecency(time, count);
      return {
        id: id2,
        name: "core/block",
        initialAttributes: {
          ref: reusableBlock.id
        },
        title: reusableBlock.title.raw,
        icon,
        category: "reusable",
        keywords: [],
        isDisabled: false,
        utility: 1,
        frecency
      };
    };
    const blockTypeInserterItems = getBlockTypes().filter((blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeInserterItem);
    const reusableBlockInserterItems = canInsertBlockTypeUnmemoized(state, "core/block", rootClientId) ? getReusableBlocks(state).map(buildReusableBlockInserterItem) : [];
    const items = blockTypeInserterItems.reduce((accumulator, item2) => {
      const {
        variations = []
      } = item2;
      if (!variations.some((_ref52) => {
        let {
          isDefault
        } = _ref52;
        return isDefault;
      })) {
        accumulator.push(item2);
      }
      if (variations.length) {
        const variationMapper = getItemFromVariation(state, item2);
        accumulator.push(...variations.map(variationMapper));
      }
      return accumulator;
    }, []);
    const groupByType = (blocks2, block4) => {
      const {
        core,
        noncore
      } = blocks2;
      const type = block4.name.startsWith("core/") ? core : noncore;
      type.push(block4);
      return blocks2;
    };
    const {
      core: coreItems,
      noncore: nonCoreItems
    } = items.reduce(groupByType, {
      core: [],
      noncore: []
    });
    const sortedBlockTypes = [...coreItems, ...nonCoreItems];
    return [...sortedBlockTypes, ...reusableBlockInserterItems];
  }, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.blocks.order, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), getBlockTypes()]);
  var getBlockTransformItems = rememo_default(function(state, blocks2) {
    var _itemsByName$sourceBl;
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const normalizedBlocks = Array.isArray(blocks2) ? blocks2 : [blocks2];
    const [sourceBlock] = normalizedBlocks;
    const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
      buildScope: "transform"
    });
    const blockTypeTransformItems = getBlockTypes().filter((blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeTransformItem);
    const itemsByName = Object.fromEntries(Object.entries(blockTypeTransformItems).map((_ref62) => {
      let [, value] = _ref62;
      return [value.name, value];
    }));
    itemsByName["*"] = {
      frecency: Infinity,
      id: "*",
      isDisabled: false,
      name: "*",
      title: __("Unwrap"),
      icon: (_itemsByName$sourceBl = itemsByName[sourceBlock === null || sourceBlock === void 0 ? void 0 : sourceBlock.name]) === null || _itemsByName$sourceBl === void 0 ? void 0 : _itemsByName$sourceBl.icon
    };
    const possibleTransforms = getPossibleBlockTransformations(normalizedBlocks).reduce((accumulator, block4) => {
      if (block4 === "*") {
        accumulator.push(itemsByName["*"]);
      } else if (itemsByName[block4 === null || block4 === void 0 ? void 0 : block4.name]) {
        accumulator.push(itemsByName[block4.name]);
      }
      return accumulator;
    }, []);
    return (0, import_lodash20.orderBy)(possibleTransforms, (block4) => itemsByName[block4.name].frecency, "desc");
  }, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getBlockTypes()]);
  var hasInserterItems = rememo_default(function(state) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const hasBlockType = getBlockTypes().some((blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
    if (hasBlockType) {
      return true;
    }
    const hasReusableBlock = canInsertBlockTypeUnmemoized(state, "core/block", rootClientId) && getReusableBlocks(state).length > 0;
    return hasReusableBlock;
  }, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), getBlockTypes()]);
  var __experimentalGetAllowedBlocks = rememo_default(function(state) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!rootClientId) {
      return;
    }
    return (0, import_lodash20.filter)(getBlockTypes(), (blockType) => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
  }, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getBlockTypes()]);
  var __experimentalGetDirectInsertBlock = rememo_default(function(state) {
    var _state$blockListSetti, _state$blockListSetti2;
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!rootClientId) {
      return;
    }
    const defaultBlock = (_state$blockListSetti = state.blockListSettings[rootClientId]) === null || _state$blockListSetti === void 0 ? void 0 : _state$blockListSetti.__experimentalDefaultBlock;
    const directInsert = (_state$blockListSetti2 = state.blockListSettings[rootClientId]) === null || _state$blockListSetti2 === void 0 ? void 0 : _state$blockListSetti2.__experimentalDirectInsert;
    if (!defaultBlock || !directInsert) {
      return;
    }
    if (typeof directInsert === "function") {
      return directInsert(getBlock(state, rootClientId)) ? defaultBlock : null;
    }
    return defaultBlock;
  }, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.tree[rootClientId]]);
  var checkAllowListRecursive = (blocks2, allowedBlockTypes) => {
    if (typeof allowedBlockTypes === "boolean") {
      return allowedBlockTypes;
    }
    const blocksQueue = [...blocks2];
    while (blocksQueue.length > 0) {
      var _block$innerBlocks;
      const block4 = blocksQueue.shift();
      const isAllowed = checkAllowList(allowedBlockTypes, block4.name || block4.blockName, true);
      if (!isAllowed) {
        return false;
      }
      (_block$innerBlocks = block4.innerBlocks) === null || _block$innerBlocks === void 0 ? void 0 : _block$innerBlocks.forEach((innerBlock) => {
        blocksQueue.push(innerBlock);
      });
    }
    return true;
  };
  var __experimentalGetParsedPattern = rememo_default((state, patternName) => {
    const patterns = state.settings.__experimentalBlockPatterns;
    const pattern = patterns.find((_ref72) => {
      let {
        name
      } = _ref72;
      return name === patternName;
    });
    if (!pattern) {
      return null;
    }
    return {
      ...pattern,
      blocks: parse3(pattern.content, {
        __unstableSkipMigrationLogs: true
      })
    };
  }, (state) => [state.settings.__experimentalBlockPatterns]);
  var getAllAllowedPatterns = rememo_default((state) => {
    const patterns = state.settings.__experimentalBlockPatterns;
    const {
      allowedBlockTypes
    } = getSettings(state);
    const parsedPatterns = patterns.filter((_ref8) => {
      let {
        inserter = true
      } = _ref8;
      return !!inserter;
    }).map((_ref9) => {
      let {
        name
      } = _ref9;
      return __experimentalGetParsedPattern(state, name);
    });
    const allowedPatterns = parsedPatterns.filter((_ref10) => {
      let {
        blocks: blocks2
      } = _ref10;
      return checkAllowListRecursive(blocks2, allowedBlockTypes);
    });
    return allowedPatterns;
  }, (state) => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes]);
  var __experimentalGetAllowedPatterns = rememo_default(function(state) {
    let rootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const availableParsedPatterns = getAllAllowedPatterns(state);
    const patternsAllowed = (0, import_lodash20.filter)(availableParsedPatterns, (_ref11) => {
      let {
        blocks: blocks2
      } = _ref11;
      return blocks2.every((_ref12) => {
        let {
          name
        } = _ref12;
        return canInsertBlockType(state, name, rootClientId);
      });
    });
    return patternsAllowed;
  }, (state, rootClientId) => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId]]);
  var __experimentalGetPatternsByBlockTypes = rememo_default(function(state, blockNames) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (!blockNames)
      return EMPTY_ARRAY;
    const patterns = __experimentalGetAllowedPatterns(state, rootClientId);
    const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
    return patterns.filter((pattern) => {
      var _pattern$blockTypes, _pattern$blockTypes$s;
      return pattern === null || pattern === void 0 ? void 0 : (_pattern$blockTypes = pattern.blockTypes) === null || _pattern$blockTypes === void 0 ? void 0 : (_pattern$blockTypes$s = _pattern$blockTypes.some) === null || _pattern$blockTypes$s === void 0 ? void 0 : _pattern$blockTypes$s.call(_pattern$blockTypes, (blockName) => normalizedBlockNames.includes(blockName));
    });
  }, (state, rootClientId) => [...__experimentalGetAllowedPatterns.getDependants(state, rootClientId)]);
  var __experimentalGetPatternTransformItems = rememo_default(function(state, blocks2) {
    let rootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (!blocks2)
      return EMPTY_ARRAY;
    if (blocks2.some((_ref13) => {
      let {
        clientId,
        innerBlocks
      } = _ref13;
      return innerBlocks.length || areInnerBlocksControlled(state, clientId);
    })) {
      return EMPTY_ARRAY;
    }
    const selectedBlockNames = Array.from(new Set(blocks2.map((_ref14) => {
      let {
        name
      } = _ref14;
      return name;
    })));
    return __experimentalGetPatternsByBlockTypes(state, selectedBlockNames, rootClientId);
  }, (state, rootClientId) => [...__experimentalGetPatternsByBlockTypes.getDependants(state, rootClientId)]);
  function getBlockListSettings(state, clientId) {
    return state.blockListSettings[clientId];
  }
  function getSettings(state) {
    return state.settings;
  }
  function isLastBlockChangePersistent(state) {
    return state.blocks.isPersistentChange;
  }
  var __experimentalGetBlockListSettingsForBlocks = rememo_default(function(state) {
    let clientIds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
      if (!state.blockListSettings[clientId]) {
        return blockListSettingsForBlocks;
      }
      return {
        ...blockListSettingsForBlocks,
        [clientId]: state.blockListSettings[clientId]
      };
    }, {});
  }, (state) => [state.blockListSettings]);
  var __experimentalGetReusableBlockTitle = rememo_default((state, ref2) => {
    var _reusableBlock$title;
    const reusableBlock = (0, import_lodash20.find)(getReusableBlocks(state), (block4) => block4.id === ref2);
    if (!reusableBlock) {
      return null;
    }
    return (_reusableBlock$title = reusableBlock.title) === null || _reusableBlock$title === void 0 ? void 0 : _reusableBlock$title.raw;
  }, (state) => [getReusableBlocks(state)]);
  function __unstableIsLastBlockChangeIgnored(state) {
    return state.blocks.isIgnoredChange;
  }
  function __experimentalGetLastBlockAttributeChanges(state) {
    return state.lastBlockAttributesChange;
  }
  function getReusableBlocks(state) {
    var _state$settings$__exp, _state$settings2;
    return (_state$settings$__exp = state === null || state === void 0 ? void 0 : (_state$settings2 = state.settings) === null || _state$settings2 === void 0 ? void 0 : _state$settings2.__experimentalReusableBlocks) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : EMPTY_ARRAY;
  }
  function isNavigationMode(state) {
    return state.editorMode === "navigation";
  }
  function __unstableGetEditorMode(state) {
    return state.editorMode;
  }
  function hasBlockMovingClientId2(state) {
    return state.hasBlockMovingClientId;
  }
  function didAutomaticChange(state) {
    return !!state.automaticChangeStatus;
  }
  function isBlockHighlighted(state, clientId) {
    return state.highlightedBlock === clientId;
  }
  function areInnerBlocksControlled(state, clientId) {
    return !!state.blocks.controlledInnerBlocks[clientId];
  }
  var __experimentalGetActiveBlockIdByBlockNames = rememo_default((state, validBlockNames) => {
    if (!validBlockNames.length) {
      return null;
    }
    const selectedBlockClientId = getSelectedBlockClientId(state);
    if (validBlockNames.includes(getBlockName(state, selectedBlockClientId))) {
      return selectedBlockClientId;
    }
    const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
    const entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);
    if (entityAreaParents) {
      return entityAreaParents[entityAreaParents.length - 1];
    }
    return null;
  }, (state, validBlockNames) => [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames]);
  function wasBlockJustInserted(state, clientId, source) {
    const {
      lastBlockInserted: lastBlockInserted2
    } = state;
    return lastBlockInserted2.clientId === clientId && lastBlockInserted2.source === source;
  }
  function isBlockVisible(state, clientId) {
    var _state$blockVisibilit, _state$blockVisibilit2;
    return (_state$blockVisibilit = (_state$blockVisibilit2 = state.blockVisibility) === null || _state$blockVisibilit2 === void 0 ? void 0 : _state$blockVisibilit2[clientId]) !== null && _state$blockVisibilit !== void 0 ? _state$blockVisibilit : true;
  }
  var __unstableGetVisibleBlocks = rememo_default((state) => {
    return new Set(Object.keys(state.blockVisibility).filter((key) => state.blockVisibility[key]));
  }, (state) => [state.blockVisibility]);
  var __unstableGetContentLockingParent = rememo_default((state, clientId) => {
    let current = clientId;
    let result;
    while (!!state.blocks.parents[current]) {
      current = state.blocks.parents[current];
      if (getTemplateLock(state, current) === "contentOnly") {
        result = current;
      }
    }
    return result;
  }, (state) => [state.blocks.parents, state.blockListSettings]);
  function __unstableGetTemporarilyEditingAsBlocks(state) {
    return state.temporarilyEditingAsBlocks;
  }
  function __unstableHasActiveBlockOverlayActive(state, clientId) {
    if (!canEditBlock(state, clientId)) {
      return true;
    }
    const editorMode2 = __unstableGetEditorMode(state);
    if (editorMode2 === "zoom-out" && clientId && !getBlockRootClientId(state, clientId)) {
      return true;
    }
    const blockSupportDisable = hasBlockSupport(getBlockName(state, clientId), "__experimentalDisableBlockOverlay", false);
    const shouldEnableIfUnselected = editorMode2 === "navigation" || (blockSupportDisable ? false : areInnerBlocksControlled(state, clientId));
    return shouldEnableIfUnselected && !isBlockSelected(state, clientId) && !hasSelectedInnerBlock(state, clientId, true);
  }
  function __unstableIsWithinBlockOverlay(state, clientId) {
    let parent = state.blocks.parents[clientId];
    while (!!parent) {
      if (__unstableHasActiveBlockOverlayActive(state, parent)) {
        return true;
      }
      parent = state.blocks.parents[parent];
    }
    return false;
  }

  // node_modules/@wordpress/block-editor/build-module/store/actions.js
  var actions_exports5 = {};
  __export(actions_exports5, {
    __unstableDeleteSelection: () => __unstableDeleteSelection,
    __unstableExpandSelection: () => __unstableExpandSelection,
    __unstableMarkAutomaticChange: () => __unstableMarkAutomaticChange,
    __unstableMarkLastChangeAsPersistent: () => __unstableMarkLastChangeAsPersistent,
    __unstableMarkNextChangeAsNotPersistent: () => __unstableMarkNextChangeAsNotPersistent,
    __unstableSaveReusableBlock: () => __unstableSaveReusableBlock,
    __unstableSetEditorMode: () => __unstableSetEditorMode,
    __unstableSetTemporarilyEditingAsBlocks: () => __unstableSetTemporarilyEditingAsBlocks,
    __unstableSplitSelection: () => __unstableSplitSelection,
    clearSelectedBlock: () => clearSelectedBlock,
    duplicateBlocks: () => duplicateBlocks,
    enterFormattedText: () => enterFormattedText,
    exitFormattedText: () => exitFormattedText,
    flashBlock: () => flashBlock,
    hideInsertionPoint: () => hideInsertionPoint,
    insertAfterBlock: () => insertAfterBlock,
    insertBeforeBlock: () => insertBeforeBlock,
    insertBlock: () => insertBlock,
    insertBlocks: () => insertBlocks,
    insertDefaultBlock: () => insertDefaultBlock,
    mergeBlocks: () => mergeBlocks,
    moveBlockToPosition: () => moveBlockToPosition,
    moveBlocksDown: () => moveBlocksDown,
    moveBlocksToPosition: () => moveBlocksToPosition,
    moveBlocksUp: () => moveBlocksUp,
    multiSelect: () => multiSelect,
    receiveBlocks: () => receiveBlocks,
    removeBlock: () => removeBlock,
    removeBlocks: () => removeBlocks,
    replaceBlock: () => replaceBlock,
    replaceBlocks: () => replaceBlocks,
    replaceInnerBlocks: () => replaceInnerBlocks,
    resetBlocks: () => resetBlocks,
    resetSelection: () => resetSelection,
    selectBlock: () => selectBlock,
    selectNextBlock: () => selectNextBlock,
    selectPreviousBlock: () => selectPreviousBlock,
    selectionChange: () => selectionChange,
    setBlockMovingClientId: () => setBlockMovingClientId,
    setBlockVisibility: () => setBlockVisibility,
    setHasControlledInnerBlocks: () => setHasControlledInnerBlocks,
    setNavigationMode: () => setNavigationMode,
    setTemplateValidity: () => setTemplateValidity,
    showInsertionPoint: () => showInsertionPoint,
    startDraggingBlocks: () => startDraggingBlocks,
    startMultiSelect: () => startMultiSelect,
    startTyping: () => startTyping,
    stopDraggingBlocks: () => stopDraggingBlocks,
    stopMultiSelect: () => stopMultiSelect,
    stopTyping: () => stopTyping,
    synchronizeTemplate: () => synchronizeTemplate,
    toggleBlockHighlight: () => toggleBlockHighlight,
    toggleBlockMode: () => toggleBlockMode,
    toggleSelection: () => toggleSelection,
    updateBlock: () => updateBlock,
    updateBlockAttributes: () => updateBlockAttributes,
    updateBlockListSettings: () => updateBlockListSettings,
    updateSettings: () => updateSettings,
    validateBlocksToTemplate: () => validateBlocksToTemplate
  });

  // node_modules/@wordpress/block-editor/build-module/utils/selection.js
  var START_OF_SELECTED_AREA = "\x86";
  function retrieveSelectedAttribute(blockAttributes) {
    if (!blockAttributes) {
      return;
    }
    return Object.keys(blockAttributes).find((name) => {
      const value = blockAttributes[name];
      return typeof value === "string" && value.indexOf(START_OF_SELECTED_AREA) !== -1;
    });
  }

  // node_modules/@wordpress/block-editor/build-module/store/actions.js
  var castArray2 = (maybeArray) => Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  var ensureDefaultBlock = () => (_ref8) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref8;
    const count = select2.getBlockCount();
    if (count > 0) {
      return;
    }
    const {
      __unstableHasCustomAppender
    } = select2.getSettings();
    if (__unstableHasCustomAppender) {
      return;
    }
    dispatch2.insertDefaultBlock();
  };
  var resetBlocks = (blocks2) => (_ref22) => {
    let {
      dispatch: dispatch2
    } = _ref22;
    dispatch2({
      type: "RESET_BLOCKS",
      blocks: blocks2
    });
    dispatch2(validateBlocksToTemplate(blocks2));
  };
  var validateBlocksToTemplate = (blocks2) => (_ref32) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref32;
    const template2 = select2.getTemplate();
    const templateLock = select2.getTemplateLock();
    const isBlocksValidToTemplate = !template2 || templateLock !== "all" || doBlocksMatchTemplate(blocks2, template2);
    const isValidTemplate2 = select2.isValidTemplate();
    if (isBlocksValidToTemplate !== isValidTemplate2) {
      dispatch2.setTemplateValidity(isBlocksValidToTemplate);
      return isBlocksValidToTemplate;
    }
  };
  function resetSelection(selectionStart, selectionEnd, initialPosition2) {
    return {
      type: "RESET_SELECTION",
      selectionStart,
      selectionEnd,
      initialPosition: initialPosition2
    };
  }
  function receiveBlocks(blocks2) {
    deprecated('wp.data.dispatch( "core/block-editor" ).receiveBlocks', {
      since: "5.9",
      alternative: "resetBlocks or insertBlocks"
    });
    return {
      type: "RECEIVE_BLOCKS",
      blocks: blocks2
    };
  }
  function updateBlockAttributes(clientIds, attributes) {
    let uniqueByBlock = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return {
      type: "UPDATE_BLOCK_ATTRIBUTES",
      clientIds: castArray2(clientIds),
      attributes,
      uniqueByBlock
    };
  }
  function updateBlock(clientId, updates) {
    return {
      type: "UPDATE_BLOCK",
      clientId,
      updates
    };
  }
  function selectBlock(clientId) {
    let initialPosition2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return {
      type: "SELECT_BLOCK",
      initialPosition: initialPosition2,
      clientId
    };
  }
  var selectPreviousBlock = (clientId) => (_ref42) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref42;
    const previousBlockClientId = select2.getPreviousBlockClientId(clientId);
    if (previousBlockClientId) {
      dispatch2.selectBlock(previousBlockClientId, -1);
    }
  };
  var selectNextBlock = (clientId) => (_ref52) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref52;
    const nextBlockClientId = select2.getNextBlockClientId(clientId);
    if (nextBlockClientId) {
      dispatch2.selectBlock(nextBlockClientId);
    }
  };
  function startMultiSelect() {
    return {
      type: "START_MULTI_SELECT"
    };
  }
  function stopMultiSelect() {
    return {
      type: "STOP_MULTI_SELECT"
    };
  }
  var multiSelect = function(start2, end) {
    let __experimentalInitialPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    return (_ref62) => {
      let {
        select: select2,
        dispatch: dispatch2
      } = _ref62;
      const startBlockRootClientId = select2.getBlockRootClientId(start2);
      const endBlockRootClientId = select2.getBlockRootClientId(end);
      if (startBlockRootClientId !== endBlockRootClientId) {
        return;
      }
      dispatch2({
        type: "MULTI_SELECT",
        start: start2,
        end,
        initialPosition: __experimentalInitialPosition
      });
      const blockCount = select2.getSelectedBlockCount();
      speak(sprintf(
        _n("%s block selected.", "%s blocks selected.", blockCount),
        blockCount
      ), "assertive");
    };
  };
  function clearSelectedBlock() {
    return {
      type: "CLEAR_SELECTED_BLOCK"
    };
  }
  function toggleSelection() {
    let isSelectionEnabled3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return {
      type: "TOGGLE_SELECTION",
      isSelectionEnabled: isSelectionEnabled3
    };
  }
  function getBlocksWithDefaultStylesApplied(blocks2, blockEditorSettings) {
    var _blockEditorSettings$, _blockEditorSettings$2;
    const preferredStyleVariations = (_blockEditorSettings$ = blockEditorSettings === null || blockEditorSettings === void 0 ? void 0 : (_blockEditorSettings$2 = blockEditorSettings.__experimentalPreferredStyleVariations) === null || _blockEditorSettings$2 === void 0 ? void 0 : _blockEditorSettings$2.value) !== null && _blockEditorSettings$ !== void 0 ? _blockEditorSettings$ : {};
    return blocks2.map((block4) => {
      var _block$attributes;
      const blockName = block4.name;
      if (!hasBlockSupport(blockName, "defaultStylePicker", true)) {
        return block4;
      }
      if (!preferredStyleVariations[blockName]) {
        return block4;
      }
      const className = (_block$attributes = block4.attributes) === null || _block$attributes === void 0 ? void 0 : _block$attributes.className;
      if (className !== null && className !== void 0 && className.includes("is-style-")) {
        return block4;
      }
      const {
        attributes = {}
      } = block4;
      const blockStyle = preferredStyleVariations[blockName];
      return {
        ...block4,
        attributes: {
          ...attributes,
          className: `${className || ""} is-style-${blockStyle}`.trim()
        }
      };
    });
  }
  var replaceBlocks = function(clientIds, blocks2, indexToSelect) {
    let initialPosition2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let meta = arguments.length > 4 ? arguments[4] : void 0;
    return (_ref72) => {
      let {
        select: select2,
        dispatch: dispatch2
      } = _ref72;
      clientIds = castArray2(clientIds);
      blocks2 = getBlocksWithDefaultStylesApplied(castArray2(blocks2), select2.getSettings());
      const rootClientId = select2.getBlockRootClientId(clientIds[0]);
      for (let index2 = 0; index2 < blocks2.length; index2++) {
        const block4 = blocks2[index2];
        const canInsertBlock = select2.canInsertBlockType(block4.name, rootClientId);
        if (!canInsertBlock) {
          return;
        }
      }
      dispatch2({
        type: "REPLACE_BLOCKS",
        clientIds,
        blocks: blocks2,
        time: Date.now(),
        indexToSelect,
        initialPosition: initialPosition2,
        meta
      });
      dispatch2(ensureDefaultBlock());
    };
  };
  function replaceBlock(clientId, block4) {
    return replaceBlocks(clientId, block4);
  }
  var createOnMove = (type) => (clientIds, rootClientId) => (_ref8) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref8;
    const canMoveBlocks2 = select2.canMoveBlocks(clientIds, rootClientId);
    if (!canMoveBlocks2) {
      return;
    }
    dispatch2({
      type,
      clientIds: castArray2(clientIds),
      rootClientId
    });
  };
  var moveBlocksDown = createOnMove("MOVE_BLOCKS_DOWN");
  var moveBlocksUp = createOnMove("MOVE_BLOCKS_UP");
  var moveBlocksToPosition = function(clientIds) {
    let fromRootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let toRootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    let index2 = arguments.length > 3 ? arguments[3] : void 0;
    return (_ref9) => {
      let {
        select: select2,
        dispatch: dispatch2
      } = _ref9;
      const canMoveBlocks2 = select2.canMoveBlocks(clientIds, fromRootClientId);
      if (!canMoveBlocks2) {
        return;
      }
      if (fromRootClientId !== toRootClientId) {
        const canRemoveBlocks2 = select2.canRemoveBlocks(clientIds, fromRootClientId);
        if (!canRemoveBlocks2) {
          return;
        }
        const canInsertBlocks2 = select2.canInsertBlocks(clientIds, toRootClientId);
        if (!canInsertBlocks2) {
          return;
        }
      }
      dispatch2({
        type: "MOVE_BLOCKS_TO_POSITION",
        fromRootClientId,
        toRootClientId,
        clientIds,
        index: index2
      });
    };
  };
  function moveBlockToPosition(clientId) {
    let fromRootClientId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let toRootClientId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    let index2 = arguments.length > 3 ? arguments[3] : void 0;
    return moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index2);
  }
  function insertBlock(block4, index2, rootClientId, updateSelection, meta) {
    return insertBlocks([block4], index2, rootClientId, updateSelection, 0, meta);
  }
  var insertBlocks = function(blocks2, index2, rootClientId) {
    let updateSelection = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    let initialPosition2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    let meta = arguments.length > 5 ? arguments[5] : void 0;
    return (_ref10) => {
      let {
        select: select2,
        dispatch: dispatch2
      } = _ref10;
      if (initialPosition2 !== null && typeof initialPosition2 === "object") {
        meta = initialPosition2;
        initialPosition2 = 0;
        deprecated("meta argument in wp.data.dispatch('core/block-editor')", {
          since: "5.8",
          hint: "The meta argument is now the 6th argument of the function"
        });
      }
      blocks2 = getBlocksWithDefaultStylesApplied(castArray2(blocks2), select2.getSettings());
      const allowedBlocks = [];
      for (const block4 of blocks2) {
        const isValid = select2.canInsertBlockType(block4.name, rootClientId);
        if (isValid) {
          allowedBlocks.push(block4);
        }
      }
      if (allowedBlocks.length) {
        dispatch2({
          type: "INSERT_BLOCKS",
          blocks: allowedBlocks,
          index: index2,
          rootClientId,
          time: Date.now(),
          updateSelection,
          initialPosition: updateSelection ? initialPosition2 : null,
          meta
        });
      }
    };
  };
  function showInsertionPoint(rootClientId, index2) {
    let __unstableOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      __unstableWithInserter,
      operation
    } = __unstableOptions;
    return {
      type: "SHOW_INSERTION_POINT",
      rootClientId,
      index: index2,
      __unstableWithInserter,
      operation
    };
  }
  var hideInsertionPoint = () => (_ref11) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref11;
    if (!select2.isBlockInsertionPointVisible()) {
      return;
    }
    dispatch2({
      type: "HIDE_INSERTION_POINT"
    });
  };
  function setTemplateValidity(isValid) {
    return {
      type: "SET_TEMPLATE_VALIDITY",
      isValid
    };
  }
  var synchronizeTemplate = () => (_ref12) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref12;
    dispatch2({
      type: "SYNCHRONIZE_TEMPLATE"
    });
    const blocks2 = select2.getBlocks();
    const template2 = select2.getTemplate();
    const updatedBlockList = synchronizeBlocksWithTemplate(blocks2, template2);
    dispatch2.resetBlocks(updatedBlockList);
  };
  var __unstableDeleteSelection = (isForward) => (_ref13) => {
    let {
      registry,
      select: select2,
      dispatch: dispatch2
    } = _ref13;
    const selectionAnchor = select2.getSelectionStart();
    const selectionFocus = select2.getSelectionEnd();
    if (selectionAnchor.clientId === selectionFocus.clientId)
      return;
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined")
      return false;
    const anchorRootClientId = select2.getBlockRootClientId(selectionAnchor.clientId);
    const focusRootClientId = select2.getBlockRootClientId(selectionFocus.clientId);
    if (anchorRootClientId !== focusRootClientId) {
      return;
    }
    const blockOrder = select2.getBlockOrder(anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    let selectionStart, selectionEnd;
    if (anchorIndex > focusIndex) {
      selectionStart = selectionFocus;
      selectionEnd = selectionAnchor;
    } else {
      selectionStart = selectionAnchor;
      selectionEnd = selectionFocus;
    }
    const targetSelection = isForward ? selectionEnd : selectionStart;
    const targetBlock = select2.getBlock(targetSelection.clientId);
    const targetBlockType = getBlockType(targetBlock.name);
    if (!targetBlockType.merge) {
      return;
    }
    const selectionA = selectionStart;
    const selectionB = selectionEnd;
    const blockA = select2.getBlock(selectionA.clientId);
    const blockAType = getBlockType(blockA.name);
    const blockB = select2.getBlock(selectionB.clientId);
    const blockBType = getBlockType(blockB.name);
    const htmlA = blockA.attributes[selectionA.attributeKey];
    const htmlB = blockB.attributes[selectionB.attributeKey];
    const attributeDefinitionA = blockAType.attributes[selectionA.attributeKey];
    const attributeDefinitionB = blockBType.attributes[selectionB.attributeKey];
    let valueA = create2({
      html: htmlA,
      ...mapRichTextSettings(attributeDefinitionA)
    });
    let valueB = create2({
      html: htmlB,
      ...mapRichTextSettings(attributeDefinitionB)
    });
    valueA = remove2(valueA, selectionA.offset, valueA.text.length);
    valueB = insert(valueB, START_OF_SELECTED_AREA, 0, selectionB.offset);
    const cloneA = cloneBlock(blockA, {
      [selectionA.attributeKey]: toHTMLString({
        value: valueA,
        ...mapRichTextSettings(attributeDefinitionA)
      })
    });
    const cloneB = cloneBlock(blockB, {
      [selectionB.attributeKey]: toHTMLString({
        value: valueB,
        ...mapRichTextSettings(attributeDefinitionB)
      })
    });
    const followingBlock = isForward ? cloneA : cloneB;
    const blocksWithTheSameType = blockA.name === blockB.name ? [followingBlock] : switchToBlockType(followingBlock, targetBlockType.name);
    if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
      return;
    }
    let updatedAttributes;
    if (isForward) {
      const blockToMerge = blocksWithTheSameType.pop();
      updatedAttributes = targetBlockType.merge(blockToMerge.attributes, cloneB.attributes);
    } else {
      const blockToMerge = blocksWithTheSameType.shift();
      updatedAttributes = targetBlockType.merge(cloneA.attributes, blockToMerge.attributes);
    }
    const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const convertedValue = create2({
      html: convertedHtml,
      ...mapRichTextSettings(targetBlockType.attributes[newAttributeKey])
    });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = remove2(convertedValue, newOffset, newOffset + 1);
    const newHtml = toHTMLString({
      value: newValue,
      ...mapRichTextSettings(targetBlockType.attributes[newAttributeKey])
    });
    updatedAttributes[newAttributeKey] = newHtml;
    const selectedBlockClientIds = select2.getSelectedBlockClientIds();
    const replacement = [...isForward ? blocksWithTheSameType : [], {
      ...targetBlock,
      attributes: {
        ...targetBlock.attributes,
        ...updatedAttributes
      }
    }, ...isForward ? [] : blocksWithTheSameType];
    registry.batch(() => {
      dispatch2.selectionChange(targetBlock.clientId, newAttributeKey, newOffset, newOffset);
      dispatch2.replaceBlocks(
        selectedBlockClientIds,
        replacement,
        0,
        select2.getSelectedBlocksInitialCaretPosition()
      );
    });
  };
  var __unstableSplitSelection = () => (_ref14) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref14;
    const selectionAnchor = select2.getSelectionStart();
    const selectionFocus = select2.getSelectionEnd();
    if (selectionAnchor.clientId === selectionFocus.clientId)
      return;
    if (!selectionAnchor.attributeKey || !selectionFocus.attributeKey || typeof selectionAnchor.offset === "undefined" || typeof selectionFocus.offset === "undefined")
      return;
    const anchorRootClientId = select2.getBlockRootClientId(selectionAnchor.clientId);
    const focusRootClientId = select2.getBlockRootClientId(selectionFocus.clientId);
    if (anchorRootClientId !== focusRootClientId) {
      return;
    }
    const blockOrder = select2.getBlockOrder(anchorRootClientId);
    const anchorIndex = blockOrder.indexOf(selectionAnchor.clientId);
    const focusIndex = blockOrder.indexOf(selectionFocus.clientId);
    let selectionStart, selectionEnd;
    if (anchorIndex > focusIndex) {
      selectionStart = selectionFocus;
      selectionEnd = selectionAnchor;
    } else {
      selectionStart = selectionAnchor;
      selectionEnd = selectionFocus;
    }
    const selectionA = selectionStart;
    const selectionB = selectionEnd;
    const blockA = select2.getBlock(selectionA.clientId);
    const blockAType = getBlockType(blockA.name);
    const blockB = select2.getBlock(selectionB.clientId);
    const blockBType = getBlockType(blockB.name);
    const htmlA = blockA.attributes[selectionA.attributeKey];
    const htmlB = blockB.attributes[selectionB.attributeKey];
    const attributeDefinitionA = blockAType.attributes[selectionA.attributeKey];
    const attributeDefinitionB = blockBType.attributes[selectionB.attributeKey];
    let valueA = create2({
      html: htmlA,
      ...mapRichTextSettings(attributeDefinitionA)
    });
    let valueB = create2({
      html: htmlB,
      ...mapRichTextSettings(attributeDefinitionB)
    });
    valueA = remove2(valueA, selectionA.offset, valueA.text.length);
    valueB = remove2(valueB, 0, selectionB.offset);
    dispatch2.replaceBlocks(
      select2.getSelectedBlockClientIds(),
      [{
        ...blockA,
        attributes: {
          ...blockA.attributes,
          [selectionA.attributeKey]: toHTMLString({
            value: valueA,
            ...mapRichTextSettings(attributeDefinitionA)
          })
        }
      }, createBlock(getDefaultBlockName()), {
        ...blockB,
        attributes: {
          ...blockB.attributes,
          [selectionB.attributeKey]: toHTMLString({
            value: valueB,
            ...mapRichTextSettings(attributeDefinitionB)
          })
        }
      }],
      1,
      select2.getSelectedBlocksInitialCaretPosition()
    );
  };
  var __unstableExpandSelection = () => (_ref15) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref15;
    const selectionAnchor = select2.getSelectionStart();
    const selectionFocus = select2.getSelectionEnd();
    dispatch2.selectionChange({
      start: {
        clientId: selectionAnchor.clientId
      },
      end: {
        clientId: selectionFocus.clientId
      }
    });
  };
  var mergeBlocks = (firstBlockClientId, secondBlockClientId) => (_ref16) => {
    let {
      registry,
      select: select2,
      dispatch: dispatch2
    } = _ref16;
    const blocks2 = [firstBlockClientId, secondBlockClientId];
    dispatch2({
      type: "MERGE_BLOCKS",
      blocks: blocks2
    });
    const [clientIdA, clientIdB] = blocks2;
    const blockA = select2.getBlock(clientIdA);
    const blockAType = getBlockType(blockA.name);
    if (!blockAType)
      return;
    const blockB = select2.getBlock(clientIdB);
    if (blockAType && !blockAType.merge) {
      const blocksWithTheSameType2 = switchToBlockType(blockB, blockAType.name);
      if ((blocksWithTheSameType2 === null || blocksWithTheSameType2 === void 0 ? void 0 : blocksWithTheSameType2.length) !== 1) {
        dispatch2.selectBlock(blockA.clientId);
        return;
      }
      const [blockWithSameType] = blocksWithTheSameType2;
      if (blockWithSameType.innerBlocks.length < 1) {
        dispatch2.selectBlock(blockA.clientId);
        return;
      }
      registry.batch(() => {
        dispatch2.insertBlocks(blockWithSameType.innerBlocks, void 0, clientIdA);
        dispatch2.removeBlock(clientIdB);
        dispatch2.selectBlock(blockWithSameType.innerBlocks[0].clientId);
      });
      return;
    }
    const blockBType = getBlockType(blockB.name);
    const {
      clientId,
      attributeKey,
      offset: offset4
    } = select2.getSelectionStart();
    const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
    const attributeDefinition = selectedBlockType.attributes[attributeKey];
    const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== void 0 && offset4 !== void 0 && !!attributeDefinition;
    if (!attributeDefinition) {
      if (typeof attributeKey === "number") {
        window.console.error(`RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`);
      } else {
        window.console.error("The RichText identifier prop does not match any attributes defined by the block.");
      }
    }
    const cloneA = cloneBlock(blockA);
    const cloneB = cloneBlock(blockB);
    if (canRestoreTextSelection) {
      const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
      const html2 = selectedBlock.attributes[attributeKey];
      const value = insert(create2({
        html: html2,
        ...mapRichTextSettings(attributeDefinition)
      }), START_OF_SELECTED_AREA, offset4, offset4);
      selectedBlock.attributes[attributeKey] = toHTMLString({
        value,
        ...mapRichTextSettings(attributeDefinition)
      });
    }
    const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : switchToBlockType(cloneB, blockA.name);
    if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
      return;
    }
    const updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);
    if (canRestoreTextSelection) {
      const newAttributeKey = retrieveSelectedAttribute(updatedAttributes);
      const convertedHtml = updatedAttributes[newAttributeKey];
      const convertedValue = create2({
        html: convertedHtml,
        ...mapRichTextSettings(blockAType.attributes[newAttributeKey])
      });
      const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
      const newValue = remove2(convertedValue, newOffset, newOffset + 1);
      const newHtml = toHTMLString({
        value: newValue,
        ...mapRichTextSettings(blockAType.attributes[newAttributeKey])
      });
      updatedAttributes[newAttributeKey] = newHtml;
      dispatch2.selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);
    }
    dispatch2.replaceBlocks(
      [blockA.clientId, blockB.clientId],
      [{
        ...blockA,
        attributes: {
          ...blockA.attributes,
          ...updatedAttributes
        }
      }, ...blocksWithTheSameType.slice(1)],
      0
    );
  };
  var removeBlocks = function(clientIds) {
    let selectPrevious = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return (_ref17) => {
      let {
        select: select2,
        dispatch: dispatch2
      } = _ref17;
      if (!clientIds || !clientIds.length) {
        return;
      }
      clientIds = castArray2(clientIds);
      const rootClientId = select2.getBlockRootClientId(clientIds[0]);
      const canRemoveBlocks2 = select2.canRemoveBlocks(clientIds, rootClientId);
      if (!canRemoveBlocks2) {
        return;
      }
      if (selectPrevious) {
        dispatch2.selectPreviousBlock(clientIds[0]);
      }
      dispatch2({
        type: "REMOVE_BLOCKS",
        clientIds
      });
      dispatch2(ensureDefaultBlock());
    };
  };
  function removeBlock(clientId, selectPrevious) {
    return removeBlocks([clientId], selectPrevious);
  }
  function replaceInnerBlocks(rootClientId, blocks2) {
    let updateSelection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let initialPosition2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    return {
      type: "REPLACE_INNER_BLOCKS",
      rootClientId,
      blocks: blocks2,
      updateSelection,
      initialPosition: updateSelection ? initialPosition2 : null,
      time: Date.now()
    };
  }
  function toggleBlockMode(clientId) {
    return {
      type: "TOGGLE_BLOCK_MODE",
      clientId
    };
  }
  function startTyping() {
    return {
      type: "START_TYPING"
    };
  }
  function stopTyping() {
    return {
      type: "STOP_TYPING"
    };
  }
  function startDraggingBlocks() {
    let clientIds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return {
      type: "START_DRAGGING_BLOCKS",
      clientIds
    };
  }
  function stopDraggingBlocks() {
    return {
      type: "STOP_DRAGGING_BLOCKS"
    };
  }
  function enterFormattedText() {
    deprecated('wp.data.dispatch( "core/block-editor" ).enterFormattedText', {
      since: "6.1",
      version: "6.3"
    });
    return {
      type: "DO_NOTHING"
    };
  }
  function exitFormattedText() {
    deprecated('wp.data.dispatch( "core/block-editor" ).exitFormattedText', {
      since: "6.1",
      version: "6.3"
    });
    return {
      type: "DO_NOTHING"
    };
  }
  function selectionChange(clientId, attributeKey, startOffset, endOffset) {
    if (typeof clientId === "string") {
      return {
        type: "SELECTION_CHANGE",
        clientId,
        attributeKey,
        startOffset,
        endOffset
      };
    }
    return {
      type: "SELECTION_CHANGE",
      ...clientId
    };
  }
  var insertDefaultBlock = (attributes, rootClientId, index2) => (_ref18) => {
    let {
      dispatch: dispatch2
    } = _ref18;
    const defaultBlockName2 = getDefaultBlockName();
    if (!defaultBlockName2) {
      return;
    }
    const block4 = createBlock(defaultBlockName2, attributes);
    return dispatch2.insertBlock(block4, index2, rootClientId);
  };
  function updateBlockListSettings(clientId, settings2) {
    return {
      type: "UPDATE_BLOCK_LIST_SETTINGS",
      clientId,
      settings: settings2
    };
  }
  function updateSettings(settings2) {
    return {
      type: "UPDATE_SETTINGS",
      settings: settings2
    };
  }
  function __unstableSaveReusableBlock(id2, updatedId) {
    return {
      type: "SAVE_REUSABLE_BLOCK_SUCCESS",
      id: id2,
      updatedId
    };
  }
  function __unstableMarkLastChangeAsPersistent() {
    return {
      type: "MARK_LAST_CHANGE_AS_PERSISTENT"
    };
  }
  function __unstableMarkNextChangeAsNotPersistent() {
    return {
      type: "MARK_NEXT_CHANGE_AS_NOT_PERSISTENT"
    };
  }
  var __unstableMarkAutomaticChange = () => (_ref19) => {
    let {
      dispatch: dispatch2
    } = _ref19;
    dispatch2({
      type: "MARK_AUTOMATIC_CHANGE"
    });
    const {
      requestIdleCallback: requestIdleCallback2 = (cb2) => setTimeout(cb2, 100)
    } = window;
    requestIdleCallback2(() => {
      dispatch2({
        type: "MARK_AUTOMATIC_CHANGE_FINAL"
      });
    });
  };
  var setNavigationMode = function() {
    let isNavigationMode2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return (_ref20) => {
      let {
        dispatch: dispatch2
      } = _ref20;
      dispatch2.__unstableSetEditorMode(isNavigationMode2 ? "navigation" : "edit");
    };
  };
  var __unstableSetEditorMode = (mode) => (_ref21) => {
    let {
      dispatch: dispatch2,
      select: select2
    } = _ref21;
    if (mode === "zoom-out") {
      const firstSelectedClientId = select2.getBlockSelectionStart();
      if (firstSelectedClientId) {
        dispatch2.selectBlock(select2.getBlockHierarchyRootClientId(firstSelectedClientId));
      }
    }
    dispatch2({
      type: "SET_EDITOR_MODE",
      mode
    });
    if (mode === "navigation") {
      speak(__("You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter."));
    } else if (mode === "edit") {
      speak(__("You are currently in edit mode. To return to the navigation mode, press Escape."));
    } else if (mode === "zoom-out") {
      speak(__("You are currently in zoom-out mode."));
    }
  };
  var setBlockMovingClientId = function() {
    let hasBlockMovingClientId3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return (_ref22) => {
      let {
        dispatch: dispatch2
      } = _ref22;
      dispatch2({
        type: "SET_BLOCK_MOVING_MODE",
        hasBlockMovingClientId: hasBlockMovingClientId3
      });
      if (hasBlockMovingClientId3) {
        speak(__("Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block."));
      }
    };
  };
  var duplicateBlocks = function(clientIds) {
    let updateSelection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return (_ref23) => {
      let {
        select: select2,
        dispatch: dispatch2
      } = _ref23;
      if (!clientIds || !clientIds.length) {
        return;
      }
      const blocks2 = select2.getBlocksByClientId(clientIds);
      if (blocks2.some((block4) => !block4)) {
        return;
      }
      const blockNames = blocks2.map((block4) => block4.name);
      if (blockNames.some((blockName) => !hasBlockSupport(blockName, "multiple", true))) {
        return;
      }
      const rootClientId = select2.getBlockRootClientId(clientIds[0]);
      const clientIdsArray = castArray2(clientIds);
      const lastSelectedIndex = select2.getBlockIndex(clientIdsArray[clientIdsArray.length - 1]);
      const clonedBlocks = blocks2.map((block4) => __experimentalCloneSanitizedBlock(block4));
      dispatch2.insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);
      if (clonedBlocks.length > 1 && updateSelection) {
        dispatch2.multiSelect(clonedBlocks[0].clientId, clonedBlocks[clonedBlocks.length - 1].clientId);
      }
      return clonedBlocks.map((block4) => block4.clientId);
    };
  };
  var insertBeforeBlock = (clientId) => (_ref24) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref24;
    if (!clientId) {
      return;
    }
    const rootClientId = select2.getBlockRootClientId(clientId);
    const isLocked = select2.getTemplateLock(rootClientId);
    if (isLocked) {
      return;
    }
    const firstSelectedIndex = select2.getBlockIndex(clientId);
    return dispatch2.insertDefaultBlock({}, rootClientId, firstSelectedIndex);
  };
  var insertAfterBlock = (clientId) => (_ref25) => {
    let {
      select: select2,
      dispatch: dispatch2
    } = _ref25;
    if (!clientId) {
      return;
    }
    const rootClientId = select2.getBlockRootClientId(clientId);
    const isLocked = select2.getTemplateLock(rootClientId);
    if (isLocked) {
      return;
    }
    const firstSelectedIndex = select2.getBlockIndex(clientId);
    return dispatch2.insertDefaultBlock({}, rootClientId, firstSelectedIndex + 1);
  };
  function toggleBlockHighlight(clientId, isHighlighted) {
    return {
      type: "TOGGLE_BLOCK_HIGHLIGHT",
      clientId,
      isHighlighted
    };
  }
  var flashBlock = (clientId) => async (_ref26) => {
    let {
      dispatch: dispatch2
    } = _ref26;
    dispatch2(toggleBlockHighlight(clientId, true));
    await new Promise((resolve) => setTimeout(resolve, 150));
    dispatch2(toggleBlockHighlight(clientId, false));
  };
  function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
    return {
      type: "SET_HAS_CONTROLLED_INNER_BLOCKS",
      hasControlledInnerBlocks,
      clientId
    };
  }
  function setBlockVisibility(updates) {
    return {
      type: "SET_BLOCK_VISIBILITY",
      updates
    };
  }
  function __unstableSetTemporarilyEditingAsBlocks(temporarilyEditingAsBlocks2) {
    return {
      type: "SET_TEMPORARILY_EDITING_AS_BLOCKS",
      temporarilyEditingAsBlocks: temporarilyEditingAsBlocks2
    };
  }

  // node_modules/@wordpress/block-editor/build-module/store/constants.js
  var STORE_NAME3 = "core/block-editor";

  // node_modules/@wordpress/block-editor/build-module/store/index.js
  var storeConfig = {
    reducer: reducer_default4,
    selectors: selectors_exports4,
    actions: actions_exports5
  };
  var store3 = createReduxStore(STORE_NAME3, {
    ...storeConfig,
    persist: ["preferences"]
  });
  registerStore(STORE_NAME3, {
    ...storeConfig,
    persist: ["preferences"]
  });

  // node_modules/@wordpress/block-editor/build-module/components/use-setting/index.js
  var blockedPaths = ["color", "border", "typography", "spacing"];
  var deprecatedFlags = {
    "color.palette": (settings2) => settings2.colors,
    "color.gradients": (settings2) => settings2.gradients,
    "color.custom": (settings2) => settings2.disableCustomColors === void 0 ? void 0 : !settings2.disableCustomColors,
    "color.customGradient": (settings2) => settings2.disableCustomGradients === void 0 ? void 0 : !settings2.disableCustomGradients,
    "typography.fontSizes": (settings2) => settings2.fontSizes,
    "typography.customFontSize": (settings2) => settings2.disableCustomFontSizes === void 0 ? void 0 : !settings2.disableCustomFontSizes,
    "typography.lineHeight": (settings2) => settings2.enableCustomLineHeight,
    "spacing.units": (settings2) => {
      if (settings2.enableCustomUnits === void 0) {
        return;
      }
      if (settings2.enableCustomUnits === true) {
        return ["px", "em", "rem", "vh", "vw", "%"];
      }
      return settings2.enableCustomUnits;
    },
    "spacing.padding": (settings2) => settings2.enableCustomSpacing
  };
  var prefixedFlags = {
    "border.customColor": "border.color",
    "border.customStyle": "border.style",
    "border.customWidth": "border.width",
    "typography.customFontStyle": "typography.fontStyle",
    "typography.customFontWeight": "typography.fontWeight",
    "typography.customLetterSpacing": "typography.letterSpacing",
    "typography.customTextDecorations": "typography.textDecoration",
    "typography.customTextTransforms": "typography.textTransform",
    "border.customRadius": "border.radius",
    "spacing.customMargin": "spacing.margin",
    "spacing.customPadding": "spacing.padding",
    "typography.customLineHeight": "typography.lineHeight"
  };
  var removeCustomPrefixes = (path) => {
    return prefixedFlags[path] || path;
  };
  function useSetting(path) {
    const {
      name: blockName,
      clientId
    } = useBlockEditContext();
    return useSelect((select2) => {
      if (blockedPaths.includes(path)) {
        console.warn("Top level useSetting paths are disabled. Please use a subpath to query the information needed.");
        return void 0;
      }
      let result;
      const normalizedPath = removeCustomPrefixes(path);
      const candidates = [clientId, ...select2(store3).getBlockParents(
        clientId,
        true
      )];
      for (const candidateClientId of candidates) {
        const candidateBlockName = select2(store3).getBlockName(candidateClientId);
        if (hasBlockSupport(candidateBlockName, "__experimentalSettings", false)) {
          var _get;
          const candidateAtts = select2(store3).getBlockAttributes(candidateClientId);
          result = (_get = (0, import_lodash21.get)(candidateAtts, `settings.blocks.${blockName}.${normalizedPath}`)) !== null && _get !== void 0 ? _get : (0, import_lodash21.get)(candidateAtts, `settings.${normalizedPath}`);
          if (result !== void 0) {
            break;
          }
        }
      }
      const settings2 = select2(store3).getSettings();
      if (result === void 0) {
        var _get2;
        const defaultsPath = `__experimentalFeatures.${normalizedPath}`;
        const blockPath = `__experimentalFeatures.blocks.${blockName}.${normalizedPath}`;
        result = (_get2 = (0, import_lodash21.get)(settings2, blockPath)) !== null && _get2 !== void 0 ? _get2 : (0, import_lodash21.get)(settings2, defaultsPath);
      }
      if (result !== void 0) {
        if (__EXPERIMENTAL_PATHS_WITH_MERGE[normalizedPath]) {
          var _ref8, _result$custom;
          return (_ref8 = (_result$custom = result.custom) !== null && _result$custom !== void 0 ? _result$custom : result.theme) !== null && _ref8 !== void 0 ? _ref8 : result.default;
        }
        return result;
      }
      const deprecatedSettingsValue = deprecatedFlags[normalizedPath] ? deprecatedFlags[normalizedPath](settings2) : void 0;
      if (deprecatedSettingsValue !== void 0) {
        return deprecatedSettingsValue;
      }
      return normalizedPath === "typography.dropCap" ? true : void 0;
    }, [blockName, clientId, path]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/duotone/utils.js
  function getValuesFromColors() {
    let colors2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const values = {
      r: [],
      g: [],
      b: [],
      a: []
    };
    colors2.forEach((color4) => {
      const rgbColor = w(color4).toRgb();
      values.r.push(rgbColor.r / 255);
      values.g.push(rgbColor.g / 255);
      values.b.push(rgbColor.b / 255);
      values.a.push(rgbColor.a);
    });
    return values;
  }

  // node_modules/@wordpress/block-editor/build-module/components/duotone/components.js
  function DuotoneFilter(_ref32) {
    let {
      id: id2,
      colors: colors2
    } = _ref32;
    const values = getValuesFromColors(colors2);
    return (0, import_react.createElement)(SVG, {
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      viewBox: "0 0 0 0",
      width: "0",
      height: "0",
      focusable: "false",
      role: "none",
      style: {
        visibility: "hidden",
        position: "absolute",
        left: "-9999px",
        overflow: "hidden"
      }
    }, (0, import_react.createElement)("defs", null, (0, import_react.createElement)("filter", {
      id: id2
    }, (0, import_react.createElement)("feColorMatrix", {
      colorInterpolationFilters: "sRGB",
      type: "matrix",
      values: " .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 .299 .587 .114 0 0 "
    }), (0, import_react.createElement)("feComponentTransfer", {
      colorInterpolationFilters: "sRGB"
    }, (0, import_react.createElement)("feFuncR", {
      type: "table",
      tableValues: values.r.join(" ")
    }), (0, import_react.createElement)("feFuncG", {
      type: "table",
      tableValues: values.g.join(" ")
    }), (0, import_react.createElement)("feFuncB", {
      type: "table",
      tableValues: values.b.join(" ")
    }), (0, import_react.createElement)("feFuncA", {
      type: "table",
      tableValues: values.a.join(" ")
    })), (0, import_react.createElement)("feComposite", {
      in2: "SourceGraphic",
      operator: "in"
    }))));
  }
  function PresetDuotoneFilter(_ref42) {
    let {
      preset
    } = _ref42;
    return (0, import_react.createElement)(DuotoneFilter, {
      id: `wp-duotone-${preset.slug}`,
      colors: preset.colors
    });
  }

  // node_modules/@wordpress/block-editor/build-module/components/inserter/search-items.js
  var import_remove_accents2 = __toESM(require_remove_accents());
  var import_lodash22 = __toESM(require_lodash());
  var defaultGetName = (item2) => item2.name || "";
  var defaultGetTitle = (item2) => item2.title;
  var defaultGetDescription = (item2) => item2.description || "";
  var defaultGetKeywords = (item2) => item2.keywords || [];
  var defaultGetCategory = (item2) => item2.category;
  var defaultGetCollection = () => null;
  function extractWords() {
    let input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return noCase(input, {
      splitRegexp: [
        /([\p{Ll}\p{Lo}\p{N}])([\p{Lu}\p{Lt}])/gu,
        /([\p{Lu}\p{Lt}])([\p{Lu}\p{Lt}][\p{Ll}\p{Lo}])/gu
      ],
      stripRegexp: /(\p{C}|\p{P}|\p{S})+/giu
    }).split(" ").filter(Boolean);
  }
  function normalizeSearchInput() {
    let input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    input = (0, import_remove_accents2.default)(input);
    input = input.replace(/^\//, "");
    input = input.toLowerCase();
    return input;
  }
  var getNormalizedSearchTerms = function() {
    let input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return extractWords(normalizeSearchInput(input));
  };
  var removeMatchingTerms = (unmatchedTerms, unprocessedTerms) => {
    return unmatchedTerms.filter((term) => !getNormalizedSearchTerms(unprocessedTerms).some((unprocessedTerm) => unprocessedTerm.includes(term)));
  };
  var searchBlockItems = (items, categories2, collections2, searchInput) => {
    const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
    if (normalizedSearchTerms.length === 0) {
      return items;
    }
    const config2 = {
      getCategory: (item2) => {
        var _find;
        return (_find = (0, import_lodash22.find)(categories2, {
          slug: item2.category
        })) === null || _find === void 0 ? void 0 : _find.title;
      },
      getCollection: (item2) => {
        var _collections$item$nam;
        return (_collections$item$nam = collections2[item2.name.split("/")[0]]) === null || _collections$item$nam === void 0 ? void 0 : _collections$item$nam.title;
      }
    };
    return searchItems(items, searchInput, config2);
  };
  var searchItems = function() {
    let items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let searchInput = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const normalizedSearchTerms = getNormalizedSearchTerms(searchInput);
    if (normalizedSearchTerms.length === 0) {
      return items;
    }
    const rankedItems = items.map((item2) => {
      return [item2, getItemSearchRank(item2, searchInput, config2)];
    }).filter((_ref8) => {
      let [, rank] = _ref8;
      return rank > 0;
    });
    rankedItems.sort((_ref22, _ref32) => {
      let [, rank1] = _ref22;
      let [, rank2] = _ref32;
      return rank2 - rank1;
    });
    return rankedItems.map((_ref42) => {
      let [item2] = _ref42;
      return item2;
    });
  };
  function getItemSearchRank(item2, searchTerm) {
    let config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      getName = defaultGetName,
      getTitle = defaultGetTitle,
      getDescription = defaultGetDescription,
      getKeywords = defaultGetKeywords,
      getCategory = defaultGetCategory,
      getCollection = defaultGetCollection
    } = config2;
    const name = getName(item2);
    const title = getTitle(item2);
    const description = getDescription(item2);
    const keywords = getKeywords(item2);
    const category = getCategory(item2);
    const collection = getCollection(item2);
    const normalizedSearchInput = normalizeSearchInput(searchTerm);
    const normalizedTitle = normalizeSearchInput(title);
    let rank = 0;
    if (normalizedSearchInput === normalizedTitle) {
      rank += 30;
    } else if (normalizedTitle.startsWith(normalizedSearchInput)) {
      rank += 20;
    } else {
      const terms = [name, title, description, ...keywords, category, collection].join(" ");
      const normalizedSearchTerms = extractWords(normalizedSearchInput);
      const unmatchedTerms = removeMatchingTerms(normalizedSearchTerms, terms);
      if (unmatchedTerms.length === 0) {
        rank += 10;
      }
    }
    if (rank !== 0 && name.startsWith("core/")) {
      const isCoreBlockVariation = name !== item2.id;
      rank += isCoreBlockVariation ? 1 : 2;
    }
    return rank;
  }

  // node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-block-types-state.js
  var useBlockTypesState = (rootClientId, onInsert) => {
    const {
      categories: categories2,
      collections: collections2,
      items
    } = useSelect((select2) => {
      const {
        getInserterItems: getInserterItems2
      } = select2(store3);
      const {
        getCategories: getCategories2,
        getCollections: getCollections2
      } = select2(store);
      return {
        categories: getCategories2(),
        collections: getCollections2(),
        items: getInserterItems2(rootClientId)
      };
    }, [rootClientId]);
    const onSelectItem = (0, import_react.useCallback)((_ref8, shouldFocusBlock) => {
      let {
        name,
        initialAttributes,
        innerBlocks
      } = _ref8;
      const insertedBlock = createBlock(name, initialAttributes, createBlocksFromInnerBlocksTemplate(innerBlocks));
      onInsert(insertedBlock, void 0, shouldFocusBlock);
    }, [onInsert]);
    return [items, categories2, collections2, onSelectItem];
  };
  var use_block_types_state_default = useBlockTypesState;

  // node_modules/@wordpress/block-editor/build-module/components/block-icon/index.js
  var import_classnames22 = __toESM(require_classnames());
  function BlockIcon(_ref8) {
    var _icon;
    let {
      icon,
      showColors = false,
      className
    } = _ref8;
    if (((_icon = icon) === null || _icon === void 0 ? void 0 : _icon.src) === "block-default") {
      icon = {
        src: block_default_default
      };
    }
    const renderedIcon = (0, import_react.createElement)(icon_default2, {
      icon: icon && icon.src ? icon.src : icon
    });
    const style = showColors ? {
      backgroundColor: icon && icon.background,
      color: icon && icon.foreground
    } : {};
    return (0, import_react.createElement)("span", {
      style,
      className: (0, import_classnames22.default)("block-editor-block-icon", className, {
        "has-colors": showColors
      })
    }, renderedIcon);
  }
  var block_icon_default = (0, import_react.memo)(BlockIcon);

  // node_modules/@wordpress/url/build-module/get-query-string.js
  function getQueryString(url) {
    let query2;
    try {
      query2 = new URL(url, "http://example.com").search.substring(1);
    } catch (error2) {
    }
    if (query2) {
      return query2;
    }
  }

  // node_modules/@wordpress/url/build-module/build-query-string.js
  function buildQueryString(data) {
    let string2 = "";
    const stack4 = Object.entries(data);
    let pair;
    while (pair = stack4.shift()) {
      let [key, value] = pair;
      const hasNestedData = Array.isArray(value) || value && value.constructor === Object;
      if (hasNestedData) {
        const valuePairs = Object.entries(value).reverse();
        for (const [member, memberValue] of valuePairs) {
          stack4.unshift([`${key}[${member}]`, memberValue]);
        }
      } else if (value !== void 0) {
        if (value === null) {
          value = "";
        }
        string2 += "&" + [key, value].map(encodeURIComponent).join("=");
      }
    }
    return string2.substr(1);
  }

  // node_modules/@wordpress/url/build-module/get-query-args.js
  function setPath(object, path, value) {
    const length = path.length;
    const lastIndex = length - 1;
    for (let i5 = 0; i5 < length; i5++) {
      let key = path[i5];
      if (!key && Array.isArray(object)) {
        key = object.length.toString();
      }
      key = ["__proto__", "constructor", "prototype"].includes(key) ? key.toUpperCase() : key;
      const isNextKeyArrayIndex = !isNaN(Number(path[i5 + 1]));
      object[key] = i5 === lastIndex ? value : object[key] || (isNextKeyArrayIndex ? [] : {});
      if (Array.isArray(object[key]) && !isNextKeyArrayIndex) {
        object[key] = {
          ...object[key]
        };
      }
      object = object[key];
    }
  }
  function getQueryArgs(url) {
    return (getQueryString(url) || "").replace(/\+/g, "%20").split("&").reduce((accumulator, keyValue) => {
      const [key, value = ""] = keyValue.split("=").filter(Boolean).map(decodeURIComponent);
      if (key) {
        const segments = key.replace(/\]/g, "").split("[");
        setPath(accumulator, segments, value);
      }
      return accumulator;
    }, /* @__PURE__ */ Object.create(null));
  }

  // node_modules/@wordpress/url/build-module/add-query-args.js
  function addQueryArgs() {
    let url = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let args = arguments.length > 1 ? arguments[1] : void 0;
    if (!args || !Object.keys(args).length) {
      return url;
    }
    let baseUrl = url;
    const queryStringIndex = url.indexOf("?");
    if (queryStringIndex !== -1) {
      args = Object.assign(getQueryArgs(url), args);
      baseUrl = baseUrl.substr(0, queryStringIndex);
    }
    return baseUrl + "?" + buildQueryString(args);
  }

  // node_modules/@wordpress/block-editor/build-module/layouts/utils.js
  function appendSelectors(selectors) {
    let append2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return selectors.split(",").map((subselector) => `.editor-styles-wrapper ${subselector}${append2 ? ` ${append2}` : ""}`).join(",");
  }
  function getBlockGapCSS(selector4, layoutDefinitions, layoutType, blockGapValue) {
    var _layoutDefinitions$la, _layoutDefinitions$la2;
    let output3 = "";
    if (layoutDefinitions !== null && layoutDefinitions !== void 0 && (_layoutDefinitions$la = layoutDefinitions[layoutType]) !== null && _layoutDefinitions$la !== void 0 && (_layoutDefinitions$la2 = _layoutDefinitions$la.spacingStyles) !== null && _layoutDefinitions$la2 !== void 0 && _layoutDefinitions$la2.length && blockGapValue) {
      layoutDefinitions[layoutType].spacingStyles.forEach((gapStyle) => {
        output3 += `${appendSelectors(selector4, gapStyle.selector.trim())} { `;
        output3 += Object.entries(gapStyle.rules).map((_ref8) => {
          let [cssProperty, value] = _ref8;
          return `${cssProperty}: ${value ? value : blockGapValue}`;
        }).join("; ");
        output3 += "; }";
      });
    }
    return output3;
  }
  function getAlignmentsInfo(layout) {
    const {
      contentSize,
      wideSize
    } = layout;
    const alignmentInfo = {};
    const sizeRegex = /^(?!0)\d+(px|em|rem|vw|vh|%)?$/i;
    if (sizeRegex.test(contentSize)) {
      alignmentInfo.none = sprintf(__("Max %s wide"), contentSize);
    }
    if (sizeRegex.test(wideSize)) {
      alignmentInfo.wide = sprintf(__("Max %s wide"), wideSize);
    }
    return alignmentInfo;
  }

  // node_modules/@wordpress/block-editor/build-module/components/provider/block-refs-provider.js
  var BlockRefs = (0, import_react.createContext)({
    refs: /* @__PURE__ */ new Map(),
    callbacks: /* @__PURE__ */ new Map()
  });
  function BlockRefsProvider(_ref8) {
    let {
      children
    } = _ref8;
    const value = (0, import_react.useMemo)(() => ({
      refs: /* @__PURE__ */ new Map(),
      callbacks: /* @__PURE__ */ new Map()
    }), []);
    return (0, import_react.createElement)(BlockRefs.Provider, {
      value
    }, children);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-refs.js
  function useBlockRefProvider(clientId) {
    const {
      refs,
      callbacks
    } = (0, import_react.useContext)(BlockRefs);
    const ref2 = (0, import_react.useRef)();
    (0, import_react.useLayoutEffect)(() => {
      refs.set(ref2, clientId);
      return () => {
        refs.delete(ref2);
      };
    }, [clientId]);
    return useRefEffect((element) => {
      ref2.current = element;
      callbacks.forEach((id2, setElement) => {
        if (clientId === id2) {
          setElement(element);
        }
      });
    }, [clientId]);
  }
  function useBlockRef(clientId) {
    const {
      refs
    } = (0, import_react.useContext)(BlockRefs);
    const freshClientId = (0, import_react.useRef)();
    freshClientId.current = clientId;
    return (0, import_react.useMemo)(() => ({
      get current() {
        let element = null;
        for (const [ref2, id2] of refs.entries()) {
          if (id2 === freshClientId.current && ref2.current) {
            element = ref2.current;
          }
        }
        return element;
      }
    }), []);
  }
  function useBlockElement(clientId) {
    const {
      callbacks
    } = (0, import_react.useContext)(BlockRefs);
    const ref2 = useBlockRef(clientId);
    const [element, setElement] = (0, import_react.useState)(null);
    (0, import_react.useLayoutEffect)(() => {
      if (!clientId) {
        return;
      }
      callbacks.set(setElement, clientId);
      return () => {
        callbacks.delete(setElement);
      };
    }, [clientId]);
    return ref2.current || element;
  }

  // node_modules/@wordpress/block-editor/build-module/components/spacing-sizes-control/utils.js
  var import_lodash23 = __toESM(require_lodash());
  function getSpacingPresetCssVar(value) {
    if (!value) {
      return;
    }
    const slug = value.match(/var:preset\|spacing\|(.+)/);
    if (!slug) {
      return value;
    }
    return `var(--wp--preset--spacing--${slug[1]})`;
  }
  var LABELS = {
    all: __("All sides"),
    top: __("Top"),
    bottom: __("Bottom"),
    left: __("Left"),
    right: __("Right"),
    mixed: __("Mixed"),
    vertical: __("Vertical"),
    horizontal: __("Horizontal")
  };

  // node_modules/@wordpress/block-editor/build-module/components/use-display-block-controls/index.js
  function useDisplayBlockControls() {
    const {
      isSelected,
      clientId,
      name
    } = useBlockEditContext();
    return useSelect((select2) => {
      if (isSelected) {
        return true;
      }
      const {
        getBlockName: getBlockName2,
        isFirstMultiSelectedBlock: isFirstMultiSelectedBlock2,
        getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2
      } = select2(store3);
      if (isFirstMultiSelectedBlock2(clientId)) {
        return getMultiSelectedBlockClientIds2().every((id2) => getBlockName2(id2) === name);
      }
      return false;
    }, [clientId, isSelected, name]);
  }

  // node_modules/@wordpress/block-editor/build-module/hooks/utils.js
  var import_lodash24 = __toESM(require_lodash());
  function shouldSkipSerialization(blockType, featureSet, feature) {
    const support = getBlockSupport(blockType, featureSet);
    const skipSerialization = support === null || support === void 0 ? void 0 : support.__experimentalSkipSerialization;
    if (Array.isArray(skipSerialization)) {
      return skipSerialization.includes(feature);
    }
    return skipSerialization;
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-popover/index.js
  var import_classnames23 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-popover/use-popover-scroll.js
  function usePopoverScroll(scrollableRef) {
    return useRefEffect((node) => {
      if (!scrollableRef) {
        return;
      }
      function onWheel(event) {
        const {
          deltaX,
          deltaY
        } = event;
        scrollableRef.current.scrollBy(deltaX, deltaY);
      }
      const options = {
        passive: true
      };
      node.addEventListener("wheel", onWheel, options);
      return () => {
        node.removeEventListener("wheel", onWheel, options);
      };
    }, [scrollableRef]);
  }
  var use_popover_scroll_default = usePopoverScroll;

  // node_modules/@wordpress/block-editor/build-module/components/block-popover/index.js
  var MAX_POPOVER_RECOMPUTE_COUNTER = Number.MAX_SAFE_INTEGER;
  function BlockPopover(_ref8, ref2) {
    let {
      clientId,
      bottomClientId,
      children,
      __unstableRefreshSize,
      __unstableCoverTarget = false,
      __unstablePopoverSlot,
      __unstableContentRef,
      shift = true,
      ...props
    } = _ref8;
    const selectedElement = useBlockElement(clientId);
    const lastSelectedElement = useBlockElement(bottomClientId !== null && bottomClientId !== void 0 ? bottomClientId : clientId);
    const mergedRefs = useMergeRefs([ref2, use_popover_scroll_default(__unstableContentRef)]);
    const [popoverDimensionsRecomputeCounter, forceRecomputePopoverDimensions] = (0, import_react.useReducer)(
      (s5) => (s5 + 1) % MAX_POPOVER_RECOMPUTE_COUNTER,
      0
    );
    (0, import_react.useLayoutEffect)(() => {
      if (!selectedElement) {
        return;
      }
      const observer = new window.MutationObserver(forceRecomputePopoverDimensions);
      observer.observe(selectedElement, {
        attributes: true
      });
      return () => {
        observer.disconnect();
      };
    }, [selectedElement]);
    const style = (0, import_react.useMemo)(() => {
      if (popoverDimensionsRecomputeCounter < 0 || !selectedElement || lastSelectedElement !== selectedElement) {
        return {};
      }
      return {
        position: "absolute",
        width: selectedElement.offsetWidth,
        height: selectedElement.offsetHeight
      };
    }, [selectedElement, lastSelectedElement, __unstableRefreshSize, popoverDimensionsRecomputeCounter]);
    const popoverAnchor = (0, import_react.useMemo)(() => {
      if (popoverDimensionsRecomputeCounter < 0 || !selectedElement || bottomClientId && !lastSelectedElement) {
        return void 0;
      }
      return {
        getBoundingClientRect() {
          var _lastSelectedBCR$left, _lastSelectedBCR$top, _lastSelectedBCR$righ, _lastSelectedBCR$bott;
          const selectedBCR = selectedElement.getBoundingClientRect();
          const lastSelectedBCR = lastSelectedElement === null || lastSelectedElement === void 0 ? void 0 : lastSelectedElement.getBoundingClientRect();
          const left = Math.min(selectedBCR.left, (_lastSelectedBCR$left = lastSelectedBCR === null || lastSelectedBCR === void 0 ? void 0 : lastSelectedBCR.left) !== null && _lastSelectedBCR$left !== void 0 ? _lastSelectedBCR$left : Infinity);
          const top = Math.min(selectedBCR.top, (_lastSelectedBCR$top = lastSelectedBCR === null || lastSelectedBCR === void 0 ? void 0 : lastSelectedBCR.top) !== null && _lastSelectedBCR$top !== void 0 ? _lastSelectedBCR$top : Infinity);
          const right = Math.max(selectedBCR.right, (_lastSelectedBCR$righ = lastSelectedBCR.right) !== null && _lastSelectedBCR$righ !== void 0 ? _lastSelectedBCR$righ : -Infinity);
          const bottom = Math.max(selectedBCR.bottom, (_lastSelectedBCR$bott = lastSelectedBCR.bottom) !== null && _lastSelectedBCR$bott !== void 0 ? _lastSelectedBCR$bott : -Infinity);
          const width3 = right - left;
          const height = bottom - top;
          return new window.DOMRect(left, top, width3, height);
        },
        ownerDocument: selectedElement.ownerDocument
      };
    }, [bottomClientId, lastSelectedElement, selectedElement, popoverDimensionsRecomputeCounter]);
    if (!selectedElement || bottomClientId && !lastSelectedElement) {
      return null;
    }
    return (0, import_react.createElement)(popover_default, _extends({
      ref: mergedRefs,
      animate: false,
      focusOnMount: false,
      anchor: popoverAnchor,
      __unstableSlotName: __unstablePopoverSlot || null,
      placement: "top-start",
      resize: false,
      flip: false,
      shift
    }, props, {
      className: (0, import_classnames23.default)("block-editor-block-popover", props.className),
      variant: "unstyled"
    }), __unstableCoverTarget && (0, import_react.createElement)("div", {
      style
    }, children), !__unstableCoverTarget && children);
  }
  var block_popover_default = (0, import_react.forwardRef)(BlockPopover);

  // node_modules/@wordpress/block-editor/build-module/hooks/gap.js
  function getGapBoxControlValueFromStyle(blockGapValue) {
    if (!blockGapValue) {
      return null;
    }
    const isValueString = typeof blockGapValue === "string";
    return {
      top: isValueString ? blockGapValue : blockGapValue === null || blockGapValue === void 0 ? void 0 : blockGapValue.top,
      left: isValueString ? blockGapValue : blockGapValue === null || blockGapValue === void 0 ? void 0 : blockGapValue.left
    };
  }
  function getGapCSSValue(blockGapValue) {
    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0";
    const blockGapBoxControlValue = getGapBoxControlValueFromStyle(blockGapValue);
    if (!blockGapBoxControlValue) {
      return null;
    }
    const row2 = getSpacingPresetCssVar(blockGapBoxControlValue === null || blockGapBoxControlValue === void 0 ? void 0 : blockGapBoxControlValue.top) || defaultValue;
    const column = getSpacingPresetCssVar(blockGapBoxControlValue === null || blockGapBoxControlValue === void 0 ? void 0 : blockGapBoxControlValue.left) || defaultValue;
    return row2 === column ? row2 : `${row2} ${column}`;
  }

  // node_modules/@wordpress/block-editor/build-module/layouts/flex.js
  var justifyContentMap = {
    left: "flex-start",
    right: "flex-end",
    center: "center",
    "space-between": "space-between"
  };
  var alignItemsMap = {
    left: "flex-start",
    right: "flex-end",
    center: "center"
  };
  var verticalAlignmentMap = {
    top: "flex-start",
    center: "center",
    bottom: "flex-end"
  };
  var flexWrapOptions = ["wrap", "nowrap"];
  var flex_default = {
    name: "flex",
    label: __("Flex"),
    inspectorControls: function FlexLayoutInspectorControls(_ref8) {
      let {
        layout = {},
        onChange,
        layoutBlockSupport = {}
      } = _ref8;
      const {
        allowOrientation = true
      } = layoutBlockSupport;
      return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(component_default3, null, (0, import_react.createElement)(component_default4, null, (0, import_react.createElement)(FlexLayoutJustifyContentControl, {
        layout,
        onChange
      })), (0, import_react.createElement)(component_default4, null, allowOrientation && (0, import_react.createElement)(OrientationControl, {
        layout,
        onChange
      }))), (0, import_react.createElement)(FlexWrapControl, {
        layout,
        onChange
      }));
    },
    toolBarControls: function FlexLayoutToolbarControls(_ref22) {
      let {
        layout = {},
        onChange,
        layoutBlockSupport
      } = _ref22;
      if (layoutBlockSupport !== null && layoutBlockSupport !== void 0 && layoutBlockSupport.allowSwitching) {
        return null;
      }
      const {
        allowVerticalAlignment = true
      } = layoutBlockSupport;
      return (0, import_react.createElement)(block_controls_default, {
        group: "block",
        __experimentalShareWithChildBlocks: true
      }, (0, import_react.createElement)(FlexLayoutJustifyContentControl, {
        layout,
        onChange,
        isToolbar: true
      }), allowVerticalAlignment && (layout === null || layout === void 0 ? void 0 : layout.orientation) !== "vertical" && (0, import_react.createElement)(FlexLayoutVerticalAlignmentControl, {
        layout,
        onChange,
        isToolbar: true
      }));
    },
    getLayoutStyle: function getLayoutStyle(_ref32) {
      var _style$spacing, _style$spacing2;
      let {
        selector: selector4,
        layout,
        style,
        blockName,
        hasBlockGapSupport,
        layoutDefinitions
      } = _ref32;
      const {
        orientation = "horizontal"
      } = layout;
      const blockGapValue = style !== null && style !== void 0 && (_style$spacing = style.spacing) !== null && _style$spacing !== void 0 && _style$spacing.blockGap && !shouldSkipSerialization(blockName, "spacing", "blockGap") ? getGapCSSValue(style === null || style === void 0 ? void 0 : (_style$spacing2 = style.spacing) === null || _style$spacing2 === void 0 ? void 0 : _style$spacing2.blockGap, "0.5em") : void 0;
      const justifyContent = justifyContentMap[layout.justifyContent];
      const flexWrap = flexWrapOptions.includes(layout.flexWrap) ? layout.flexWrap : "wrap";
      const verticalAlignment = verticalAlignmentMap[layout.verticalAlignment];
      const alignItems = alignItemsMap[layout.justifyContent] || alignItemsMap.left;
      let output3 = "";
      const rules = [];
      if (flexWrap && flexWrap !== "wrap") {
        rules.push(`flex-wrap: ${flexWrap}`);
      }
      if (orientation === "horizontal") {
        if (verticalAlignment) {
          rules.push(`align-items: ${verticalAlignment}`);
        }
        if (justifyContent) {
          rules.push(`justify-content: ${justifyContent}`);
        }
      } else {
        rules.push("flex-direction: column");
        rules.push(`align-items: ${alignItems}`);
      }
      if (rules.length) {
        output3 = `${appendSelectors(selector4)} {
				${rules.join("; ")};
			}`;
      }
      if (hasBlockGapSupport && blockGapValue) {
        output3 += getBlockGapCSS(selector4, layoutDefinitions, "flex", blockGapValue);
      }
      return output3;
    },
    getOrientation(layout) {
      const {
        orientation = "horizontal"
      } = layout;
      return orientation;
    },
    getAlignments() {
      return [];
    }
  };
  function FlexLayoutVerticalAlignmentControl(_ref42) {
    let {
      layout,
      onChange,
      isToolbar = false
    } = _ref42;
    const {
      verticalAlignment = verticalAlignmentMap.center
    } = layout;
    const onVerticalAlignmentChange = (value) => {
      onChange({
        ...layout,
        verticalAlignment: value
      });
    };
    if (isToolbar) {
      return (0, import_react.createElement)(BlockVerticalAlignmentControl, {
        onChange: onVerticalAlignmentChange,
        value: verticalAlignment
      });
    }
    const verticalAlignmentOptions = [{
      value: "flex-start",
      label: __("Align items top")
    }, {
      value: "center",
      label: __("Align items center")
    }, {
      value: "flex-end",
      label: __("Align items bottom")
    }];
    return (0, import_react.createElement)("fieldset", {
      className: "block-editor-hooks__flex-layout-vertical-alignment-control"
    }, (0, import_react.createElement)("legend", null, __("Vertical alignment")), (0, import_react.createElement)("div", null, verticalAlignmentOptions.map((value, icon, label) => {
      return (0, import_react.createElement)(button_default, {
        key: value,
        label,
        icon,
        isPressed: verticalAlignment === value,
        onClick: () => onVerticalAlignmentChange(value)
      });
    })));
  }
  function FlexLayoutJustifyContentControl(_ref52) {
    let {
      layout,
      onChange,
      isToolbar = false
    } = _ref52;
    const {
      justifyContent = "left",
      orientation = "horizontal"
    } = layout;
    const onJustificationChange = (value) => {
      onChange({
        ...layout,
        justifyContent: value
      });
    };
    const allowedControls = ["left", "center", "right"];
    if (orientation === "horizontal") {
      allowedControls.push("space-between");
    }
    if (isToolbar) {
      return (0, import_react.createElement)(JustifyContentControl, {
        allowedControls,
        value: justifyContent,
        onChange: onJustificationChange,
        popoverProps: {
          position: "bottom right",
          variant: "toolbar"
        }
      });
    }
    const justificationOptions = [{
      value: "left",
      icon: justify_left_default,
      label: __("Justify items left")
    }, {
      value: "center",
      icon: justify_center_default,
      label: __("Justify items center")
    }, {
      value: "right",
      icon: justify_right_default,
      label: __("Justify items right")
    }];
    if (orientation === "horizontal") {
      justificationOptions.push({
        value: "space-between",
        icon: justify_space_between_default,
        label: __("Space between items")
      });
    }
    return (0, import_react.createElement)("fieldset", {
      className: "block-editor-hooks__flex-layout-justification-controls"
    }, (0, import_react.createElement)("legend", null, __("Justification")), (0, import_react.createElement)("div", null, justificationOptions.map((_ref62) => {
      let {
        value,
        icon,
        label
      } = _ref62;
      return (0, import_react.createElement)(button_default, {
        key: value,
        label,
        icon,
        isPressed: justifyContent === value,
        onClick: () => onJustificationChange(value)
      });
    })));
  }
  function FlexWrapControl(_ref72) {
    let {
      layout,
      onChange
    } = _ref72;
    const {
      flexWrap = "wrap"
    } = layout;
    return (0, import_react.createElement)(toggle_control_default, {
      label: __("Allow to wrap to multiple lines"),
      onChange: (value) => {
        onChange({
          ...layout,
          flexWrap: value ? "wrap" : "nowrap"
        });
      },
      checked: flexWrap === "wrap"
    });
  }
  function OrientationControl(_ref8) {
    let {
      layout,
      onChange
    } = _ref8;
    const {
      orientation = "horizontal"
    } = layout;
    return (0, import_react.createElement)("fieldset", {
      className: "block-editor-hooks__flex-layout-orientation-controls"
    }, (0, import_react.createElement)("legend", null, __("Orientation")), (0, import_react.createElement)(button_default, {
      label: __("Horizontal"),
      icon: arrow_right_default,
      isPressed: orientation === "horizontal",
      onClick: () => onChange({
        ...layout,
        orientation: "horizontal"
      })
    }), (0, import_react.createElement)(button_default, {
      label: __("Vertical"),
      icon: arrow_down_default,
      isPressed: orientation === "vertical",
      onClick: () => onChange({
        ...layout,
        orientation: "vertical"
      })
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/layouts/flow.js
  var flow_default = {
    name: "default",
    label: __("Flow"),
    inspectorControls: function DefaultLayoutInspectorControls() {
      return null;
    },
    toolBarControls: function DefaultLayoutToolbarControls() {
      return null;
    },
    getLayoutStyle: function getLayoutStyle2(_ref8) {
      var _style$spacing;
      let {
        selector: selector4,
        style,
        blockName,
        hasBlockGapSupport,
        layoutDefinitions
      } = _ref8;
      const blockGapStyleValue = getGapCSSValue(style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.blockGap);
      let blockGapValue = "";
      if (!shouldSkipSerialization(blockName, "spacing", "blockGap")) {
        if (blockGapStyleValue !== null && blockGapStyleValue !== void 0 && blockGapStyleValue.top) {
          blockGapValue = getGapCSSValue(blockGapStyleValue === null || blockGapStyleValue === void 0 ? void 0 : blockGapStyleValue.top);
        } else if (typeof blockGapStyleValue === "string") {
          blockGapValue = getGapCSSValue(blockGapStyleValue);
        }
      }
      let output3 = "";
      if (hasBlockGapSupport && blockGapValue) {
        output3 += getBlockGapCSS(selector4, layoutDefinitions, "default", blockGapValue);
      }
      return output3;
    },
    getOrientation() {
      return "vertical";
    },
    getAlignments(layout) {
      const alignmentInfo = getAlignmentsInfo(layout);
      if (layout.alignments !== void 0) {
        if (!layout.alignments.includes("none")) {
          layout.alignments.unshift("none");
        }
        return layout.alignments.map((alignment) => ({
          name: alignment,
          info: alignmentInfo[alignment]
        }));
      }
      const {
        contentSize,
        wideSize
      } = layout;
      const alignments = [{
        name: "left"
      }, {
        name: "center"
      }, {
        name: "right"
      }];
      if (contentSize) {
        alignments.unshift({
          name: "full"
        });
      }
      if (wideSize) {
        alignments.unshift({
          name: "wide",
          info: alignmentInfo.wide
        });
      }
      alignments.unshift({
        name: "none",
        info: alignmentInfo.none
      });
      return alignments;
    }
  };

  // node_modules/@wordpress/style-engine/build-module/index.js
  var import_lodash26 = __toESM(require_lodash());

  // node_modules/@wordpress/style-engine/build-module/styles/utils.js
  var import_lodash25 = __toESM(require_lodash());

  // node_modules/@wordpress/style-engine/build-module/styles/constants.js
  var VARIABLE_REFERENCE_PREFIX = "var:";
  var VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE = "|";
  var VARIABLE_PATH_SEPARATOR_TOKEN_STYLE = "--";

  // node_modules/@wordpress/style-engine/build-module/styles/utils.js
  function generateRule(style, options, path, ruleKey) {
    const styleValue = (0, import_lodash25.get)(style, path);
    return styleValue ? [{
      selector: options === null || options === void 0 ? void 0 : options.selector,
      key: ruleKey,
      value: getCSSVarFromStyleValue(styleValue)
    }] : [];
  }
  function generateBoxRules(style, options, path, ruleKeys) {
    let individualProperties = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ["top", "right", "bottom", "left"];
    const boxStyle = (0, import_lodash25.get)(style, path);
    if (!boxStyle) {
      return [];
    }
    const rules = [];
    if (typeof boxStyle === "string") {
      rules.push({
        selector: options === null || options === void 0 ? void 0 : options.selector,
        key: ruleKeys.default,
        value: boxStyle
      });
    } else {
      const sideRules = individualProperties.reduce((acc, side) => {
        const value = getCSSVarFromStyleValue((0, import_lodash25.get)(boxStyle, [side]));
        if (value) {
          acc.push({
            selector: options === null || options === void 0 ? void 0 : options.selector,
            key: ruleKeys === null || ruleKeys === void 0 ? void 0 : ruleKeys.individual.replace("%s", upperFirst(side)),
            value
          });
        }
        return acc;
      }, []);
      rules.push(...sideRules);
    }
    return rules;
  }
  function getCSSVarFromStyleValue(styleValue) {
    if (typeof styleValue === "string" && styleValue.startsWith(VARIABLE_REFERENCE_PREFIX)) {
      const variable = styleValue.slice(VARIABLE_REFERENCE_PREFIX.length).split(VARIABLE_PATH_SEPARATOR_TOKEN_ATTRIBUTE).map((presetVariable) => (0, import_lodash25.kebabCase)(presetVariable)).join(VARIABLE_PATH_SEPARATOR_TOKEN_STYLE);
      return `var(--wp--${variable})`;
    }
    return styleValue;
  }
  function upperFirst(string2) {
    const [firstLetter, ...rest] = string2;
    return firstLetter.toUpperCase() + rest.join("");
  }
  function camelCaseJoin(strings) {
    const [firstItem, ...rest] = strings;
    return firstItem.toLowerCase() + rest.map(upperFirst).join("");
  }

  // node_modules/@wordpress/style-engine/build-module/styles/border/index.js
  function createBorderGenerateFunction(path) {
    return (style, options) => generateRule(style, options, path, camelCaseJoin(path));
  }
  function createBorderEdgeGenerateFunction(edge) {
    return (style, options) => {
      return ["color", "style", "width"].flatMap((key) => {
        const path = ["border", edge, key];
        return createBorderGenerateFunction(path)(style, options);
      });
    };
  }
  var color2 = {
    name: "color",
    generate: createBorderGenerateFunction(["border", "color"])
  };
  var radius = {
    name: "radius",
    generate: (style, options) => {
      return generateBoxRules(style, options, ["border", "radius"], {
        default: "borderRadius",
        individual: "border%sRadius"
      }, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
    }
  };
  var borderStyle = {
    name: "style",
    generate: createBorderGenerateFunction(["border", "style"])
  };
  var width = {
    name: "width",
    generate: createBorderGenerateFunction(["border", "width"])
  };
  var borderTop = {
    name: "borderTop",
    generate: createBorderEdgeGenerateFunction("top")
  };
  var borderRight = {
    name: "borderRight",
    generate: createBorderEdgeGenerateFunction("right")
  };
  var borderBottom = {
    name: "borderBottom",
    generate: createBorderEdgeGenerateFunction("bottom")
  };
  var borderLeft = {
    name: "borderLeft",
    generate: createBorderEdgeGenerateFunction("left")
  };
  var border_default = [color2, borderStyle, width, radius, borderTop, borderRight, borderBottom, borderLeft];

  // node_modules/@wordpress/style-engine/build-module/styles/color/background.js
  var background = {
    name: "background",
    generate: (style, options) => {
      return generateRule(style, options, ["color", "background"], "backgroundColor");
    }
  };
  var background_default = background;

  // node_modules/@wordpress/style-engine/build-module/styles/color/gradient.js
  var gradient = {
    name: "gradient",
    generate: (style, options) => {
      return generateRule(style, options, ["color", "gradient"], "background");
    }
  };
  var gradient_default = gradient;

  // node_modules/@wordpress/style-engine/build-module/styles/color/text.js
  var text2 = {
    name: "text",
    generate: (style, options) => {
      return generateRule(style, options, ["color", "text"], "color");
    }
  };
  var text_default = text2;

  // node_modules/@wordpress/style-engine/build-module/styles/color/index.js
  var color_default = [text_default, gradient_default, background_default];

  // node_modules/@wordpress/style-engine/build-module/styles/dimensions/index.js
  var minHeight = {
    name: "minHeight",
    generate: (style, options) => {
      return generateRule(style, options, ["dimensions", "minHeight"], "minHeight");
    }
  };
  var dimensions_default = [minHeight];

  // node_modules/@wordpress/style-engine/build-module/styles/shadow/index.js
  var shadow = {
    name: "shadow",
    generate: (style, options) => {
      return generateRule(style, options, ["shadow"], "boxShadow");
    }
  };
  var shadow_default = [shadow];

  // node_modules/@wordpress/style-engine/build-module/styles/outline/index.js
  var color3 = {
    name: "color",
    generate: function(style, options) {
      let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["outline", "color"];
      let ruleKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "outlineColor";
      return generateRule(style, options, path, ruleKey);
    }
  };
  var offset3 = {
    name: "offset",
    generate: function(style, options) {
      let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["outline", "offset"];
      let ruleKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "outlineOffset";
      return generateRule(style, options, path, ruleKey);
    }
  };
  var outlineStyle = {
    name: "style",
    generate: function(style, options) {
      let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["outline", "style"];
      let ruleKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "outlineStyle";
      return generateRule(style, options, path, ruleKey);
    }
  };
  var width2 = {
    name: "width",
    generate: function(style, options) {
      let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["outline", "width"];
      let ruleKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "outlineWidth";
      return generateRule(style, options, path, ruleKey);
    }
  };
  var outline_default = [color3, outlineStyle, offset3, width2];

  // node_modules/@wordpress/style-engine/build-module/styles/spacing/padding.js
  var padding = {
    name: "padding",
    generate: (style, options) => {
      return generateBoxRules(style, options, ["spacing", "padding"], {
        default: "padding",
        individual: "padding%s"
      });
    }
  };
  var padding_default = padding;

  // node_modules/@wordpress/style-engine/build-module/styles/spacing/margin.js
  var margin = {
    name: "margin",
    generate: (style, options) => {
      return generateBoxRules(style, options, ["spacing", "margin"], {
        default: "margin",
        individual: "margin%s"
      });
    }
  };
  var margin_default = margin;

  // node_modules/@wordpress/style-engine/build-module/styles/spacing/index.js
  var spacing_default = [margin_default, padding_default];

  // node_modules/@wordpress/style-engine/build-module/styles/typography/index.js
  var fontSize = {
    name: "fontSize",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "fontSize"], "fontSize");
    }
  };
  var fontStyle = {
    name: "fontStyle",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "fontStyle"], "fontStyle");
    }
  };
  var fontWeight = {
    name: "fontWeight",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "fontWeight"], "fontWeight");
    }
  };
  var fontFamily = {
    name: "fontFamily",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "fontFamily"], "fontFamily");
    }
  };
  var letterSpacing = {
    name: "letterSpacing",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "letterSpacing"], "letterSpacing");
    }
  };
  var lineHeight = {
    name: "letterSpacing",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "lineHeight"], "lineHeight");
    }
  };
  var textDecoration = {
    name: "textDecoration",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "textDecoration"], "textDecoration");
    }
  };
  var textTransform = {
    name: "textTransform",
    generate: (style, options) => {
      return generateRule(style, options, ["typography", "textTransform"], "textTransform");
    }
  };
  var typography_default = [fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textDecoration, textTransform];

  // node_modules/@wordpress/style-engine/build-module/styles/index.js
  var styleDefinitions = [...border_default, ...color_default, ...dimensions_default, ...outline_default, ...spacing_default, ...typography_default, ...shadow_default];

  // node_modules/@wordpress/style-engine/build-module/index.js
  function getCSSRules(style) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rules = [];
    styleDefinitions.forEach((definition) => {
      if (typeof definition.generate === "function") {
        rules.push(...definition.generate(style, options));
      }
    });
    return rules;
  }

  // node_modules/@wordpress/block-editor/build-module/layouts/constrained.js
  var constrained_default = {
    name: "constrained",
    label: __("Constrained"),
    inspectorControls: function DefaultLayoutInspectorControls2(_ref8) {
      let {
        layout,
        onChange
      } = _ref8;
      const {
        wideSize,
        contentSize,
        justifyContent = "center"
      } = layout;
      const onJustificationChange = (value) => {
        onChange({
          ...layout,
          justifyContent: value
        });
      };
      const justificationOptions = [{
        value: "left",
        icon: justify_left_default,
        label: __("Justify items left")
      }, {
        value: "center",
        icon: justify_center_default,
        label: __("Justify items center")
      }, {
        value: "right",
        icon: justify_right_default,
        label: __("Justify items right")
      }];
      const units = useCustomUnits({
        availableUnits: useSetting("spacing.units") || ["%", "px", "em", "rem", "vw"]
      });
      return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("div", {
        className: "block-editor-hooks__layout-controls"
      }, (0, import_react.createElement)("div", {
        className: "block-editor-hooks__layout-controls-unit"
      }, (0, import_react.createElement)(unit_control_default, {
        label: __("Content"),
        labelPosition: "top",
        __unstableInputWidth: "80px",
        value: contentSize || wideSize || "",
        onChange: (nextWidth) => {
          nextWidth = 0 > parseFloat(nextWidth) ? "0" : nextWidth;
          onChange({
            ...layout,
            contentSize: nextWidth
          });
        },
        units
      }), (0, import_react.createElement)(icon_default, {
        icon: position_center_default
      })), (0, import_react.createElement)("div", {
        className: "block-editor-hooks__layout-controls-unit"
      }, (0, import_react.createElement)(unit_control_default, {
        label: __("Wide"),
        labelPosition: "top",
        __unstableInputWidth: "80px",
        value: wideSize || contentSize || "",
        onChange: (nextWidth) => {
          nextWidth = 0 > parseFloat(nextWidth) ? "0" : nextWidth;
          onChange({
            ...layout,
            wideSize: nextWidth
          });
        },
        units
      }), (0, import_react.createElement)(icon_default, {
        icon: stretch_wide_default
      }))), (0, import_react.createElement)("p", {
        className: "block-editor-hooks__layout-controls-helptext"
      }, __("Customize the width for all elements that are assigned to the center or wide columns.")), (0, import_react.createElement)(component_default13, {
        label: __("Justification"),
        value: justifyContent,
        onChange: onJustificationChange
      }, justificationOptions.map((_ref22) => {
        let {
          value,
          icon,
          label
        } = _ref22;
        return (0, import_react.createElement)(component_default15, {
          key: value,
          value,
          icon,
          label
        });
      })));
    },
    toolBarControls: function DefaultLayoutToolbarControls2() {
      return null;
    },
    getLayoutStyle: function getLayoutStyle3(_ref32) {
      var _style$spacing, _style$spacing2;
      let {
        selector: selector4,
        layout = {},
        style,
        blockName,
        hasBlockGapSupport,
        layoutDefinitions
      } = _ref32;
      const {
        contentSize,
        wideSize,
        justifyContent
      } = layout;
      const blockGapStyleValue = getGapCSSValue(style === null || style === void 0 ? void 0 : (_style$spacing = style.spacing) === null || _style$spacing === void 0 ? void 0 : _style$spacing.blockGap);
      let blockGapValue = "";
      if (!shouldSkipSerialization(blockName, "spacing", "blockGap")) {
        if (blockGapStyleValue !== null && blockGapStyleValue !== void 0 && blockGapStyleValue.top) {
          blockGapValue = getGapCSSValue(blockGapStyleValue === null || blockGapStyleValue === void 0 ? void 0 : blockGapStyleValue.top);
        } else if (typeof blockGapStyleValue === "string") {
          blockGapValue = getGapCSSValue(blockGapStyleValue);
        }
      }
      const marginLeft = justifyContent === "left" ? "0 !important" : "auto !important";
      const marginRight = justifyContent === "right" ? "0 !important" : "auto !important";
      let output3 = !!contentSize || !!wideSize ? `
					${appendSelectors(selector4, "> :where(:not(.alignleft):not(.alignright):not(.alignfull))")} {
						max-width: ${contentSize !== null && contentSize !== void 0 ? contentSize : wideSize};
						margin-left: ${marginLeft};
						margin-right: ${marginRight};
					}
					${appendSelectors(selector4, "> .alignwide")}  {
						max-width: ${wideSize !== null && wideSize !== void 0 ? wideSize : contentSize};
					}
					${appendSelectors(selector4, "> .alignfull")} {
						max-width: none;
					}
				` : "";
      if (justifyContent === "left") {
        output3 += `${appendSelectors(selector4, "> :where(:not(.alignleft):not(.alignright):not(.alignfull))")}
			{ margin-left: ${marginLeft}; }`;
      } else if (justifyContent === "right") {
        output3 += `${appendSelectors(selector4, "> :where(:not(.alignleft):not(.alignright):not(.alignfull))")}
			{ margin-right: ${marginRight}; }`;
      }
      if (style !== null && style !== void 0 && (_style$spacing2 = style.spacing) !== null && _style$spacing2 !== void 0 && _style$spacing2.padding) {
        const paddingValues = getCSSRules(style);
        paddingValues.forEach((rule) => {
          if (rule.key === "paddingRight") {
            output3 += `
					${appendSelectors(selector4, "> .alignfull")} {
						margin-right: calc(${rule.value} * -1);
					}
					`;
          } else if (rule.key === "paddingLeft") {
            output3 += `
					${appendSelectors(selector4, "> .alignfull")} {
						margin-left: calc(${rule.value} * -1);
					}
					`;
          }
        });
      }
      if (hasBlockGapSupport && blockGapValue) {
        output3 += getBlockGapCSS(selector4, layoutDefinitions, "constrained", blockGapValue);
      }
      return output3;
    },
    getOrientation() {
      return "vertical";
    },
    getAlignments(layout) {
      const alignmentInfo = getAlignmentsInfo(layout);
      if (layout.alignments !== void 0) {
        if (!layout.alignments.includes("none")) {
          layout.alignments.unshift("none");
        }
        return layout.alignments.map((alignment) => ({
          name: alignment,
          info: alignmentInfo[alignment]
        }));
      }
      const {
        contentSize,
        wideSize
      } = layout;
      const alignments = [{
        name: "left"
      }, {
        name: "center"
      }, {
        name: "right"
      }];
      if (contentSize) {
        alignments.unshift({
          name: "full"
        });
      }
      if (wideSize) {
        alignments.unshift({
          name: "wide",
          info: alignmentInfo.wide
        });
      }
      alignments.unshift({
        name: "none",
        info: alignmentInfo.none
      });
      return alignments;
    }
  };

  // node_modules/@wordpress/block-editor/build-module/layouts/index.js
  var layoutTypes = [flow_default, flex_default, constrained_default];
  function getLayoutType() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "default";
    return layoutTypes.find((layoutType) => layoutType.name === name);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/layout.js
  var defaultLayout = {
    type: "default"
  };
  var Layout = (0, import_react.createContext)(defaultLayout);
  var LayoutProvider = Layout.Provider;

  // node_modules/@wordpress/block-editor/build-module/components/use-block-display-information/index.js
  function useBlockDisplayInformation(clientId) {
    return useSelect((select2) => {
      if (!clientId)
        return null;
      const {
        getBlockName: getBlockName2,
        getBlockAttributes: getBlockAttributes3
      } = select2(store3);
      const {
        getBlockType: getBlockType3,
        getActiveBlockVariation: getActiveBlockVariation2
      } = select2(store);
      const blockName = getBlockName2(clientId);
      const blockType = getBlockType3(blockName);
      if (!blockType)
        return null;
      const attributes = getBlockAttributes3(clientId);
      const match = getActiveBlockVariation2(blockName, attributes);
      const blockTypeInfo = {
        title: blockType.title,
        icon: blockType.icon,
        description: blockType.description,
        anchor: attributes === null || attributes === void 0 ? void 0 : attributes.anchor
      };
      if (!match)
        return blockTypeInfo;
      return {
        title: match.title || blockType.title,
        icon: match.icon || blockType.icon,
        description: match.description || blockType.description,
        anchor: attributes === null || attributes === void 0 ? void 0 : attributes.anchor
      };
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-title/use-block-display-title.js
  function useBlockDisplayTitle(_ref8) {
    let {
      clientId,
      maximumLength,
      context: context2
    } = _ref8;
    const {
      attributes,
      name,
      reusableBlockTitle
    } = useSelect((select2) => {
      if (!clientId) {
        return {};
      }
      const {
        getBlockName: getBlockName2,
        getBlockAttributes: getBlockAttributes3,
        __experimentalGetReusableBlockTitle: __experimentalGetReusableBlockTitle2
      } = select2(store3);
      const blockName = getBlockName2(clientId);
      if (!blockName) {
        return {};
      }
      const isReusable = isReusableBlock(getBlockType(blockName));
      return {
        attributes: getBlockAttributes3(clientId),
        name: blockName,
        reusableBlockTitle: isReusable && __experimentalGetReusableBlockTitle2(getBlockAttributes3(clientId).ref)
      };
    }, [clientId]);
    const blockInformation = useBlockDisplayInformation(clientId);
    if (!name || !blockInformation) {
      return null;
    }
    const blockType = getBlockType(name);
    const blockLabel = blockType ? getBlockLabel(blockType, attributes, context2) : null;
    const label = reusableBlockTitle || blockLabel;
    const blockTitle = label && label !== blockType.title ? label : blockInformation.title;
    if (maximumLength && maximumLength > 0 && blockTitle.length > maximumLength) {
      const omission = "...";
      return blockTitle.slice(0, maximumLength - omission.length) + omission;
    }
    return blockTitle;
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-title/index.js
  function BlockTitle(_ref8) {
    let {
      clientId,
      maximumLength,
      context: context2
    } = _ref8;
    return useBlockDisplayTitle({
      clientId,
      maximumLength,
      context: context2
    });
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-content-overlay/index.js
  function useBlockOverlayActive(clientId) {
    return useSelect((select2) => {
      const {
        __unstableHasActiveBlockOverlayActive: __unstableHasActiveBlockOverlayActive2
      } = select2(store3);
      return __unstableHasActiveBlockOverlayActive2(clientId);
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js
  var import_lodash27 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/components/block-controls/groups.js
  var BlockControlsDefault = createSlotFill("BlockControls");
  var BlockControlsBlock = createSlotFill("BlockControlsBlock");
  var BlockControlsInline = createSlotFill("BlockFormatControls");
  var BlockControlsOther = createSlotFill("BlockControlsOther");
  var BlockControlsParent = createSlotFill("BlockControlsParent");
  var groups = {
    default: BlockControlsDefault,
    block: BlockControlsBlock,
    inline: BlockControlsInline,
    other: BlockControlsOther,
    parent: BlockControlsParent
  };
  var groups_default = groups;

  // node_modules/@wordpress/block-editor/build-module/components/block-controls/hook.js
  function useBlockControlsFill(group2, shareWithChildBlocks) {
    const isDisplayed = useDisplayBlockControls();
    const {
      clientId
    } = useBlockEditContext();
    const isParentDisplayed = useSelect((select2) => {
      const {
        getBlockName: getBlockName2,
        hasSelectedInnerBlock: hasSelectedInnerBlock2
      } = select2(store3);
      const {
        hasBlockSupport: hasBlockSupport3
      } = select2(store);
      return shareWithChildBlocks && hasBlockSupport3(getBlockName2(clientId), "__experimentalExposeControlsToChildren", false) && hasSelectedInnerBlock2(clientId);
    }, [shareWithChildBlocks, clientId]);
    if (isDisplayed) {
      var _groups$group;
      return (_groups$group = groups_default[group2]) === null || _groups$group === void 0 ? void 0 : _groups$group.Fill;
    }
    if (isParentDisplayed) {
      return groups_default.parent.Fill;
    }
    return null;
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-controls/fill.js
  function BlockControlsFill(_ref8) {
    let {
      group: group2 = "default",
      controls,
      children,
      __experimentalShareWithChildBlocks = false
    } = _ref8;
    const Fill5 = useBlockControlsFill(group2, __experimentalShareWithChildBlocks);
    if (!Fill5) {
      return null;
    }
    return (0, import_react.createElement)(style_provider_default, {
      document
    }, (0, import_react.createElement)(Fill5, null, (fillProps) => {
      const value = !(0, import_lodash27.isEmpty)(fillProps) ? fillProps : null;
      return (0, import_react.createElement)(toolbar_context_default.Provider, {
        value
      }, group2 === "default" && (0, import_react.createElement)(toolbar_group_default, {
        controls
      }), children);
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-controls/slot.js
  function BlockControlsSlot(_ref8) {
    let {
      group: group2 = "default",
      ...props
    } = _ref8;
    const accessibleToolbarState = (0, import_react.useContext)(toolbar_context_default);
    const Slot8 = groups_default[group2].Slot;
    const fills = useSlotFills(Slot8.__unstableName);
    const hasFills = Boolean(fills && fills.length);
    if (!hasFills) {
      return null;
    }
    if (group2 === "default") {
      return (0, import_react.createElement)(Slot8, _extends({}, props, {
        bubblesVirtually: true,
        fillProps: accessibleToolbarState
      }));
    }
    return (0, import_react.createElement)(toolbar_group_default, null, (0, import_react.createElement)(Slot8, _extends({}, props, {
      bubblesVirtually: true,
      fillProps: accessibleToolbarState
    })));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-controls/index.js
  var BlockControls = BlockControlsFill;
  BlockControls.Slot = BlockControlsSlot;
  var BlockFormatControls = (props) => {
    return (0, import_react.createElement)(BlockControlsFill, _extends({
      group: "inline"
    }, props));
  };
  BlockFormatControls.Slot = (props) => {
    return (0, import_react.createElement)(BlockControlsSlot, _extends({
      group: "inline"
    }, props));
  };
  var block_controls_default = BlockControls;

  // node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js
  var updateQueue = makeQueue();
  var raf = (fn) => schedule(fn, updateQueue);
  var writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  var onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  var onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  var onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  var timeouts = [];
  raf.setTimeout = (handler, ms) => {
    let time = raf.now() + ms;
    let cancel = () => {
      let i5 = timeouts.findIndex((t5) => t5.cancel == cancel);
      if (~i5)
        timeouts.splice(i5, 1);
      pendingCount -= ~i5 ? 1 : 0;
    };
    let timeout = {
      time,
      handler,
      cancel
    };
    timeouts.splice(findTimeout(time), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  var findTimeout = (time) => ~(~timeouts.findIndex((t5) => t5.time > time) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync2 = true;
    raf.batchedUpdates(fn);
    sync2 = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
  };
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
    } else {
      update();
    }
  };
  var ts = -1;
  var pendingCount = 0;
  var sync2 = false;
  function schedule(fn, queue) {
    if (sync2) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    let prevTs = ts;
    ts = raf.now();
    let count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t5) => t5.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next2 = /* @__PURE__ */ new Set();
    let current = next2;
    return {
      add(fn) {
        pendingCount += current == next2 && !next2.has(fn) ? 1 : 0;
        next2.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next2 && next2.has(fn) ? 1 : 0;
        return next2.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next2 = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next2.add(fn));
          pendingCount += next2.size;
          current = next2;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value) => {
      try {
        each2(value);
      } catch (e4) {
        raf.catch(e4);
      }
    });
  }

  // node_modules/@react-spring/shared/dist/react-spring-shared.esm.js
  var import_react86 = __toESM(require_react());
  function noop10() {
  }
  var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
    value,
    writable: true,
    configurable: true
  });
  var is = {
    arr: Array.isArray,
    obj: (a6) => !!a6 && a6.constructor.name === "Object",
    fun: (a6) => typeof a6 === "function",
    str: (a6) => typeof a6 === "string",
    num: (a6) => typeof a6 === "number",
    und: (a6) => a6 === void 0
  };
  function isEqual4(a6, b6) {
    if (is.arr(a6)) {
      if (!is.arr(b6) || a6.length !== b6.length)
        return false;
      for (let i5 = 0; i5 < a6.length; i5++) {
        if (a6[i5] !== b6[i5])
          return false;
      }
      return true;
    }
    return a6 === b6;
  }
  var each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is.arr(obj)) {
      for (let i5 = 0; i5 < obj.length; i5++) {
        fn.call(ctx2, obj[i5], `${i5}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx2, obj[key], key);
      }
    }
  }
  var toArray2 = (a6) => is.und(a6) ? [] : is.arr(a6) ? a6 : [a6];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  var createStringInterpolator$1;
  var to;
  var colors$1 = null;
  var skipAnimation = false;
  var willAdvance = noop10;
  var assign = (globals2) => {
    if (globals2.to)
      to = globals2.to;
    if (globals2.now)
      raf.now = globals2.now;
    if (globals2.colors !== void 0)
      colors$1 = globals2.colors;
    if (globals2.skipAnimation != null)
      skipAnimation = globals2.skipAnimation;
    if (globals2.createStringInterpolator)
      createStringInterpolator$1 = globals2.createStringInterpolator;
    if (globals2.requestAnimationFrame)
      raf.use(globals2.requestAnimationFrame);
    if (globals2.batchedUpdates)
      raf.batchedUpdates = globals2.batchedUpdates;
    if (globals2.willAdvance)
      willAdvance = globals2.willAdvance;
    if (globals2.frameLoop)
      raf.frameLoop = globals2.frameLoop;
  };
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
      return createStringInterpolator$1;
    },
    get to() {
      return to;
    },
    get colors() {
      return colors$1;
    },
    get skipAnimation() {
      return skipAnimation;
    },
    get willAdvance() {
      return willAdvance;
    },
    assign
  });
  var startQueue = /* @__PURE__ */ new Set();
  var currentFrame = [];
  var prevFrame = [];
  var priority = 0;
  var frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    advance,
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation))
      startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i5 = 0; i5 < currentFrame.length; i5++) {
      const animation = currentFrame[i5];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test2) {
    const index2 = arr.findIndex(test2);
    return index2 < 0 ? arr.length : index2;
  }
  var colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  var NUMBER = "[-+]?\\d*\\.?\\d+";
  var PERCENTAGE = NUMBER + "%";
  function call2(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  var rgb = new RegExp("rgb" + call2(NUMBER, NUMBER, NUMBER));
  var rgba3 = new RegExp("rgba" + call2(NUMBER, NUMBER, NUMBER, NUMBER));
  var hsl = new RegExp("hsl" + call2(NUMBER, PERCENTAGE, PERCENTAGE));
  var hsla2 = new RegExp("hsla" + call2(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
  var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex6 = /^#([0-9a-fA-F]{6})$/;
  var hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color4) {
    let match;
    if (typeof color4 === "number") {
      return color4 >>> 0 === color4 && color4 >= 0 && color4 <= 4294967295 ? color4 : null;
    }
    if (match = hex6.exec(color4))
      return parseInt(match[1] + "ff", 16) >>> 0;
    if (colors$1 && colors$1[color4] !== void 0) {
      return colors$1[color4];
    }
    if (match = rgb.exec(color4)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
    if (match = rgba3.exec(color4)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
    if (match = hex3.exec(color4)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
    if (match = hex8.exec(color4))
      return parseInt(match[1], 16) >>> 0;
    if (match = hex4.exec(color4)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
    if (match = hsl.exec(color4)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
    if (match = hsla2.exec(color4)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
    return null;
  }
  function hue2rgb(p5, q, t5) {
    if (t5 < 0)
      t5 += 1;
    if (t5 > 1)
      t5 -= 1;
    if (t5 < 1 / 6)
      return p5 + (q - p5) * 6 * t5;
    if (t5 < 1 / 2)
      return q;
    if (t5 < 2 / 3)
      return p5 + (q - p5) * (2 / 3 - t5) * 6;
    return p5;
  }
  function hslToRgb(h4, s5, l5) {
    const q = l5 < 0.5 ? l5 * (1 + s5) : l5 + s5 - l5 * s5;
    const p5 = 2 * l5 - q;
    const r5 = hue2rgb(p5, q, h4 + 1 / 3);
    const g5 = hue2rgb(p5, q, h4);
    const b6 = hue2rgb(p5, q, h4 - 1 / 3);
    return Math.round(r5 * 255) << 24 | Math.round(g5 * 255) << 16 | Math.round(b6 * 255) << 8;
  }
  function parse255(str) {
    const int2 = parseInt(str, 10);
    if (int2 < 0)
      return 0;
    if (int2 > 255)
      return 255;
    return int2;
  }
  function parse360(str) {
    const int2 = parseFloat(str);
    return (int2 % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0)
      return 0;
    if (num > 1)
      return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int2 = parseFloat(str);
    if (int2 < 0)
      return 0;
    if (int2 > 100)
      return 1;
    return int2 / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null)
      return input;
    int32Color = int32Color || 0;
    let r5 = (int32Color & 4278190080) >>> 24;
    let g5 = (int32Color & 16711680) >>> 16;
    let b6 = (int32Color & 65280) >>> 8;
    let a6 = (int32Color & 255) / 255;
    return `rgba(${r5}, ${g5}, ${b6}, ${a6})`;
  }
  var createInterpolator = (range, output3, extrapolate) => {
    if (is.fun(range)) {
      return range;
    }
    if (is.arr(range)) {
      return createInterpolator({
        range,
        output: output3,
        extrapolate
      });
    }
    if (is.str(range.output[0])) {
      return createStringInterpolator$1(range);
    }
    const config2 = range;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t5) => t5);
    return (input) => {
      const range2 = findRange(input, inputRange);
      return interpolate2(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
    };
  };
  function interpolate2(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map9) {
    let result = map9 ? map9(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity")
        return result;
      else if (extrapolateLeft === "clamp")
        result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity")
        return result;
      else if (extrapolateRight === "clamp")
        result = inputMax;
    }
    if (outputMin === outputMax)
      return outputMin;
    if (inputMin === inputMax)
      return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity)
      result = -result;
    else if (inputMax === Infinity)
      result = result - inputMin;
    else
      result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity)
      result = -result;
    else if (outputMax === Infinity)
      result = result + outputMin;
    else
      result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i5 = 1; i5 < inputRange.length - 1; ++i5)
      if (inputRange[i5] >= input)
        break;
    return i5 - 1;
  }
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  var $get = Symbol.for("FluidValue.get");
  var $observers = Symbol.for("FluidValue.observers");
  var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  var getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
      observer.eventObserved(event);
    } else {
      observer(event);
    }
  }
  function callFluidObservers(target, event) {
    let observers2 = target[$observers];
    if (observers2) {
      observers2.forEach((observer) => {
        callFluidObserver(observer, event);
      });
    }
  }
  var FluidValue = class {
    constructor(get11) {
      this[$get] = void 0;
      this[$observers] = void 0;
      if (!get11 && !(get11 = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get11);
    }
  };
  var setFluidGetter = (target, get11) => setHidden(target, $get, get11);
  function addFluidObserver(target, observer) {
    if (target[$get]) {
      let observers2 = target[$observers];
      if (!observers2) {
        setHidden(target, $observers, observers2 = /* @__PURE__ */ new Set());
      }
      if (!observers2.has(observer)) {
        observers2.add(observer);
        if (target.observerAdded) {
          target.observerAdded(observers2.size, observer);
        }
      }
    }
    return observer;
  }
  function removeFluidObserver(target, observer) {
    let observers2 = target[$observers];
    if (observers2 && observers2.has(observer)) {
      const count = observers2.size - 1;
      if (count) {
        observers2.delete(observer);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer);
      }
    }
  }
  var setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var colorRegex2 = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  var cssVariableRegex2 = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  var variableToRgba = (input) => {
    const [token, fallback] = parseCSSVariable2(input);
    if (!token || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (_value) {
        return _value;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex2.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  var parseCSSVariable2 = (current) => {
    const match = cssVariableRegex2.exec(current);
    if (!match)
      return [,];
    const [, token, fallback] = match;
    return [token, fallback];
  };
  var namedColorRegex;
  var rgbaRound = (_, p1, p22, p32, p42) => `rgba(${Math.round(p1)}, ${Math.round(p22)}, ${Math.round(p32)}, ${p42})`;
  var createStringInterpolator = (config2) => {
    if (!namedColorRegex)
      namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
    const output3 = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex2, variableToRgba).replace(colorRegex2, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes3 = output3.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes3[0].map((_, i5) => keyframes3.map((values) => {
      if (!(i5 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i5];
    }));
    const interpolators = outputRanges.map((output4) => createInterpolator(_extends2({}, config2, {
      output: output4
    })));
    return (input) => {
      var _output$find;
      const missingUnit = !unitRegex.test(output3[0]) && ((_output$find = output3.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
      let i5 = 0;
      return output3[0].replace(numberRegex, () => `${interpolators[i5++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
    };
  };
  var prefix = "react-spring: ";
  var once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  var warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
  }
  var warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
  }
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex2.test(value) || value in (colors$1 || {}));
  }
  var useIsomorphicLayoutEffect3 = isSSR() ? import_react86.useEffect : import_react86.useLayoutEffect;
  var useIsMounted = () => {
    const isMounted = (0, import_react86.useRef)(false);
    useIsomorphicLayoutEffect3(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate2() {
    const update3 = (0, import_react86.useState)()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update3(Math.random());
      }
    };
  }
  function useMemoOne2(getResult, inputs) {
    const [initial] = (0, import_react86.useState)(() => ({
      inputs,
      result: getResult()
    }));
    const committed = (0, import_react86.useRef)();
    const prevCache = committed.current;
    let cache2 = prevCache;
    if (cache2) {
      const useCache = Boolean(inputs && cache2.inputs && areInputsEqual2(inputs, cache2.inputs));
      if (!useCache) {
        cache2 = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache2 = initial;
    }
    (0, import_react86.useEffect)(() => {
      committed.current = cache2;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache2]);
    return cache2.result;
  }
  function areInputsEqual2(next2, prev) {
    if (next2.length !== prev.length) {
      return false;
    }
    for (let i5 = 0; i5 < next2.length; i5++) {
      if (next2[i5] !== prev[i5]) {
        return false;
      }
    }
    return true;
  }
  var useOnce = (effect) => (0, import_react86.useEffect)(effect, emptyDeps);
  var emptyDeps = [];
  function usePrev(value) {
    const prevRef = (0, import_react86.useRef)();
    (0, import_react86.useEffect)(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }

  // node_modules/@react-spring/core/dist/react-spring-core.esm.js
  var React7 = __toESM(require_react());
  var import_react88 = __toESM(require_react());

  // node_modules/@react-spring/animated/dist/react-spring-animated.esm.js
  var React6 = __toESM(require_react());
  var import_react87 = __toESM(require_react());
  var $node = Symbol.for("Animated:node");
  var isAnimated = (value) => !!value && value[$node] === value;
  var getAnimated = (owner) => owner && owner[$node];
  var setAnimated = (owner, node) => defineHidden(owner, $node, node);
  var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  var Animated = class {
    constructor() {
      this.payload = void 0;
      setAnimated(this, this);
    }
    getPayload() {
      return this.payload || [];
    }
  };
  var AnimatedValue = class extends Animated {
    constructor(_value) {
      super();
      this.done = true;
      this.elapsedTime = void 0;
      this.lastPosition = void 0;
      this.lastVelocity = void 0;
      this.v0 = void 0;
      this.durationProgress = 0;
      this._value = _value;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    static create(value) {
      return new AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const {
        done
      } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done)
          this.lastVelocity = null;
        this.v0 = null;
      }
    }
  };
  var AnimatedString = class extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = void 0;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    static create(value) {
      return new AnimatedString(value);
    }
    getValue() {
      let value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  };
  var TreeContext = {
    dependencies: null
  };
  var AnimatedObject = class extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated2) {
          values[key] = source;
        }
      });
      return values;
    }
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node) => node.reset());
      }
    }
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node) => this.add(node));
      }
    }
  };
  var AnimatedArray = class extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node) => node.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node, i5) => node.setValue(source[i5])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  };
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  var withAnimated = (Component2, host2) => {
    const hasInstance = !is.fun(Component2) || Component2.prototype && Component2.prototype.isReactComponent;
    return (0, import_react87.forwardRef)((givenProps, givenRef) => {
      const instanceRef = (0, import_react87.useRef)(null);
      const ref2 = hasInstance && (0, import_react87.useCallback)((value) => {
        instanceRef.current = updateRef(givenRef, value);
      }, [givenRef]);
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate2();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = (0, import_react87.useRef)();
      useIsomorphicLayoutEffect3(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
            raf.cancel(observerRef.current.update);
          }
        };
      });
      (0, import_react87.useEffect)(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return React6.createElement(Component2, _extends3({}, usedProps, {
        ref: ref2
      }));
    });
  };
  var PropsObserver = class {
    constructor(update3, deps) {
      this.update = update3;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  };
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style)
      props = _extends3({}, props, {
        style: host2.createAnimatedStyle(props.style)
      });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref2, value) {
    if (ref2) {
      if (is.fun(ref2))
        ref2(value);
      else
        ref2.current = value;
    }
    return value;
  }
  var cacheKey = Symbol.for("AnimatedComponent");
  var createHost = (components, {
    applyAnimatedValues: _applyAnimatedValues = () => false,
    createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps: _getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: _applyAnimatedValues,
      createAnimatedStyle: _createAnimatedStyle,
      getComponentProps: _getComponentProps
    };
    const animated2 = (Component2) => {
      const displayName = getDisplayName(Component2) || "Anonymous";
      if (is.str(Component2)) {
        Component2 = animated2[Component2] || (animated2[Component2] = withAnimated(Component2, hostConfig));
      } else {
        Component2 = Component2[cacheKey] || (Component2[cacheKey] = withAnimated(Component2, hostConfig));
      }
      Component2.displayName = `Animated(${displayName})`;
      return Component2;
    };
    eachProp(components, (Component2, key) => {
      if (is.arr(components)) {
        key = getDisplayName(Component2);
      }
      animated2[key] = animated2(Component2);
    });
    return {
      animated: animated2
    };
  };
  var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

  // node_modules/@react-spring/core/dist/react-spring-core.esm.js
  function _extends4() {
    _extends4 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        var source = arguments[i5];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray2(value).includes(key)));
  var resolveProp = (prop2, key) => is.obj(prop2) ? key && prop2[key] : prop2;
  var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  var noopTransform = (value) => value;
  var getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  var DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
  var RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop2) => {
      if (!RESERVED_PROPS[prop2]) {
        forward[prop2] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = {
        to: to2
      };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return _extends4({}, props);
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _ in props)
      return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref2) {
    var _ctrl$ref;
    (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
    ref2 == null ? void 0 : ref2.delete(ctrl);
  }
  function replaceRef(ctrl, ref2) {
    if (ref2 && ctrl.ref !== ref2) {
      var _ctrl$ref2;
      (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
      ref2.add(ctrl);
      ctrl.ref = ref2;
    }
  }
  var config = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  };
  var c1 = 1.70158;
  var c22 = c1 * 1.525;
  var c32 = c1 + 1;
  var c42 = 2 * Math.PI / 3;
  var c52 = 2 * Math.PI / 4.5;
  var bounceOut2 = (x4) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x4 < 1 / d1) {
      return n1 * x4 * x4;
    } else if (x4 < 2 / d1) {
      return n1 * (x4 -= 1.5 / d1) * x4 + 0.75;
    } else if (x4 < 2.5 / d1) {
      return n1 * (x4 -= 2.25 / d1) * x4 + 0.9375;
    } else {
      return n1 * (x4 -= 2.625 / d1) * x4 + 0.984375;
    }
  };
  var easings = {
    linear: (x4) => x4,
    easeInQuad: (x4) => x4 * x4,
    easeOutQuad: (x4) => 1 - (1 - x4) * (1 - x4),
    easeInOutQuad: (x4) => x4 < 0.5 ? 2 * x4 * x4 : 1 - Math.pow(-2 * x4 + 2, 2) / 2,
    easeInCubic: (x4) => x4 * x4 * x4,
    easeOutCubic: (x4) => 1 - Math.pow(1 - x4, 3),
    easeInOutCubic: (x4) => x4 < 0.5 ? 4 * x4 * x4 * x4 : 1 - Math.pow(-2 * x4 + 2, 3) / 2,
    easeInQuart: (x4) => x4 * x4 * x4 * x4,
    easeOutQuart: (x4) => 1 - Math.pow(1 - x4, 4),
    easeInOutQuart: (x4) => x4 < 0.5 ? 8 * x4 * x4 * x4 * x4 : 1 - Math.pow(-2 * x4 + 2, 4) / 2,
    easeInQuint: (x4) => x4 * x4 * x4 * x4 * x4,
    easeOutQuint: (x4) => 1 - Math.pow(1 - x4, 5),
    easeInOutQuint: (x4) => x4 < 0.5 ? 16 * x4 * x4 * x4 * x4 * x4 : 1 - Math.pow(-2 * x4 + 2, 5) / 2,
    easeInSine: (x4) => 1 - Math.cos(x4 * Math.PI / 2),
    easeOutSine: (x4) => Math.sin(x4 * Math.PI / 2),
    easeInOutSine: (x4) => -(Math.cos(Math.PI * x4) - 1) / 2,
    easeInExpo: (x4) => x4 === 0 ? 0 : Math.pow(2, 10 * x4 - 10),
    easeOutExpo: (x4) => x4 === 1 ? 1 : 1 - Math.pow(2, -10 * x4),
    easeInOutExpo: (x4) => x4 === 0 ? 0 : x4 === 1 ? 1 : x4 < 0.5 ? Math.pow(2, 20 * x4 - 10) / 2 : (2 - Math.pow(2, -20 * x4 + 10)) / 2,
    easeInCirc: (x4) => 1 - Math.sqrt(1 - Math.pow(x4, 2)),
    easeOutCirc: (x4) => Math.sqrt(1 - Math.pow(x4 - 1, 2)),
    easeInOutCirc: (x4) => x4 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x4, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x4 + 2, 2)) + 1) / 2,
    easeInBack: (x4) => c32 * x4 * x4 * x4 - c1 * x4 * x4,
    easeOutBack: (x4) => 1 + c32 * Math.pow(x4 - 1, 3) + c1 * Math.pow(x4 - 1, 2),
    easeInOutBack: (x4) => x4 < 0.5 ? Math.pow(2 * x4, 2) * ((c22 + 1) * 2 * x4 - c22) / 2 : (Math.pow(2 * x4 - 2, 2) * ((c22 + 1) * (x4 * 2 - 2) + c22) + 2) / 2,
    easeInElastic: (x4) => x4 === 0 ? 0 : x4 === 1 ? 1 : -Math.pow(2, 10 * x4 - 10) * Math.sin((x4 * 10 - 10.75) * c42),
    easeOutElastic: (x4) => x4 === 0 ? 0 : x4 === 1 ? 1 : Math.pow(2, -10 * x4) * Math.sin((x4 * 10 - 0.75) * c42) + 1,
    easeInOutElastic: (x4) => x4 === 0 ? 0 : x4 === 1 ? 1 : x4 < 0.5 ? -(Math.pow(2, 20 * x4 - 10) * Math.sin((20 * x4 - 11.125) * c52)) / 2 : Math.pow(2, -20 * x4 + 10) * Math.sin((20 * x4 - 11.125) * c52) / 2 + 1,
    easeInBounce: (x4) => 1 - bounceOut2(1 - x4),
    easeOutBounce: bounceOut2,
    easeInOutBounce: (x4) => x4 < 0.5 ? (1 - bounceOut2(1 - 2 * x4)) / 2 : (1 + bounceOut2(2 * x4 - 1)) / 2
  };
  var defaults = _extends4({}, config.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  var AnimationConfig = class {
    constructor() {
      this.tension = void 0;
      this.friction = void 0;
      this.frequency = void 0;
      this.damping = void 0;
      this.mass = void 0;
      this.velocity = 0;
      this.restVelocity = void 0;
      this.precision = void 0;
      this.progress = void 0;
      this.duration = void 0;
      this.easing = void 0;
      this.clamp = void 0;
      this.bounce = void 0;
      this.decay = void 0;
      this.round = void 0;
      Object.assign(this, defaults);
    }
  };
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = _extends4({}, defaultConfig);
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = _extends4({}, defaultConfig, newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let {
      mass,
      frequency,
      damping
    } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01)
        frequency = 0.01;
      if (damping < 0)
        damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  var emptyArray = [];
  var Animation = class {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.to = void 0;
      this.from = void 0;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  };
  function scheduleProps(callId, {
    key,
    props,
    defaultProps,
    state,
    actions: actions2
  }) {
    return new Promise((resolve, reject) => {
      var _props$cancel;
      let delay;
      let timeout;
      let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps == null ? void 0 : defaultProps.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions2.pause();
        } else {
          actions2.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions2.start(_extends4({}, props, {
            callId,
            cancel
          }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
  var getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  var getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  var getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const {
      callId,
      parentId,
      onRest
    } = props;
    const {
      asyncTo: prevTo,
      promise: prevPromise
    } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
      let preventBail;
      let bail;
      const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
      const bailIfEnded = (bailSignal) => {
        const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate3 = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAniamtionSignal();
        return (async () => {
          if (globals.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
            to: arg1
          });
          props2.parentId = callId;
          eachProp(defaultProps, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate3(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate3, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAniamtionSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t5) => t5.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId)
      state.cancelId = cancelId;
  }
  var BailSignal = class extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      this.result = void 0;
    }
  };
  var SkipAniamtionSignal = class extends Error {
    constructor() {
      super("SkipAnimationSignal");
      this.result = void 0;
    }
  };
  var isFrameValue = (value) => value instanceof FrameValue;
  var nextId$1 = 1;
  var FrameValue = class extends FluidValue {
    constructor(...args) {
      super(...args);
      this.id = nextId$1++;
      this.key = void 0;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    get() {
      const node = getAnimated(this);
      return node && node.getValue();
    }
    to(...args) {
      return globals.to(this, args);
    }
    interpolate(...args) {
      deprecateInterpolate();
      return globals.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1)
        this._attach();
    }
    observerRemoved(count) {
      if (count == 0)
        this._detach();
    }
    _attach() {
    }
    _detach() {
    }
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  };
  var $P = Symbol.for("SpringPhase");
  var HAS_ANIMATED = 1;
  var IS_ANIMATING = 2;
  var IS_PAUSED = 4;
  var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  var SpringValue = class extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.key = void 0;
      this.animation = new Animation();
      this.queue = void 0;
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
          from: arg1
        });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node = getAnimated(this);
      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
    }
    get hasAnimated() {
      return hasAnimated(this);
    }
    get isAnimating() {
      return isAnimating(this);
    }
    get isPaused() {
      return isPaused(this);
    }
    get isDelayed() {
      return this._state.delayed;
    }
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let {
        config: config2,
        toValues
      } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray2(getFluidValue(anim.to));
      }
      anim.values.forEach((node2, i5) => {
        if (node2.done)
          return;
        const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i5].lastPosition : toValues[i5];
        let finished = anim.immediate;
        let position = to2;
        if (!finished) {
          position = node2.lastPosition;
          if (config2.tension <= 0) {
            node2.done = true;
            return;
          }
          let elapsed = node2.elapsedTime += dt;
          const from = anim.fromValues[i5];
          const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i5] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          if (!is.und(config2.duration)) {
            let p5 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node2.durationProgress > 0) {
                  node2.elapsedTime = config2.duration * node2.durationProgress;
                  elapsed = node2.elapsedTime += dt;
                }
              }
              p5 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p5 = p5 > 1 ? 1 : p5 < 0 ? 0 : p5;
              node2.durationProgress = p5;
            }
            position = from + config2.easing(p5) * (to2 - from);
            velocity = (position - node2.lastPosition) / dt;
            finished = p5 == 1;
          } else if (config2.decay) {
            const decay2 = config2.decay === true ? 0.998 : config2.decay;
            const e4 = Math.exp(-(1 - decay2) * elapsed);
            position = from + v0 / (1 - decay2) * (1 - e4);
            finished = Math.abs(node2.lastPosition - position) <= precision;
            velocity = v0 * e4;
          } else {
            velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n5 = 0; n5 < numSteps; ++n5) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position == to2 || position > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position = position + velocity * step;
            }
          }
          node2.lastVelocity = velocity;
          if (Number.isNaN(position)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i5].done) {
          finished = false;
        }
        if (finished) {
          node2.done = true;
        } else {
          idle = false;
        }
        if (node2.setValue(position, config2.round)) {
          changed = true;
        }
      });
      const node = getAnimated(this);
      const currVal = node.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    pause() {
      this._update({
        pause: true
      });
    }
    resume() {
      this._update({
        pause: false
      });
    }
    finish() {
      if (isAnimating(this)) {
        const {
          to: to2,
          config: config2
        } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : _extends4({}, arg2, {
          to: to2
        })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(queue.map((props) => {
        const up = this._update(props);
        return up;
      })).then((results) => getCombinedResult(this, results));
    }
    stop(cancel) {
      const {
        to: to2
      } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    reset() {
      this._update({
        reset: true
      });
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    _prepareNode(props) {
      const key = this.key || "";
      let {
        to: to2,
        from
      } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from = is.obj(from) ? from[key] : from;
      if (from == null) {
        from = void 0;
      }
      const range = {
        to: to2,
        from
      };
      if (!hasAnimated(this)) {
        if (props.reverse)
          [to2, from] = [from, to2];
        from = getFluidValue(from);
        if (!is.und(from)) {
          this._set(from);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range;
    }
    _update(_ref8, isLoop) {
      let props = _extends4({}, _ref8);
      const {
        key,
        defaultProps
      } = this;
      if (props.default)
        Object.assign(defaultProps, getDefaultProps(props, (value, prop2) => /^on/.test(prop2) ? resolveProp(value, key) : value));
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          start: this._merge.bind(this, range)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    _merge(range, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range.to);
      const hasFromProp = !is.und(range.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const {
        key,
        defaultProps,
        animation: anim
      } = this;
      const {
        to: prevTo,
        from: prevFrom
      } = anim;
      let {
        to: to2 = prevTo,
        from = prevFrom
      } = range;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from;
      }
      if (props.reverse)
        [to2, from] = [from, to2];
      const hasFromChanged = !isEqual4(from, prevFrom);
      if (hasFromChanged) {
        anim.from = from;
      }
      from = getFluidValue(from);
      const hasToChanged = !isEqual4(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const {
        config: config2
      } = anim;
      const {
        decay: decay2,
        velocity
      } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);
      }
      let node = getAnimated(this);
      if (!node || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset2 = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
      const value = reset2 ? from : this.get();
      const goal = computeGoal(to2);
      const isAnimatable2 = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable2 || matchProp(defaultProps.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node.constructor) {
          if (immediate) {
            node = this._set(goal);
          } else
            throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
        }
      }
      const goalType = node.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset2 || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual4(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual4(anim.immediate, immediate) && !immediate || !isEqual4(config2.decay, decay2) || !isEqual4(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset2) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray2(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset2) {
            this._set(prevTo);
          }
        }
        if (started) {
          const {
            onRest
          } = anim;
          each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed)
            raf.batchedUpdates(() => {
              anim.changed = !reset2;
              onRest == null ? void 0 : onRest(result, this);
              if (reset2) {
                callProp(defaultProps.onRest, result);
              } else {
                anim.onStart == null ? void 0 : anim.onStart(result, this);
              }
            });
        }
      }
      if (reset2) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    _set(arg, idle = true) {
      const value = getFluidValue(arg);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual4(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node) => node.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node) => {
          node.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  };
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual4(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    let loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse2 = (overrides || props).reverse;
      const reset2 = !overrides || overrides.reset;
      return createUpdate(_extends4({}, props, {
        loop: loop2,
        default: false,
        pause: void 0,
        to: !reverse2 || isAsyncTo(to2) ? to2 : void 0,
        from: reset2 ? props.from : void 0,
        reset: reset2
      }, overrides));
    }
  }
  function createUpdate(props) {
    const {
      to: to2,
      from
    } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2))
      findDefined(to2, keys);
    if (is.obj(from))
      findDefined(from, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function declareUpdate(props) {
    const update3 = createUpdate(props);
    if (is.und(update3.default)) {
      update3.default = getDefaultProps(update3);
    }
    return update3;
  }
  function findDefined(values, keys) {
    eachProp(values, (value, key) => value != null && keys.add(key));
  }
  var ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
    (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
    (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
  }
  var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  var nextId = 1;
  var Controller2 = class {
    constructor(props, flush2) {
      this.id = nextId++;
      this.springs = {};
      this.queue = [];
      this.ref = void 0;
      this._flush = void 0;
      this._initialProps = void 0;
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._item = void 0;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush2) {
        this._flush = flush2;
      }
      if (props) {
        this.start(_extends4({
          default: true
        }, props));
      }
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring2) => {
        return spring2.idle && !spring2.isDelayed && !spring2.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item2) {
      this._item = item2;
    }
    get() {
      const values = {};
      this.each((spring2, key) => values[key] = spring2.get());
      return values;
    }
    set(values) {
      for (const key in values) {
        const value = values[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    start(props) {
      let {
        queue
      } = this;
      if (props) {
        queue = toArray2(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    stop(arg, keys) {
      if (arg !== !!arg) {
        keys = arg;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray2(keys), (key) => springs[key].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring2) => spring2.stop(!!arg));
      }
      return this;
    }
    pause(keys) {
      if (is.und(keys)) {
        this.start({
          pause: true
        });
      } else {
        const springs = this.springs;
        each(toArray2(keys), (key) => springs[key].pause());
      }
      return this;
    }
    resume(keys) {
      if (is.und(keys)) {
        this.start({
          pause: false
        });
      } else {
        const springs = this.springs;
        each(toArray2(keys), (key) => springs[key].resume());
      }
      return this;
    }
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    _onFrame() {
      const {
        onStart,
        onChange,
        onRest
      } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else
        return;
      raf.onFrame(this._onFrame);
    }
  };
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const {
      keys,
      to: to2,
      from,
      loop: loop2,
      onRest,
      onResolve
    } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false)
      props.to = null;
    if (from === false)
      props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({
            finished,
            cancelled
          }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished)
                result2.finished = false;
              if (cancelled)
                result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop10,
          resume: noop10,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(runAsync(asyncTo, props2, state, ctrl));
            }
          }
        }
      }));
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = _extends4({}, ctrl.springs);
    if (props) {
      each(toArray2(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = _extends4({}, props2, {
            to: void 0
          });
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring2, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring2;
        addFluidObserver(spring2, ctrl);
      }
    });
  }
  function createSpring(key, observer) {
    const spring2 = new SpringValue();
    spring2.key = key;
    if (observer) {
      addFluidObserver(spring2, observer);
    }
    return spring2;
  }
  function prepareSprings(springs, props, create3) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring2 = springs[key] || (springs[key] = create3(key));
        spring2["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  function _objectWithoutPropertiesLoose5(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i5;
    for (i5 = 0; i5 < sourceKeys.length; i5++) {
      key = sourceKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var _excluded$3 = ["children"];
  var SpringContext = (_ref8) => {
    let {
      children
    } = _ref8, props = _objectWithoutPropertiesLoose5(_ref8, _excluded$3);
    const inherited = (0, import_react88.useContext)(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne2(() => ({
      pause,
      immediate
    }), [pause, immediate]);
    const {
      Provider: Provider8
    } = ctx;
    return React7.createElement(Provider8, {
      value: props
    }, children);
  };
  var ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React7.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  var SpringRef = () => {
    const current = [];
    const SpringRef2 = function SpringRef3(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i5) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update3 = _getProps(props, ctrl, i5);
          if (update3) {
            results.push(ctrl.start(update3));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i5 = current.indexOf(ctrl);
      if (~i5)
        current.splice(i5, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values) {
      each(current, (ctrl) => ctrl.set(values));
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i5) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update3 = this._getProps(props, ctrl, i5);
          if (update3) {
            results.push(ctrl.start(update3));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i5) => ctrl.update(this._getProps(props, ctrl, i5)));
      return this;
    };
    const _getProps = function _getProps2(arg, ctrl, index2) {
      return is.fun(arg) ? arg(index2, ctrl) : arg;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useSprings(length, props, deps) {
    const propsFn = is.fun(props) && props;
    if (propsFn && !deps)
      deps = [];
    const ref2 = (0, import_react88.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
    const layoutId = (0, import_react88.useRef)(0);
    const forceUpdate = useForceUpdate2();
    const state = (0, import_react88.useMemo)(() => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }), []);
    const ctrls = (0, import_react88.useRef)([...state.ctrls]);
    const updates = [];
    const prevLength = usePrev(length) || 0;
    (0, import_react88.useMemo)(() => {
      each(ctrls.current.slice(length, prevLength), (ctrl) => {
        detachRefs(ctrl, ref2);
        ctrl.stop(true);
      });
      ctrls.current.length = length;
      declareUpdates(prevLength, length);
    }, [length]);
    (0, import_react88.useMemo)(() => {
      declareUpdates(0, Math.min(prevLength, length));
    }, deps);
    function declareUpdates(startIndex, endIndex) {
      for (let i5 = startIndex; i5 < endIndex; i5++) {
        const ctrl = ctrls.current[i5] || (ctrls.current[i5] = new Controller2(null, state.flush));
        const update3 = propsFn ? propsFn(i5, ctrl) : props[i5];
        if (update3) {
          updates[i5] = declareUpdate(update3);
        }
      }
    }
    const springs = ctrls.current.map((ctrl, i5) => getSprings(ctrl, updates[i5]));
    const context2 = (0, import_react88.useContext)(SpringContext);
    const prevContext = usePrev(context2);
    const hasContext = context2 !== prevContext && hasProps(context2);
    useIsomorphicLayoutEffect3(() => {
      layoutId.current++;
      state.ctrls = ctrls.current;
      const {
        queue
      } = state;
      if (queue.length) {
        state.queue = [];
        each(queue, (cb2) => cb2());
      }
      each(ctrls.current, (ctrl, i5) => {
        ref2 == null ? void 0 : ref2.add(ctrl);
        if (hasContext) {
          ctrl.start({
            default: context2
          });
        }
        const update3 = updates[i5];
        if (update3) {
          replaceRef(ctrl, update3.ref);
          if (ctrl.ref) {
            ctrl.queue.push(update3);
          } else {
            ctrl.start(update3);
          }
        }
      });
    });
    useOnce(() => () => {
      each(state.ctrls, (ctrl) => ctrl.stop(true));
    });
    const values = springs.map((x4) => _extends4({}, x4));
    return ref2 ? [values, ref2] : values;
  }
  function useSpring(props, deps) {
    const isFn = is.fun(props);
    const [[values], ref2] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
    return isFn || arguments.length == 2 ? [values, ref2] : values;
  }
  var TransitionPhase;
  (function(TransitionPhase2) {
    TransitionPhase2["MOUNT"] = "mount";
    TransitionPhase2["ENTER"] = "enter";
    TransitionPhase2["UPDATE"] = "update";
    TransitionPhase2["LEAVE"] = "leave";
  })(TransitionPhase || (TransitionPhase = {}));
  var Interpolation = class extends FrameValue {
    constructor(source, args) {
      super();
      this.key = void 0;
      this.idle = true;
      this.calc = void 0;
      this._active = /* @__PURE__ */ new Set();
      this.source = source;
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual4(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray2(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node) => {
          node.done = false;
        });
        if (globals.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    _attach() {
      let priority2 = 1;
      each(toArray2(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    _detach() {
      each(toArray2(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray2(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
      }
    }
  };
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node) => {
        node.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals.assign({
    createStringInterpolator,
    to: (source, args) => new Interpolation(source, args)
  });
  var update2 = frameLoop.advance;

  // node_modules/@react-spring/web/dist/react-spring-web.esm.js
  var import_react_dom4 = __toESM(require_react_dom());
  function _objectWithoutPropertiesLoose6(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i5;
    for (i5 = 0; i5 < sourceKeys.length; i5++) {
      key = sourceKeys[i5];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var _excluded$2 = ["style", "children", "scrollTop", "scrollLeft"];
  var isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "")
      return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
      return value + "px";
    return ("" + value).trim();
  }
  var attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const _ref8 = props, {
      style,
      children,
      scrollTop,
      scrollLeft
    } = _ref8, attributes = _objectWithoutPropertiesLoose6(_ref8, _excluded$2);
    const values = Object.values(attributes);
    const names2 = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n5) => "-" + n5.toLowerCase())));
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (let name in style) {
      if (style.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style[name]);
        if (isCustomPropRE.test(name)) {
          instance.style.setProperty(name, value);
        } else {
          instance.style[name] = value;
        }
      }
    }
    names2.forEach((name, i5) => {
      instance.setAttribute(name, values[i5]);
    });
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
  }
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  var prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop2) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop2)] = acc[prop2]);
    return acc;
  }, isUnitlessNumber);
  var _excluded$1 = ["x", "y", "z"];
  var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  var pxTransforms = /^(translate)/;
  var degTransforms = /^(rotate|skew)/;
  var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
  var isValueIdentity = (value, id2) => is.arr(value) ? value.every((v5) => isValueIdentity(v5, id2)) : is.num(value) ? value === id2 : parseFloat(value) === id2;
  var AnimatedStyle = class extends AnimatedObject {
    constructor(_ref8) {
      let {
        x: x4,
        y: y5,
        z: z2
      } = _ref8, style = _objectWithoutPropertiesLoose6(_ref8, _excluded$1);
      const inputs = [];
      const transforms = [];
      if (x4 || y5 || z2) {
        inputs.push([x4 || 0, y5 || 0, z2 || 0]);
        transforms.push((xyz) => [`translate3d(${xyz.map((v5) => addUnit(v5, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
      }
      eachProp(style, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style[key];
          if (is.und(value))
            return;
          const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray2(value));
          transforms.push(key === "rotate3d" ? ([x5, y6, z3, deg]) => [`rotate3d(${x5},${y6},${z3},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v5) => addUnit(v5, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  };
  var FluidTransform = class extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this._value = null;
      this.inputs = inputs;
      this.transforms = transforms;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity4 = true;
      each(this.inputs, (input, i5) => {
        const arg1 = getFluidValue(input[0]);
        const [t5, id2] = this.transforms[i5](is.arr(arg1) ? arg1 : input.map(getFluidValue));
        transform += " " + t5;
        identity4 = identity4 && id2;
      });
      return identity4 ? "none" : transform;
    }
    observerAdded(count) {
      if (count == 1)
        each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
    }
    observerRemoved(count) {
      if (count == 0)
        each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  };
  var primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
  var _excluded2 = ["scrollTop", "scrollLeft"];
  globals.assign({
    batchedUpdates: import_react_dom4.unstable_batchedUpdates,
    createStringInterpolator,
    colors
  });
  var host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    getComponentProps: (_ref8) => {
      let props = _objectWithoutPropertiesLoose6(_ref8, _excluded2);
      return props;
    }
  });
  var animated = host.animated;

  // node_modules/@wordpress/block-editor/build-module/components/use-moving-animation/index.js
  var counterReducer = (state) => state + 1;
  var getAbsolutePosition = (element) => {
    return {
      top: element.offsetTop,
      left: element.offsetLeft
    };
  };
  function useMovingAnimation(_ref8) {
    let {
      isSelected,
      adjustScrolling,
      enableAnimation,
      triggerAnimationOnChange
    } = _ref8;
    const ref2 = (0, import_react.useRef)();
    const prefersReducedMotion2 = use_reduced_motion_default() || !enableAnimation;
    const [triggeredAnimation, triggerAnimation] = (0, import_react.useReducer)(counterReducer, 0);
    const [finishedAnimation, endAnimation] = (0, import_react.useReducer)(counterReducer, 0);
    const [transform, setTransform] = (0, import_react.useState)({
      x: 0,
      y: 0
    });
    const previous = (0, import_react.useMemo)(() => ref2.current ? getAbsolutePosition(ref2.current) : null, [triggerAnimationOnChange]);
    const preserveScrollPosition = (0, import_react.useMemo)(() => {
      if (!adjustScrolling || !ref2.current) {
        return () => {
        };
      }
      const scrollContainer = getScrollContainer(ref2.current);
      if (!scrollContainer) {
        return () => {
        };
      }
      const prevRect = ref2.current.getBoundingClientRect();
      return () => {
        const blockRect = ref2.current.getBoundingClientRect();
        const diff = blockRect.top - prevRect.top;
        if (diff) {
          scrollContainer.scrollTop += diff;
        }
      };
    }, [triggerAnimationOnChange, adjustScrolling]);
    (0, import_react.useLayoutEffect)(() => {
      if (triggeredAnimation) {
        endAnimation();
      }
    }, [triggeredAnimation]);
    (0, import_react.useLayoutEffect)(() => {
      if (!previous) {
        return;
      }
      if (prefersReducedMotion2) {
        preserveScrollPosition();
        return;
      }
      ref2.current.style.transform = void 0;
      const destination = getAbsolutePosition(ref2.current);
      triggerAnimation();
      setTransform({
        x: Math.round(previous.left - destination.left),
        y: Math.round(previous.top - destination.top)
      });
    }, [triggerAnimationOnChange]);
    function onChange(_ref22) {
      let {
        value
      } = _ref22;
      if (!ref2.current) {
        return;
      }
      let {
        x: x4,
        y: y5
      } = value;
      x4 = Math.round(x4);
      y5 = Math.round(y5);
      const finishedMoving = x4 === 0 && y5 === 0;
      ref2.current.style.transformOrigin = "center center";
      ref2.current.style.transform = finishedMoving ? void 0 : `translate3d(${x4}px,${y5}px,0)`;
      ref2.current.style.zIndex = isSelected ? "1" : "";
      preserveScrollPosition();
    }
    useSpring({
      from: {
        x: transform.x,
        y: transform.y
      },
      to: {
        x: 0,
        y: 0
      },
      reset: triggeredAnimation !== finishedAnimation,
      config: {
        mass: 5,
        tension: 2e3,
        friction: 200
      },
      immediate: prefersReducedMotion2,
      onChange
    });
    return ref2;
  }
  var use_moving_animation_default = useMovingAnimation;

  // node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js
  var import_classnames24 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-mover/mover-description.js
  var getMovementDirection = (moveDirection, orientation) => {
    if (moveDirection === "up") {
      if (orientation === "horizontal") {
        return isRTL() ? "right" : "left";
      }
      return "up";
    } else if (moveDirection === "down") {
      if (orientation === "horizontal") {
        return isRTL() ? "left" : "right";
      }
      return "down";
    }
    return null;
  };
  function getBlockMoverDescription(selectedCount, type, firstIndex, isFirst, isLast, dir, orientation) {
    const position = firstIndex + 1;
    if (selectedCount > 1) {
      return getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation);
    }
    if (isFirst && isLast) {
      return sprintf(
        __("Block %s is the only block, and cannot be moved"),
        type
      );
    }
    if (dir > 0 && !isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return sprintf(
          __("Move %1$s block from position %2$d down to position %3$d"),
          type,
          position,
          position + 1
        );
      }
      if (movementDirection === "left") {
        return sprintf(
          __("Move %1$s block from position %2$d left to position %3$d"),
          type,
          position,
          position + 1
        );
      }
      if (movementDirection === "right") {
        return sprintf(
          __("Move %1$s block from position %2$d right to position %3$d"),
          type,
          position,
          position + 1
        );
      }
    }
    if (dir > 0 && isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return sprintf(
          __("Block %1$s is at the end of the content and can\u2019t be moved down"),
          type
        );
      }
      if (movementDirection === "left") {
        return sprintf(
          __("Block %1$s is at the end of the content and can\u2019t be moved left"),
          type
        );
      }
      if (movementDirection === "right") {
        return sprintf(
          __("Block %1$s is at the end of the content and can\u2019t be moved right"),
          type
        );
      }
    }
    if (dir < 0 && !isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return sprintf(
          __("Move %1$s block from position %2$d up to position %3$d"),
          type,
          position,
          position - 1
        );
      }
      if (movementDirection === "left") {
        return sprintf(
          __("Move %1$s block from position %2$d left to position %3$d"),
          type,
          position,
          position - 1
        );
      }
      if (movementDirection === "right") {
        return sprintf(
          __("Move %1$s block from position %2$d right to position %3$d"),
          type,
          position,
          position - 1
        );
      }
    }
    if (dir < 0 && isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return sprintf(
          __("Block %1$s is at the beginning of the content and can\u2019t be moved up"),
          type
        );
      }
      if (movementDirection === "left") {
        return sprintf(
          __("Block %1$s is at the beginning of the content and can\u2019t be moved left"),
          type
        );
      }
      if (movementDirection === "right") {
        return sprintf(
          __("Block %1$s is at the beginning of the content and can\u2019t be moved right"),
          type
        );
      }
    }
  }
  function getMultiBlockMoverDescription(selectedCount, firstIndex, isFirst, isLast, dir, orientation) {
    const position = firstIndex + 1;
    if (isFirst && isLast) {
      return __("All blocks are selected, and cannot be moved");
    }
    if (dir > 0 && !isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return sprintf(
          __("Move %1$d blocks from position %2$d down by one place"),
          selectedCount,
          position
        );
      }
      if (movementDirection === "left") {
        return sprintf(
          __("Move %1$d blocks from position %2$d left by one place"),
          selectedCount,
          position
        );
      }
      if (movementDirection === "right") {
        return sprintf(
          __("Move %1$d blocks from position %2$d right by one place"),
          selectedCount,
          position
        );
      }
    }
    if (dir > 0 && isLast) {
      const movementDirection = getMovementDirection("down", orientation);
      if (movementDirection === "down") {
        return __("Blocks cannot be moved down as they are already at the bottom");
      }
      if (movementDirection === "left") {
        return __("Blocks cannot be moved left as they are already are at the leftmost position");
      }
      if (movementDirection === "right") {
        return __("Blocks cannot be moved right as they are already are at the rightmost position");
      }
    }
    if (dir < 0 && !isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return sprintf(
          __("Move %1$d blocks from position %2$d up by one place"),
          selectedCount,
          position
        );
      }
      if (movementDirection === "left") {
        return sprintf(
          __("Move %1$d blocks from position %2$d left by one place"),
          selectedCount,
          position
        );
      }
      if (movementDirection === "right") {
        return sprintf(
          __("Move %1$d blocks from position %2$d right by one place"),
          selectedCount,
          position
        );
      }
    }
    if (dir < 0 && isFirst) {
      const movementDirection = getMovementDirection("up", orientation);
      if (movementDirection === "up") {
        return __("Blocks cannot be moved up as they are already at the top");
      }
      if (movementDirection === "left") {
        return __("Blocks cannot be moved left as they are already are at the leftmost position");
      }
      if (movementDirection === "right") {
        return __("Blocks cannot be moved right as they are already are at the rightmost position");
      }
    }
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-mover/button.js
  var getArrowIcon = (direction, orientation) => {
    if (direction === "up") {
      if (orientation === "horizontal") {
        return isRTL() ? chevron_right_default : chevron_left_default;
      }
      return chevron_up_default;
    } else if (direction === "down") {
      if (orientation === "horizontal") {
        return isRTL() ? chevron_left_default : chevron_right_default;
      }
      return chevron_down_default;
    }
    return null;
  };
  var getMovementDirectionLabel = (moveDirection, orientation) => {
    if (moveDirection === "up") {
      if (orientation === "horizontal") {
        return isRTL() ? __("Move right") : __("Move left");
      }
      return __("Move up");
    } else if (moveDirection === "down") {
      if (orientation === "horizontal") {
        return isRTL() ? __("Move left") : __("Move right");
      }
      return __("Move down");
    }
    return null;
  };
  var BlockMoverButton = (0, import_react.forwardRef)((_ref8, ref2) => {
    let {
      clientIds,
      direction,
      orientation: moverOrientation,
      ...props
    } = _ref8;
    const instanceId = use_instance_id_default(BlockMoverButton);
    const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
    const blocksCount = normalizedClientIds.length;
    const {
      blockType,
      isDisabled,
      rootClientId,
      isFirst,
      isLast,
      firstIndex,
      orientation = "vertical"
    } = useSelect((select2) => {
      const {
        getBlockIndex: getBlockIndex2,
        getBlockRootClientId: getBlockRootClientId2,
        getBlockOrder: getBlockOrder2,
        getBlock: getBlock2,
        getBlockListSettings: getBlockListSettings2
      } = select2(store3);
      const firstClientId = normalizedClientIds[0];
      const blockRootClientId = getBlockRootClientId2(firstClientId);
      const firstBlockIndex = getBlockIndex2(firstClientId);
      const lastBlockIndex = getBlockIndex2(normalizedClientIds[normalizedClientIds.length - 1]);
      const blockOrder = getBlockOrder2(blockRootClientId);
      const block4 = getBlock2(firstClientId);
      const isFirstBlock = firstBlockIndex === 0;
      const isLastBlock = lastBlockIndex === blockOrder.length - 1;
      const {
        orientation: blockListOrientation
      } = getBlockListSettings2(blockRootClientId) || {};
      return {
        blockType: block4 ? getBlockType(block4.name) : null,
        isDisabled: direction === "up" ? isFirstBlock : isLastBlock,
        rootClientId: blockRootClientId,
        firstIndex: firstBlockIndex,
        isFirst: isFirstBlock,
        isLast: isLastBlock,
        orientation: moverOrientation || blockListOrientation
      };
    }, [clientIds, direction]);
    const {
      moveBlocksDown: moveBlocksDown2,
      moveBlocksUp: moveBlocksUp2
    } = use_dispatch_default(store3);
    const moverFunction = direction === "up" ? moveBlocksUp2 : moveBlocksDown2;
    const onClick = (event) => {
      moverFunction(clientIds, rootClientId);
      if (props.onClick) {
        props.onClick(event);
      }
    };
    const descriptionId = `block-editor-block-mover-button__description-${instanceId}`;
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(button_default, _extends({
      ref: ref2,
      className: (0, import_classnames24.default)("block-editor-block-mover-button", `is-${direction}-button`),
      icon: getArrowIcon(direction, orientation),
      label: getMovementDirectionLabel(direction, orientation),
      "aria-describedby": descriptionId
    }, props, {
      onClick: isDisabled ? null : onClick,
      disabled: isDisabled,
      __experimentalIsFocusable: true
    })), (0, import_react.createElement)(component_default2, {
      id: descriptionId
    }, getBlockMoverDescription(blocksCount, blockType && blockType.title, firstIndex, isFirst, isLast, direction === "up" ? -1 : 1, orientation)));
  });
  var BlockMoverUpButton = (0, import_react.forwardRef)((props, ref2) => {
    return (0, import_react.createElement)(BlockMoverButton, _extends({
      direction: "up",
      ref: ref2
    }, props));
  });
  var BlockMoverDownButton = (0, import_react.forwardRef)((props, ref2) => {
    return (0, import_react.createElement)(BlockMoverButton, _extends({
      direction: "down",
      ref: ref2
    }, props));
  });

  // node_modules/@wordpress/block-editor/build-module/components/block-lock/use-block-lock.js
  function useBlockLock(clientId) {
    return useSelect((select2) => {
      const {
        canEditBlock: canEditBlock2,
        canMoveBlock: canMoveBlock2,
        canRemoveBlock: canRemoveBlock2,
        canLockBlockType: canLockBlockType2,
        getBlockName: getBlockName2,
        getBlockRootClientId: getBlockRootClientId2,
        getTemplateLock: getTemplateLock2
      } = select2(store3);
      const rootClientId = getBlockRootClientId2(clientId);
      const canEdit = canEditBlock2(clientId);
      const canMove = canMoveBlock2(clientId, rootClientId);
      const canRemove = canRemoveBlock2(clientId, rootClientId);
      return {
        canEdit,
        canMove,
        canRemove,
        canLock: canLockBlockType2(getBlockName2(clientId)),
        isContentLocked: getTemplateLock2(clientId) === "contentOnly",
        isLocked: !canEdit || !canMove || !canRemove
      };
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-lock/modal.js
  var ALLOWS_EDIT_LOCKING = ["core/block", "core/navigation"];
  function getTemplateLockValue(lock2) {
    if (lock2.remove && lock2.move) {
      return "all";
    }
    if (lock2.remove && !lock2.move) {
      return "insert";
    }
    return false;
  }
  function BlockLockModal(_ref8) {
    let {
      clientId,
      onClose
    } = _ref8;
    const [lock2, setLock] = (0, import_react.useState)({
      move: false,
      remove: false
    });
    const {
      canEdit,
      canMove,
      canRemove
    } = useBlockLock(clientId);
    const {
      allowsEditLocking,
      templateLock,
      hasTemplateLock
    } = useSelect((select2) => {
      var _getBlockAttributes, _blockType$attributes;
      const {
        getBlockName: getBlockName2,
        getBlockAttributes: getBlockAttributes3
      } = select2(store3);
      const blockName = getBlockName2(clientId);
      const blockType = getBlockType(blockName);
      return {
        allowsEditLocking: ALLOWS_EDIT_LOCKING.includes(blockName),
        templateLock: (_getBlockAttributes = getBlockAttributes3(clientId)) === null || _getBlockAttributes === void 0 ? void 0 : _getBlockAttributes.templateLock,
        hasTemplateLock: !!(blockType !== null && blockType !== void 0 && (_blockType$attributes = blockType.attributes) !== null && _blockType$attributes !== void 0 && _blockType$attributes.templateLock)
      };
    }, [clientId]);
    const [applyTemplateLock, setApplyTemplateLock] = (0, import_react.useState)(!!templateLock);
    const {
      updateBlockAttributes: updateBlockAttributes2
    } = use_dispatch_default(store3);
    const blockInformation = useBlockDisplayInformation(clientId);
    const instanceId = use_instance_id_default(BlockLockModal, "block-editor-block-lock-modal__options-title");
    (0, import_react.useEffect)(() => {
      setLock({
        move: !canMove,
        remove: !canRemove,
        ...allowsEditLocking ? {
          edit: !canEdit
        } : {}
      });
    }, [canEdit, canMove, canRemove, allowsEditLocking]);
    const isAllChecked = Object.values(lock2).every(Boolean);
    const isMixed = Object.values(lock2).some(Boolean) && !isAllChecked;
    return (0, import_react.createElement)(modal_default, {
      title: sprintf(
        __("Lock %s"),
        blockInformation.title
      ),
      overlayClassName: "block-editor-block-lock-modal",
      closeLabel: __("Close"),
      onRequestClose: onClose
    }, (0, import_react.createElement)("p", null, __("Choose specific attributes to restrict or lock all available options.")), (0, import_react.createElement)("form", {
      onSubmit: (event) => {
        event.preventDefault();
        updateBlockAttributes2([clientId], {
          lock: lock2,
          templateLock: applyTemplateLock ? getTemplateLockValue(lock2) : void 0
        });
        onClose();
      }
    }, (0, import_react.createElement)("div", {
      role: "group",
      "aria-labelledby": instanceId,
      className: "block-editor-block-lock-modal__options"
    }, (0, import_react.createElement)(checkbox_control_default, {
      className: "block-editor-block-lock-modal__options-title",
      label: (0, import_react.createElement)("span", {
        id: instanceId
      }, __("Lock all")),
      checked: isAllChecked,
      indeterminate: isMixed,
      onChange: (newValue) => setLock({
        move: newValue,
        remove: newValue,
        ...allowsEditLocking ? {
          edit: newValue
        } : {}
      })
    }), (0, import_react.createElement)("ul", {
      className: "block-editor-block-lock-modal__checklist"
    }, allowsEditLocking && (0, import_react.createElement)("li", {
      className: "block-editor-block-lock-modal__checklist-item"
    }, (0, import_react.createElement)(checkbox_control_default, {
      label: (0, import_react.createElement)(import_react.Fragment, null, __("Restrict editing"), (0, import_react.createElement)(icon_default2, {
        icon: lock2.edit ? lock_default : unlock_default
      })),
      checked: !!lock2.edit,
      onChange: (edit) => setLock((prevLock) => ({
        ...prevLock,
        edit
      }))
    })), (0, import_react.createElement)("li", {
      className: "block-editor-block-lock-modal__checklist-item"
    }, (0, import_react.createElement)(checkbox_control_default, {
      label: (0, import_react.createElement)(import_react.Fragment, null, __("Disable movement"), (0, import_react.createElement)(icon_default2, {
        icon: lock2.move ? lock_default : unlock_default
      })),
      checked: lock2.move,
      onChange: (move) => setLock((prevLock) => ({
        ...prevLock,
        move
      }))
    })), (0, import_react.createElement)("li", {
      className: "block-editor-block-lock-modal__checklist-item"
    }, (0, import_react.createElement)(checkbox_control_default, {
      label: (0, import_react.createElement)(import_react.Fragment, null, __("Prevent removal"), (0, import_react.createElement)(icon_default2, {
        icon: lock2.remove ? lock_default : unlock_default
      })),
      checked: lock2.remove,
      onChange: (remove4) => setLock((prevLock) => ({
        ...prevLock,
        remove: remove4
      }))
    }))), hasTemplateLock && (0, import_react.createElement)(toggle_control_default, {
      className: "block-editor-block-lock-modal__template-lock",
      label: __("Apply to all blocks inside"),
      checked: applyTemplateLock,
      disabled: lock2.move && !lock2.remove,
      onChange: () => setApplyTemplateLock(!applyTemplateLock)
    })), (0, import_react.createElement)(component_default3, {
      className: "block-editor-block-lock-modal__actions",
      justify: "flex-end",
      expanded: false
    }, (0, import_react.createElement)(component_default4, null, (0, import_react.createElement)(button_default, {
      variant: "tertiary",
      onClick: onClose
    }, __("Cancel"))), (0, import_react.createElement)(component_default4, null, (0, import_react.createElement)(button_default, {
      variant: "primary",
      type: "submit"
    }, __("Apply"))))));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-lock/menu-item.js
  function BlockLockMenuItem(_ref8) {
    let {
      clientId
    } = _ref8;
    const {
      canLock,
      isLocked
    } = useBlockLock(clientId);
    const [isModalOpen, toggleModal] = (0, import_react.useReducer)((isActive) => !isActive, false);
    if (!canLock) {
      return null;
    }
    const label = isLocked ? __("Unlock") : __("Lock");
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(menu_item_default, {
      icon: isLocked ? unlock_default : lock_default,
      onClick: toggleModal
    }, label), isModalOpen && (0, import_react.createElement)(BlockLockModal, {
      clientId,
      onClose: toggleModal
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-lock/toolbar.js
  function BlockLockToolbar(_ref8) {
    let {
      clientId
    } = _ref8;
    const blockInformation = useBlockDisplayInformation(clientId);
    const {
      canEdit,
      canMove,
      canRemove,
      canLock
    } = useBlockLock(clientId);
    const [isModalOpen, toggleModal] = (0, import_react.useReducer)((isActive) => !isActive, false);
    if (!canLock) {
      return null;
    }
    if (canEdit && canMove && canRemove) {
      return null;
    }
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(toolbar_group_default, {
      className: "block-editor-block-lock-toolbar"
    }, (0, import_react.createElement)(toolbar_button_default, {
      icon: lock_default,
      label: sprintf(
        __("Unlock %s"),
        blockInformation.title
      ),
      onClick: toggleModal
    })), isModalOpen && (0, import_react.createElement)(BlockLockModal, {
      clientId,
      onClose: toggleModal
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-draggable/draggable-chip.js
  function BlockDraggableChip(_ref8) {
    let {
      count,
      icon,
      isPattern
    } = _ref8;
    const patternLabel = isPattern && __("Pattern");
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-draggable-chip-wrapper"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-draggable-chip",
      "data-testid": "block-draggable-chip"
    }, (0, import_react.createElement)(component_default3, {
      justify: "center",
      className: "block-editor-block-draggable-chip__content"
    }, (0, import_react.createElement)(component_default4, null, icon ? (0, import_react.createElement)(block_icon_default, {
      icon
    }) : patternLabel || sprintf(
      _n("%d block", "%d blocks", count),
      count
    )), (0, import_react.createElement)(component_default4, null, (0, import_react.createElement)(block_icon_default, {
      icon: drag_handle_default
    })))));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-draggable/use-scroll-when-dragging.js
  var SCROLL_INACTIVE_DISTANCE_PX = 50;
  var SCROLL_INTERVAL_MS = 25;
  var PIXELS_PER_SECOND_PER_PERCENTAGE = 1e3;
  var VELOCITY_MULTIPLIER = PIXELS_PER_SECOND_PER_PERCENTAGE * (SCROLL_INTERVAL_MS / 1e3);
  function useScrollWhenDragging() {
    const dragStartY = (0, import_react.useRef)(null);
    const velocityY = (0, import_react.useRef)(null);
    const scrollParentY = (0, import_react.useRef)(null);
    const scrollEditorInterval = (0, import_react.useRef)(null);
    (0, import_react.useEffect)(() => () => {
      if (scrollEditorInterval.current) {
        clearInterval(scrollEditorInterval.current);
        scrollEditorInterval.current = null;
      }
    }, []);
    const startScrolling = (0, import_react.useCallback)((event) => {
      dragStartY.current = event.clientY;
      scrollParentY.current = getScrollContainer(event.target);
      scrollEditorInterval.current = setInterval(() => {
        if (scrollParentY.current && velocityY.current) {
          const newTop = scrollParentY.current.scrollTop + velocityY.current;
          scrollParentY.current.scroll({
            top: newTop
          });
        }
      }, SCROLL_INTERVAL_MS);
    }, []);
    const scrollOnDragOver = (0, import_react.useCallback)((event) => {
      if (!scrollParentY.current) {
        return;
      }
      const scrollParentHeight = scrollParentY.current.offsetHeight;
      const offsetDragStartPosition = dragStartY.current - scrollParentY.current.offsetTop;
      const offsetDragPosition = event.clientY - scrollParentY.current.offsetTop;
      if (event.clientY > offsetDragStartPosition) {
        const moveableDistance = Math.max(scrollParentHeight - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
        const dragDistance = Math.max(offsetDragPosition - offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
        const distancePercentage = dragDistance / moveableDistance;
        velocityY.current = VELOCITY_MULTIPLIER * distancePercentage;
      } else if (event.clientY < offsetDragStartPosition) {
        const moveableDistance = Math.max(offsetDragStartPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
        const dragDistance = Math.max(offsetDragStartPosition - offsetDragPosition - SCROLL_INACTIVE_DISTANCE_PX, 0);
        const distancePercentage = dragDistance / moveableDistance;
        velocityY.current = -VELOCITY_MULTIPLIER * distancePercentage;
      } else {
        velocityY.current = 0;
      }
    }, []);
    const stopScrolling = () => {
      dragStartY.current = null;
      scrollParentY.current = null;
      if (scrollEditorInterval.current) {
        clearInterval(scrollEditorInterval.current);
        scrollEditorInterval.current = null;
      }
    };
    return [startScrolling, scrollOnDragOver, stopScrolling];
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-draggable/index.js
  var BlockDraggable = (_ref8) => {
    let {
      children,
      clientIds,
      cloneClassname,
      onDragStart,
      onDragEnd
    } = _ref8;
    const {
      srcRootClientId,
      isDraggable,
      icon
    } = useSelect((select2) => {
      var _getBlockType;
      const {
        canMoveBlocks: canMoveBlocks2,
        getBlockRootClientId: getBlockRootClientId2,
        getBlockName: getBlockName2
      } = select2(store3);
      const rootClientId = getBlockRootClientId2(clientIds[0]);
      const blockName = getBlockName2(clientIds[0]);
      return {
        srcRootClientId: rootClientId,
        isDraggable: canMoveBlocks2(clientIds, rootClientId),
        icon: (_getBlockType = getBlockType(blockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon
      };
    }, [clientIds]);
    const isDragging = (0, import_react.useRef)(false);
    const [startScrolling, scrollOnDragOver, stopScrolling] = useScrollWhenDragging();
    const {
      startDraggingBlocks: startDraggingBlocks2,
      stopDraggingBlocks: stopDraggingBlocks2
    } = use_dispatch_default(store3);
    (0, import_react.useEffect)(() => {
      return () => {
        if (isDragging.current) {
          stopDraggingBlocks2();
        }
      };
    }, []);
    if (!isDraggable) {
      return children({
        draggable: false
      });
    }
    const transferData = {
      type: "block",
      srcClientIds: clientIds,
      srcRootClientId
    };
    return (0, import_react.createElement)(Draggable, {
      cloneClassname,
      __experimentalTransferDataType: "wp-blocks",
      transferData,
      onDragStart: (event) => {
        startDraggingBlocks2(clientIds);
        isDragging.current = true;
        startScrolling(event);
        if (onDragStart) {
          onDragStart();
        }
      },
      onDragOver: scrollOnDragOver,
      onDragEnd: () => {
        stopDraggingBlocks2();
        isDragging.current = false;
        stopScrolling();
        if (onDragEnd) {
          onDragEnd();
        }
      },
      __experimentalDragComponent: (0, import_react.createElement)(BlockDraggableChip, {
        count: clientIds.length,
        icon
      })
    }, (_ref22) => {
      let {
        onDraggableStart,
        onDraggableEnd
      } = _ref22;
      return children({
        draggable: true,
        onDragStart: onDraggableStart,
        onDragEnd: onDraggableEnd
      });
    });
  };
  var block_draggable_default = BlockDraggable;

  // node_modules/@wordpress/keyboard-shortcuts/build-module/store/reducer.js
  function reducer2() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "REGISTER_SHORTCUT":
        return {
          ...state,
          [action.name]: {
            category: action.category,
            keyCombination: action.keyCombination,
            aliases: action.aliases,
            description: action.description
          }
        };
      case "UNREGISTER_SHORTCUT":
        const {
          [action.name]: actionName,
          ...remainingState
        } = state;
        return remainingState;
    }
    return state;
  }
  var reducer_default5 = reducer2;

  // node_modules/@wordpress/keyboard-shortcuts/build-module/store/actions.js
  var actions_exports6 = {};
  __export(actions_exports6, {
    registerShortcut: () => registerShortcut,
    unregisterShortcut: () => unregisterShortcut
  });
  function registerShortcut(_ref8) {
    let {
      name,
      category,
      description,
      keyCombination,
      aliases
    } = _ref8;
    return {
      type: "REGISTER_SHORTCUT",
      name,
      category,
      keyCombination,
      aliases,
      description
    };
  }
  function unregisterShortcut(name) {
    return {
      type: "UNREGISTER_SHORTCUT",
      name
    };
  }

  // node_modules/@wordpress/keyboard-shortcuts/build-module/store/selectors.js
  var selectors_exports5 = {};
  __export(selectors_exports5, {
    getAllShortcutKeyCombinations: () => getAllShortcutKeyCombinations,
    getAllShortcutRawKeyCombinations: () => getAllShortcutRawKeyCombinations,
    getCategoryShortcuts: () => getCategoryShortcuts,
    getShortcutAliases: () => getShortcutAliases,
    getShortcutDescription: () => getShortcutDescription,
    getShortcutKeyCombination: () => getShortcutKeyCombination,
    getShortcutRepresentation: () => getShortcutRepresentation
  });
  var EMPTY_ARRAY2 = [];
  var FORMATTING_METHODS = {
    display: displayShortcut,
    raw: rawShortcut,
    ariaLabel: shortcutAriaLabel
  };
  function getKeyCombinationRepresentation(shortcut, representation) {
    if (!shortcut) {
      return null;
    }
    return shortcut.modifier ? FORMATTING_METHODS[representation][shortcut.modifier](shortcut.character) : shortcut.character;
  }
  function getShortcutKeyCombination(state, name) {
    return state[name] ? state[name].keyCombination : null;
  }
  function getShortcutRepresentation(state, name) {
    let representation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "display";
    const shortcut = getShortcutKeyCombination(state, name);
    return getKeyCombinationRepresentation(shortcut, representation);
  }
  function getShortcutDescription(state, name) {
    return state[name] ? state[name].description : null;
  }
  function getShortcutAliases(state, name) {
    return state[name] && state[name].aliases ? state[name].aliases : EMPTY_ARRAY2;
  }
  var getAllShortcutKeyCombinations = rememo_default((state, name) => {
    return [getShortcutKeyCombination(state, name), ...getShortcutAliases(state, name)].filter(Boolean);
  }, (state, name) => [state[name]]);
  var getAllShortcutRawKeyCombinations = rememo_default((state, name) => {
    return getAllShortcutKeyCombinations(state, name).map((combination) => getKeyCombinationRepresentation(combination, "raw"));
  }, (state, name) => [state[name]]);
  var getCategoryShortcuts = rememo_default((state, categoryName) => {
    return Object.entries(state).filter((_ref8) => {
      let [, shortcut] = _ref8;
      return shortcut.category === categoryName;
    }).map((_ref22) => {
      let [name] = _ref22;
      return name;
    });
  }, (state) => [state]);

  // node_modules/@wordpress/keyboard-shortcuts/build-module/store/index.js
  var STORE_NAME4 = "core/keyboard-shortcuts";
  var store4 = createReduxStore(STORE_NAME4, {
    reducer: reducer_default5,
    actions: actions_exports6,
    selectors: selectors_exports5
  });
  register(store4);

  // node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut-event-match.js
  function useShortcutEventMatch() {
    const {
      getAllShortcutKeyCombinations: getAllShortcutKeyCombinations2
    } = useSelect(store4);
    function isMatch(name, event) {
      return getAllShortcutKeyCombinations2(name).some((_ref8) => {
        let {
          modifier,
          character
        } = _ref8;
        return isKeyboardEvent[modifier](event, character);
      });
    }
    return isMatch;
  }

  // node_modules/@wordpress/keyboard-shortcuts/build-module/context.js
  var context = (0, import_react.createContext)();

  // node_modules/@wordpress/keyboard-shortcuts/build-module/hooks/use-shortcut.js
  function useShortcut(name, callback) {
    let {
      isDisabled
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const shortcuts = (0, import_react.useContext)(context);
    const isMatch = useShortcutEventMatch();
    const callbackRef = (0, import_react.useRef)();
    callbackRef.current = callback;
    (0, import_react.useEffect)(() => {
      if (isDisabled) {
        return;
      }
      function _callback(event) {
        if (isMatch(name, event)) {
          callbackRef.current(event);
        }
      }
      shortcuts.current.add(_callback);
      return () => {
        shortcuts.current.delete(_callback);
      };
    }, [name, isDisabled]);
  }

  // node_modules/@wordpress/keyboard-shortcuts/build-module/components/shortcut-provider.js
  var {
    Provider: Provider7
  } = context;

  // node_modules/@wordpress/notices/build-module/store/utils/on-sub-key.js
  var onSubKey2 = (actionProperty) => (reducer3) => function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let action = arguments.length > 1 ? arguments[1] : void 0;
    const key = action[actionProperty];
    if (key === void 0) {
      return state;
    }
    const nextKeyState = reducer3(state[key], action);
    if (nextKeyState === state[key]) {
      return state;
    }
    return {
      ...state,
      [key]: nextKeyState
    };
  };
  var on_sub_key_default = onSubKey2;

  // node_modules/@wordpress/notices/build-module/store/reducer.js
  var notices = on_sub_key_default("context")(function() {
    let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let action = arguments.length > 1 ? arguments[1] : void 0;
    switch (action.type) {
      case "CREATE_NOTICE":
        return [...state.filter((_ref8) => {
          let {
            id: id2
          } = _ref8;
          return id2 !== action.notice.id;
        }), action.notice];
      case "REMOVE_NOTICE":
        return state.filter((_ref22) => {
          let {
            id: id2
          } = _ref22;
          return id2 !== action.id;
        });
    }
    return state;
  });
  var reducer_default6 = notices;

  // node_modules/@wordpress/notices/build-module/store/actions.js
  var actions_exports7 = {};
  __export(actions_exports7, {
    createErrorNotice: () => createErrorNotice,
    createInfoNotice: () => createInfoNotice,
    createNotice: () => createNotice,
    createSuccessNotice: () => createSuccessNotice,
    createWarningNotice: () => createWarningNotice,
    removeNotice: () => removeNotice
  });

  // node_modules/@wordpress/notices/build-module/store/constants.js
  var DEFAULT_CONTEXT = "global";
  var DEFAULT_STATUS = "info";

  // node_modules/@wordpress/notices/build-module/store/actions.js
  var uniqueId = 0;
  function createNotice() {
    let status = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_STATUS;
    let content = arguments.length > 1 ? arguments[1] : void 0;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      speak: speak2 = true,
      isDismissible = true,
      context: context2 = DEFAULT_CONTEXT,
      id: id2 = `${context2}${++uniqueId}`,
      actions: actions2 = [],
      type = "default",
      __unstableHTML,
      icon = null,
      explicitDismiss = false,
      onDismiss
    } = options;
    content = String(content);
    return {
      type: "CREATE_NOTICE",
      context: context2,
      notice: {
        id: id2,
        status,
        content,
        spokenMessage: speak2 ? content : null,
        __unstableHTML,
        isDismissible,
        actions: actions2,
        type,
        icon,
        explicitDismiss,
        onDismiss
      }
    };
  }
  function createSuccessNotice(content, options) {
    return createNotice("success", content, options);
  }
  function createInfoNotice(content, options) {
    return createNotice("info", content, options);
  }
  function createErrorNotice(content, options) {
    return createNotice("error", content, options);
  }
  function createWarningNotice(content, options) {
    return createNotice("warning", content, options);
  }
  function removeNotice(id2) {
    let context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CONTEXT;
    return {
      type: "REMOVE_NOTICE",
      id: id2,
      context: context2
    };
  }

  // node_modules/@wordpress/notices/build-module/store/selectors.js
  var selectors_exports6 = {};
  __export(selectors_exports6, {
    getNotices: () => getNotices
  });
  var DEFAULT_NOTICES = [];
  function getNotices(state) {
    let context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CONTEXT;
    return state[context2] || DEFAULT_NOTICES;
  }

  // node_modules/@wordpress/notices/build-module/store/index.js
  var store5 = createReduxStore("core/notices", {
    reducer: reducer_default6,
    actions: actions_exports7,
    selectors: selectors_exports6
  });
  register(store5);

  // node_modules/@wordpress/block-editor/build-module/components/copy-handler/index.js
  function useNotifyCopy() {
    const {
      getBlockName: getBlockName2
    } = useSelect(store3);
    const {
      getBlockType: getBlockType3
    } = useSelect(store);
    const {
      createSuccessNotice: createSuccessNotice2
    } = use_dispatch_default(store5);
    return (0, import_react.useCallback)((eventType, selectedBlockClientIds) => {
      let notice = "";
      if (selectedBlockClientIds.length === 1) {
        var _getBlockType;
        const clientId = selectedBlockClientIds[0];
        const title = (_getBlockType = getBlockType3(getBlockName2(clientId))) === null || _getBlockType === void 0 ? void 0 : _getBlockType.title;
        notice = eventType === "copy" ? sprintf(
          __('Copied "%s" to clipboard.'),
          title
        ) : sprintf(
          __('Moved "%s" to clipboard.'),
          title
        );
      } else {
        notice = eventType === "copy" ? sprintf(
          _n("Copied %d block to clipboard.", "Copied %d blocks to clipboard.", selectedBlockClientIds.length),
          selectedBlockClientIds.length
        ) : sprintf(
          _n("Moved %d block to clipboard.", "Moved %d blocks to clipboard.", selectedBlockClientIds.length),
          selectedBlockClientIds.length
        );
      }
      createSuccessNotice2(notice, {
        type: "snackbar"
      });
    }, []);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-actions/index.js
  function BlockActions(_ref8) {
    let {
      clientIds,
      children,
      __experimentalUpdateSelection: updateSelection
    } = _ref8;
    const {
      canInsertBlockType: canInsertBlockType2,
      getBlockRootClientId: getBlockRootClientId2,
      getBlocksByClientId: getBlocksByClientId2,
      canMoveBlocks: canMoveBlocks2,
      canRemoveBlocks: canRemoveBlocks2
    } = useSelect(store3);
    const {
      getDefaultBlockName: getDefaultBlockName3,
      getGroupingBlockName: getGroupingBlockName3
    } = useSelect(store);
    const blocks2 = getBlocksByClientId2(clientIds);
    const rootClientId = getBlockRootClientId2(clientIds[0]);
    const canDuplicate = blocks2.every((block4) => {
      return !!block4 && hasBlockSupport(block4.name, "multiple", true) && canInsertBlockType2(block4.name, rootClientId);
    });
    const canInsertDefaultBlock = canInsertBlockType2(getDefaultBlockName3(), rootClientId);
    const canMove = canMoveBlocks2(clientIds, rootClientId);
    const canRemove = canRemoveBlocks2(clientIds, rootClientId);
    const {
      removeBlocks: removeBlocks2,
      replaceBlocks: replaceBlocks2,
      duplicateBlocks: duplicateBlocks2,
      insertAfterBlock: insertAfterBlock2,
      insertBeforeBlock: insertBeforeBlock2,
      flashBlock: flashBlock2,
      setBlockMovingClientId: setBlockMovingClientId2,
      setNavigationMode: setNavigationMode2,
      selectBlock: selectBlock2
    } = use_dispatch_default(store3);
    const notifyCopy = useNotifyCopy();
    return children({
      canDuplicate,
      canInsertDefaultBlock,
      canMove,
      canRemove,
      rootClientId,
      blocks: blocks2,
      onDuplicate() {
        return duplicateBlocks2(clientIds, updateSelection);
      },
      onRemove() {
        return removeBlocks2(clientIds, updateSelection);
      },
      onInsertBefore() {
        const clientId = Array.isArray(clientIds) ? clientIds[0] : clientId;
        insertBeforeBlock2(clientId);
      },
      onInsertAfter() {
        const clientId = Array.isArray(clientIds) ? clientIds[clientIds.length - 1] : clientId;
        insertAfterBlock2(clientId);
      },
      onMoveTo() {
        setNavigationMode2(true);
        selectBlock2(clientIds[0]);
        setBlockMovingClientId2(clientIds[0]);
      },
      onGroup() {
        if (!blocks2.length) {
          return;
        }
        const groupingBlockName2 = getGroupingBlockName3();
        const newBlocks = switchToBlockType(blocks2, groupingBlockName2);
        if (!newBlocks) {
          return;
        }
        replaceBlocks2(clientIds, newBlocks);
      },
      onUngroup() {
        if (!blocks2.length) {
          return;
        }
        const innerBlocks = blocks2[0].innerBlocks;
        if (!innerBlocks.length) {
          return;
        }
        replaceBlocks2(clientIds, innerBlocks);
      },
      onCopy() {
        const selectedBlockClientIds = blocks2.map((_ref22) => {
          let {
            clientId
          } = _ref22;
          return clientId;
        });
        if (blocks2.length === 1) {
          flashBlock2(selectedBlockClientIds[0]);
        }
        notifyCopy("copy", selectedBlockClientIds);
      }
    });
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-mode-toggle.js
  var noop11 = () => {
  };
  function BlockModeToggle(_ref8) {
    let {
      blockType,
      mode,
      onToggleMode,
      small = false,
      isCodeEditingEnabled = true
    } = _ref8;
    if (!blockType || !hasBlockSupport(blockType, "html", true) || !isCodeEditingEnabled) {
      return null;
    }
    const label = mode === "visual" ? __("Edit as HTML") : __("Edit visually");
    return (0, import_react.createElement)(menu_item_default, {
      onClick: onToggleMode
    }, !small && label);
  }
  var block_mode_toggle_default = compose_default([with_select_default((select2, _ref22) => {
    let {
      clientId
    } = _ref22;
    const {
      getBlock: getBlock2,
      getBlockMode: getBlockMode2,
      getSettings: getSettings2
    } = select2(store3);
    const block4 = getBlock2(clientId);
    const isCodeEditingEnabled = getSettings2().codeEditingEnabled;
    return {
      mode: getBlockMode2(clientId),
      blockType: block4 ? getBlockType(block4.name) : null,
      isCodeEditingEnabled
    };
  }), with_dispatch_default((dispatch2, _ref32) => {
    let {
      onToggle = noop11,
      clientId
    } = _ref32;
    return {
      onToggleMode() {
        dispatch2(store3).toggleBlockMode(clientId);
        onToggle();
      }
    };
  })])(BlockModeToggle);

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-convert-button.js
  function BlockConvertButton(_ref8) {
    let {
      shouldRender,
      onClick,
      small
    } = _ref8;
    if (!shouldRender) {
      return null;
    }
    const label = __("Convert to Blocks");
    return (0, import_react.createElement)(menu_item_default, {
      onClick
    }, !small && label);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-html-convert-button.js
  var block_html_convert_button_default = compose_default(with_select_default((select2, _ref8) => {
    let {
      clientId
    } = _ref8;
    const block4 = select2(store3).getBlock(clientId);
    return {
      block: block4,
      shouldRender: block4 && block4.name === "core/html"
    };
  }), with_dispatch_default((dispatch2, _ref22) => {
    let {
      block: block4
    } = _ref22;
    return {
      onClick: () => dispatch2(store3).replaceBlocks(block4.clientId, rawHandler({
        HTML: getBlockInnerHTML(block4)
      }))
    };
  }))(BlockConvertButton);

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-menu-first-item.js
  var {
    Fill: __unstableBlockSettingsMenuFirstItem,
    Slot: Slot4
  } = createSlotFill("__unstableBlockSettingsMenuFirstItem");
  __unstableBlockSettingsMenuFirstItem.Slot = Slot4;
  var block_settings_menu_first_item_default = __unstableBlockSettingsMenuFirstItem;

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js
  var import_lodash28 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/use-convert-to-group-button-props.js
  function useConvertToGroupButtonProps() {
    const {
      clientIds,
      isGroupable,
      isUngroupable,
      blocksSelection,
      groupingBlockName: groupingBlockName2
    } = useSelect((select2) => {
      var _blocksSelection$;
      const {
        getBlockRootClientId: getBlockRootClientId2,
        getBlocksByClientId: getBlocksByClientId2,
        canInsertBlockType: canInsertBlockType2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2
      } = select2(store3);
      const {
        getGroupingBlockName: getGroupingBlockName3
      } = select2(store);
      const _clientIds = getSelectedBlockClientIds2();
      const _groupingBlockName = getGroupingBlockName3();
      const rootClientId = !!(_clientIds !== null && _clientIds !== void 0 && _clientIds.length) ? getBlockRootClientId2(_clientIds[0]) : void 0;
      const groupingBlockAvailable = canInsertBlockType2(_groupingBlockName, rootClientId);
      const _blocksSelection = getBlocksByClientId2(_clientIds);
      const isSingleGroupingBlock = _blocksSelection.length === 1 && ((_blocksSelection$ = _blocksSelection[0]) === null || _blocksSelection$ === void 0 ? void 0 : _blocksSelection$.name) === _groupingBlockName;
      const _isGroupable = groupingBlockAvailable && _blocksSelection.length;
      const _isUngroupable = isSingleGroupingBlock && !!_blocksSelection[0].innerBlocks.length;
      return {
        clientIds: _clientIds,
        isGroupable: _isGroupable,
        isUngroupable: _isUngroupable,
        blocksSelection: _blocksSelection,
        groupingBlockName: _groupingBlockName
      };
    }, []);
    return {
      clientIds,
      isGroupable,
      isUngroupable,
      blocksSelection,
      groupingBlockName: groupingBlockName2
    };
  }

  // node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/toolbar.js
  var layouts = {
    group: {
      type: "constrained"
    },
    row: {
      type: "flex",
      flexWrap: "nowrap"
    },
    stack: {
      type: "flex",
      orientation: "vertical"
    }
  };
  function BlockGroupToolbar() {
    const {
      blocksSelection,
      clientIds,
      groupingBlockName: groupingBlockName2,
      isGroupable
    } = useConvertToGroupButtonProps();
    const {
      replaceBlocks: replaceBlocks2
    } = use_dispatch_default(store3);
    const {
      canRemove,
      variations
    } = useSelect((select2) => {
      const {
        canRemoveBlocks: canRemoveBlocks2
      } = select2(store3);
      const {
        getBlockVariations: getBlockVariations3
      } = select2(store);
      return {
        canRemove: canRemoveBlocks2(clientIds),
        variations: getBlockVariations3(groupingBlockName2, "transform")
      };
    }, [clientIds, groupingBlockName2]);
    const onConvertToGroup = (layout) => {
      const newBlocks = switchToBlockType(blocksSelection, groupingBlockName2);
      if (typeof layout !== "string") {
        layout = "group";
      }
      if (newBlocks && newBlocks.length > 0) {
        newBlocks[0].attributes.layout = layouts[layout];
        replaceBlocks2(clientIds, newBlocks);
      }
    };
    const onConvertToRow = () => onConvertToGroup("row");
    const onConvertToStack = () => onConvertToGroup("stack");
    if (!isGroupable || !canRemove) {
      return null;
    }
    const canInsertRow = !!variations.find((_ref8) => {
      let {
        name
      } = _ref8;
      return name === "group-row";
    });
    const canInsertStack = !!variations.find((_ref22) => {
      let {
        name
      } = _ref22;
      return name === "group-stack";
    });
    return (0, import_react.createElement)(toolbar_group_default, null, (0, import_react.createElement)(toolbar_button_default, {
      icon: group_default,
      label: _x("Group", "verb"),
      onClick: onConvertToGroup
    }), canInsertRow && (0, import_react.createElement)(toolbar_button_default, {
      icon: row_default,
      label: _x("Row", "single horizontal line"),
      onClick: onConvertToRow
    }), canInsertStack && (0, import_react.createElement)(toolbar_button_default, {
      icon: stack_default,
      label: _x("Stack", "verb"),
      onClick: onConvertToStack
    }));
  }
  var toolbar_default2 = BlockGroupToolbar;

  // node_modules/@wordpress/block-editor/build-module/components/convert-to-group-buttons/index.js
  function ConvertToGroupButton(_ref8) {
    let {
      clientIds,
      isGroupable,
      isUngroupable,
      blocksSelection,
      groupingBlockName: groupingBlockName2,
      onClose = () => {
      }
    } = _ref8;
    const {
      replaceBlocks: replaceBlocks2
    } = use_dispatch_default(store3);
    const onConvertToGroup = () => {
      const newBlocks = switchToBlockType(blocksSelection, groupingBlockName2);
      if (newBlocks) {
        replaceBlocks2(clientIds, newBlocks);
      }
    };
    const onConvertFromGroup = () => {
      const innerBlocks = blocksSelection[0].innerBlocks;
      if (!innerBlocks.length) {
        return;
      }
      replaceBlocks2(clientIds, innerBlocks);
    };
    if (!isGroupable && !isUngroupable) {
      return null;
    }
    return (0, import_react.createElement)(import_react.Fragment, null, isGroupable && (0, import_react.createElement)(menu_item_default, {
      onClick: () => {
        onConvertToGroup();
        onClose();
      }
    }, _x("Group", "verb")), isUngroupable && (0, import_react.createElement)(menu_item_default, {
      onClick: () => {
        onConvertFromGroup();
        onClose();
      }
    }, _x("Ungroup", "Ungrouping blocks from within a Group block back into individual blocks within the Editor ")));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu-controls/index.js
  var {
    Fill: Fill4,
    Slot: Slot5
  } = createSlotFill("BlockSettingsMenuControls");
  var BlockSettingsMenuControlsSlot = (_ref8) => {
    let {
      fillProps,
      clientIds = null,
      __unstableDisplayLocation
    } = _ref8;
    const {
      selectedBlocks,
      selectedClientIds,
      canRemove
    } = useSelect((select2) => {
      const {
        getBlocksByClientId: getBlocksByClientId2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        canRemoveBlocks: canRemoveBlocks2
      } = select2(store3);
      const ids = clientIds !== null ? clientIds : getSelectedBlockClientIds2();
      return {
        selectedBlocks: (0, import_lodash28.map)(getBlocksByClientId2(ids).filter(Boolean), (block4) => block4.name),
        selectedClientIds: ids,
        canRemove: canRemoveBlocks2(ids)
      };
    }, [clientIds]);
    const {
      canLock
    } = useBlockLock(selectedClientIds[0]);
    const showLockButton = selectedClientIds.length === 1 && canLock;
    const convertToGroupButtonProps = useConvertToGroupButtonProps();
    const {
      isGroupable,
      isUngroupable
    } = convertToGroupButtonProps;
    const showConvertToGroupButton = (isGroupable || isUngroupable) && canRemove;
    return (0, import_react.createElement)(Slot5, {
      fillProps: {
        ...fillProps,
        __unstableDisplayLocation,
        selectedBlocks,
        selectedClientIds
      }
    }, (fills) => {
      if (!(fills !== null && fills !== void 0 && fills.length) > 0 && !showConvertToGroupButton && !showLockButton) {
        return null;
      }
      return (0, import_react.createElement)(menu_group_default, null, showLockButton && (0, import_react.createElement)(BlockLockMenuItem, {
        clientId: selectedClientIds[0]
      }), fills, showConvertToGroupButton && (0, import_react.createElement)(ConvertToGroupButton, _extends({}, convertToGroupButtonProps, {
        onClose: fillProps === null || fillProps === void 0 ? void 0 : fillProps.onClose
      })));
    });
  };
  function BlockSettingsMenuControls(_ref22) {
    let {
      ...props
    } = _ref22;
    return (0, import_react.createElement)(style_provider_default, {
      document
    }, (0, import_react.createElement)(Fill4, props));
  }
  BlockSettingsMenuControls.Slot = BlockSettingsMenuControlsSlot;
  var block_settings_menu_controls_default = BlockSettingsMenuControls;

  // node_modules/@wordpress/block-editor/build-module/components/block-toolbar/utils.js
  var {
    clearTimeout: clearTimeout2,
    setTimeout: setTimeout2
  } = window;
  var noop12 = () => {
  };
  var DEBOUNCE_TIMEOUT = 200;
  function useDebouncedShowMovers(_ref8) {
    let {
      ref: ref2,
      isFocused,
      debounceTimeout = DEBOUNCE_TIMEOUT,
      onChange = noop12
    } = _ref8;
    const [showMovers, setShowMovers] = (0, import_react.useState)(false);
    const timeoutRef = (0, import_react.useRef)();
    const handleOnChange = (nextIsFocused) => {
      if (ref2 !== null && ref2 !== void 0 && ref2.current) {
        setShowMovers(nextIsFocused);
      }
      onChange(nextIsFocused);
    };
    const getIsHovered = () => {
      return (ref2 === null || ref2 === void 0 ? void 0 : ref2.current) && ref2.current.matches(":hover");
    };
    const shouldHideMovers = () => {
      const isHovered = getIsHovered();
      return !isFocused && !isHovered;
    };
    const clearTimeoutRef = () => {
      const timeout = timeoutRef.current;
      if (timeout && clearTimeout2) {
        clearTimeout2(timeout);
      }
    };
    const debouncedShowMovers = (event) => {
      if (event) {
        event.stopPropagation();
      }
      clearTimeoutRef();
      if (!showMovers) {
        handleOnChange(true);
      }
    };
    const debouncedHideMovers = (event) => {
      if (event) {
        event.stopPropagation();
      }
      clearTimeoutRef();
      timeoutRef.current = setTimeout2(() => {
        if (shouldHideMovers()) {
          handleOnChange(false);
        }
      }, debounceTimeout);
    };
    (0, import_react.useEffect)(() => () => {
      handleOnChange(false);
      clearTimeoutRef();
    }, []);
    return {
      showMovers,
      debouncedShowMovers,
      debouncedHideMovers
    };
  }
  function useShowMoversGestures(_ref22) {
    let {
      ref: ref2,
      debounceTimeout = DEBOUNCE_TIMEOUT,
      onChange = noop12
    } = _ref22;
    const [isFocused, setIsFocused] = (0, import_react.useState)(false);
    const {
      showMovers,
      debouncedShowMovers,
      debouncedHideMovers
    } = useDebouncedShowMovers({
      ref: ref2,
      debounceTimeout,
      isFocused,
      onChange
    });
    const registerRef = (0, import_react.useRef)(false);
    const isFocusedWithin = () => {
      return (ref2 === null || ref2 === void 0 ? void 0 : ref2.current) && ref2.current.contains(ref2.current.ownerDocument.activeElement);
    };
    (0, import_react.useEffect)(() => {
      const node = ref2.current;
      const handleOnFocus = () => {
        if (isFocusedWithin()) {
          setIsFocused(true);
          debouncedShowMovers();
        }
      };
      const handleOnBlur = () => {
        if (!isFocusedWithin()) {
          setIsFocused(false);
          debouncedHideMovers();
        }
      };
      if (node && !registerRef.current) {
        node.addEventListener("focus", handleOnFocus, true);
        node.addEventListener("blur", handleOnBlur, true);
        registerRef.current = true;
      }
      return () => {
        if (node) {
          node.removeEventListener("focus", handleOnFocus);
          node.removeEventListener("blur", handleOnBlur);
        }
      };
    }, [ref2, registerRef, setIsFocused, debouncedShowMovers, debouncedHideMovers]);
    return {
      showMovers,
      gestures: {
        onMouseMove: debouncedShowMovers,
        onMouseLeave: debouncedHideMovers
      }
    };
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/block-settings-dropdown.js
  var noop13 = () => {
  };
  var POPOVER_PROPS = {
    className: "block-editor-block-settings-menu__popover",
    position: "bottom right",
    variant: "toolbar"
  };
  function CopyMenuItem(_ref8) {
    let {
      blocks: blocks2,
      onCopy
    } = _ref8;
    const ref2 = useCopyToClipboard(() => serialize(blocks2), onCopy);
    const copyMenuItemLabel = blocks2.length > 1 ? __("Copy blocks") : __("Copy block");
    return (0, import_react.createElement)(menu_item_default, {
      ref: ref2
    }, copyMenuItemLabel);
  }
  function BlockSettingsDropdown(_ref22) {
    let {
      clientIds,
      __experimentalSelectBlock,
      children,
      __unstableDisplayLocation,
      ...props
    } = _ref22;
    const blockClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
    const count = blockClientIds.length;
    const firstBlockClientId = blockClientIds[0];
    const {
      firstParentClientId,
      isDistractionFree,
      onlyBlock,
      parentBlockType,
      previousBlockClientId,
      nextBlockClientId,
      selectedBlockClientIds
    } = useSelect((select2) => {
      const {
        getBlockCount: getBlockCount2,
        getBlockName: getBlockName2,
        getBlockRootClientId: getBlockRootClientId2,
        getPreviousBlockClientId: getPreviousBlockClientId2,
        getNextBlockClientId: getNextBlockClientId2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        getSettings: getSettings2,
        getBlockAttributes: getBlockAttributes3
      } = select2(store3);
      const {
        getActiveBlockVariation: getActiveBlockVariation2
      } = select2(store);
      const _firstParentClientId = getBlockRootClientId2(firstBlockClientId);
      const parentBlockName = _firstParentClientId && getBlockName2(_firstParentClientId);
      return {
        firstParentClientId: _firstParentClientId,
        isDistractionFree: getSettings2().isDistractionFree,
        onlyBlock: 1 === getBlockCount2(_firstParentClientId),
        parentBlockType: _firstParentClientId && (getActiveBlockVariation2(parentBlockName, getBlockAttributes3(_firstParentClientId)) || getBlockType(parentBlockName)),
        previousBlockClientId: getPreviousBlockClientId2(firstBlockClientId),
        nextBlockClientId: getNextBlockClientId2(firstBlockClientId),
        selectedBlockClientIds: getSelectedBlockClientIds2()
      };
    }, [firstBlockClientId]);
    const shortcuts = useSelect((select2) => {
      const {
        getShortcutRepresentation: getShortcutRepresentation2
      } = select2(store4);
      return {
        duplicate: getShortcutRepresentation2("core/block-editor/duplicate"),
        remove: getShortcutRepresentation2("core/block-editor/remove"),
        insertAfter: getShortcutRepresentation2("core/block-editor/insert-after"),
        insertBefore: getShortcutRepresentation2("core/block-editor/insert-before")
      };
    }, []);
    const {
      selectBlock: selectBlock2,
      toggleBlockHighlight: toggleBlockHighlight2
    } = use_dispatch_default(store3);
    const updateSelectionAfterDuplicate = (0, import_react.useCallback)(__experimentalSelectBlock ? async (clientIdsPromise) => {
      const ids = await clientIdsPromise;
      if (ids && ids[0]) {
        __experimentalSelectBlock(ids[0]);
      }
    } : noop13, [__experimentalSelectBlock]);
    const blockTitle = useBlockDisplayTitle({
      clientId: firstBlockClientId,
      maximumLength: 25
    });
    const updateSelectionAfterRemove = (0, import_react.useCallback)(__experimentalSelectBlock ? () => {
      const blockToSelect = previousBlockClientId || nextBlockClientId;
      if (blockToSelect && selectedBlockClientIds.includes(firstBlockClientId) && !selectedBlockClientIds.includes(blockToSelect)) {
        __experimentalSelectBlock(blockToSelect);
      }
    } : noop13, [__experimentalSelectBlock, previousBlockClientId, nextBlockClientId, selectedBlockClientIds]);
    const label = sprintf(
      __("Remove %s"),
      blockTitle
    );
    const removeBlockLabel = count === 1 ? label : __("Remove blocks");
    const selectParentButtonRef = (0, import_react.useRef)();
    const {
      gestures: showParentOutlineGestures
    } = useShowMoversGestures({
      ref: selectParentButtonRef,
      onChange(isFocused) {
        if (isFocused && isDistractionFree) {
          return;
        }
        toggleBlockHighlight2(firstParentClientId, isFocused);
      }
    });
    return (0, import_react.createElement)(BlockActions, {
      clientIds,
      __experimentalUpdateSelection: !__experimentalSelectBlock
    }, (_ref32) => {
      let {
        canDuplicate,
        canInsertDefaultBlock,
        canMove,
        canRemove,
        onDuplicate,
        onInsertAfter,
        onInsertBefore,
        onRemove,
        onCopy,
        onMoveTo,
        blocks: blocks2
      } = _ref32;
      return (0, import_react.createElement)(dropdown_menu_default, _extends({
        icon: more_vertical_default,
        label: __("Options"),
        className: "block-editor-block-settings-menu",
        popoverProps: POPOVER_PROPS,
        noIcons: true
      }, props), (_ref42) => {
        let {
          onClose
        } = _ref42;
        return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(menu_group_default, null, (0, import_react.createElement)(block_settings_menu_first_item_default.Slot, {
          fillProps: {
            onClose
          }
        }), !!firstParentClientId && (0, import_react.createElement)(menu_item_default, _extends({}, showParentOutlineGestures, {
          ref: selectParentButtonRef,
          icon: (0, import_react.createElement)(block_icon_default, {
            icon: parentBlockType.icon
          }),
          onClick: () => selectBlock2(firstParentClientId)
        }), sprintf(
          __("Select parent block (%s)"),
          parentBlockType.title
        )), count === 1 && (0, import_react.createElement)(block_html_convert_button_default, {
          clientId: firstBlockClientId
        }), (0, import_react.createElement)(CopyMenuItem, {
          blocks: blocks2,
          onCopy
        }), canDuplicate && (0, import_react.createElement)(menu_item_default, {
          onClick: pipe_default(onClose, onDuplicate, updateSelectionAfterDuplicate),
          shortcut: shortcuts.duplicate
        }, __("Duplicate")), canInsertDefaultBlock && (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(menu_item_default, {
          onClick: pipe_default(onClose, onInsertBefore),
          shortcut: shortcuts.insertBefore
        }, __("Insert before")), (0, import_react.createElement)(menu_item_default, {
          onClick: pipe_default(onClose, onInsertAfter),
          shortcut: shortcuts.insertAfter
        }, __("Insert after"))), canMove && !onlyBlock && (0, import_react.createElement)(menu_item_default, {
          onClick: pipe_default(onClose, onMoveTo)
        }, __("Move to")), count === 1 && (0, import_react.createElement)(block_mode_toggle_default, {
          clientId: firstBlockClientId,
          onToggle: onClose
        })), (0, import_react.createElement)(block_settings_menu_controls_default.Slot, {
          fillProps: {
            onClose
          },
          clientIds,
          __unstableDisplayLocation
        }), typeof children === "function" ? children({
          onClose
        }) : import_react.Children.map((child) => (0, import_react.cloneElement)(child, {
          onClose
        })), canRemove && (0, import_react.createElement)(menu_group_default, null, (0, import_react.createElement)(menu_item_default, {
          onClick: pipe_default(onClose, onRemove, updateSelectionAfterRemove),
          shortcut: shortcuts.remove
        }, removeBlockLabel)));
      });
    });
  }
  var block_settings_dropdown_default = BlockSettingsDropdown;

  // node_modules/@wordpress/block-editor/build-module/utils/math.js
  function getDistanceFromPointToEdge(point, rect, edge) {
    const isHorizontal = edge === "top" || edge === "bottom";
    const {
      x: x4,
      y: y5
    } = point;
    const pointLateralPosition = isHorizontal ? x4 : y5;
    const pointForwardPosition = isHorizontal ? y5 : x4;
    const edgeStart = isHorizontal ? rect.left : rect.top;
    const edgeEnd = isHorizontal ? rect.right : rect.bottom;
    const edgeForwardPosition = rect[edge];
    let edgeLateralPosition;
    if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
      edgeLateralPosition = pointLateralPosition;
    } else if (pointLateralPosition < edgeEnd) {
      edgeLateralPosition = edgeStart;
    } else {
      edgeLateralPosition = edgeEnd;
    }
    return Math.sqrt((pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2);
  }
  function getDistanceToNearestEdge(point, rect) {
    let allowedEdges = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ["top", "bottom", "left", "right"];
    let candidateDistance;
    let candidateEdge;
    allowedEdges.forEach((edge) => {
      const distance2 = getDistanceFromPointToEdge(point, rect, edge);
      if (candidateDistance === void 0 || distance2 < candidateDistance) {
        candidateDistance = distance2;
        candidateEdge = edge;
      }
    });
    return [candidateDistance, candidateEdge];
  }
  function isPointContainedByRect(point, rect) {
    return rect.left <= point.x && rect.right >= point.x && rect.top <= point.y && rect.bottom >= point.y;
  }

  // node_modules/@wordpress/block-editor/build-module/components/use-on-block-drop/index.js
  function parseDropEvent(event) {
    let result = {
      srcRootClientId: null,
      srcClientIds: null,
      srcIndex: null,
      type: null,
      blocks: null
    };
    if (!event.dataTransfer) {
      return result;
    }
    try {
      result = Object.assign(result, JSON.parse(event.dataTransfer.getData("wp-blocks")));
    } catch (err) {
      return result;
    }
    return result;
  }
  function onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex2, getClientIdsOfDescendants2, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock2) {
    return (event) => {
      const {
        srcRootClientId: sourceRootClientId,
        srcClientIds: sourceClientIds,
        type: dropType,
        blocks: blocks2
      } = parseDropEvent(event);
      if (dropType === "inserter") {
        clearSelectedBlock2();
        const blocksToInsert = blocks2.map((block4) => cloneBlock(block4));
        insertOrReplaceBlocks(blocksToInsert, true, null);
      }
      if (dropType === "block") {
        const sourceBlockIndex = getBlockIndex2(sourceClientIds[0]);
        if (sourceRootClientId === targetRootClientId && sourceBlockIndex === targetBlockIndex) {
          return;
        }
        if (sourceClientIds.includes(targetRootClientId) || getClientIdsOfDescendants2(sourceClientIds).some((id2) => id2 === targetRootClientId)) {
          return;
        }
        const isAtSameLevel = sourceRootClientId === targetRootClientId;
        const draggedBlockCount = sourceClientIds.length;
        const insertIndex = isAtSameLevel && sourceBlockIndex < targetBlockIndex ? targetBlockIndex - draggedBlockCount : targetBlockIndex;
        moveBlocks(sourceClientIds, sourceRootClientId, insertIndex);
      }
    };
  }
  function onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes2, canInsertBlockType2, insertOrReplaceBlocks) {
    return (files) => {
      if (!hasUploadPermissions) {
        return;
      }
      const transformation = findTransform(getBlockTransforms("from"), (transform) => transform.type === "files" && canInsertBlockType2(transform.blockName, targetRootClientId) && transform.isMatch(files));
      if (transformation) {
        const blocks2 = transformation.transform(files, updateBlockAttributes2);
        insertOrReplaceBlocks(blocks2);
      }
    };
  }
  function onHTMLDrop(targetRootClientId, targetBlockIndex, insertOrReplaceBlocks) {
    return (HTML) => {
      const blocks2 = pasteHandler({
        HTML,
        mode: "BLOCKS"
      });
      if (blocks2.length) {
        insertOrReplaceBlocks(blocks2);
      }
    };
  }
  function useOnBlockDrop(targetRootClientId, targetBlockIndex) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      operation = "insert"
    } = options;
    const hasUploadPermissions = useSelect((select2) => select2(store3).getSettings().mediaUpload, []);
    const {
      canInsertBlockType: canInsertBlockType2,
      getBlockIndex: getBlockIndex2,
      getClientIdsOfDescendants: getClientIdsOfDescendants2,
      getBlockOrder: getBlockOrder2,
      getBlocksByClientId: getBlocksByClientId2
    } = useSelect(store3);
    const {
      insertBlocks: insertBlocks2,
      moveBlocksToPosition: moveBlocksToPosition2,
      updateBlockAttributes: updateBlockAttributes2,
      clearSelectedBlock: clearSelectedBlock2,
      replaceBlocks: replaceBlocks2,
      removeBlocks: removeBlocks2
    } = use_dispatch_default(store3);
    const registry = useRegistry();
    const insertOrReplaceBlocks = (0, import_react.useCallback)(function(blocks2) {
      let updateSelection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      let initialPosition2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (operation === "replace") {
        const clientIds = getBlockOrder2(targetRootClientId);
        const clientId = clientIds[targetBlockIndex];
        replaceBlocks2(clientId, blocks2, void 0, initialPosition2);
      } else {
        insertBlocks2(blocks2, targetBlockIndex, targetRootClientId, updateSelection, initialPosition2);
      }
    }, [operation, getBlockOrder2, insertBlocks2, replaceBlocks2, targetBlockIndex, targetRootClientId]);
    const moveBlocks = (0, import_react.useCallback)((sourceClientIds, sourceRootClientId, insertIndex) => {
      if (operation === "replace") {
        const sourceBlocks = getBlocksByClientId2(sourceClientIds);
        const targetBlockClientIds = getBlockOrder2(targetRootClientId);
        const targetBlockClientId = targetBlockClientIds[targetBlockIndex];
        registry.batch(() => {
          removeBlocks2(sourceClientIds, false);
          replaceBlocks2(targetBlockClientId, sourceBlocks, void 0, 0);
        });
      } else {
        moveBlocksToPosition2(sourceClientIds, sourceRootClientId, targetRootClientId, insertIndex);
      }
    }, [operation, getBlockOrder2, getBlocksByClientId2, insertBlocks2, moveBlocksToPosition2, removeBlocks2, targetBlockIndex, targetRootClientId]);
    const _onDrop = onBlockDrop(targetRootClientId, targetBlockIndex, getBlockIndex2, getClientIdsOfDescendants2, moveBlocks, insertOrReplaceBlocks, clearSelectedBlock2);
    const _onFilesDrop = onFilesDrop(targetRootClientId, targetBlockIndex, hasUploadPermissions, updateBlockAttributes2, canInsertBlockType2, insertOrReplaceBlocks);
    const _onHTMLDrop = onHTMLDrop(targetRootClientId, targetBlockIndex, insertOrReplaceBlocks);
    return (event) => {
      const files = getFilesFromDataTransfer(event.dataTransfer);
      const html2 = event.dataTransfer.getData("text/html");
      if (html2) {
        _onHTMLDrop(html2);
      } else if (files.length) {
        _onFilesDrop(files);
      } else {
        _onDrop(event);
      }
    };
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-card/index.js
  function BlockCard(_ref8) {
    let {
      title,
      icon,
      description,
      blockType
    } = _ref8;
    if (blockType) {
      deprecated("`blockType` property in `BlockCard component`", {
        since: "5.7",
        alternative: "`title, icon and description` properties"
      });
      ({
        title,
        icon,
        description
      } = blockType);
    }
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-card"
    }, (0, import_react.createElement)(block_icon_default, {
      icon,
      showColors: true
    }), (0, import_react.createElement)("div", {
      className: "block-editor-block-card__content"
    }, (0, import_react.createElement)("h2", {
      className: "block-editor-block-card__title"
    }, title), (0, import_react.createElement)("span", {
      className: "block-editor-block-card__description"
    }, description)));
  }
  var block_card_default = BlockCard;

  // node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js
  var import_classnames50 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/provider/with-registry-provider.js
  var withRegistryProvider = createHigherOrderComponent((WrappedComponent) => {
    return with_registry_default((_ref8) => {
      let {
        useSubRegistry = true,
        registry,
        ...props
      } = _ref8;
      if (!useSubRegistry) {
        return (0, import_react.createElement)(WrappedComponent, _extends({
          registry
        }, props));
      }
      const [subRegistry, setSubRegistry] = (0, import_react.useState)(null);
      (0, import_react.useEffect)(() => {
        const newRegistry = createRegistry({}, registry);
        newRegistry.registerStore(STORE_NAME3, storeConfig);
        setSubRegistry(newRegistry);
      }, [registry]);
      if (!subRegistry) {
        return null;
      }
      return (0, import_react.createElement)(context_default, {
        value: subRegistry
      }, (0, import_react.createElement)(WrappedComponent, _extends({
        registry: subRegistry
      }, props)));
    });
  }, "withRegistryProvider");
  var with_registry_provider_default = withRegistryProvider;

  // node_modules/@wordpress/block-editor/build-module/components/provider/use-block-sync.js
  var noop14 = () => {
  };
  function useBlockSync(_ref8) {
    let {
      clientId = null,
      value: controlledBlocks,
      selection: controlledSelection,
      onChange = noop14,
      onInput = noop14
    } = _ref8;
    const registry = useRegistry();
    const {
      resetBlocks: resetBlocks2,
      resetSelection: resetSelection2,
      replaceInnerBlocks: replaceInnerBlocks2,
      setHasControlledInnerBlocks: setHasControlledInnerBlocks2,
      __unstableMarkNextChangeAsNotPersistent: __unstableMarkNextChangeAsNotPersistent2
    } = registry.dispatch(store3);
    const {
      getBlockName: getBlockName2,
      getBlocks: getBlocks2
    } = registry.select(store3);
    const isControlled = useSelect((select2) => {
      return !clientId || select2(store3).areInnerBlocksControlled(clientId);
    }, [clientId]);
    const pendingChanges = (0, import_react.useRef)({
      incoming: null,
      outgoing: []
    });
    const subscribed = (0, import_react.useRef)(false);
    const setControlledBlocks = () => {
      if (!controlledBlocks) {
        return;
      }
      __unstableMarkNextChangeAsNotPersistent2();
      if (clientId) {
        registry.batch(() => {
          setHasControlledInnerBlocks2(clientId, true);
          const storeBlocks = controlledBlocks.map((block4) => cloneBlock(block4));
          if (subscribed.current) {
            pendingChanges.current.incoming = storeBlocks;
          }
          __unstableMarkNextChangeAsNotPersistent2();
          replaceInnerBlocks2(clientId, storeBlocks);
        });
      } else {
        if (subscribed.current) {
          pendingChanges.current.incoming = controlledBlocks;
        }
        resetBlocks2(controlledBlocks);
      }
    };
    const onInputRef = (0, import_react.useRef)(onInput);
    const onChangeRef = (0, import_react.useRef)(onChange);
    (0, import_react.useEffect)(() => {
      onInputRef.current = onInput;
      onChangeRef.current = onChange;
    }, [onInput, onChange]);
    (0, import_react.useEffect)(() => {
      if (pendingChanges.current.outgoing.includes(controlledBlocks)) {
        if (pendingChanges.current.outgoing[pendingChanges.current.outgoing.length - 1] === controlledBlocks) {
          pendingChanges.current.outgoing = [];
        }
      } else if (getBlocks2(clientId) !== controlledBlocks) {
        pendingChanges.current.outgoing = [];
        setControlledBlocks();
        if (controlledSelection) {
          resetSelection2(controlledSelection.selectionStart, controlledSelection.selectionEnd, controlledSelection.initialPosition);
        }
      }
    }, [controlledBlocks, clientId]);
    (0, import_react.useEffect)(() => {
      if (!isControlled) {
        pendingChanges.current.outgoing = [];
        setControlledBlocks();
      }
    }, [isControlled]);
    (0, import_react.useEffect)(() => {
      const {
        getSelectionStart: getSelectionStart2,
        getSelectionEnd: getSelectionEnd2,
        getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
        isLastBlockChangePersistent: isLastBlockChangePersistent2,
        __unstableIsLastBlockChangeIgnored: __unstableIsLastBlockChangeIgnored2,
        areInnerBlocksControlled: areInnerBlocksControlled2
      } = registry.select(store3);
      let blocks2 = getBlocks2(clientId);
      let isPersistent = isLastBlockChangePersistent2();
      let previousAreBlocksDifferent = false;
      subscribed.current = true;
      const unsubscribe = registry.subscribe(() => {
        if (clientId !== null && getBlockName2(clientId) === null)
          return;
        const isStillControlled = !clientId || areInnerBlocksControlled2(clientId);
        if (!isStillControlled) {
          return;
        }
        const newIsPersistent = isLastBlockChangePersistent2();
        const newBlocks = getBlocks2(clientId);
        const areBlocksDifferent = newBlocks !== blocks2;
        blocks2 = newBlocks;
        if (areBlocksDifferent && (pendingChanges.current.incoming || __unstableIsLastBlockChangeIgnored2())) {
          pendingChanges.current.incoming = null;
          isPersistent = newIsPersistent;
          return;
        }
        const didPersistenceChange = previousAreBlocksDifferent && !areBlocksDifferent && newIsPersistent && !isPersistent;
        if (areBlocksDifferent || didPersistenceChange) {
          isPersistent = newIsPersistent;
          pendingChanges.current.outgoing.push(blocks2);
          const updateParent = isPersistent ? onChangeRef.current : onInputRef.current;
          updateParent(blocks2, {
            selection: {
              selectionStart: getSelectionStart2(),
              selectionEnd: getSelectionEnd2(),
              initialPosition: getSelectedBlocksInitialCaretPosition2()
            }
          });
        }
        previousAreBlocksDifferent = areBlocksDifferent;
      });
      return () => unsubscribe();
    }, [registry, clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/provider/index.js
  function BlockEditorProvider(props) {
    const {
      children,
      settings: settings2
    } = props;
    const {
      updateSettings: updateSettings2
    } = use_dispatch_default(store3);
    (0, import_react.useEffect)(() => {
      updateSettings2(settings2);
    }, [settings2]);
    useBlockSync(props);
    return (0, import_react.createElement)(BlockRefsProvider, null, children);
  }
  var provider_default = with_registry_provider_default(BlockEditorProvider);

  // node_modules/@wordpress/block-editor/build-module/components/block-list/index.js
  var import_classnames47 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-list/block.js
  var import_classnames30 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/warning/index.js
  var import_classnames25 = __toESM(require_classnames());
  function Warning(_ref8) {
    let {
      className,
      actions: actions2,
      children,
      secondaryActions
    } = _ref8;
    return (0, import_react.createElement)("div", {
      style: {
        display: "contents",
        all: "initial"
      }
    }, (0, import_react.createElement)("div", {
      className: (0, import_classnames25.default)(className, "block-editor-warning")
    }, (0, import_react.createElement)("div", {
      className: "block-editor-warning__contents"
    }, (0, import_react.createElement)("p", {
      className: "block-editor-warning__message"
    }, children), (import_react.Children.count(actions2) > 0 || secondaryActions) && (0, import_react.createElement)("div", {
      className: "block-editor-warning__actions"
    }, import_react.Children.count(actions2) > 0 && import_react.Children.map(actions2, (action, i5) => (0, import_react.createElement)("span", {
      key: i5,
      className: "block-editor-warning__action"
    }, action)), secondaryActions && (0, import_react.createElement)(dropdown_menu_default, {
      className: "block-editor-warning__secondary",
      icon: more_horizontal_default,
      label: __("More options"),
      popoverProps: {
        position: "bottom left",
        className: "block-editor-warning__dropdown"
      },
      noIcons: true
    }, () => (0, import_react.createElement)(menu_group_default, null, secondaryActions.map((item2, pos) => (0, import_react.createElement)(menu_item_default, {
      onClick: item2.onClick,
      key: pos
    }, item2.title))))))));
  }
  var warning_default = Warning;

  // node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js
  var import_classnames26 = __toESM(require_classnames());
  var import_character = __toESM(require_character());

  // node_modules/@wordpress/block-editor/build-module/components/block-compare/block-view.js
  function BlockView(_ref8) {
    let {
      title,
      rawContent,
      renderedContent,
      action,
      actionText,
      className
    } = _ref8;
    return (0, import_react.createElement)("div", {
      className
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-compare__content"
    }, (0, import_react.createElement)("h2", {
      className: "block-editor-block-compare__heading"
    }, title), (0, import_react.createElement)("div", {
      className: "block-editor-block-compare__html"
    }, rawContent), (0, import_react.createElement)("div", {
      className: "block-editor-block-compare__preview edit-post-visual-editor"
    }, (0, import_react.createElement)(RawHTML, null, safeHTML(renderedContent)))), (0, import_react.createElement)("div", {
      className: "block-editor-block-compare__action"
    }, (0, import_react.createElement)(button_default, {
      variant: "secondary",
      tabIndex: "0",
      onClick: action
    }, actionText)));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-compare/index.js
  function BlockCompare(_ref8) {
    let {
      block: block4,
      onKeep,
      onConvert,
      convertor,
      convertButtonText
    } = _ref8;
    function getDifference(originalContent, newContent) {
      const difference2 = (0, import_character.diffChars)(originalContent, newContent);
      return difference2.map((item2, pos) => {
        const classes = (0, import_classnames26.default)({
          "block-editor-block-compare__added": item2.added,
          "block-editor-block-compare__removed": item2.removed
        });
        return (0, import_react.createElement)("span", {
          key: pos,
          className: classes
        }, item2.value);
      });
    }
    function getConvertedContent(convertedBlock) {
      const newBlocks = Array.isArray(convertedBlock) ? convertedBlock : [convertedBlock];
      const newContent = newBlocks.map((item2) => getSaveContent(item2.name, item2.attributes, item2.innerBlocks));
      return newContent.join("");
    }
    const converted = getConvertedContent(convertor(block4));
    const difference = getDifference(block4.originalContent, converted);
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-compare__wrapper"
    }, (0, import_react.createElement)(BlockView, {
      title: __("Current"),
      className: "block-editor-block-compare__current",
      action: onKeep,
      actionText: __("Convert to HTML"),
      rawContent: block4.originalContent,
      renderedContent: block4.originalContent
    }), (0, import_react.createElement)(BlockView, {
      title: __("After Conversion"),
      className: "block-editor-block-compare__converted",
      action: onConvert,
      actionText: convertButtonText,
      rawContent: difference,
      renderedContent: converted
    }));
  }
  var block_compare_default = BlockCompare;

  // node_modules/@wordpress/block-editor/build-module/components/block-list/block-invalid-warning.js
  function BlockInvalidWarning(_ref8) {
    let {
      convertToHTML,
      convertToBlocks,
      convertToClassic,
      attemptBlockRecovery,
      block: block4
    } = _ref8;
    const hasHTMLBlock = !!getBlockType("core/html");
    const [compare, setCompare] = (0, import_react.useState)(false);
    const onCompare = (0, import_react.useCallback)(() => setCompare(true), []);
    const onCompareClose = (0, import_react.useCallback)(() => setCompare(false), []);
    const hiddenActions = (0, import_react.useMemo)(() => [{
      title: _x("Resolve", "imperative verb"),
      onClick: onCompare
    }, hasHTMLBlock && {
      title: __("Convert to HTML"),
      onClick: convertToHTML
    }, {
      title: __("Convert to Classic Block"),
      onClick: convertToClassic
    }].filter(Boolean), [onCompare, convertToHTML, convertToClassic]);
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(warning_default, {
      actions: [(0, import_react.createElement)(button_default, {
        key: "recover",
        onClick: attemptBlockRecovery,
        variant: "primary"
      }, __("Attempt Block Recovery"))],
      secondaryActions: hiddenActions
    }, __("This block contains unexpected or invalid content.")), compare && (0, import_react.createElement)(modal_default, {
      title: __("Resolve Block"),
      onRequestClose: onCompareClose,
      className: "block-editor-block-compare"
    }, (0, import_react.createElement)(block_compare_default, {
      block: block4,
      onKeep: convertToHTML,
      onConvert: convertToBlocks,
      convertor: blockToBlocks,
      convertButtonText: __("Convert to Blocks")
    })));
  }
  var blockToClassic = (block4) => createBlock("core/freeform", {
    content: block4.originalContent
  });
  var blockToHTML = (block4) => createBlock("core/html", {
    content: block4.originalContent
  });
  var blockToBlocks = (block4) => rawHandler({
    HTML: block4.originalContent
  });
  var recoverBlock = (_ref22) => {
    let {
      name,
      attributes,
      innerBlocks
    } = _ref22;
    return createBlock(name, attributes, innerBlocks);
  };
  var block_invalid_warning_default = compose_default([with_select_default((select2, _ref32) => {
    let {
      clientId
    } = _ref32;
    return {
      block: select2(store3).getBlock(clientId)
    };
  }), with_dispatch_default((dispatch2, _ref42) => {
    let {
      block: block4
    } = _ref42;
    const {
      replaceBlock: replaceBlock2
    } = dispatch2(store3);
    return {
      convertToClassic() {
        replaceBlock2(block4.clientId, blockToClassic(block4));
      },
      convertToHTML() {
        replaceBlock2(block4.clientId, blockToHTML(block4));
      },
      convertToBlocks() {
        replaceBlock2(block4.clientId, blockToBlocks(block4));
      },
      attemptBlockRecovery() {
        replaceBlock2(block4.clientId, recoverBlock(block4));
      }
    };
  })])(BlockInvalidWarning);

  // node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-warning.js
  var warning5 = (0, import_react.createElement)(warning_default, {
    className: "block-editor-block-list__block-crash-warning"
  }, __("This block has encountered an error and cannot be previewed."));
  var block_crash_warning_default = () => warning5;

  // node_modules/@wordpress/block-editor/build-module/components/block-list/block-crash-boundary.js
  var BlockCrashBoundary = class extends import_react.Component {
    constructor() {
      super(...arguments);
      this.state = {
        hasError: false
      };
    }
    componentDidCatch() {
      this.setState({
        hasError: true
      });
    }
    render() {
      if (this.state.hasError) {
        return this.props.fallback;
      }
      return this.props.children;
    }
  };
  var block_crash_boundary_default = BlockCrashBoundary;

  // node_modules/@wordpress/block-editor/build-module/components/block-list/block-html.js
  var import_react_autosize_textarea = __toESM(require_lib());
  function BlockHTML(_ref8) {
    let {
      clientId
    } = _ref8;
    const [html2, setHtml] = (0, import_react.useState)("");
    const block4 = useSelect((select2) => select2(store3).getBlock(clientId), [clientId]);
    const {
      updateBlock: updateBlock2
    } = use_dispatch_default(store3);
    const onChange = () => {
      const blockType = getBlockType(block4.name);
      if (!blockType) {
        return;
      }
      const attributes = getBlockAttributes(blockType, html2, block4.attributes);
      const content = html2 ? html2 : getSaveContent(blockType, attributes);
      const [isValid] = html2 ? validateBlock({
        ...block4,
        attributes,
        originalContent: content
      }) : [true];
      updateBlock2(clientId, {
        attributes,
        originalContent: content,
        isValid
      });
      if (!html2) {
        setHtml({
          content
        });
      }
    };
    (0, import_react.useEffect)(() => {
      setHtml(getBlockInnerHTML(block4));
    }, [block4]);
    return (0, import_react.createElement)(import_react_autosize_textarea.default, {
      className: "block-editor-block-list__block-html-textarea",
      value: html2,
      onBlur: onChange,
      onChange: (event) => setHtml(event.target.value)
    });
  }
  var block_html_default = BlockHTML;

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js
  var import_classnames29 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/utils/dom.js
  var BLOCK_SELECTOR = ".block-editor-block-list__block";
  var APPENDER_SELECTOR = ".block-list-appender";
  var BLOCK_APPENDER_CLASS = ".block-editor-button-block-appender";
  function isInSameBlock(a6, b6) {
    return a6.closest(BLOCK_SELECTOR) === b6.closest(BLOCK_SELECTOR);
  }
  function isInsideRootBlock(blockElement, element) {
    const parentBlock = element.closest([BLOCK_SELECTOR, APPENDER_SELECTOR, BLOCK_APPENDER_CLASS].join(","));
    return parentBlock === blockElement;
  }
  function getBlockClientId(node) {
    while (node && node.nodeType !== node.ELEMENT_NODE) {
      node = node.parentNode;
    }
    if (!node) {
      return;
    }
    const elementNode = node;
    const blockNode = elementNode.closest(BLOCK_SELECTOR);
    if (!blockNode) {
      return;
    }
    return blockNode.id.slice("block-".length);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-first-element.js
  function useInitialPosition(clientId) {
    return useSelect((select2) => {
      const {
        getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
        __unstableGetEditorMode: __unstableGetEditorMode2,
        isBlockSelected: isBlockSelected2
      } = select2(store3);
      if (!isBlockSelected2(clientId)) {
        return;
      }
      if (__unstableGetEditorMode2() !== "edit") {
        return;
      }
      return getSelectedBlocksInitialCaretPosition2();
    }, [clientId]);
  }
  function useFocusFirstElement(clientId) {
    const ref2 = (0, import_react.useRef)();
    const initialPosition2 = useInitialPosition(clientId);
    const {
      isBlockSelected: isBlockSelected2,
      isMultiSelecting: isMultiSelecting3
    } = useSelect(store3);
    (0, import_react.useEffect)(() => {
      if (!isBlockSelected2(clientId) || isMultiSelecting3()) {
        return;
      }
      if (initialPosition2 === void 0 || initialPosition2 === null) {
        return;
      }
      if (!ref2.current) {
        return;
      }
      const {
        ownerDocument
      } = ref2.current;
      if (isInsideRootBlock(ref2.current, ownerDocument.activeElement)) {
        return;
      }
      const textInputs = focus.tabbable.find(ref2.current).filter((node) => isTextField(node));
      const isReverse = -1 === initialPosition2;
      const target = textInputs[isReverse ? textInputs.length - 1 : 0] || ref2.current;
      if (!isInsideRootBlock(ref2.current, target)) {
        ref2.current.focus();
        return;
      }
      if (!ref2.current.getAttribute("contenteditable")) {
        const focusElement = focus.tabbable.findNext(ref2.current);
        if (focusElement && isInsideRootBlock(ref2.current, focusElement) && isFormElement(focusElement)) {
          focusElement.focus();
          return;
        }
      }
      placeCaretAtHorizontalEdge(target, isReverse);
    }, [initialPosition2, clientId]);
    return ref2;
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-is-hovered.js
  function listener(event) {
    if (event.defaultPrevented) {
      return;
    }
    const action = event.type === "mouseover" ? "add" : "remove";
    event.preventDefault();
    event.currentTarget.classList[action]("is-hovered");
  }
  function useIsHovered() {
    const isEnabled = useSelect((select2) => {
      const {
        getSettings: getSettings2
      } = select2(store3);
      return getSettings2().outlineMode;
    }, []);
    return useRefEffect((node) => {
      if (isEnabled) {
        node.addEventListener("mouseout", listener);
        node.addEventListener("mouseover", listener);
        return () => {
          node.removeEventListener("mouseout", listener);
          node.removeEventListener("mouseover", listener);
          node.classList.remove("is-hovered");
        };
      }
    }, [isEnabled]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-class-names.js
  var import_classnames27 = __toESM(require_classnames());
  function useBlockClassNames(clientId) {
    return useSelect((select2) => {
      const {
        isBlockBeingDragged: isBlockBeingDragged2,
        isBlockHighlighted: isBlockHighlighted2,
        isBlockSelected: isBlockSelected2,
        isBlockMultiSelected: isBlockMultiSelected2,
        getBlockName: getBlockName2,
        getSettings: getSettings2,
        hasSelectedInnerBlock: hasSelectedInnerBlock2,
        isTyping: isTyping3,
        __unstableIsFullySelected: __unstableIsFullySelected2,
        __unstableSelectionHasUnmergeableBlock: __unstableSelectionHasUnmergeableBlock2
      } = select2(store3);
      const {
        outlineMode
      } = getSettings2();
      const isDragging = isBlockBeingDragged2(clientId);
      const isSelected = isBlockSelected2(clientId);
      const name = getBlockName2(clientId);
      const checkDeep = true;
      const isAncestorOfSelectedBlock = hasSelectedInnerBlock2(clientId, checkDeep);
      const isMultiSelected = isBlockMultiSelected2(clientId);
      return (0, import_classnames27.default)({
        "is-selected": isSelected,
        "is-highlighted": isBlockHighlighted2(clientId),
        "is-multi-selected": isMultiSelected,
        "is-partially-selected": isMultiSelected && !__unstableIsFullySelected2() && !__unstableSelectionHasUnmergeableBlock2(),
        "is-reusable": isReusableBlock(getBlockType(name)),
        "is-dragging": isDragging,
        "has-child-selected": isAncestorOfSelectedBlock,
        "remove-outline": isSelected && outlineMode && isTyping3()
      });
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-default-class-name.js
  function useBlockDefaultClassName(clientId) {
    return useSelect((select2) => {
      const name = select2(store3).getBlockName(clientId);
      const blockType = getBlockType(name);
      const hasLightBlockWrapper = (blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) > 1;
      if (!hasLightBlockWrapper) {
        return;
      }
      return getBlockDefaultClassName(name);
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-custom-class-name.js
  function useBlockCustomClassName(clientId) {
    return useSelect((select2) => {
      const {
        getBlockName: getBlockName2,
        getBlockAttributes: getBlockAttributes3
      } = select2(store3);
      const attributes = getBlockAttributes3(clientId);
      if (!(attributes !== null && attributes !== void 0 && attributes.className)) {
        return;
      }
      const blockType = getBlockType(getBlockName2(clientId));
      const hasLightBlockWrapper = (blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) > 1;
      if (!hasLightBlockWrapper) {
        return;
      }
      return attributes.className;
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-block-moving-mode-class-names.js
  var import_classnames28 = __toESM(require_classnames());
  function useBlockMovingModeClassNames(clientId) {
    return useSelect((select2) => {
      const {
        hasBlockMovingClientId: hasBlockMovingClientId3,
        canInsertBlockType: canInsertBlockType2,
        getBlockName: getBlockName2,
        getBlockRootClientId: getBlockRootClientId2,
        isBlockSelected: isBlockSelected2
      } = select2(store3);
      if (!isBlockSelected2(clientId)) {
        return;
      }
      const movingClientId = hasBlockMovingClientId3();
      if (!movingClientId) {
        return;
      }
      return (0, import_classnames28.default)("is-block-moving-mode", {
        "can-insert-moving-block": canInsertBlockType2(getBlockName2(movingClientId), getBlockRootClientId2(clientId))
      });
    }, [clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-focus-handler.js
  function useFocusHandler(clientId) {
    const {
      isBlockSelected: isBlockSelected2
    } = useSelect(store3);
    const {
      selectBlock: selectBlock2,
      selectionChange: selectionChange2
    } = use_dispatch_default(store3);
    return useRefEffect((node) => {
      function onFocus(event) {
        if (node.parentElement.closest('[contenteditable="true"]')) {
          return;
        }
        if (isBlockSelected2(clientId)) {
          if (!event.target.isContentEditable) {
            selectionChange2(clientId);
          }
          return;
        }
        if (!isInsideRootBlock(node, event.target)) {
          return;
        }
        selectBlock2(clientId);
      }
      node.addEventListener("focusin", onFocus);
      return () => {
        node.removeEventListener("focusin", onFocus);
      };
    }, [isBlockSelected2, selectBlock2]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-selected-block-event-handlers.js
  function useEventHandlers(clientId) {
    const isSelected = useSelect((select2) => select2(store3).isBlockSelected(clientId), [clientId]);
    const {
      getBlockRootClientId: getBlockRootClientId2,
      getBlockIndex: getBlockIndex2
    } = useSelect(store3);
    const {
      insertDefaultBlock: insertDefaultBlock2,
      removeBlock: removeBlock2
    } = use_dispatch_default(store3);
    return useRefEffect((node) => {
      if (!isSelected) {
        return;
      }
      function onKeyDown(event) {
        const {
          keyCode,
          target
        } = event;
        if (keyCode !== ENTER && keyCode !== BACKSPACE && keyCode !== DELETE) {
          return;
        }
        if (target !== node || isTextField(target)) {
          return;
        }
        event.preventDefault();
        if (keyCode === ENTER) {
          insertDefaultBlock2({}, getBlockRootClientId2(clientId), getBlockIndex2(clientId) + 1);
        } else {
          removeBlock2(clientId);
        }
      }
      function onDragStart(event) {
        event.preventDefault();
      }
      node.addEventListener("keydown", onKeyDown);
      node.addEventListener("dragstart", onDragStart);
      return () => {
        node.removeEventListener("keydown", onKeyDown);
        node.removeEventListener("dragstart", onDragStart);
      };
    }, [clientId, isSelected, getBlockRootClientId2, getBlockIndex2, insertDefaultBlock2, removeBlock2]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-nav-mode-exit.js
  function useNavModeExit(clientId) {
    const {
      isNavigationMode: isNavigationMode2,
      isBlockSelected: isBlockSelected2
    } = useSelect(store3);
    const {
      setNavigationMode: setNavigationMode2,
      selectBlock: selectBlock2
    } = use_dispatch_default(store3);
    return useRefEffect((node) => {
      function onMouseDown(event) {
        if (isNavigationMode2() && !event.defaultPrevented) {
          event.preventDefault();
          if (isBlockSelected2(clientId)) {
            setNavigationMode2(false);
          } else {
            selectBlock2(clientId);
          }
        }
      }
      node.addEventListener("mousedown", onMouseDown);
      return () => {
        node.addEventListener("mousedown", onMouseDown);
      };
    }, [clientId, isNavigationMode2, isBlockSelected2, setNavigationMode2]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/use-intersection-observer.js
  function useIntersectionObserver3() {
    const observer = (0, import_react.useContext)(IntersectionObserver2);
    return useRefEffect((node) => {
      if (observer) {
        observer.observe(node);
        return () => {
          observer.unobserve(node);
        };
      }
    }, [observer]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-block-props/index.js
  var BLOCK_ANIMATION_THRESHOLD = 200;
  function useBlockProps2() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let {
      __unstableIsHtml
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      clientId,
      className,
      wrapperProps = {},
      isAligned
    } = (0, import_react.useContext)(BlockListBlockContext);
    const {
      index: index2,
      mode,
      name,
      blockApiVersion,
      blockTitle,
      isPartOfSelection,
      adjustScrolling,
      enableAnimation
    } = useSelect((select2) => {
      const {
        getBlockAttributes: getBlockAttributes3,
        getBlockIndex: getBlockIndex2,
        getBlockMode: getBlockMode2,
        getBlockName: getBlockName2,
        isTyping: isTyping3,
        getGlobalBlockCount: getGlobalBlockCount2,
        isBlockSelected: isBlockSelected2,
        isBlockMultiSelected: isBlockMultiSelected2,
        isAncestorMultiSelected: isAncestorMultiSelected2,
        isFirstMultiSelectedBlock: isFirstMultiSelectedBlock2
      } = select2(store3);
      const {
        getActiveBlockVariation: getActiveBlockVariation2
      } = select2(store);
      const isSelected = isBlockSelected2(clientId);
      const isPartOfMultiSelection = isBlockMultiSelected2(clientId) || isAncestorMultiSelected2(clientId);
      const blockName = getBlockName2(clientId);
      const blockType = getBlockType(blockName);
      const attributes = getBlockAttributes3(clientId);
      const match = getActiveBlockVariation2(blockName, attributes);
      return {
        index: getBlockIndex2(clientId),
        mode: getBlockMode2(clientId),
        name: blockName,
        blockApiVersion: (blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) || 1,
        blockTitle: (match === null || match === void 0 ? void 0 : match.title) || (blockType === null || blockType === void 0 ? void 0 : blockType.title),
        isPartOfSelection: isSelected || isPartOfMultiSelection,
        adjustScrolling: isSelected || isFirstMultiSelectedBlock2(clientId),
        enableAnimation: !isTyping3() && getGlobalBlockCount2() <= BLOCK_ANIMATION_THRESHOLD
      };
    }, [clientId]);
    const hasOverlay = useBlockOverlayActive(clientId);
    const blockLabel = sprintf(__("Block: %s"), blockTitle);
    const htmlSuffix = mode === "html" && !__unstableIsHtml ? "-visual" : "";
    const mergedRefs = useMergeRefs([props.ref, useFocusFirstElement(clientId), useBlockRefProvider(clientId), useFocusHandler(clientId), useEventHandlers(clientId), useNavModeExit(clientId), useIsHovered(), useIntersectionObserver3(), use_moving_animation_default({
      isSelected: isPartOfSelection,
      adjustScrolling,
      enableAnimation,
      triggerAnimationOnChange: index2
    }), useDisabled({
      isDisabled: !hasOverlay
    })]);
    const blockEditContext = useBlockEditContext();
    if (blockApiVersion < 2 && clientId === blockEditContext.clientId) {
      typeof process !== "undefined" && process.env && true ? warning4(`Block type "${name}" must support API version 2 or higher to work correctly with "useBlockProps" method.`) : void 0;
    }
    return {
      tabIndex: 0,
      ...wrapperProps,
      ...props,
      ref: mergedRefs,
      id: `block-${clientId}${htmlSuffix}`,
      role: "document",
      "aria-label": blockLabel,
      "data-block": clientId,
      "data-type": name,
      "data-title": blockTitle,
      className: (0, import_classnames29.default)(
        (0, import_classnames29.default)("block-editor-block-list__block", {
          "wp-block": !isAligned,
          "has-block-overlay": hasOverlay
        }),
        className,
        props.className,
        wrapperProps.className,
        useBlockClassNames(clientId),
        useBlockDefaultClassName(clientId),
        useBlockCustomClassName(clientId),
        useBlockMovingModeClassNames(clientId)
      ),
      style: {
        ...wrapperProps.style,
        ...props.style
      }
    };
  }
  useBlockProps2.save = getBlockProps;

  // node_modules/@wordpress/block-editor/build-module/components/block-list/block.js
  var BlockListBlockContext = (0, import_react.createContext)();
  function mergeWrapperProps(propsA, propsB) {
    const newProps = {
      ...propsA,
      ...propsB
    };
    if (propsA !== null && propsA !== void 0 && propsA.className && propsB !== null && propsB !== void 0 && propsB.className) {
      newProps.className = (0, import_classnames30.default)(propsA.className, propsB.className);
    }
    if (propsA !== null && propsA !== void 0 && propsA.style && propsB !== null && propsB !== void 0 && propsB.style) {
      newProps.style = {
        ...propsA.style,
        ...propsB.style
      };
    }
    return newProps;
  }
  function Block2(_ref8) {
    let {
      children,
      isHtml,
      ...props
    } = _ref8;
    return (0, import_react.createElement)("div", useBlockProps2(props, {
      __unstableIsHtml: isHtml
    }), children);
  }
  function BlockListBlock(_ref22) {
    var _wrapperProps;
    let {
      block: {
        __unstableBlockSource
      },
      mode,
      isLocked,
      canRemove,
      clientId,
      isSelected,
      isSelectionEnabled: isSelectionEnabled3,
      className,
      __unstableLayoutClassNames: layoutClassNames,
      name,
      isValid,
      attributes,
      wrapperProps,
      setAttributes,
      onReplace,
      onInsertBlocksAfter,
      onMerge,
      toggleSelection: toggleSelection2
    } = _ref22;
    const {
      themeSupportsLayout,
      hasContentLockedParent,
      isContentBlock,
      isContentLocking,
      isTemporarilyEditingAsBlocks
    } = useSelect((select2) => {
      const {
        getSettings: getSettings2,
        __unstableGetContentLockingParent: __unstableGetContentLockingParent2,
        getTemplateLock: getTemplateLock2,
        __unstableGetTemporarilyEditingAsBlocks: __unstableGetTemporarilyEditingAsBlocks2
      } = select2(store3);
      const _hasContentLockedParent = !!__unstableGetContentLockingParent2(clientId);
      return {
        themeSupportsLayout: getSettings2().supportsLayout,
        isContentBlock: select2(store).__experimentalHasContentRoleAttribute(name),
        hasContentLockedParent: _hasContentLockedParent,
        isContentLocking: getTemplateLock2(clientId) === "contentOnly" && !_hasContentLockedParent,
        isTemporarilyEditingAsBlocks: __unstableGetTemporarilyEditingAsBlocks2() === clientId
      };
    }, [name, clientId]);
    const {
      removeBlock: removeBlock2
    } = use_dispatch_default(store3);
    const onRemove = (0, import_react.useCallback)(() => removeBlock2(clientId), [clientId]);
    let blockEdit = (0, import_react.createElement)(BlockEdit, {
      name,
      isSelected,
      attributes,
      setAttributes,
      insertBlocksAfter: isLocked ? void 0 : onInsertBlocksAfter,
      onReplace: canRemove ? onReplace : void 0,
      onRemove: canRemove ? onRemove : void 0,
      mergeBlocks: canRemove ? onMerge : void 0,
      clientId,
      isSelectionEnabled: isSelectionEnabled3,
      toggleSelection: toggleSelection2,
      __unstableLayoutClassNames: layoutClassNames
    });
    const blockType = getBlockType(name);
    if (hasContentLockedParent && !isContentBlock) {
      wrapperProps = {
        ...wrapperProps,
        tabIndex: -1
      };
    }
    if (blockType !== null && blockType !== void 0 && blockType.getEditWrapperProps) {
      wrapperProps = mergeWrapperProps(wrapperProps, blockType.getEditWrapperProps(attributes));
    }
    const isAligned = wrapperProps && !!wrapperProps["data-align"] && !themeSupportsLayout;
    if (isAligned) {
      blockEdit = (0, import_react.createElement)("div", {
        className: "wp-block",
        "data-align": wrapperProps["data-align"]
      }, blockEdit);
    }
    let block4;
    if (!isValid) {
      const saveContent = __unstableBlockSource ? serializeRawBlock(__unstableBlockSource) : getSaveContent(blockType, attributes);
      block4 = (0, import_react.createElement)(Block2, {
        className: "has-warning"
      }, (0, import_react.createElement)(block_invalid_warning_default, {
        clientId
      }), (0, import_react.createElement)(RawHTML, null, safeHTML(saveContent)));
    } else if (mode === "html") {
      block4 = (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("div", {
        style: {
          display: "none"
        }
      }, blockEdit), (0, import_react.createElement)(Block2, {
        isHtml: true
      }, (0, import_react.createElement)(block_html_default, {
        clientId
      })));
    } else if ((blockType === null || blockType === void 0 ? void 0 : blockType.apiVersion) > 1) {
      block4 = blockEdit;
    } else {
      block4 = (0, import_react.createElement)(Block2, wrapperProps, blockEdit);
    }
    const {
      "data-align": dataAlign,
      ...restWrapperProps
    } = (_wrapperProps = wrapperProps) !== null && _wrapperProps !== void 0 ? _wrapperProps : {};
    const value = {
      clientId,
      className: (0, import_classnames30.default)({
        "is-content-locked": isContentLocking,
        "is-content-locked-temporarily-editing-as-blocks": isTemporarilyEditingAsBlocks,
        "is-content-block": hasContentLockedParent && isContentBlock
      }, dataAlign && themeSupportsLayout && `align${dataAlign}`, className),
      wrapperProps: restWrapperProps,
      isAligned
    };
    const memoizedValue = (0, import_react.useMemo)(() => value, Object.values(value));
    return (0, import_react.createElement)(BlockListBlockContext.Provider, {
      value: memoizedValue
    }, (0, import_react.createElement)(block_crash_boundary_default, {
      fallback: (0, import_react.createElement)(Block2, {
        className: "has-warning"
      }, (0, import_react.createElement)(block_crash_warning_default, null))
    }, block4));
  }
  var applyWithSelect = with_select_default((select2, _ref32) => {
    let {
      clientId,
      rootClientId
    } = _ref32;
    const {
      isBlockSelected: isBlockSelected2,
      getBlockMode: getBlockMode2,
      isSelectionEnabled: isSelectionEnabled3,
      getTemplateLock: getTemplateLock2,
      __unstableGetBlockWithoutInnerBlocks: __unstableGetBlockWithoutInnerBlocks2,
      canRemoveBlock: canRemoveBlock2,
      canMoveBlock: canMoveBlock2
    } = select2(store3);
    const block4 = __unstableGetBlockWithoutInnerBlocks2(clientId);
    const isSelected = isBlockSelected2(clientId);
    const templateLock = getTemplateLock2(rootClientId);
    const canRemove = canRemoveBlock2(clientId, rootClientId);
    const canMove = canMoveBlock2(clientId, rootClientId);
    const {
      name,
      attributes,
      isValid
    } = block4 || {};
    return {
      mode: getBlockMode2(clientId),
      isSelectionEnabled: isSelectionEnabled3(),
      isLocked: !!templateLock,
      canRemove,
      canMove,
      block: block4,
      name,
      attributes,
      isValid,
      isSelected
    };
  });
  var applyWithDispatch = with_dispatch_default((dispatch2, ownProps, registry) => {
    const {
      updateBlockAttributes: updateBlockAttributes2,
      insertBlocks: insertBlocks2,
      mergeBlocks: mergeBlocks2,
      replaceBlocks: replaceBlocks2,
      toggleSelection: toggleSelection2,
      __unstableMarkLastChangeAsPersistent: __unstableMarkLastChangeAsPersistent2,
      moveBlocksToPosition: moveBlocksToPosition2,
      removeBlock: removeBlock2,
      selectBlock: selectBlock2
    } = dispatch2(store3);
    return {
      setAttributes(newAttributes) {
        const {
          getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2
        } = registry.select(store3);
        const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds2();
        const {
          clientId
        } = ownProps;
        const clientIds = multiSelectedBlockClientIds.length ? multiSelectedBlockClientIds : [clientId];
        updateBlockAttributes2(clientIds, newAttributes);
      },
      onInsertBlocks(blocks2, index2) {
        const {
          rootClientId
        } = ownProps;
        insertBlocks2(blocks2, index2, rootClientId);
      },
      onInsertBlocksAfter(blocks2) {
        const {
          clientId,
          rootClientId
        } = ownProps;
        const {
          getBlockIndex: getBlockIndex2
        } = registry.select(store3);
        const index2 = getBlockIndex2(clientId);
        insertBlocks2(blocks2, index2 + 1, rootClientId);
      },
      onMerge(forward) {
        const {
          clientId,
          rootClientId
        } = ownProps;
        const {
          getPreviousBlockClientId: getPreviousBlockClientId2,
          getNextBlockClientId: getNextBlockClientId2,
          getBlock: getBlock2,
          getBlockAttributes: getBlockAttributes3,
          getBlockName: getBlockName2,
          getBlockOrder: getBlockOrder2
        } = registry.select(store3);
        if (forward) {
          if (rootClientId) {
            const nextRootClientId = getNextBlockClientId2(rootClientId);
            if (nextRootClientId) {
              if (getBlockName2(rootClientId) === getBlockName2(nextRootClientId)) {
                const rootAttributes = getBlockAttributes3(rootClientId);
                const previousRootAttributes = getBlockAttributes3(nextRootClientId);
                if (Object.keys(rootAttributes).every((key) => rootAttributes[key] === previousRootAttributes[key])) {
                  registry.batch(() => {
                    moveBlocksToPosition2(getBlockOrder2(nextRootClientId), nextRootClientId, rootClientId);
                    removeBlock2(nextRootClientId, false);
                  });
                  return;
                }
              } else {
                mergeBlocks2(rootClientId, nextRootClientId);
                return;
              }
            }
          }
          const nextBlockClientId = getNextBlockClientId2(clientId);
          if (!nextBlockClientId) {
            return;
          }
          const replacement = switchToBlockType(getBlock2(nextBlockClientId), "*");
          if (replacement && replacement.length) {
            replaceBlocks2(nextBlockClientId, replacement);
          } else {
            mergeBlocks2(clientId, nextBlockClientId);
          }
        } else {
          const previousBlockClientId = getPreviousBlockClientId2(clientId);
          if (previousBlockClientId) {
            mergeBlocks2(previousBlockClientId, clientId);
          } else if (rootClientId) {
            const previousRootClientId = getPreviousBlockClientId2(rootClientId);
            if (previousRootClientId && getBlockName2(rootClientId) === getBlockName2(previousRootClientId)) {
              const rootAttributes = getBlockAttributes3(rootClientId);
              const previousRootAttributes = getBlockAttributes3(previousRootClientId);
              if (Object.keys(rootAttributes).every((key) => rootAttributes[key] === previousRootAttributes[key])) {
                registry.batch(() => {
                  moveBlocksToPosition2(getBlockOrder2(rootClientId), rootClientId, previousRootClientId);
                  removeBlock2(rootClientId, false);
                });
                return;
              }
            }
            const replacement = switchToBlockType(getBlock2(rootClientId), "*");
            if (replacement && replacement.length) {
              registry.batch(() => {
                replaceBlocks2(rootClientId, replacement);
                selectBlock2(replacement[0].clientId, 0);
              });
            }
          }
        }
      },
      onReplace(blocks2, indexToSelect, initialPosition2) {
        if (blocks2.length && !isUnmodifiedDefaultBlock(blocks2[blocks2.length - 1])) {
          __unstableMarkLastChangeAsPersistent2();
        }
        replaceBlocks2([ownProps.clientId], blocks2, indexToSelect, initialPosition2);
      },
      toggleSelection(selectionEnabled) {
        toggleSelection2(selectionEnabled);
      }
    };
  });
  var block_default = compose_default(
    pure_default,
    applyWithSelect,
    applyWithDispatch,
    if_condition_default((_ref42) => {
      let {
        block: block4
      } = _ref42;
      return !!block4;
    }),
    withFilters("editor.BlockListBlock")
  )(BlockListBlock);

  // node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js
  var import_classnames37 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js
  var import_classnames35 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/inserter/index.js
  var import_classnames34 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js
  var import_classnames32 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/inserter/tips.js
  var globalTips = [create_interpolate_element_default(__("While writing, you can press <kbd>/</kbd> to quickly insert new blocks."), {
    kbd: (0, import_react.createElement)("kbd", null)
  }), create_interpolate_element_default(__("Indent a list by pressing <kbd>space</kbd> at the beginning of a line."), {
    kbd: (0, import_react.createElement)("kbd", null)
  }), create_interpolate_element_default(__("Outdent a list by pressing <kbd>backspace</kbd> at the beginning of a line."), {
    kbd: (0, import_react.createElement)("kbd", null)
  }), __("Drag files into the editor to automatically insert media blocks."), __("Change a block's type by pressing the block icon on the toolbar.")];
  function Tips() {
    const [randomIndex] = (0, import_react.useState)(
      Math.floor(Math.random() * globalTips.length)
    );
    return (0, import_react.createElement)(tip_default2, null, globalTips[randomIndex]);
  }
  var tips_default = Tips;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js
  var import_lodash29 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js
  var import_classnames31 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/context.js
  var InserterListboxContext = (0, import_react.createContext)();
  var context_default5 = InserterListboxContext;

  // node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/group.js
  function InserterListboxGroup(props, ref2) {
    const [shouldSpeak, setShouldSpeak] = (0, import_react.useState)(false);
    (0, import_react.useEffect)(() => {
      if (shouldSpeak) {
        speak(__("Use left and right arrow keys to move through blocks"));
      }
    }, [shouldSpeak]);
    return (0, import_react.createElement)("div", _extends({
      ref: ref2,
      role: "listbox",
      "aria-orientation": "horizontal",
      onFocus: () => {
        setShouldSpeak(true);
      },
      onBlur: (event) => {
        const focusingOutsideGroup = !event.currentTarget.contains(event.relatedTarget);
        if (focusingOutsideGroup) {
          setShouldSpeak(false);
        }
      }
    }, props));
  }
  var group_default2 = (0, import_react.forwardRef)(InserterListboxGroup);

  // node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/row.js
  function InserterListboxRow(props, ref2) {
    const state = (0, import_react.useContext)(context_default5);
    return (0, import_react.createElement)(CompositeGroup, _extends({
      state,
      role: "presentation",
      ref: ref2
    }, props));
  }
  var row_default2 = (0, import_react.forwardRef)(InserterListboxRow);

  // node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/item.js
  function InserterListboxItem(_ref8, ref2) {
    let {
      isFirst,
      as: Component2,
      children,
      ...props
    } = _ref8;
    const state = (0, import_react.useContext)(context_default5);
    return (0, import_react.createElement)(CompositeItem, _extends({
      ref: ref2,
      state,
      role: "option",
      focusable: true
    }, props), (htmlProps) => {
      const propsWithTabIndex = {
        ...htmlProps,
        tabIndex: isFirst ? 0 : htmlProps.tabIndex
      };
      if (Component2) {
        return (0, import_react.createElement)(Component2, propsWithTabIndex, children);
      }
      if (typeof children === "function") {
        return children(propsWithTabIndex);
      }
      return (0, import_react.createElement)(button_default, propsWithTabIndex, children);
    });
  }
  var item_default = (0, import_react.forwardRef)(InserterListboxItem);

  // node_modules/@wordpress/block-editor/build-module/components/inserter-listbox/index.js
  function InserterListbox(_ref8) {
    let {
      children
    } = _ref8;
    const compositeState = useCompositeState({
      shift: true,
      wrap: "horizontal"
    });
    return (0, import_react.createElement)(context_default5.Provider, {
      value: compositeState
    }, children);
  }
  var inserter_listbox_default = InserterListbox;

  // node_modules/@wordpress/block-editor/build-module/components/inserter-draggable-blocks/index.js
  var InserterDraggableBlocks = (_ref8) => {
    let {
      isEnabled,
      blocks: blocks2,
      icon,
      children,
      isPattern
    } = _ref8;
    const transferData = {
      type: "inserter",
      blocks: blocks2
    };
    return (0, import_react.createElement)(Draggable, {
      __experimentalTransferDataType: "wp-blocks",
      transferData,
      __experimentalDragComponent: (0, import_react.createElement)(BlockDraggableChip, {
        count: blocks2.length,
        icon,
        isPattern
      })
    }, (_ref22) => {
      let {
        onDraggableStart,
        onDraggableEnd
      } = _ref22;
      return children({
        draggable: isEnabled,
        onDragStart: isEnabled ? onDraggableStart : void 0,
        onDragEnd: isEnabled ? onDraggableEnd : void 0
      });
    });
  };
  var inserter_draggable_blocks_default = InserterDraggableBlocks;

  // node_modules/@wordpress/block-editor/build-module/components/inserter-list-item/index.js
  function InserterListItem(_ref8) {
    let {
      className,
      isFirst,
      item: item2,
      onSelect,
      onHover,
      isDraggable,
      ...props
    } = _ref8;
    const isDragging = (0, import_react.useRef)(false);
    const itemIconStyle = item2.icon ? {
      backgroundColor: item2.icon.background,
      color: item2.icon.foreground
    } : {};
    const blocks2 = (0, import_react.useMemo)(() => {
      return [createBlock(item2.name, item2.initialAttributes, createBlocksFromInnerBlocksTemplate(item2.innerBlocks))];
    }, [item2.name, item2.initialAttributes, item2.initialAttributes]);
    return (0, import_react.createElement)(inserter_draggable_blocks_default, {
      isEnabled: isDraggable && !item2.disabled,
      blocks: blocks2,
      icon: item2.icon
    }, (_ref22) => {
      let {
        draggable,
        onDragStart,
        onDragEnd
      } = _ref22;
      return (0, import_react.createElement)("div", {
        className: "block-editor-block-types-list__list-item",
        draggable,
        onDragStart: (event) => {
          isDragging.current = true;
          if (onDragStart) {
            onHover(null);
            onDragStart(event);
          }
        },
        onDragEnd: (event) => {
          isDragging.current = false;
          if (onDragEnd) {
            onDragEnd(event);
          }
        }
      }, (0, import_react.createElement)(item_default, _extends({
        isFirst,
        className: (0, import_classnames31.default)("block-editor-block-types-list__item", className),
        disabled: item2.isDisabled,
        onClick: (event) => {
          event.preventDefault();
          onSelect(item2, isAppleOS() ? event.metaKey : event.ctrlKey);
          onHover(null);
        },
        onKeyDown: (event) => {
          const {
            keyCode
          } = event;
          if (keyCode === ENTER) {
            event.preventDefault();
            onSelect(item2, isAppleOS() ? event.metaKey : event.ctrlKey);
            onHover(null);
          }
        },
        onFocus: () => {
          if (isDragging.current) {
            return;
          }
          onHover(item2);
        },
        onMouseEnter: () => {
          if (isDragging.current) {
            return;
          }
          onHover(item2);
        },
        onMouseLeave: () => onHover(null),
        onBlur: () => onHover(null)
      }, props), (0, import_react.createElement)("span", {
        className: "block-editor-block-types-list__item-icon",
        style: itemIconStyle
      }, (0, import_react.createElement)(block_icon_default, {
        icon: item2.icon,
        showColors: true
      })), (0, import_react.createElement)("span", {
        className: "block-editor-block-types-list__item-title"
      }, (0, import_react.createElement)(component_default6, {
        numberOfLines: 3
      }, item2.title))));
    });
  }
  var inserter_list_item_default = (0, import_react.memo)(InserterListItem);

  // node_modules/@wordpress/block-editor/build-module/components/block-types-list/index.js
  function chunk(array, size) {
    const chunks = [];
    for (let i5 = 0, j2 = array.length; i5 < j2; i5 += size) {
      chunks.push(array.slice(i5, i5 + size));
    }
    return chunks;
  }
  function BlockTypesList(_ref8) {
    let {
      items = [],
      onSelect,
      onHover = () => {
      },
      children,
      label,
      isDraggable = true
    } = _ref8;
    return (0, import_react.createElement)(group_default2, {
      className: "block-editor-block-types-list",
      "aria-label": label
    }, chunk(items, 3).map((row2, i5) => (0, import_react.createElement)(row_default2, {
      key: i5
    }, row2.map((item2, j2) => (0, import_react.createElement)(inserter_list_item_default, {
      key: item2.id,
      item: item2,
      className: getBlockMenuDefaultClassName(item2.id),
      onSelect,
      onHover,
      isDraggable: isDraggable && !item2.isDisabled,
      isFirst: i5 === 0 && j2 === 0
    })))), children);
  }
  var block_types_list_default = BlockTypesList;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/panel.js
  function InserterPanel(_ref8) {
    let {
      title,
      icon,
      children
    } = _ref8;
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("div", {
      className: "block-editor-inserter__panel-header"
    }, (0, import_react.createElement)("h2", {
      className: "block-editor-inserter__panel-title"
    }, title), (0, import_react.createElement)(icon_default2, {
      icon
    })), (0, import_react.createElement)("div", {
      className: "block-editor-inserter__panel-content"
    }, children));
  }
  var panel_default = InserterPanel;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/block-types-tab.js
  var getBlockNamespace = (item2) => item2.name.split("/")[0];
  var MAX_SUGGESTED_ITEMS = 6;
  var EMPTY_ARRAY3 = [];
  function BlockTypesTab(_ref8) {
    let {
      rootClientId,
      onInsert,
      onHover,
      showMostUsedBlocks
    } = _ref8;
    const [items, categories2, collections2, onSelectItem] = use_block_types_state_default(rootClientId, onInsert);
    const suggestedItems = (0, import_react.useMemo)(() => {
      return (0, import_lodash29.orderBy)(items, ["frecency"], ["desc"]).slice(0, MAX_SUGGESTED_ITEMS);
    }, [items]);
    const uncategorizedItems = (0, import_react.useMemo)(() => {
      return items.filter((item2) => !item2.category);
    }, [items]);
    const itemsPerCategory = (0, import_react.useMemo)(() => {
      return pipe_default((itemList) => itemList.filter((item2) => item2.category && item2.category !== "reusable"), (itemList) => (0, import_lodash29.groupBy)(itemList, "category"))(items);
    }, [items]);
    const itemsPerCollection = (0, import_react.useMemo)(() => {
      const result = {
        ...collections2
      };
      Object.keys(collections2).forEach((namespace) => {
        result[namespace] = items.filter((item2) => getBlockNamespace(item2) === namespace);
        if (result[namespace].length === 0) {
          delete result[namespace];
        }
      });
      return result;
    }, [items, collections2]);
    (0, import_react.useEffect)(() => () => onHover(null), []);
    const currentlyRenderedCategories = use_async_list_default(categories2);
    const didRenderAllCategories = categories2.length === currentlyRenderedCategories.length;
    const collectionEntries = (0, import_react.useMemo)(() => {
      return Object.entries(collections2);
    }, [collections2]);
    const currentlyRenderedCollections = use_async_list_default(didRenderAllCategories ? collectionEntries : EMPTY_ARRAY3);
    return (0, import_react.createElement)(inserter_listbox_default, null, (0, import_react.createElement)("div", null, showMostUsedBlocks && !!suggestedItems.length && (0, import_react.createElement)(panel_default, {
      title: _x("Most used", "blocks")
    }, (0, import_react.createElement)(block_types_list_default, {
      items: suggestedItems,
      onSelect: onSelectItem,
      onHover,
      label: _x("Most used", "blocks")
    })), (0, import_lodash29.map)(currentlyRenderedCategories, (category) => {
      const categoryItems = itemsPerCategory[category.slug];
      if (!categoryItems || !categoryItems.length) {
        return null;
      }
      return (0, import_react.createElement)(panel_default, {
        key: category.slug,
        title: category.title,
        icon: category.icon
      }, (0, import_react.createElement)(block_types_list_default, {
        items: categoryItems,
        onSelect: onSelectItem,
        onHover,
        label: category.title
      }));
    }), didRenderAllCategories && uncategorizedItems.length > 0 && (0, import_react.createElement)(panel_default, {
      className: "block-editor-inserter__uncategorized-blocks-panel",
      title: __("Uncategorized")
    }, (0, import_react.createElement)(block_types_list_default, {
      items: uncategorizedItems,
      onSelect: onSelectItem,
      onHover,
      label: __("Uncategorized")
    })), (0, import_lodash29.map)(currentlyRenderedCollections, (_ref22) => {
      let [namespace, collection] = _ref22;
      const collectionItems = itemsPerCollection[namespace];
      if (!collectionItems || !collectionItems.length) {
        return null;
      }
      return (0, import_react.createElement)(panel_default, {
        key: namespace,
        title: collection.title,
        icon: collection.icon
      }, (0, import_react.createElement)(block_types_list_default, {
        items: collectionItems,
        onSelect: onSelectItem,
        onHover,
        label: collection.title
      }));
    })));
  }
  var block_types_tab_default = BlockTypesTab;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-patterns-state.js
  var import_lodash30 = __toESM(require_lodash());
  var usePatternsState = (onInsert, rootClientId) => {
    const {
      patternCategories,
      patterns
    } = useSelect((select2) => {
      const {
        __experimentalGetAllowedPatterns: __experimentalGetAllowedPatterns2,
        getSettings: getSettings2
      } = select2(store3);
      return {
        patterns: __experimentalGetAllowedPatterns2(rootClientId),
        patternCategories: getSettings2().__experimentalBlockPatternCategories
      };
    }, [rootClientId]);
    const {
      createSuccessNotice: createSuccessNotice2
    } = use_dispatch_default(store5);
    const onClickPattern = (0, import_react.useCallback)((pattern, blocks2) => {
      onInsert((0, import_lodash30.map)(blocks2, (block4) => cloneBlock(block4)), pattern.name);
      createSuccessNotice2(sprintf(
        __('Block pattern "%s" inserted.'),
        pattern.title
      ), {
        type: "snackbar"
      });
    }, []);
    return [patterns, patternCategories, onClickPattern];
  };
  var use_patterns_state_default = usePatternsState;

  // node_modules/@wordpress/block-editor/build-module/components/block-patterns-list/index.js
  function BlockPattern(_ref8) {
    let {
      isDraggable,
      pattern,
      onClick,
      composite
    } = _ref8;
    const {
      blocks: blocks2,
      viewportWidth
    } = pattern;
    const instanceId = use_instance_id_default(BlockPattern);
    const descriptionId = `block-editor-block-patterns-list__item-description-${instanceId}`;
    return (0, import_react.createElement)(inserter_draggable_blocks_default, {
      isEnabled: isDraggable,
      blocks: blocks2,
      isPattern: !!pattern
    }, (_ref22) => {
      let {
        draggable,
        onDragStart,
        onDragEnd
      } = _ref22;
      return (0, import_react.createElement)("div", {
        className: "block-editor-block-patterns-list__list-item",
        draggable,
        onDragStart,
        onDragEnd
      }, (0, import_react.createElement)(CompositeItem, _extends({
        role: "option",
        as: "div"
      }, composite, {
        className: "block-editor-block-patterns-list__item",
        onClick: () => onClick(pattern, blocks2),
        "aria-label": pattern.title,
        "aria-describedby": pattern.description ? descriptionId : void 0
      }), (0, import_react.createElement)(block_preview_default, {
        blocks: blocks2,
        viewportWidth
      }), (0, import_react.createElement)("div", {
        className: "block-editor-block-patterns-list__item-title"
      }, pattern.title), !!pattern.description && (0, import_react.createElement)(component_default2, {
        id: descriptionId
      }, pattern.description)));
    });
  }
  function BlockPatternPlaceholder() {
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-patterns-list__item is-placeholder"
    });
  }
  function BlockPatternList(_ref32) {
    let {
      isDraggable,
      blockPatterns,
      shownPatterns,
      onClickPattern,
      orientation,
      label = __("Block Patterns")
    } = _ref32;
    const composite = useCompositeState({
      orientation
    });
    return (0, import_react.createElement)(Composite, _extends({}, composite, {
      role: "listbox",
      className: "block-editor-block-patterns-list",
      "aria-label": label
    }), blockPatterns.map((pattern) => {
      const isShown = shownPatterns.includes(pattern);
      return isShown ? (0, import_react.createElement)(BlockPattern, {
        key: pattern.name,
        pattern,
        onClick: onClickPattern,
        isDraggable,
        composite
      }) : (0, import_react.createElement)(BlockPatternPlaceholder, {
        key: pattern.name
      });
    }));
  }
  var block_patterns_list_default = BlockPatternList;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/sidebar.js
  function PatternCategoriesList(_ref8) {
    let {
      selectedCategory,
      patternCategories,
      onClickCategory
    } = _ref8;
    const baseClassName = "block-editor-block-patterns-explorer__sidebar";
    return (0, import_react.createElement)("div", {
      className: `${baseClassName}__categories-list`
    }, patternCategories.map((_ref22) => {
      let {
        name,
        label
      } = _ref22;
      return (0, import_react.createElement)(button_default, {
        key: name,
        label,
        className: `${baseClassName}__categories-list__item`,
        isPressed: selectedCategory === name,
        onClick: () => {
          onClickCategory(name);
        }
      }, label);
    }));
  }
  function PatternsExplorerSearch(_ref32) {
    let {
      filterValue,
      setFilterValue
    } = _ref32;
    const baseClassName = "block-editor-block-patterns-explorer__search";
    return (0, import_react.createElement)("div", {
      className: baseClassName
    }, (0, import_react.createElement)(search_control_default, {
      onChange: setFilterValue,
      value: filterValue,
      label: __("Search for patterns"),
      placeholder: __("Search")
    }));
  }
  function PatternExplorerSidebar(_ref42) {
    let {
      selectedCategory,
      patternCategories,
      onClickCategory,
      filterValue,
      setFilterValue
    } = _ref42;
    const baseClassName = "block-editor-block-patterns-explorer__sidebar";
    return (0, import_react.createElement)("div", {
      className: baseClassName
    }, (0, import_react.createElement)(PatternsExplorerSearch, {
      filterValue,
      setFilterValue
    }), !filterValue && (0, import_react.createElement)(PatternCategoriesList, {
      selectedCategory,
      patternCategories,
      onClickCategory
    }));
  }
  var sidebar_default = PatternExplorerSidebar;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/no-results.js
  function InserterNoResults() {
    return (0, import_react.createElement)("div", {
      className: "block-editor-inserter__no-results"
    }, (0, import_react.createElement)(icon_default, {
      className: "block-editor-inserter__no-results-icon",
      icon: block_default_default
    }), (0, import_react.createElement)("p", null, __("No results found.")));
  }
  var no_results_default = InserterNoResults;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/hooks/use-insertion-point.js
  function useInsertionPoint(_ref8) {
    let {
      rootClientId = "",
      insertionIndex,
      clientId,
      isAppender,
      onSelect,
      shouldFocusBlock = true
    } = _ref8;
    const {
      getSelectedBlock: getSelectedBlock2
    } = useSelect(store3);
    const {
      destinationRootClientId,
      destinationIndex
    } = useSelect((select2) => {
      const {
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getBlockRootClientId: getBlockRootClientId2,
        getBlockIndex: getBlockIndex2,
        getBlockOrder: getBlockOrder2
      } = select2(store3);
      const selectedBlockClientId = getSelectedBlockClientId2();
      let _destinationRootClientId = rootClientId;
      let _destinationIndex;
      if (insertionIndex !== void 0) {
        _destinationIndex = insertionIndex;
      } else if (clientId) {
        _destinationIndex = getBlockIndex2(clientId);
      } else if (!isAppender && selectedBlockClientId) {
        _destinationRootClientId = getBlockRootClientId2(selectedBlockClientId);
        _destinationIndex = getBlockIndex2(selectedBlockClientId) + 1;
      } else {
        _destinationIndex = getBlockOrder2(_destinationRootClientId).length;
      }
      return {
        destinationRootClientId: _destinationRootClientId,
        destinationIndex: _destinationIndex
      };
    }, [rootClientId, insertionIndex, clientId, isAppender]);
    const {
      replaceBlocks: replaceBlocks2,
      insertBlocks: insertBlocks2,
      showInsertionPoint: showInsertionPoint2,
      hideInsertionPoint: hideInsertionPoint2
    } = use_dispatch_default(store3);
    const onInsertBlocks = (0, import_react.useCallback)(function(blocks2, meta) {
      let shouldForceFocusBlock = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      const selectedBlock = getSelectedBlock2();
      if (!isAppender && selectedBlock && isUnmodifiedDefaultBlock(selectedBlock)) {
        replaceBlocks2(selectedBlock.clientId, blocks2, null, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
      } else {
        insertBlocks2(blocks2, destinationIndex, destinationRootClientId, true, shouldFocusBlock || shouldForceFocusBlock ? 0 : null, meta);
      }
      const blockLength = Array.isArray(blocks2) ? blocks2.length : 1;
      const message = sprintf(
        _n("%d block added.", "%d blocks added.", blockLength),
        blockLength
      );
      speak(message);
      if (onSelect) {
        onSelect();
      }
    }, [isAppender, getSelectedBlock2, replaceBlocks2, insertBlocks2, destinationRootClientId, destinationIndex, onSelect, shouldFocusBlock]);
    const onToggleInsertionPoint = (0, import_react.useCallback)((show) => {
      if (show) {
        showInsertionPoint2(destinationRootClientId, destinationIndex);
      } else {
        hideInsertionPoint2();
      }
    }, [showInsertionPoint2, hideInsertionPoint2, destinationRootClientId, destinationIndex]);
    return [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint];
  }
  var use_insertion_point_default = useInsertionPoint;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/patterns-list.js
  var INITIAL_INSERTER_RESULTS = 2;
  function PatternsListHeader(_ref8) {
    let {
      filterValue,
      filteredBlockPatternsLength
    } = _ref8;
    if (!filterValue) {
      return null;
    }
    return (0, import_react.createElement)(component_default10, {
      level: 2,
      lineHeight: "48px",
      className: "block-editor-block-patterns-explorer__search-results-count"
    }, sprintf(
      _n('%1$d pattern found for "%2$s"', '%1$d patterns found for "%2$s"', filteredBlockPatternsLength),
      filteredBlockPatternsLength,
      filterValue
    ));
  }
  function PatternList(_ref22) {
    let {
      filterValue,
      selectedCategory,
      patternCategories
    } = _ref22;
    const debouncedSpeak = useDebounce(speak, 500);
    const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
      shouldFocusBlock: true
    });
    const [allPatterns, , onSelectBlockPattern] = use_patterns_state_default(onInsertBlocks, destinationRootClientId);
    const registeredPatternCategories = (0, import_react.useMemo)(() => patternCategories.map((patternCategory) => patternCategory.name), [patternCategories]);
    const filteredBlockPatterns = (0, import_react.useMemo)(() => {
      if (!filterValue) {
        return allPatterns.filter((pattern) => {
          var _pattern$categories, _pattern$categories2;
          return selectedCategory === "uncategorized" ? !((_pattern$categories = pattern.categories) !== null && _pattern$categories !== void 0 && _pattern$categories.length) || pattern.categories.every((category) => !registeredPatternCategories.includes(category)) : (_pattern$categories2 = pattern.categories) === null || _pattern$categories2 === void 0 ? void 0 : _pattern$categories2.includes(selectedCategory);
        });
      }
      return searchItems(allPatterns, filterValue);
    }, [filterValue, selectedCategory, allPatterns]);
    (0, import_react.useEffect)(() => {
      if (!filterValue) {
        return;
      }
      const count = filteredBlockPatterns.length;
      const resultsFoundMessage = sprintf(
        _n("%d result found.", "%d results found.", count),
        count
      );
      debouncedSpeak(resultsFoundMessage);
    }, [filterValue, debouncedSpeak]);
    const currentShownPatterns = use_async_list_default(filteredBlockPatterns, {
      step: INITIAL_INSERTER_RESULTS
    });
    const hasItems = !!(filteredBlockPatterns !== null && filteredBlockPatterns !== void 0 && filteredBlockPatterns.length);
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-patterns-explorer__list"
    }, hasItems && (0, import_react.createElement)(PatternsListHeader, {
      filterValue,
      filteredBlockPatternsLength: filteredBlockPatterns.length
    }), (0, import_react.createElement)(inserter_listbox_default, null, !hasItems && (0, import_react.createElement)(no_results_default, null), hasItems && (0, import_react.createElement)(block_patterns_list_default, {
      shownPatterns: currentShownPatterns,
      blockPatterns: filteredBlockPatterns,
      onClickPattern: onSelectBlockPattern,
      isDraggable: false
    })));
  }
  var patterns_list_default = PatternList;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-explorer/explorer.js
  function PatternsExplorer(_ref8) {
    let {
      initialCategory,
      patternCategories
    } = _ref8;
    const [filterValue, setFilterValue] = (0, import_react.useState)("");
    const [selectedCategory, setSelectedCategory] = (0, import_react.useState)(initialCategory === null || initialCategory === void 0 ? void 0 : initialCategory.name);
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-patterns-explorer"
    }, (0, import_react.createElement)(sidebar_default, {
      selectedCategory,
      patternCategories,
      onClickCategory: setSelectedCategory,
      filterValue,
      setFilterValue
    }), (0, import_react.createElement)(patterns_list_default, {
      filterValue,
      selectedCategory,
      patternCategories
    }));
  }
  function PatternsExplorerModal(_ref22) {
    let {
      onModalClose,
      ...restProps
    } = _ref22;
    return (0, import_react.createElement)(modal_default, {
      title: __("Patterns"),
      closeLabel: __("Close"),
      onRequestClose: onModalClose,
      isFullScreen: true
    }, (0, import_react.createElement)(PatternsExplorer, restProps));
  }
  var explorer_default = PatternsExplorerModal;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/block-patterns-tab.js
  function usePatternsCategories() {
    const [allPatterns, allCategories] = use_patterns_state_default();
    const hasRegisteredCategory = (0, import_react.useCallback)((pattern) => {
      if (!pattern.categories || !pattern.categories.length) {
        return false;
      }
      return pattern.categories.some((cat) => allCategories.some((category) => category.name === cat));
    }, [allCategories]);
    const populatedCategories = (0, import_react.useMemo)(() => {
      const categories2 = allCategories.filter((category) => allPatterns.some((pattern) => {
        var _pattern$categories;
        return (_pattern$categories = pattern.categories) === null || _pattern$categories === void 0 ? void 0 : _pattern$categories.includes(category.name);
      })).sort((_ref8, _ref22) => {
        let {
          name: currentName
        } = _ref8;
        let {
          name: nextName
        } = _ref22;
        if (![currentName, nextName].includes("featured")) {
          return 0;
        }
        return currentName === "featured" ? -1 : 1;
      });
      if (allPatterns.some((pattern) => !hasRegisteredCategory(pattern)) && !categories2.find((category) => category.name === "uncategorized")) {
        categories2.push({
          name: "uncategorized",
          label: _x("Uncategorized")
        });
      }
      return categories2;
    }, [allPatterns, allCategories]);
    return populatedCategories;
  }
  function BlockPatternsCategoryDialog(_ref32) {
    let {
      rootClientId,
      onInsert,
      category
    } = _ref32;
    const container = (0, import_react.useRef)();
    (0, import_react.useEffect)(() => {
      const timeout = setTimeout(() => {
        const [firstTabbable] = focus.tabbable.find(container.current);
        firstTabbable === null || firstTabbable === void 0 ? void 0 : firstTabbable.focus();
      });
      return () => clearTimeout(timeout);
    }, [category]);
    return (0, import_react.createElement)("div", {
      ref: container,
      className: "block-editor-inserter__patterns-category-panel"
    }, (0, import_react.createElement)(BlockPatternsCategoryPanel, {
      rootClientId,
      onInsert,
      category
    }));
  }
  function BlockPatternsCategoryPanel(_ref42) {
    let {
      rootClientId,
      onInsert,
      category
    } = _ref42;
    const [allPatterns, , onClick] = use_patterns_state_default(onInsert, rootClientId);
    const availableCategories = usePatternsCategories();
    const currentCategoryPatterns = (0, import_react.useMemo)(() => allPatterns.filter((pattern) => {
      var _pattern$categories$f, _pattern$categories3;
      if (category.name !== "uncategorized") {
        var _pattern$categories2;
        return (_pattern$categories2 = pattern.categories) === null || _pattern$categories2 === void 0 ? void 0 : _pattern$categories2.includes(category.name);
      }
      const availablePatternCategories = (_pattern$categories$f = (_pattern$categories3 = pattern.categories) === null || _pattern$categories3 === void 0 ? void 0 : _pattern$categories3.filter((cat) => availableCategories.find((availableCategory) => availableCategory.name === cat))) !== null && _pattern$categories$f !== void 0 ? _pattern$categories$f : [];
      return availablePatternCategories.length === 0;
    }), [allPatterns, category]);
    const currentShownPatterns = use_async_list_default(currentCategoryPatterns);
    if (!currentCategoryPatterns.length) {
      return null;
    }
    return (0, import_react.createElement)("div", null, (0, import_react.createElement)("div", {
      className: "block-editor-inserter__patterns-category-panel-title"
    }, category.label), (0, import_react.createElement)("p", null, category.description), (0, import_react.createElement)(block_patterns_list_default, {
      shownPatterns: currentShownPatterns,
      blockPatterns: currentCategoryPatterns,
      onClickPattern: onClick,
      label: category.label,
      orientation: "vertical",
      category: category.label,
      isDraggable: true
    }));
  }
  function BlockPatternsTabs(_ref52) {
    let {
      onSelectCategory,
      selectedCategory,
      onInsert,
      rootClientId
    } = _ref52;
    const [showPatternsExplorer, setShowPatternsExplorer] = (0, import_react.useState)(false);
    const categories2 = usePatternsCategories();
    const isMobile = use_viewport_match_default("medium", "<");
    return (0, import_react.createElement)(import_react.Fragment, null, !isMobile && (0, import_react.createElement)("div", {
      className: "block-editor-inserter__block-patterns-tabs-container"
    }, (0, import_react.createElement)("nav", {
      "aria-label": __("Block pattern categories")
    }, (0, import_react.createElement)(component_default12, {
      role: "list",
      className: "block-editor-inserter__block-patterns-tabs"
    }, categories2.map((category) => (0, import_react.createElement)(component_default11, {
      role: "listitem",
      key: category.name,
      onClick: () => onSelectCategory(category),
      className: category === selectedCategory ? "block-editor-inserter__patterns-category block-editor-inserter__patterns-selected-category" : "block-editor-inserter__patterns-category",
      "aria-label": category.label,
      "aria-current": category === selectedCategory ? "true" : void 0
    }, (0, import_react.createElement)(component_default8, null, (0, import_react.createElement)(component_default5, null, category.label), (0, import_react.createElement)(icon_default, {
      icon: chevron_right_default
    })))), (0, import_react.createElement)("div", {
      role: "presentation",
      className: "block-editor-inserter__patterns-fill-space"
    }), (0, import_react.createElement)("div", {
      role: "listitem"
    }, (0, import_react.createElement)(button_default, {
      className: "block-editor-inserter__patterns-explore-button",
      onClick: () => setShowPatternsExplorer(true),
      variant: "secondary"
    }, __("Explore all patterns")))))), isMobile && (0, import_react.createElement)(BlockPatternsTabNavigation, {
      onInsert,
      rootClientId
    }), showPatternsExplorer && (0, import_react.createElement)(explorer_default, {
      initialCategory: selectedCategory,
      patternCategories: categories2,
      onModalClose: () => setShowPatternsExplorer(false)
    }));
  }
  function BlockPatternsTabNavigation(_ref62) {
    let {
      onInsert,
      rootClientId
    } = _ref62;
    const categories2 = usePatternsCategories();
    return (0, import_react.createElement)(component_default16, {
      initialPath: "/"
    }, (0, import_react.createElement)(component_default17, {
      path: "/"
    }, (0, import_react.createElement)(component_default12, null, categories2.map((category) => (0, import_react.createElement)(component_default18, {
      key: category.name,
      path: `/category/${category.name}`,
      as: component_default11,
      isAction: true
    }, (0, import_react.createElement)(component_default8, null, (0, import_react.createElement)(component_default5, null, category.label), (0, import_react.createElement)(icon_default, {
      icon: isRTL() ? chevron_left_default : chevron_right_default
    })))))), categories2.map((category) => (0, import_react.createElement)(component_default17, {
      key: category.name,
      path: `/category/${category.name}`
    }, (0, import_react.createElement)(component_default19, {
      icon: isRTL() ? chevron_right_default : chevron_left_default,
      isSmall: true,
      "aria-label": __("Navigate to the categories list")
    }, __("Back")), (0, import_react.createElement)(BlockPatternsCategoryPanel, {
      category,
      rootClientId,
      onInsert
    }))));
  }
  var block_patterns_tab_default = BlockPatternsTabs;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/reusable-blocks-tab.js
  function ReusableBlocksList(_ref8) {
    let {
      onHover,
      onInsert,
      rootClientId
    } = _ref8;
    const [items, , , onSelectItem] = use_block_types_state_default(rootClientId, onInsert);
    const filteredItems = (0, import_react.useMemo)(() => {
      return items.filter((_ref22) => {
        let {
          category
        } = _ref22;
        return category === "reusable";
      });
    }, [items]);
    if (filteredItems.length === 0) {
      return (0, import_react.createElement)(no_results_default, null);
    }
    return (0, import_react.createElement)(panel_default, {
      title: __("Reusable blocks")
    }, (0, import_react.createElement)(block_types_list_default, {
      items: filteredItems,
      onSelect: onSelectItem,
      onHover,
      label: __("Reusable blocks")
    }));
  }
  function ReusableBlocksTab(_ref32) {
    let {
      rootClientId,
      onInsert,
      onHover
    } = _ref32;
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(ReusableBlocksList, {
      onHover,
      onInsert,
      rootClientId
    }), (0, import_react.createElement)("div", {
      className: "block-editor-inserter__manage-reusable-blocks-container"
    }, (0, import_react.createElement)("a", {
      className: "block-editor-inserter__manage-reusable-blocks",
      href: addQueryArgs("edit.php", {
        post_type: "wp_block"
      })
    }, __("Manage Reusable blocks"))));
  }
  var reusable_blocks_tab_default = ReusableBlocksTab;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js
  var import_lodash31 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/components/inserter-menu-extension/index.js
  var {
    Fill: __unstableInserterMenuExtension,
    Slot: Slot6
  } = createSlotFill("__unstableInserterMenuExtension");
  __unstableInserterMenuExtension.Slot = Slot6;
  var inserter_menu_extension_default = __unstableInserterMenuExtension;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/search-results.js
  var INITIAL_INSERTER_RESULTS2 = 9;
  var EMPTY_ARRAY4 = [];
  function InserterSearchResults(_ref8) {
    let {
      filterValue,
      onSelect,
      onHover,
      rootClientId,
      clientId,
      isAppender,
      __experimentalInsertionIndex,
      maxBlockPatterns,
      maxBlockTypes,
      showBlockDirectory = false,
      isDraggable = true,
      shouldFocusBlock = true,
      prioritizePatterns
    } = _ref8;
    const debouncedSpeak = useDebounce(speak, 500);
    const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
      onSelect,
      rootClientId,
      clientId,
      isAppender,
      insertionIndex: __experimentalInsertionIndex,
      shouldFocusBlock
    });
    const [blockTypes2, blockTypeCategories, blockTypeCollections, onSelectBlockType] = use_block_types_state_default(destinationRootClientId, onInsertBlocks);
    const [patterns, , onSelectBlockPattern] = use_patterns_state_default(onInsertBlocks, destinationRootClientId);
    const filteredBlockPatterns = (0, import_react.useMemo)(() => {
      if (maxBlockPatterns === 0) {
        return [];
      }
      const results = searchItems(patterns, filterValue);
      return maxBlockPatterns !== void 0 ? results.slice(0, maxBlockPatterns) : results;
    }, [filterValue, patterns, maxBlockPatterns]);
    let maxBlockTypesToShow = maxBlockTypes;
    if (prioritizePatterns && filteredBlockPatterns.length > 2) {
      maxBlockTypesToShow = 0;
    }
    const filteredBlockTypes = (0, import_react.useMemo)(() => {
      if (maxBlockTypesToShow === 0) {
        return [];
      }
      const results = searchBlockItems((0, import_lodash31.orderBy)(blockTypes2, ["frecency"], ["desc"]), blockTypeCategories, blockTypeCollections, filterValue);
      return maxBlockTypesToShow !== void 0 ? results.slice(0, maxBlockTypesToShow) : results;
    }, [filterValue, blockTypes2, blockTypeCategories, blockTypeCollections, maxBlockTypes]);
    (0, import_react.useEffect)(() => {
      if (!filterValue) {
        return;
      }
      const count = filteredBlockTypes.length + filteredBlockPatterns.length;
      const resultsFoundMessage = sprintf(
        _n("%d result found.", "%d results found.", count),
        count
      );
      debouncedSpeak(resultsFoundMessage);
    }, [filterValue, debouncedSpeak]);
    const currentShownBlockTypes = use_async_list_default(filteredBlockTypes, {
      step: INITIAL_INSERTER_RESULTS2
    });
    const currentShownPatterns = use_async_list_default(currentShownBlockTypes.length === filteredBlockTypes.length ? filteredBlockPatterns : EMPTY_ARRAY4);
    const hasItems = !(0, import_lodash31.isEmpty)(filteredBlockTypes) || !(0, import_lodash31.isEmpty)(filteredBlockPatterns);
    const blocksUI = !!filteredBlockTypes.length && (0, import_react.createElement)(panel_default, {
      title: (0, import_react.createElement)(component_default2, null, __("Blocks"))
    }, (0, import_react.createElement)(block_types_list_default, {
      items: currentShownBlockTypes,
      onSelect: onSelectBlockType,
      onHover,
      label: __("Blocks"),
      isDraggable
    }));
    const patternsUI = !!filteredBlockPatterns.length && (0, import_react.createElement)(panel_default, {
      title: (0, import_react.createElement)(component_default2, null, __("Block Patterns"))
    }, (0, import_react.createElement)("div", {
      className: "block-editor-inserter__quick-inserter-patterns"
    }, (0, import_react.createElement)(block_patterns_list_default, {
      shownPatterns: currentShownPatterns,
      blockPatterns: filteredBlockPatterns,
      onClickPattern: onSelectBlockPattern,
      isDraggable
    })));
    return (0, import_react.createElement)(inserter_listbox_default, null, !showBlockDirectory && !hasItems && (0, import_react.createElement)(no_results_default, null), prioritizePatterns ? patternsUI : blocksUI, !!filteredBlockTypes.length && !!filteredBlockPatterns.length && (0, import_react.createElement)("div", {
      className: "block-editor-inserter__quick-inserter-separator"
    }), prioritizePatterns ? blocksUI : patternsUI, showBlockDirectory && (0, import_react.createElement)(inserter_menu_extension_default.Slot, {
      fillProps: {
        onSelect: onSelectBlockType,
        onHover,
        filterValue,
        hasItems,
        rootClientId: destinationRootClientId
      }
    }, (fills) => {
      if (fills.length) {
        return fills;
      }
      if (!hasItems) {
        return (0, import_react.createElement)(no_results_default, null);
      }
      return null;
    }));
  }
  var search_results_default = InserterSearchResults;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/tabs.js
  var blocksTab = {
    name: "blocks",
    title: __("Blocks")
  };
  var patternsTab = {
    name: "patterns",
    title: __("Patterns")
  };
  var reusableBlocksTab = {
    name: "reusable",
    title: __("Reusable")
  };
  function InserterTabs(_ref8) {
    let {
      children,
      showPatterns = false,
      showReusableBlocks = false,
      onSelect,
      prioritizePatterns
    } = _ref8;
    const tabs = (0, import_react.useMemo)(() => {
      const tempTabs = [];
      if (prioritizePatterns && showPatterns) {
        tempTabs.push(patternsTab);
      }
      tempTabs.push(blocksTab);
      if (!prioritizePatterns && showPatterns) {
        tempTabs.push(patternsTab);
      }
      if (showReusableBlocks) {
        tempTabs.push(reusableBlocksTab);
      }
      return tempTabs;
    }, [prioritizePatterns, blocksTab, showPatterns, patternsTab, showReusableBlocks, reusableBlocksTab]);
    return (0, import_react.createElement)(tab_panel_default, {
      className: "block-editor-inserter__tabs",
      tabs,
      onSelect
    }, children);
  }
  var tabs_default = InserterTabs;

  // node_modules/@wordpress/block-editor/build-module/components/inserter/menu.js
  function InserterMenu(_ref8, ref2) {
    let {
      rootClientId,
      clientId,
      isAppender,
      __experimentalInsertionIndex,
      onSelect,
      showInserterHelpPanel,
      showMostUsedBlocks,
      __experimentalFilterValue = "",
      shouldFocusBlock = true,
      prioritizePatterns
    } = _ref8;
    const [filterValue, setFilterValue] = (0, import_react.useState)(__experimentalFilterValue);
    const [hoveredItem, setHoveredItem] = (0, import_react.useState)(null);
    const [selectedPatternCategory, setSelectedPatternCategory] = (0, import_react.useState)(null);
    const [selectedTab, setSelectedTab] = (0, import_react.useState)(null);
    const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = use_insertion_point_default({
      rootClientId,
      clientId,
      isAppender,
      insertionIndex: __experimentalInsertionIndex,
      shouldFocusBlock
    });
    const {
      showPatterns,
      hasReusableBlocks
    } = useSelect((select2) => {
      var _getSettings$__experi;
      const {
        __experimentalGetAllowedPatterns: __experimentalGetAllowedPatterns2,
        getSettings: getSettings2
      } = select2(store3);
      return {
        showPatterns: !!__experimentalGetAllowedPatterns2(destinationRootClientId).length,
        hasReusableBlocks: !!((_getSettings$__experi = getSettings2().__experimentalReusableBlocks) !== null && _getSettings$__experi !== void 0 && _getSettings$__experi.length)
      };
    }, [destinationRootClientId]);
    const onInsert = (0, import_react.useCallback)((blocks2, meta, shouldForceFocusBlock) => {
      onInsertBlocks(blocks2, meta, shouldForceFocusBlock);
      onSelect();
    }, [onInsertBlocks, onSelect]);
    const onInsertPattern = (0, import_react.useCallback)((blocks2, patternName) => {
      onInsertBlocks(blocks2, {
        patternName
      });
      onSelect();
    }, [onInsertBlocks, onSelect]);
    const onHover = (0, import_react.useCallback)((item2) => {
      onToggleInsertionPoint(!!item2);
      setHoveredItem(item2);
    }, [onToggleInsertionPoint, setHoveredItem]);
    const onClickPatternCategory = (0, import_react.useCallback)((patternCategory) => {
      setSelectedPatternCategory(patternCategory);
    }, [setSelectedPatternCategory]);
    const blocksTab2 = (0, import_react.useMemo)(() => (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("div", {
      className: "block-editor-inserter__block-list"
    }, (0, import_react.createElement)(block_types_tab_default, {
      rootClientId: destinationRootClientId,
      onInsert,
      onHover,
      showMostUsedBlocks
    })), showInserterHelpPanel && (0, import_react.createElement)("div", {
      className: "block-editor-inserter__tips"
    }, (0, import_react.createElement)(component_default2, {
      as: "h2"
    }, __("A tip for using the block editor")), (0, import_react.createElement)(tips_default, null))), [destinationRootClientId, onInsert, onHover, filterValue, showMostUsedBlocks, showInserterHelpPanel]);
    const patternsTab2 = (0, import_react.useMemo)(() => (0, import_react.createElement)(block_patterns_tab_default, {
      rootClientId: destinationRootClientId,
      onInsert: onInsertPattern,
      onSelectCategory: onClickPatternCategory,
      selectedCategory: selectedPatternCategory
    }), [destinationRootClientId, onInsertPattern, onClickPatternCategory, selectedPatternCategory]);
    const reusableBlocksTab2 = (0, import_react.useMemo)(() => (0, import_react.createElement)(reusable_blocks_tab_default, {
      rootClientId: destinationRootClientId,
      onInsert,
      onHover
    }), [destinationRootClientId, onInsert, onHover]);
    const getCurrentTab = (0, import_react.useCallback)((tab) => {
      if (tab.name === "blocks") {
        return blocksTab2;
      } else if (tab.name === "patterns") {
        return patternsTab2;
      }
      return reusableBlocksTab2;
    }, [blocksTab2, patternsTab2, reusableBlocksTab2]);
    const searchRef = (0, import_react.useRef)();
    (0, import_react.useImperativeHandle)(ref2, () => ({
      focusSearch: () => {
        searchRef.current.focus();
      }
    }));
    const showPatternPanel = selectedTab === "patterns" && !filterValue && selectedPatternCategory;
    const showAsTabs = !filterValue && (showPatterns || hasReusableBlocks);
    return (0, import_react.createElement)("div", {
      className: "block-editor-inserter__menu"
    }, (0, import_react.createElement)("div", {
      className: (0, import_classnames32.default)("block-editor-inserter__main-area", {
        "show-as-tabs": showAsTabs
      })
    }, (0, import_react.createElement)(search_control_default, {
      className: "block-editor-inserter__search",
      onChange: (value) => {
        if (hoveredItem)
          setHoveredItem(null);
        setFilterValue(value);
      },
      value: filterValue,
      label: __("Search for blocks and patterns"),
      placeholder: __("Search"),
      ref: searchRef
    }), !!filterValue && (0, import_react.createElement)("div", {
      className: "block-editor-inserter__no-tab-container"
    }, (0, import_react.createElement)(search_results_default, {
      filterValue,
      onSelect,
      onHover,
      rootClientId,
      clientId,
      isAppender,
      __experimentalInsertionIndex,
      showBlockDirectory: true,
      shouldFocusBlock
    })), showAsTabs && (0, import_react.createElement)(tabs_default, {
      showPatterns,
      showReusableBlocks: hasReusableBlocks,
      prioritizePatterns,
      onSelect: setSelectedTab
    }, getCurrentTab), !filterValue && !showAsTabs && (0, import_react.createElement)("div", {
      className: "block-editor-inserter__no-tab-container"
    }, blocksTab2)), showInserterHelpPanel && hoveredItem && (0, import_react.createElement)(preview_panel_default, {
      item: hoveredItem
    }), showPatternPanel && (0, import_react.createElement)(BlockPatternsCategoryDialog, {
      rootClientId: destinationRootClientId,
      onInsert: onInsertPattern,
      category: selectedPatternCategory
    }));
  }
  var menu_default3 = (0, import_react.forwardRef)(InserterMenu);

  // node_modules/@wordpress/block-editor/build-module/components/inserter/quick-inserter.js
  var import_classnames33 = __toESM(require_classnames());
  var SEARCH_THRESHOLD = 6;
  var SHOWN_BLOCK_TYPES = 6;
  var SHOWN_BLOCK_PATTERNS = 2;
  var SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION = 4;
  function QuickInserter(_ref8) {
    let {
      onSelect,
      rootClientId,
      clientId,
      isAppender,
      prioritizePatterns
    } = _ref8;
    const [filterValue, setFilterValue] = (0, import_react.useState)("");
    const [destinationRootClientId, onInsertBlocks] = use_insertion_point_default({
      onSelect,
      rootClientId,
      clientId,
      isAppender
    });
    const [blockTypes2] = use_block_types_state_default(destinationRootClientId, onInsertBlocks);
    const [patterns] = use_patterns_state_default(onInsertBlocks, destinationRootClientId);
    const {
      setInserterIsOpened,
      insertionIndex
    } = useSelect((select2) => {
      const {
        getSettings: getSettings2,
        getBlockIndex: getBlockIndex2,
        getBlockCount: getBlockCount2
      } = select2(store3);
      const settings2 = getSettings2();
      const index2 = getBlockIndex2(clientId);
      const blockCount = getBlockCount2();
      return {
        setInserterIsOpened: settings2.__experimentalSetIsInserterOpened,
        insertionIndex: index2 === -1 ? blockCount : index2
      };
    }, [clientId]);
    const showPatterns = patterns.length && (!!filterValue || prioritizePatterns);
    const showSearch = showPatterns && patterns.length > SEARCH_THRESHOLD || blockTypes2.length > SEARCH_THRESHOLD;
    (0, import_react.useEffect)(() => {
      if (setInserterIsOpened) {
        setInserterIsOpened(false);
      }
    }, [setInserterIsOpened]);
    const onBrowseAll = () => {
      setInserterIsOpened({
        rootClientId,
        insertionIndex,
        filterValue
      });
    };
    let maxBlockPatterns = 0;
    if (showPatterns) {
      maxBlockPatterns = prioritizePatterns ? SHOWN_BLOCK_PATTERNS_WITH_PRIORITIZATION : SHOWN_BLOCK_PATTERNS;
    }
    return (0, import_react.createElement)("div", {
      className: (0, import_classnames33.default)("block-editor-inserter__quick-inserter", {
        "has-search": showSearch,
        "has-expand": setInserterIsOpened
      })
    }, showSearch && (0, import_react.createElement)(search_control_default, {
      className: "block-editor-inserter__search",
      value: filterValue,
      onChange: (value) => {
        setFilterValue(value);
      },
      label: __("Search for blocks and patterns"),
      placeholder: __("Search")
    }), (0, import_react.createElement)("div", {
      className: "block-editor-inserter__quick-inserter-results"
    }, (0, import_react.createElement)(search_results_default, {
      filterValue,
      onSelect,
      rootClientId,
      clientId,
      isAppender,
      maxBlockPatterns,
      maxBlockTypes: SHOWN_BLOCK_TYPES,
      isDraggable: false,
      prioritizePatterns
    })), setInserterIsOpened && (0, import_react.createElement)(button_default, {
      className: "block-editor-inserter__quick-inserter-expand",
      onClick: onBrowseAll,
      "aria-label": __("Browse all. This will open the main inserter panel in the editor toolbar.")
    }, __("Browse all")));
  }

  // node_modules/@wordpress/block-editor/build-module/components/inserter/index.js
  var defaultRenderToggle = (_ref8) => {
    let {
      onToggle,
      disabled,
      isOpen,
      blockTitle,
      hasSingleBlockType,
      toggleProps = {},
      prioritizePatterns
    } = _ref8;
    let label;
    if (hasSingleBlockType) {
      label = sprintf(
        _x("Add %s", "directly add the only allowed block"),
        blockTitle
      );
    } else if (prioritizePatterns) {
      label = __("Add pattern");
    } else {
      label = _x("Add block", "Generic label for block inserter button");
    }
    const {
      onClick,
      ...rest
    } = toggleProps;
    function handleClick(event) {
      if (onToggle) {
        onToggle(event);
      }
      if (onClick) {
        onClick(event);
      }
    }
    return (0, import_react.createElement)(button_default, _extends({
      icon: plus_default,
      label,
      tooltipPosition: "bottom",
      onClick: handleClick,
      className: "block-editor-inserter__toggle",
      "aria-haspopup": !hasSingleBlockType ? "true" : false,
      "aria-expanded": !hasSingleBlockType ? isOpen : false,
      disabled
    }, rest));
  };
  var Inserter = class extends import_react.Component {
    constructor() {
      super(...arguments);
      this.onToggle = this.onToggle.bind(this);
      this.renderToggle = this.renderToggle.bind(this);
      this.renderContent = this.renderContent.bind(this);
    }
    onToggle(isOpen) {
      const {
        onToggle
      } = this.props;
      if (onToggle) {
        onToggle(isOpen);
      }
    }
    renderToggle(_ref22) {
      let {
        onToggle,
        isOpen
      } = _ref22;
      const {
        disabled,
        blockTitle,
        hasSingleBlockType,
        directInsertBlock,
        toggleProps,
        hasItems,
        renderToggle = defaultRenderToggle,
        prioritizePatterns
      } = this.props;
      return renderToggle({
        onToggle,
        isOpen,
        disabled: disabled || !hasItems,
        blockTitle,
        hasSingleBlockType,
        directInsertBlock,
        toggleProps,
        prioritizePatterns
      });
    }
    renderContent(_ref32) {
      let {
        onClose
      } = _ref32;
      const {
        rootClientId,
        clientId,
        isAppender,
        showInserterHelpPanel,
        __experimentalIsQuick: isQuick,
        prioritizePatterns
      } = this.props;
      if (isQuick) {
        return (0, import_react.createElement)(QuickInserter, {
          onSelect: () => {
            onClose();
          },
          rootClientId,
          clientId,
          isAppender,
          prioritizePatterns
        });
      }
      return (0, import_react.createElement)(menu_default3, {
        onSelect: () => {
          onClose();
        },
        rootClientId,
        clientId,
        isAppender,
        showInserterHelpPanel,
        prioritizePatterns
      });
    }
    render() {
      const {
        position,
        hasSingleBlockType,
        directInsertBlock,
        insertOnlyAllowedBlock,
        __experimentalIsQuick: isQuick,
        onSelectOrClose
      } = this.props;
      if (hasSingleBlockType || directInsertBlock) {
        return this.renderToggle({
          onToggle: insertOnlyAllowedBlock
        });
      }
      return (0, import_react.createElement)(Dropdown, {
        className: "block-editor-inserter",
        contentClassName: (0, import_classnames34.default)("block-editor-inserter__popover", {
          "is-quick": isQuick
        }),
        position,
        onToggle: this.onToggle,
        expandOnMobile: true,
        headerTitle: __("Add a block"),
        renderToggle: this.renderToggle,
        renderContent: this.renderContent,
        onClose: onSelectOrClose
      });
    }
  };
  var inserter_default = compose_default([
    with_select_default((select2, _ref42) => {
      var _getBlockVariations;
      let {
        clientId,
        rootClientId
      } = _ref42;
      const {
        getBlockRootClientId: getBlockRootClientId2,
        hasInserterItems: hasInserterItems2,
        __experimentalGetAllowedBlocks: __experimentalGetAllowedBlocks2,
        __experimentalGetDirectInsertBlock: __experimentalGetDirectInsertBlock2,
        getSettings: getSettings2
      } = select2(store3);
      const {
        getBlockVariations: getBlockVariations3
      } = select2(store);
      rootClientId = rootClientId || getBlockRootClientId2(clientId) || void 0;
      const allowedBlocks = __experimentalGetAllowedBlocks2(rootClientId);
      const directInsertBlock = __experimentalGetDirectInsertBlock2(rootClientId);
      const settings2 = getSettings2();
      const hasSingleBlockType = (allowedBlocks === null || allowedBlocks === void 0 ? void 0 : allowedBlocks.length) === 1 && ((_getBlockVariations = getBlockVariations3(allowedBlocks[0].name, "inserter")) === null || _getBlockVariations === void 0 ? void 0 : _getBlockVariations.length) === 0;
      let allowedBlockType = false;
      if (hasSingleBlockType) {
        allowedBlockType = allowedBlocks[0];
      }
      return {
        hasItems: hasInserterItems2(rootClientId),
        hasSingleBlockType,
        blockTitle: allowedBlockType ? allowedBlockType.title : "",
        allowedBlockType,
        directInsertBlock,
        rootClientId,
        prioritizePatterns: settings2.__experimentalPreferPatternsOnRoot && !rootClientId
      };
    }),
    with_dispatch_default((dispatch2, ownProps, _ref52) => {
      let {
        select: select2
      } = _ref52;
      return {
        insertOnlyAllowedBlock() {
          const {
            rootClientId,
            clientId,
            isAppender,
            hasSingleBlockType,
            allowedBlockType,
            directInsertBlock,
            onSelectOrClose
          } = ownProps;
          if (!hasSingleBlockType && !directInsertBlock) {
            return;
          }
          function getAdjacentBlockAttributes(attributesToCopy) {
            const {
              getBlock: getBlock2,
              getPreviousBlockClientId: getPreviousBlockClientId2
            } = select2(store3);
            if (!attributesToCopy || !clientId && !rootClientId) {
              return {};
            }
            const result = {};
            let adjacentAttributes = {};
            if (!clientId) {
              var _parentBlock$innerBlo;
              const parentBlock = getBlock2(rootClientId);
              if (parentBlock !== null && parentBlock !== void 0 && (_parentBlock$innerBlo = parentBlock.innerBlocks) !== null && _parentBlock$innerBlo !== void 0 && _parentBlock$innerBlo.length) {
                const lastInnerBlock = parentBlock.innerBlocks[parentBlock.innerBlocks.length - 1];
                if (directInsertBlock && (directInsertBlock === null || directInsertBlock === void 0 ? void 0 : directInsertBlock.name) === lastInnerBlock.name) {
                  adjacentAttributes = lastInnerBlock.attributes;
                }
              }
            } else {
              const currentBlock = getBlock2(clientId);
              const previousBlock = getBlock2(getPreviousBlockClientId2(clientId));
              if ((currentBlock === null || currentBlock === void 0 ? void 0 : currentBlock.name) === (previousBlock === null || previousBlock === void 0 ? void 0 : previousBlock.name)) {
                adjacentAttributes = (previousBlock === null || previousBlock === void 0 ? void 0 : previousBlock.attributes) || {};
              }
            }
            attributesToCopy.forEach((attribute) => {
              if (adjacentAttributes.hasOwnProperty(attribute)) {
                result[attribute] = adjacentAttributes[attribute];
              }
            });
            return result;
          }
          function getInsertionIndex() {
            const {
              getBlockIndex: getBlockIndex2,
              getBlockSelectionEnd: getBlockSelectionEnd2,
              getBlockOrder: getBlockOrder2,
              getBlockRootClientId: getBlockRootClientId2
            } = select2(store3);
            if (clientId) {
              return getBlockIndex2(clientId);
            }
            const end = getBlockSelectionEnd2();
            if (!isAppender && end && getBlockRootClientId2(end) === rootClientId) {
              return getBlockIndex2(end) + 1;
            }
            return getBlockOrder2(rootClientId).length;
          }
          const {
            insertBlock: insertBlock2
          } = dispatch2(store3);
          let blockToInsert;
          if (directInsertBlock) {
            const newAttributes = getAdjacentBlockAttributes(directInsertBlock.attributesToCopy);
            blockToInsert = createBlock(directInsertBlock.name, {
              ...directInsertBlock.attributes || {},
              ...newAttributes
            });
          } else {
            blockToInsert = createBlock(allowedBlockType.name);
          }
          insertBlock2(blockToInsert, getInsertionIndex(), rootClientId);
          if (onSelectOrClose) {
            onSelectOrClose();
          }
          const message = sprintf(
            __("%s block added"),
            allowedBlockType.title
          );
          speak(message);
        }
      };
    }),
    if_condition_default((_ref62) => {
      let {
        hasItems,
        isAppender,
        rootClientId,
        clientId
      } = _ref62;
      return hasItems || !isAppender && !rootClientId && !clientId;
    })
  ])(Inserter);

  // node_modules/@wordpress/block-editor/build-module/components/default-block-appender/index.js
  var ZWNBSP2 = "\uFEFF";
  function DefaultBlockAppender(_ref8) {
    let {
      isLocked,
      onAppend,
      showPrompt,
      placeholder,
      rootClientId
    } = _ref8;
    if (isLocked) {
      return null;
    }
    const value = decodeEntities(placeholder) || __("Type / to choose a block");
    return (0, import_react.createElement)("div", {
      "data-root-client-id": rootClientId || "",
      className: (0, import_classnames35.default)("block-editor-default-block-appender", {
        "has-visible-prompt": showPrompt
      })
    }, (0, import_react.createElement)("p", {
      tabIndex: "0",
      role: "button",
      "aria-label": __("Add default block"),
      className: "block-editor-default-block-appender__content",
      onKeyDown: (event) => {
        if (ENTER === event.keyCode || SPACE === event.keyCode) {
          onAppend();
        }
      },
      onClick: () => onAppend(),
      onFocus: () => {
        if (showPrompt) {
          onAppend();
        }
      }
    }, showPrompt ? value : ZWNBSP2), (0, import_react.createElement)(inserter_default, {
      rootClientId,
      position: "bottom right",
      isAppender: true,
      __experimentalIsQuick: true
    }));
  }
  var default_block_appender_default = compose_default(with_select_default((select2, ownProps) => {
    const {
      getBlockCount: getBlockCount2,
      getSettings: getSettings2,
      getTemplateLock: getTemplateLock2
    } = select2(store3);
    const isEmpty8 = !getBlockCount2(ownProps.rootClientId);
    const {
      bodyPlaceholder
    } = getSettings2();
    return {
      showPrompt: isEmpty8,
      isLocked: !!getTemplateLock2(ownProps.rootClientId),
      placeholder: bodyPlaceholder
    };
  }), with_dispatch_default((dispatch2, ownProps) => {
    const {
      insertDefaultBlock: insertDefaultBlock2,
      startTyping: startTyping2
    } = dispatch2(store3);
    return {
      onAppend() {
        const {
          rootClientId
        } = ownProps;
        insertDefaultBlock2(void 0, rootClientId);
        startTyping2();
      }
    };
  }))(DefaultBlockAppender);

  // node_modules/@wordpress/block-editor/build-module/components/button-block-appender/index.js
  var import_classnames36 = __toESM(require_classnames());
  function ButtonBlockAppender(_ref8, ref2) {
    let {
      rootClientId,
      className,
      onFocus,
      tabIndex
    } = _ref8;
    return (0, import_react.createElement)(inserter_default, {
      position: "bottom center",
      rootClientId,
      __experimentalIsQuick: true,
      renderToggle: (_ref22) => {
        let {
          onToggle,
          disabled,
          isOpen,
          blockTitle,
          hasSingleBlockType
        } = _ref22;
        let label;
        if (hasSingleBlockType) {
          label = sprintf(
            _x("Add %s", "directly add the only allowed block"),
            blockTitle
          );
        } else {
          label = _x("Add block", "Generic label for block inserter button");
        }
        const isToggleButton = !hasSingleBlockType;
        let inserterButton = (0, import_react.createElement)(button_default, {
          ref: ref2,
          onFocus,
          tabIndex,
          className: (0, import_classnames36.default)(className, "block-editor-button-block-appender"),
          onClick: onToggle,
          "aria-haspopup": isToggleButton ? "true" : void 0,
          "aria-expanded": isToggleButton ? isOpen : void 0,
          disabled,
          label
        }, !hasSingleBlockType && (0, import_react.createElement)(component_default2, {
          as: "span"
        }, label), (0, import_react.createElement)(icon_default, {
          icon: plus_default
        }));
        if (isToggleButton || hasSingleBlockType) {
          inserterButton = (0, import_react.createElement)(tooltip_default, {
            text: label
          }, inserterButton);
        }
        return inserterButton;
      },
      isAppender: true
    });
  }
  var ButtonBlockerAppender = (0, import_react.forwardRef)((props, ref2) => {
    deprecated(`wp.blockEditor.ButtonBlockerAppender`, {
      alternative: "wp.blockEditor.ButtonBlockAppender",
      since: "5.9"
    });
    return ButtonBlockAppender(props, ref2);
  });
  var button_block_appender_default = (0, import_react.forwardRef)(ButtonBlockAppender);

  // node_modules/@wordpress/block-editor/build-module/components/block-list-appender/index.js
  function BlockListAppender(_ref8) {
    let {
      rootClientId,
      renderAppender: CustomAppender,
      className,
      tagName: TagName = "div"
    } = _ref8;
    const {
      hideInserter,
      canInsertDefaultBlock,
      selectedBlockClientId
    } = useSelect((select2) => {
      const {
        canInsertBlockType: canInsertBlockType2,
        getTemplateLock: getTemplateLock2,
        getSelectedBlockClientId: getSelectedBlockClientId2,
        __unstableGetEditorMode: __unstableGetEditorMode2
      } = select2(store3);
      return {
        hideInserter: !!getTemplateLock2(rootClientId) || __unstableGetEditorMode2() === "zoom-out",
        canInsertDefaultBlock: canInsertBlockType2(getDefaultBlockName(), rootClientId),
        selectedBlockClientId: getSelectedBlockClientId2()
      };
    }, [rootClientId]);
    if (hideInserter || CustomAppender === false) {
      return null;
    }
    let appender;
    if (CustomAppender) {
      appender = (0, import_react.createElement)(CustomAppender, null);
    } else {
      const isParentSelected = selectedBlockClientId === rootClientId || !rootClientId && !selectedBlockClientId;
      if (!isParentSelected) {
        return null;
      }
      if (canInsertDefaultBlock) {
        appender = (0, import_react.createElement)(default_block_appender_default, {
          rootClientId
        });
      } else {
        appender = (0, import_react.createElement)(button_block_appender_default, {
          rootClientId,
          className: "block-list-appender__toggle"
        });
      }
    }
    return (0, import_react.createElement)(
      TagName,
      {
        tabIndex: -1,
        className: (0, import_classnames37.default)("block-list-appender wp-block", className),
        contentEditable: false,
        "data-block": true
      },
      appender
    );
  }
  var block_list_appender_default = BlockListAppender;

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js
  var import_classnames39 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-popover/inbetween.js
  var import_classnames38 = __toESM(require_classnames());
  var MAX_POPOVER_RECOMPUTE_COUNTER2 = Number.MAX_SAFE_INTEGER;
  var InsertionPointOpenRef = (0, import_react.createContext)();
  function BlockPopoverInbetween(_ref8) {
    let {
      previousClientId,
      nextClientId,
      children,
      __unstablePopoverSlot,
      __unstableContentRef,
      ...props
    } = _ref8;
    const [popoverRecomputeCounter, forcePopoverRecompute] = (0, import_react.useReducer)(
      (s5) => (s5 + 1) % MAX_POPOVER_RECOMPUTE_COUNTER2,
      0
    );
    const {
      orientation,
      rootClientId,
      isVisible: isVisible3
    } = useSelect((select2) => {
      var _getBlockListSettings;
      const {
        getBlockListSettings: getBlockListSettings2,
        getBlockRootClientId: getBlockRootClientId2,
        isBlockVisible: isBlockVisible2
      } = select2(store3);
      const _rootClientId = getBlockRootClientId2(previousClientId !== null && previousClientId !== void 0 ? previousClientId : nextClientId);
      return {
        orientation: ((_getBlockListSettings = getBlockListSettings2(_rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || "vertical",
        rootClientId: _rootClientId,
        isVisible: isBlockVisible2(previousClientId) && isBlockVisible2(nextClientId)
      };
    }, [previousClientId, nextClientId]);
    const previousElement = useBlockElement(previousClientId);
    const nextElement = useBlockElement(nextClientId);
    const isVertical = orientation === "vertical";
    const style = (0, import_react.useMemo)(() => {
      if (popoverRecomputeCounter < 0 || !previousElement && !nextElement || !isVisible3) {
        return {};
      }
      const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
      const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;
      if (isVertical) {
        return {
          width: previousRect ? previousRect.width : nextRect.width,
          height: nextRect && previousRect ? nextRect.top - previousRect.bottom : 0
        };
      }
      let width3 = 0;
      if (previousRect && nextRect) {
        width3 = isRTL() ? previousRect.left - nextRect.right : nextRect.left - previousRect.right;
      }
      return {
        width: width3,
        height: previousRect ? previousRect.height : nextRect.height
      };
    }, [previousElement, nextElement, isVertical, popoverRecomputeCounter, isVisible3]);
    const popoverAnchor = (0, import_react.useMemo)(() => {
      if (popoverRecomputeCounter < 0 || !previousElement && !nextElement || !isVisible3) {
        return void 0;
      }
      const {
        ownerDocument
      } = previousElement || nextElement;
      return {
        ownerDocument,
        getBoundingClientRect() {
          const previousRect = previousElement ? previousElement.getBoundingClientRect() : null;
          const nextRect = nextElement ? nextElement.getBoundingClientRect() : null;
          let left = 0;
          let top = 0;
          if (isVertical) {
            top = previousRect ? previousRect.bottom : nextRect.top;
            if (isRTL()) {
              left = previousRect ? previousRect.right : nextRect.right;
            } else {
              left = previousRect ? previousRect.left : nextRect.left;
            }
          } else {
            top = previousRect ? previousRect.top : nextRect.top;
            if (isRTL()) {
              left = previousRect ? previousRect.left : nextRect.right;
            } else {
              left = previousRect ? previousRect.right : nextRect.left;
            }
          }
          return new window.DOMRect(left, top, 0, 0);
        }
      };
    }, [previousElement, nextElement, popoverRecomputeCounter, isVertical, isVisible3]);
    const popoverScrollRef = use_popover_scroll_default(__unstableContentRef);
    (0, import_react.useLayoutEffect)(() => {
      if (!previousElement) {
        return;
      }
      const observer = new window.MutationObserver(forcePopoverRecompute);
      observer.observe(previousElement, {
        attributes: true
      });
      return () => {
        observer.disconnect();
      };
    }, [previousElement]);
    (0, import_react.useLayoutEffect)(() => {
      if (!nextElement) {
        return;
      }
      const observer = new window.MutationObserver(forcePopoverRecompute);
      observer.observe(nextElement, {
        attributes: true
      });
      return () => {
        observer.disconnect();
      };
    }, [nextElement]);
    (0, import_react.useLayoutEffect)(() => {
      if (!previousElement) {
        return;
      }
      previousElement.ownerDocument.defaultView.addEventListener("resize", forcePopoverRecompute);
      return () => {
        var _previousElement$owne;
        (_previousElement$owne = previousElement.ownerDocument.defaultView) === null || _previousElement$owne === void 0 ? void 0 : _previousElement$owne.removeEventListener("resize", forcePopoverRecompute);
      };
    }, [previousElement]);
    if (!previousElement && !nextElement || !isVisible3) {
      return null;
    }
    return (0, import_react.createElement)(popover_default, _extends({
      ref: popoverScrollRef,
      animate: false,
      anchor: popoverAnchor,
      focusOnMount: false,
      __unstableSlotName: __unstablePopoverSlot || null,
      key: nextClientId + "--" + rootClientId
    }, props, {
      className: (0, import_classnames38.default)("block-editor-block-popover", "block-editor-block-popover__inbetween", props.className),
      resize: false,
      flip: false,
      placement: "bottom-start",
      variant: "unstyled"
    }), (0, import_react.createElement)("div", {
      className: "block-editor-block-popover__inbetween-container",
      style
    }, children));
  }
  var inbetween_default = BlockPopoverInbetween;

  // node_modules/@wordpress/block-editor/build-module/components/block-popover/drop-zone.js
  var animateVariants = {
    hide: {
      opacity: 0,
      scaleY: 0.75
    },
    show: {
      opacity: 1,
      scaleY: 1
    },
    exit: {
      opacity: 0,
      scaleY: 0.9
    }
  };
  function BlockDropZonePopover(_ref8) {
    let {
      __unstablePopoverSlot,
      __unstableContentRef
    } = _ref8;
    const {
      clientId
    } = useSelect((select2) => {
      const {
        getBlockOrder: getBlockOrder2,
        getBlockInsertionPoint: getBlockInsertionPoint2
      } = select2(store3);
      const insertionPoint2 = getBlockInsertionPoint2();
      const order2 = getBlockOrder2(insertionPoint2.rootClientId);
      if (!order2.length) {
        return {};
      }
      return {
        clientId: order2[insertionPoint2.index]
      };
    }, []);
    const reducedMotion = use_reduced_motion_default();
    return (0, import_react.createElement)(block_popover_default, {
      clientId,
      __unstableCoverTarget: true,
      __unstablePopoverSlot,
      __unstableContentRef,
      className: "block-editor-block-popover__drop-zone"
    }, (0, import_react.createElement)(motion.div, {
      "data-testid": "block-popover-drop-zone",
      initial: reducedMotion ? animateVariants.show : animateVariants.hide,
      animate: animateVariants.show,
      exit: reducedMotion ? animateVariants.show : animateVariants.exit,
      className: "block-editor-block-popover__drop-zone-foreground"
    }));
  }
  var drop_zone_default = BlockDropZonePopover;

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/insertion-point.js
  var InsertionPointOpenRef2 = (0, import_react.createContext)();
  function InbetweenInsertionPointPopover(_ref8) {
    let {
      __unstablePopoverSlot,
      __unstableContentRef
    } = _ref8;
    const {
      selectBlock: selectBlock2,
      hideInsertionPoint: hideInsertionPoint2
    } = use_dispatch_default(store3);
    const openRef = (0, import_react.useContext)(InsertionPointOpenRef2);
    const ref2 = (0, import_react.useRef)();
    const {
      orientation,
      previousClientId,
      nextClientId,
      rootClientId,
      isInserterShown,
      isDistractionFree,
      isNavigationMode: isNavigationMode2
    } = useSelect((select2) => {
      var _getBlockListSettings;
      const {
        getBlockOrder: getBlockOrder2,
        getBlockListSettings: getBlockListSettings2,
        getBlockInsertionPoint: getBlockInsertionPoint2,
        isBlockBeingDragged: isBlockBeingDragged2,
        getPreviousBlockClientId: getPreviousBlockClientId2,
        getNextBlockClientId: getNextBlockClientId2,
        getSettings: getSettings2,
        isNavigationMode: _isNavigationMode
      } = select2(store3);
      const insertionPoint2 = getBlockInsertionPoint2();
      const order2 = getBlockOrder2(insertionPoint2.rootClientId);
      if (!order2.length) {
        return {};
      }
      let _previousClientId = order2[insertionPoint2.index - 1];
      let _nextClientId = order2[insertionPoint2.index];
      while (isBlockBeingDragged2(_previousClientId)) {
        _previousClientId = getPreviousBlockClientId2(_previousClientId);
      }
      while (isBlockBeingDragged2(_nextClientId)) {
        _nextClientId = getNextBlockClientId2(_nextClientId);
      }
      const settings2 = getSettings2();
      return {
        previousClientId: _previousClientId,
        nextClientId: _nextClientId,
        orientation: ((_getBlockListSettings = getBlockListSettings2(insertionPoint2.rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || "vertical",
        rootClientId: insertionPoint2.rootClientId,
        isNavigationMode: _isNavigationMode(),
        isDistractionFree: settings2.isDistractionFree,
        isInserterShown: insertionPoint2 === null || insertionPoint2 === void 0 ? void 0 : insertionPoint2.__unstableWithInserter
      };
    }, []);
    const isVertical = orientation === "vertical";
    const disableMotion = use_reduced_motion_default();
    function onClick(event) {
      if (event.target === ref2.current && nextClientId) {
        selectBlock2(nextClientId, -1);
      }
    }
    function maybeHideInserterPoint(event) {
      if (event.target === ref2.current && !openRef.current) {
        hideInsertionPoint2();
      }
    }
    function onFocus(event) {
      if (event.target !== ref2.current) {
        openRef.current = true;
      }
    }
    const horizontalLine = {
      start: {
        width: 0,
        top: "50%",
        bottom: "50%",
        x: 0
      },
      rest: {
        width: 4,
        top: 0,
        bottom: 0,
        x: -2
      },
      hover: {
        width: 4,
        top: 0,
        bottom: 0,
        x: -2
      }
    };
    const verticalLine = {
      start: {
        height: 0,
        left: "50%",
        right: "50%",
        y: 0
      },
      rest: {
        height: 4,
        left: 0,
        right: 0,
        y: -2
      },
      hover: {
        height: 4,
        left: 0,
        right: 0,
        y: -2
      }
    };
    const lineVariants = {
      start: {
        ...!isVertical ? horizontalLine.start : verticalLine.start,
        opacity: 0
      },
      rest: {
        ...!isVertical ? horizontalLine.rest : verticalLine.rest,
        opacity: 1,
        borderRadius: "2px",
        transition: {
          delay: isInserterShown ? 0.5 : 0,
          type: "tween"
        }
      },
      hover: {
        ...!isVertical ? horizontalLine.hover : verticalLine.hover,
        opacity: 1,
        borderRadius: "2px",
        transition: {
          delay: 0.5,
          type: "tween"
        }
      }
    };
    const inserterVariants = {
      start: {
        scale: disableMotion ? 1 : 0
      },
      rest: {
        scale: 1,
        transition: {
          delay: 0.4,
          type: "tween"
        }
      }
    };
    if (isDistractionFree && !isNavigationMode2) {
      return null;
    }
    const className = (0, import_classnames39.default)("block-editor-block-list__insertion-point", "is-" + orientation);
    return (0, import_react.createElement)(inbetween_default, {
      previousClientId,
      nextClientId,
      __unstablePopoverSlot,
      __unstableContentRef
    }, (0, import_react.createElement)(motion.div, {
      layout: !disableMotion,
      initial: disableMotion ? "rest" : "start",
      animate: "rest",
      whileHover: "hover",
      whileTap: "pressed",
      exit: "start",
      ref: ref2,
      tabIndex: -1,
      onClick,
      onFocus,
      className: (0, import_classnames39.default)(className, {
        "is-with-inserter": isInserterShown
      }),
      onHoverEnd: maybeHideInserterPoint
    }, (0, import_react.createElement)(motion.div, {
      variants: lineVariants,
      className: "block-editor-block-list__insertion-point-indicator",
      "data-testid": "block-list-insertion-point-indicator"
    }), isInserterShown && (0, import_react.createElement)(motion.div, {
      variants: inserterVariants,
      className: (0, import_classnames39.default)("block-editor-block-list__insertion-point-inserter")
    }, (0, import_react.createElement)(inserter_default, {
      position: "bottom center",
      clientId: nextClientId,
      rootClientId,
      __experimentalIsQuick: true,
      onToggle: (isOpen) => {
        openRef.current = isOpen;
      },
      onSelectOrClose: () => {
        openRef.current = false;
      }
    }))));
  }
  function InsertionPoint(props) {
    const {
      insertionPoint: insertionPoint2,
      isVisible: isVisible3
    } = useSelect((select2) => {
      const {
        getBlockInsertionPoint: getBlockInsertionPoint2,
        isBlockInsertionPointVisible: isBlockInsertionPointVisible2
      } = select2(store3);
      return {
        insertionPoint: getBlockInsertionPoint2(),
        isVisible: isBlockInsertionPointVisible2()
      };
    }, []);
    if (!isVisible3) {
      return null;
    }
    return insertionPoint2.operation === "replace" ? (0, import_react.createElement)(
      drop_zone_default,
      _extends({
        key: `${insertionPoint2.rootClientId}-${insertionPoint2.index}`
      }, props)
    ) : (0, import_react.createElement)(InbetweenInsertionPointPopover, props);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-list/use-in-between-inserter.js
  function useInBetweenInserter() {
    const openRef = (0, import_react.useContext)(InsertionPointOpenRef2);
    const isInBetweenInserterDisabled = useSelect((select2) => select2(store3).getSettings().isDistractionFree || select2(store3).__unstableGetEditorMode() === "zoom-out", []);
    const {
      getBlockListSettings: getBlockListSettings2,
      getBlockRootClientId: getBlockRootClientId2,
      getBlockIndex: getBlockIndex2,
      isBlockInsertionPointVisible: isBlockInsertionPointVisible2,
      isMultiSelecting: isMultiSelecting3,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getTemplateLock: getTemplateLock2,
      __unstableIsWithinBlockOverlay: __unstableIsWithinBlockOverlay2
    } = useSelect(store3);
    const {
      showInsertionPoint: showInsertionPoint2,
      hideInsertionPoint: hideInsertionPoint2
    } = use_dispatch_default(store3);
    return useRefEffect((node) => {
      if (isInBetweenInserterDisabled) {
        return;
      }
      function onMouseMove(event) {
        var _getBlockListSettings;
        if (openRef.current) {
          return;
        }
        if (isMultiSelecting3()) {
          return;
        }
        if (!event.target.classList.contains("block-editor-block-list__layout")) {
          hideInsertionPoint2();
          return;
        }
        let rootClientId;
        if (!event.target.classList.contains("is-root-container")) {
          const blockElement = !!event.target.getAttribute("data-block") ? event.target : event.target.closest("[data-block]");
          rootClientId = blockElement.getAttribute("data-block");
        }
        if (getTemplateLock2(rootClientId)) {
          return;
        }
        const orientation = ((_getBlockListSettings = getBlockListSettings2(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation) || "vertical";
        const offsetTop = event.clientY;
        const offsetLeft = event.clientX;
        const children = Array.from(event.target.children);
        let element = children.find((blockEl) => {
          const blockElRect = blockEl.getBoundingClientRect();
          return blockEl.classList.contains("wp-block") && orientation === "vertical" && blockElRect.top > offsetTop || blockEl.classList.contains("wp-block") && orientation === "horizontal" && blockElRect.left > offsetLeft;
        });
        if (!element) {
          hideInsertionPoint2();
          return;
        }
        if (!element.id) {
          element = element.firstElementChild;
          if (!element) {
            hideInsertionPoint2();
            return;
          }
        }
        const clientId = element.id.slice("block-".length);
        if (!clientId || __unstableIsWithinBlockOverlay2(clientId)) {
          return;
        }
        if (getSelectedBlockClientIds2().includes(clientId)) {
          return;
        }
        const elementRect = element.getBoundingClientRect();
        if (orientation === "horizontal" && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === "vertical" && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
          hideInsertionPoint2();
          return;
        }
        const index2 = getBlockIndex2(clientId);
        if (index2 === 0) {
          hideInsertionPoint2();
          return;
        }
        showInsertionPoint2(rootClientId, index2, {
          __unstableWithInserter: true
        });
      }
      node.addEventListener("mousemove", onMouseMove);
      return () => {
        node.removeEventListener("mousemove", onMouseMove);
      };
    }, [openRef, getBlockListSettings2, getBlockRootClientId2, getBlockIndex2, isBlockInsertionPointVisible2, isMultiSelecting3, showInsertionPoint2, hideInsertionPoint2, getSelectedBlockClientIds2, isInBetweenInserterDisabled]);
  }

  // node_modules/@wordpress/block-editor/build-module/utils/pre-parse-patterns.js
  var requestIdleCallback = (() => {
    if (typeof window === "undefined") {
      return (callback) => {
        setTimeout(() => callback(Date.now()), 0);
      };
    }
    return window.requestIdleCallback || window.requestAnimationFrame;
  })();
  var cancelIdleCallback = (() => {
    if (typeof window === "undefined") {
      return clearTimeout;
    }
    return window.cancelIdleCallback || window.cancelAnimationFrame;
  })();
  function usePreParsePatterns() {
    const {
      patterns,
      isPreviewMode
    } = useSelect((_select) => {
      const {
        __experimentalBlockPatterns,
        __unstableIsPreviewMode
      } = _select(store3).getSettings();
      return {
        patterns: __experimentalBlockPatterns,
        isPreviewMode: __unstableIsPreviewMode
      };
    }, []);
    (0, import_react.useEffect)(() => {
      if (isPreviewMode) {
        return;
      }
      if (!(patterns !== null && patterns !== void 0 && patterns.length)) {
        return;
      }
      let handle;
      let index2 = -1;
      const callback = () => {
        index2++;
        if (index2 >= patterns.length) {
          return;
        }
        select(store3).__experimentalGetParsedPattern(patterns[index2].name);
        handle = requestIdleCallback(callback);
      };
      handle = requestIdleCallback(callback);
      return () => cancelIdleCallback(handle);
    }, [patterns, isPreviewMode]);
    return null;
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/selected-block-popover.js
  var import_lodash33 = __toESM(require_lodash());
  var import_classnames44 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/block-selection-button.js
  var import_classnames41 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-mover/index.js
  var import_classnames40 = __toESM(require_classnames());
  function BlockMover(_ref8) {
    let {
      clientIds,
      hideDragHandle
    } = _ref8;
    const {
      canMove,
      rootClientId,
      isFirst,
      isLast,
      orientation
    } = useSelect((select2) => {
      var _getBlockListSettings;
      const {
        getBlockIndex: getBlockIndex2,
        getBlockListSettings: getBlockListSettings2,
        canMoveBlocks: canMoveBlocks2,
        getBlockOrder: getBlockOrder2,
        getBlockRootClientId: getBlockRootClientId2
      } = select2(store3);
      const normalizedClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
      const firstClientId = normalizedClientIds[0];
      const _rootClientId = getBlockRootClientId2(firstClientId);
      const firstIndex = getBlockIndex2(firstClientId);
      const lastIndex = getBlockIndex2(normalizedClientIds[normalizedClientIds.length - 1]);
      const blockOrder = getBlockOrder2(_rootClientId);
      return {
        canMove: canMoveBlocks2(clientIds, _rootClientId),
        rootClientId: _rootClientId,
        isFirst: firstIndex === 0,
        isLast: lastIndex === blockOrder.length - 1,
        orientation: (_getBlockListSettings = getBlockListSettings2(_rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation
      };
    }, [clientIds]);
    if (!canMove || isFirst && isLast && !rootClientId) {
      return null;
    }
    const dragHandleLabel = __("Drag");
    return (0, import_react.createElement)(toolbar_group_default, {
      className: (0, import_classnames40.default)("block-editor-block-mover", {
        "is-horizontal": orientation === "horizontal"
      })
    }, !hideDragHandle && (0, import_react.createElement)(block_draggable_default, {
      clientIds
    }, (draggableProps) => (0, import_react.createElement)(button_default, _extends({
      icon: drag_handle_default,
      className: "block-editor-block-mover__drag-handle",
      "aria-hidden": "true",
      label: dragHandleLabel,
      tabIndex: "-1"
    }, draggableProps))), (0, import_react.createElement)("div", {
      className: "block-editor-block-mover__move-button-container"
    }, (0, import_react.createElement)(toolbar_item_default, null, (itemProps) => (0, import_react.createElement)(BlockMoverUpButton, _extends({
      clientIds
    }, itemProps))), (0, import_react.createElement)(toolbar_item_default, null, (itemProps) => (0, import_react.createElement)(BlockMoverDownButton, _extends({
      clientIds
    }, itemProps)))));
  }
  var block_mover_default = BlockMover;

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/block-selection-button.js
  function BlockSelectionButton(_ref8) {
    let {
      clientId,
      rootClientId
    } = _ref8;
    const blockInformation = useBlockDisplayInformation(clientId);
    const selected = useSelect((select2) => {
      var _getBlockListSettings;
      const {
        getBlock: getBlock2,
        getBlockIndex: getBlockIndex3,
        hasBlockMovingClientId: hasBlockMovingClientId4,
        getBlockListSettings: getBlockListSettings2,
        __unstableGetEditorMode: __unstableGetEditorMode2
      } = select2(store3);
      const index3 = getBlockIndex3(clientId);
      const {
        name: name2,
        attributes: attributes2
      } = getBlock2(clientId);
      const blockMovingMode2 = hasBlockMovingClientId4();
      return {
        index: index3,
        name: name2,
        attributes: attributes2,
        blockMovingMode: blockMovingMode2,
        orientation: (_getBlockListSettings = getBlockListSettings2(rootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation,
        editorMode: __unstableGetEditorMode2()
      };
    }, [clientId, rootClientId]);
    const {
      index: index2,
      name,
      attributes,
      blockMovingMode,
      orientation,
      editorMode: editorMode2
    } = selected;
    const {
      setNavigationMode: setNavigationMode2,
      removeBlock: removeBlock2
    } = use_dispatch_default(store3);
    const ref2 = (0, import_react.useRef)();
    const blockType = getBlockType(name);
    const label = getAccessibleBlockLabel(blockType, attributes, index2 + 1, orientation);
    (0, import_react.useEffect)(() => {
      ref2.current.focus();
      speak(label);
    }, [label]);
    const blockElement = useBlockElement(clientId);
    const {
      hasBlockMovingClientId: hasBlockMovingClientId3,
      getBlockIndex: getBlockIndex2,
      getBlockRootClientId: getBlockRootClientId2,
      getClientIdsOfDescendants: getClientIdsOfDescendants2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getMultiSelectedBlocksEndClientId: getMultiSelectedBlocksEndClientId2,
      getPreviousBlockClientId: getPreviousBlockClientId2,
      getNextBlockClientId: getNextBlockClientId2
    } = useSelect(store3);
    const {
      selectBlock: selectBlock2,
      clearSelectedBlock: clearSelectedBlock2,
      setBlockMovingClientId: setBlockMovingClientId2,
      moveBlockToPosition: moveBlockToPosition2
    } = use_dispatch_default(store3);
    function onKeyDown(event) {
      const {
        keyCode
      } = event;
      const isUp = keyCode === UP;
      const isDown = keyCode === DOWN;
      const isLeft = keyCode === LEFT;
      const isRight = keyCode === RIGHT;
      const isTab = keyCode === TAB;
      const isEscape = keyCode === ESCAPE;
      const isEnter = keyCode === ENTER;
      const isSpace2 = keyCode === SPACE;
      const isShift = event.shiftKey;
      if (keyCode === BACKSPACE || keyCode === DELETE) {
        removeBlock2(clientId);
        event.preventDefault();
        return;
      }
      const selectedBlockClientId = getSelectedBlockClientId2();
      const selectionEndClientId = getMultiSelectedBlocksEndClientId2();
      const selectionBeforeEndClientId = getPreviousBlockClientId2(selectionEndClientId || selectedBlockClientId);
      const selectionAfterEndClientId = getNextBlockClientId2(selectionEndClientId || selectedBlockClientId);
      const navigateUp = isTab && isShift || isUp;
      const navigateDown = isTab && !isShift || isDown;
      const navigateOut = isLeft;
      const navigateIn = isRight;
      let focusedBlockUid;
      if (navigateUp) {
        focusedBlockUid = selectionBeforeEndClientId;
      } else if (navigateDown) {
        focusedBlockUid = selectionAfterEndClientId;
      } else if (navigateOut) {
        var _getBlockRootClientId;
        focusedBlockUid = (_getBlockRootClientId = getBlockRootClientId2(selectedBlockClientId)) !== null && _getBlockRootClientId !== void 0 ? _getBlockRootClientId : selectedBlockClientId;
      } else if (navigateIn) {
        var _getClientIdsOfDescen;
        focusedBlockUid = (_getClientIdsOfDescen = getClientIdsOfDescendants2([selectedBlockClientId])[0]) !== null && _getClientIdsOfDescen !== void 0 ? _getClientIdsOfDescen : selectedBlockClientId;
      }
      const startingBlockClientId = hasBlockMovingClientId3();
      if (isEscape && startingBlockClientId && !event.defaultPrevented) {
        setBlockMovingClientId2(null);
        event.preventDefault();
      }
      if ((isEnter || isSpace2) && startingBlockClientId) {
        const sourceRoot = getBlockRootClientId2(startingBlockClientId);
        const destRoot = getBlockRootClientId2(selectedBlockClientId);
        const sourceBlockIndex = getBlockIndex2(startingBlockClientId);
        let destinationBlockIndex = getBlockIndex2(selectedBlockClientId);
        if (sourceBlockIndex < destinationBlockIndex && sourceRoot === destRoot) {
          destinationBlockIndex -= 1;
        }
        moveBlockToPosition2(startingBlockClientId, sourceRoot, destRoot, destinationBlockIndex);
        selectBlock2(startingBlockClientId);
        setBlockMovingClientId2(null);
      }
      if (navigateDown || navigateUp || navigateOut || navigateIn) {
        if (focusedBlockUid) {
          event.preventDefault();
          selectBlock2(focusedBlockUid);
        } else if (isTab && selectedBlockClientId) {
          let nextTabbable;
          if (navigateDown) {
            nextTabbable = blockElement;
            do {
              nextTabbable = focus.tabbable.findNext(nextTabbable);
            } while (nextTabbable && blockElement.contains(nextTabbable));
            if (!nextTabbable) {
              nextTabbable = blockElement.ownerDocument.defaultView.frameElement;
              nextTabbable = focus.tabbable.findNext(nextTabbable);
            }
          } else {
            nextTabbable = focus.tabbable.findPrevious(blockElement);
          }
          if (nextTabbable) {
            event.preventDefault();
            nextTabbable.focus();
            clearSelectedBlock2();
          }
        }
      }
    }
    const classNames4 = (0, import_classnames41.default)("block-editor-block-list__block-selection-button", {
      "is-block-moving-mode": !!blockMovingMode
    });
    const dragHandleLabel = __("Drag");
    return (0, import_react.createElement)("div", {
      className: classNames4
    }, (0, import_react.createElement)(component_default3, {
      justify: "center",
      className: "block-editor-block-list__block-selection-button__content"
    }, (0, import_react.createElement)(component_default4, null, (0, import_react.createElement)(block_icon_default, {
      icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon,
      showColors: true
    })), (0, import_react.createElement)(component_default4, null, editorMode2 === "zoom-out" && (0, import_react.createElement)(block_mover_default, {
      clientIds: [clientId],
      hideDragHandle: true
    }), editorMode2 === "navigation" && (0, import_react.createElement)(block_draggable_default, {
      clientIds: [clientId]
    }, (draggableProps) => (0, import_react.createElement)(button_default, _extends({
      icon: drag_handle_default,
      className: "block-selection-button_drag-handle",
      "aria-hidden": "true",
      label: dragHandleLabel,
      tabIndex: "-1"
    }, draggableProps)))), (0, import_react.createElement)(component_default4, null, (0, import_react.createElement)(button_default, {
      ref: ref2,
      onClick: editorMode2 === "navigation" ? () => setNavigationMode2(false) : void 0,
      onKeyDown,
      label,
      showTooltip: false,
      className: "block-selection-button_select-button"
    }, (0, import_react.createElement)(BlockTitle, {
      clientId,
      maximumLength: 35
    })))));
  }
  var block_selection_button_default = BlockSelectionButton;

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/block-contextual-toolbar.js
  var import_classnames43 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/navigable-toolbar/index.js
  function hasOnlyToolbarItem(elements) {
    const dataProp = "toolbarItem";
    return !elements.some((element) => !(dataProp in element.dataset));
  }
  function getAllToolbarItemsIn(container) {
    return Array.from(container.querySelectorAll("[data-toolbar-item]"));
  }
  function hasFocusWithin2(container) {
    return container.contains(container.ownerDocument.activeElement);
  }
  function focusFirstTabbableIn(container) {
    const [firstTabbable] = focus.tabbable.find(container);
    if (firstTabbable) {
      firstTabbable.focus({
        preventScroll: true
      });
    }
  }
  function useIsAccessibleToolbar(ref2) {
    const initialAccessibleToolbarState = true;
    const [isAccessibleToolbar, setIsAccessibleToolbar] = (0, import_react.useState)(initialAccessibleToolbarState);
    const determineIsAccessibleToolbar = (0, import_react.useCallback)(() => {
      const tabbables = focus.tabbable.find(ref2.current);
      const onlyToolbarItem = hasOnlyToolbarItem(tabbables);
      if (!onlyToolbarItem) {
        deprecated("Using custom components as toolbar controls", {
          since: "5.6",
          alternative: "ToolbarItem, ToolbarButton or ToolbarDropdownMenu components",
          link: "https://developer.wordpress.org/block-editor/components/toolbar-button/#inside-blockcontrols"
        });
      }
      setIsAccessibleToolbar(onlyToolbarItem);
    }, []);
    (0, import_react.useLayoutEffect)(() => {
      const observer = new window.MutationObserver(determineIsAccessibleToolbar);
      observer.observe(ref2.current, {
        childList: true,
        subtree: true
      });
      return () => observer.disconnect();
    }, [isAccessibleToolbar]);
    return isAccessibleToolbar;
  }
  function useToolbarFocus(ref2, focusOnMount, isAccessibleToolbar, defaultIndex, onIndexChange) {
    const [initialFocusOnMount] = (0, import_react.useState)(focusOnMount);
    const [initialIndex] = (0, import_react.useState)(defaultIndex);
    const focusToolbar = (0, import_react.useCallback)(() => {
      focusFirstTabbableIn(ref2.current);
    }, []);
    useShortcut("core/block-editor/focus-toolbar", focusToolbar);
    (0, import_react.useEffect)(() => {
      if (initialFocusOnMount) {
        focusToolbar();
      }
    }, [isAccessibleToolbar, initialFocusOnMount, focusToolbar]);
    (0, import_react.useEffect)(() => {
      let raf2 = 0;
      if (initialIndex && !initialFocusOnMount) {
        raf2 = window.requestAnimationFrame(() => {
          const items = getAllToolbarItemsIn(ref2.current);
          const index2 = initialIndex || 0;
          if (items[index2] && hasFocusWithin2(ref2.current)) {
            items[index2].focus({
              preventScroll: true
            });
          }
        });
      }
      return () => {
        window.cancelAnimationFrame(raf2);
        if (!onIndexChange || !ref2.current)
          return;
        const items = getAllToolbarItemsIn(ref2.current);
        const index2 = items.findIndex((item2) => item2.tabIndex === 0);
        onIndexChange(index2);
      };
    }, [initialIndex, initialFocusOnMount]);
  }
  function NavigableToolbar(_ref8) {
    let {
      children,
      focusOnMount,
      __experimentalInitialIndex: initialIndex,
      __experimentalOnIndexChange: onIndexChange,
      ...props
    } = _ref8;
    const ref2 = (0, import_react.useRef)();
    const isAccessibleToolbar = useIsAccessibleToolbar(ref2);
    useToolbarFocus(ref2, focusOnMount, isAccessibleToolbar, initialIndex, onIndexChange);
    if (isAccessibleToolbar) {
      return (0, import_react.createElement)(toolbar_default, _extends({
        label: props["aria-label"],
        ref: ref2
      }, props), children);
    }
    return (0, import_react.createElement)(menu_default2, _extends({
      orientation: "horizontal",
      role: "toolbar",
      ref: ref2
    }, props), children);
  }
  var navigable_toolbar_default = NavigableToolbar;

  // node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js
  var import_classnames42 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/block-parent-selector/index.js
  function BlockParentSelector() {
    const {
      selectBlock: selectBlock2,
      toggleBlockHighlight: toggleBlockHighlight2
    } = use_dispatch_default(store3);
    const {
      firstParentClientId,
      shouldHide,
      isDistractionFree
    } = useSelect((select2) => {
      const {
        getBlockName: getBlockName2,
        getBlockParents: getBlockParents2,
        getSelectedBlockClientId: getSelectedBlockClientId2,
        getSettings: getSettings2
      } = select2(store3);
      const {
        hasBlockSupport: hasBlockSupport3
      } = select2(store);
      const selectedBlockClientId = getSelectedBlockClientId2();
      const parents = getBlockParents2(selectedBlockClientId);
      const _firstParentClientId = parents[parents.length - 1];
      const parentBlockName = getBlockName2(_firstParentClientId);
      const _parentBlockType = getBlockType(parentBlockName);
      const settings2 = getSettings2();
      return {
        firstParentClientId: _firstParentClientId,
        shouldHide: !hasBlockSupport3(_parentBlockType, "__experimentalParentSelector", true),
        isDistractionFree: settings2.isDistractionFree
      };
    }, []);
    const blockInformation = useBlockDisplayInformation(firstParentClientId);
    const nodeRef = (0, import_react.useRef)();
    const {
      gestures: showMoversGestures
    } = useShowMoversGestures({
      ref: nodeRef,
      onChange(isFocused) {
        if (isFocused && isDistractionFree) {
          return;
        }
        toggleBlockHighlight2(firstParentClientId, isFocused);
      }
    });
    if (shouldHide || firstParentClientId === void 0) {
      return null;
    }
    return (0, import_react.createElement)("div", _extends({
      className: "block-editor-block-parent-selector",
      key: firstParentClientId,
      ref: nodeRef
    }, showMoversGestures), (0, import_react.createElement)(toolbar_button_default, {
      className: "block-editor-block-parent-selector__button",
      onClick: () => selectBlock2(firstParentClientId),
      label: sprintf(
        __("Select %s"),
        blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.title
      ),
      showTooltip: true,
      icon: (0, import_react.createElement)(block_icon_default, {
        icon: blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon
      })
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/preview-block-popover.js
  function PreviewBlockPopover(_ref8) {
    let {
      blocks: blocks2
    } = _ref8;
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__popover__preview__parent"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__popover__preview__container"
    }, (0, import_react.createElement)(popover_default, {
      className: "block-editor-block-switcher__preview__popover",
      placement: "bottom-start",
      focusOnMount: false
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__preview"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__preview-title"
    }, __("Preview")), (0, import_react.createElement)(block_preview_default, {
      viewportWidth: 500,
      blocks: blocks2
    })))));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-transformations-menu.js
  function useGroupedTransforms(possibleBlockTransformations) {
    const priorityContentTranformationBlocks = {
      "core/paragraph": 1,
      "core/heading": 2,
      "core/list": 3,
      "core/quote": 4
    };
    const transformations = (0, import_react.useMemo)(() => {
      const priorityTextTranformsNames = Object.keys(priorityContentTranformationBlocks);
      return possibleBlockTransformations.reduce((accumulator, item2) => {
        const {
          name
        } = item2;
        if (priorityTextTranformsNames.includes(name)) {
          accumulator.priorityTextTransformations.push(item2);
        } else {
          accumulator.restTransformations.push(item2);
        }
        return accumulator;
      }, {
        priorityTextTransformations: [],
        restTransformations: []
      });
    }, [possibleBlockTransformations]);
    transformations.priorityTextTransformations.sort((_ref8, _ref22) => {
      let {
        name: currentName
      } = _ref8;
      let {
        name: nextName
      } = _ref22;
      return priorityContentTranformationBlocks[currentName] < priorityContentTranformationBlocks[nextName] ? -1 : 1;
    });
    return transformations;
  }
  var BlockTransformationsMenu = (_ref32) => {
    let {
      className,
      possibleBlockTransformations,
      onSelect,
      blocks: blocks2
    } = _ref32;
    const [hoveredTransformItemName, setHoveredTransformItemName] = (0, import_react.useState)();
    const {
      priorityTextTransformations,
      restTransformations
    } = useGroupedTransforms(possibleBlockTransformations);
    const hasBothContentTransformations = priorityTextTransformations.length && restTransformations.length;
    const restTransformItems = !!restTransformations.length && (0, import_react.createElement)(RestTransformationItems, {
      restTransformations,
      onSelect,
      setHoveredTransformItemName
    });
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(menu_group_default, {
      label: __("Transform to"),
      className
    }, hoveredTransformItemName && (0, import_react.createElement)(PreviewBlockPopover, {
      blocks: switchToBlockType(blocks2, hoveredTransformItemName)
    }), priorityTextTransformations.map((item2) => (0, import_react.createElement)(BlockTranformationItem, {
      key: item2.name,
      item: item2,
      onSelect,
      setHoveredTransformItemName
    })), !hasBothContentTransformations && restTransformItems), !!hasBothContentTransformations && (0, import_react.createElement)(menu_group_default, {
      className
    }, restTransformItems));
  };
  function RestTransformationItems(_ref42) {
    let {
      restTransformations,
      onSelect,
      setHoveredTransformItemName
    } = _ref42;
    return restTransformations.map((item2) => (0, import_react.createElement)(BlockTranformationItem, {
      key: item2.name,
      item: item2,
      onSelect,
      setHoveredTransformItemName
    }));
  }
  function BlockTranformationItem(_ref52) {
    let {
      item: item2,
      onSelect,
      setHoveredTransformItemName
    } = _ref52;
    const {
      name,
      icon,
      title,
      isDisabled
    } = item2;
    return (0, import_react.createElement)(menu_item_default, {
      className: getBlockMenuDefaultClassName(name),
      onClick: (event) => {
        event.preventDefault();
        onSelect(name);
      },
      disabled: isDisabled,
      onMouseLeave: () => setHoveredTransformItemName(null),
      onMouseEnter: () => setHoveredTransformItemName(name)
    }, (0, import_react.createElement)(block_icon_default, {
      icon,
      showColors: true
    }), title);
  }
  var block_transformations_menu_default = BlockTransformationsMenu;

  // node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js
  var import_lodash32 = __toESM(require_lodash());

  // node_modules/@wordpress/token-list/build-module/index.js
  var TokenList = class {
    constructor() {
      let initialValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      this.value = initialValue;
      this._currentValue;
      this._valueAsArray;
    }
    entries() {
      return this._valueAsArray.entries(...arguments);
    }
    forEach() {
      return this._valueAsArray.forEach(...arguments);
    }
    keys() {
      return this._valueAsArray.keys(...arguments);
    }
    values() {
      return this._valueAsArray.values(...arguments);
    }
    get value() {
      return this._currentValue;
    }
    set value(value) {
      value = String(value);
      this._valueAsArray = [...new Set(value.split(/\s+/g).filter(Boolean))];
      this._currentValue = this._valueAsArray.join(" ");
    }
    get length() {
      return this._valueAsArray.length;
    }
    toString() {
      return this.value;
    }
    *[Symbol.iterator]() {
      return yield* this._valueAsArray;
    }
    item(index2) {
      return this._valueAsArray[index2];
    }
    contains(item2) {
      return this._valueAsArray.indexOf(item2) !== -1;
    }
    add() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }
      this.value += " " + items.join(" ");
    }
    remove() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      this.value = this._valueAsArray.filter((val) => !items.includes(val)).join(" ");
    }
    toggle(token, force) {
      if (void 0 === force) {
        force = !this.contains(token);
      }
      if (force) {
        this.add(token);
      } else {
        this.remove(token);
      }
      return force;
    }
    replace(token, newToken) {
      if (!this.contains(token)) {
        return false;
      }
      this.remove(token);
      this.add(newToken);
      return true;
    }
    supports() {
      return true;
    }
  };

  // node_modules/@wordpress/block-editor/build-module/components/block-styles/utils.js
  function getActiveStyle(styles, className) {
    for (const style of new TokenList(className).values()) {
      if (style.indexOf("is-style-") === -1) {
        continue;
      }
      const potentialStyleName = style.substring(9);
      const activeStyle = (0, import_lodash32.find)(styles, {
        name: potentialStyleName
      });
      if (activeStyle) {
        return activeStyle;
      }
    }
    return (0, import_lodash32.find)(styles, "isDefault");
  }
  function replaceActiveStyle(className, activeStyle, newStyle) {
    const list = new TokenList(className);
    if (activeStyle) {
      list.remove("is-style-" + activeStyle.name);
    }
    list.add("is-style-" + newStyle.name);
    return list.value;
  }
  function getRenderedStyles(styles) {
    if (!styles || styles.length === 0) {
      return [];
    }
    return getDefaultStyle(styles) ? styles : [{
      name: "default",
      label: _x("Default", "block style"),
      isDefault: true
    }, ...styles];
  }
  function getDefaultStyle(styles) {
    return (0, import_lodash32.find)(styles, "isDefault");
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-styles/use-styles-for-block.js
  function useGenericPreviewBlock(block4, type) {
    return (0, import_react.useMemo)(() => {
      const example = type === null || type === void 0 ? void 0 : type.example;
      const blockName = type === null || type === void 0 ? void 0 : type.name;
      if (example && blockName) {
        return getBlockFromExample(blockName, {
          attributes: example.attributes,
          innerBlocks: example.innerBlocks
        });
      }
      if (block4) {
        return cloneBlock(block4);
      }
    }, [type !== null && type !== void 0 && type.example ? block4 === null || block4 === void 0 ? void 0 : block4.name : block4, type]);
  }
  function useStylesForBlocks(_ref8) {
    let {
      clientId,
      onSwitch
    } = _ref8;
    const selector4 = (select2) => {
      const {
        getBlock: getBlock2
      } = select2(store3);
      const block5 = getBlock2(clientId);
      if (!block5) {
        return {};
      }
      const blockType2 = getBlockType(block5.name);
      const {
        getBlockStyles: getBlockStyles2
      } = select2(store);
      return {
        block: block5,
        blockType: blockType2,
        styles: getBlockStyles2(block5.name),
        className: block5.attributes.className || ""
      };
    };
    const {
      styles,
      block: block4,
      blockType,
      className
    } = useSelect(selector4, [clientId]);
    const {
      updateBlockAttributes: updateBlockAttributes2
    } = use_dispatch_default(store3);
    const stylesToRender = getRenderedStyles(styles);
    const activeStyle = getActiveStyle(stylesToRender, className);
    const genericPreviewBlock = useGenericPreviewBlock(block4, blockType);
    const onSelect = (style) => {
      const styleClassName = replaceActiveStyle(className, activeStyle, style);
      updateBlockAttributes2(clientId, {
        className: styleClassName
      });
      onSwitch();
    };
    return {
      onSelect,
      stylesToRender,
      activeStyle,
      genericPreviewBlock,
      className
    };
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-styles/menu-items.js
  var noop15 = () => {
  };
  function BlockStylesMenuItems(_ref8) {
    let {
      clientId,
      onSwitch = noop15
    } = _ref8;
    const {
      onSelect,
      stylesToRender,
      activeStyle
    } = useStylesForBlocks({
      clientId,
      onSwitch
    });
    if (!stylesToRender || stylesToRender.length === 0) {
      return null;
    }
    return (0, import_react.createElement)(import_react.Fragment, null, stylesToRender.map((style) => {
      const menuItemText = style.label || style.name;
      return (0, import_react.createElement)(menu_item_default, {
        key: style.name,
        icon: activeStyle.name === style.name ? check_default : null,
        onClick: () => onSelect(style)
      }, (0, import_react.createElement)(component_default7, {
        as: "span",
        limit: 18,
        ellipsizeMode: "tail",
        truncate: true
      }, menuItemText));
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/block-styles-menu.js
  function BlockStylesMenu(_ref8) {
    let {
      hoveredBlock,
      onSwitch
    } = _ref8;
    const {
      clientId
    } = hoveredBlock;
    return (0, import_react.createElement)(menu_group_default, {
      label: __("Styles"),
      className: "block-editor-block-switcher__styles__menugroup"
    }, (0, import_react.createElement)(BlockStylesMenuItems, {
      clientId,
      onSwitch
    }));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/utils.js
  var getMatchingBlockByName = function(block4, selectedBlockName) {
    let consumedBlocks = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    const {
      clientId,
      name,
      innerBlocks = []
    } = block4;
    if (consumedBlocks.has(clientId))
      return;
    if (name === selectedBlockName)
      return block4;
    for (const innerBlock of innerBlocks) {
      const match = getMatchingBlockByName(innerBlock, selectedBlockName, consumedBlocks);
      if (match)
        return match;
    }
  };
  var getRetainedBlockAttributes = (name, attributes) => {
    const contentAttributes = __experimentalGetBlockAttributesNamesByRole(name, "content");
    if (!(contentAttributes !== null && contentAttributes !== void 0 && contentAttributes.length))
      return attributes;
    return contentAttributes.reduce((_accumulator, attribute) => {
      if (attributes[attribute])
        _accumulator[attribute] = attributes[attribute];
      return _accumulator;
    }, {});
  };

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/use-transformed-patterns.js
  var transformMatchingBlock = (match, selectedBlock) => {
    const retainedBlockAttributes = getRetainedBlockAttributes(selectedBlock.name, selectedBlock.attributes);
    match.attributes = {
      ...match.attributes,
      ...retainedBlockAttributes
    };
  };
  var getPatternTransformedBlocks = (selectedBlocks, patternBlocks) => {
    const _patternBlocks = patternBlocks.map((block4) => cloneBlock(block4));
    const consumedBlocks = /* @__PURE__ */ new Set();
    for (const selectedBlock of selectedBlocks) {
      let isMatch = false;
      for (const patternBlock of _patternBlocks) {
        const match = getMatchingBlockByName(patternBlock, selectedBlock.name, consumedBlocks);
        if (!match)
          continue;
        isMatch = true;
        consumedBlocks.add(match.clientId);
        transformMatchingBlock(match, selectedBlock);
        break;
      }
      if (!isMatch)
        return;
    }
    return _patternBlocks;
  };
  var useTransformedPatterns = (patterns, selectedBlocks) => {
    return (0, import_react.useMemo)(() => patterns.reduce((accumulator, _pattern) => {
      const transformedBlocks = getPatternTransformedBlocks(selectedBlocks, _pattern.blocks);
      if (transformedBlocks) {
        accumulator.push({
          ..._pattern,
          transformedBlocks
        });
      }
      return accumulator;
    }, []), [patterns, selectedBlocks]);
  };
  var use_transformed_patterns_default = useTransformedPatterns;

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/pattern-transformations-menu.js
  function PatternTransformationsMenu(_ref8) {
    let {
      blocks: blocks2,
      patterns: statePatterns,
      onSelect
    } = _ref8;
    const [showTransforms, setShowTransforms] = (0, import_react.useState)(false);
    const patterns = use_transformed_patterns_default(statePatterns, blocks2);
    if (!patterns.length)
      return null;
    return (0, import_react.createElement)(menu_group_default, {
      className: "block-editor-block-switcher__pattern__transforms__menugroup"
    }, showTransforms && (0, import_react.createElement)(PreviewPatternsPopover, {
      patterns,
      onSelect
    }), (0, import_react.createElement)(menu_item_default, {
      onClick: (event) => {
        event.preventDefault();
        setShowTransforms(!showTransforms);
      },
      icon: chevron_right_default
    }, __("Patterns")));
  }
  function PreviewPatternsPopover(_ref22) {
    let {
      patterns,
      onSelect
    } = _ref22;
    return (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__popover__preview__parent"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__popover__preview__container"
    }, (0, import_react.createElement)(popover_default, {
      className: "block-editor-block-switcher__preview__popover",
      position: "bottom right"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__preview"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-block-switcher__preview-title"
    }, __("Preview")), (0, import_react.createElement)(BlockPatternsList, {
      patterns,
      onSelect
    })))));
  }
  function BlockPatternsList(_ref32) {
    let {
      patterns,
      onSelect
    } = _ref32;
    const composite = useCompositeState();
    return (0, import_react.createElement)(Composite, _extends({}, composite, {
      role: "listbox",
      className: "block-editor-block-switcher__preview-patterns-container",
      "aria-label": __("Patterns list")
    }), patterns.map((pattern) => (0, import_react.createElement)(BlockPattern2, {
      key: pattern.name,
      pattern,
      onSelect,
      composite
    })));
  }
  function BlockPattern2(_ref42) {
    let {
      pattern,
      onSelect,
      composite
    } = _ref42;
    const baseClassName = "block-editor-block-switcher__preview-patterns-container";
    const descriptionId = use_instance_id_default(BlockPattern2, `${baseClassName}-list__item-description`);
    return (0, import_react.createElement)("div", {
      className: `${baseClassName}-list__list-item`,
      "aria-label": pattern.title,
      "aria-describedby": pattern.description ? descriptionId : void 0
    }, (0, import_react.createElement)(CompositeItem, _extends({
      role: "option",
      as: "div"
    }, composite, {
      className: `${baseClassName}-list__item`,
      onClick: () => onSelect(pattern.transformedBlocks)
    }), (0, import_react.createElement)(block_preview_default, {
      blocks: pattern.transformedBlocks,
      viewportWidth: pattern.viewportWidth || 500
    }), (0, import_react.createElement)("div", {
      className: `${baseClassName}-list__item-title`
    }, pattern.title)), !!pattern.description && (0, import_react.createElement)(component_default2, {
      id: descriptionId
    }, pattern.description));
  }
  var pattern_transformations_menu_default = PatternTransformationsMenu;

  // node_modules/@wordpress/block-editor/build-module/components/block-switcher/index.js
  var BlockSwitcherDropdownMenu = (_ref8) => {
    let {
      clientIds,
      blocks: blocks2
    } = _ref8;
    const {
      replaceBlocks: replaceBlocks2
    } = use_dispatch_default(store3);
    const blockInformation = useBlockDisplayInformation(blocks2[0].clientId);
    const {
      possibleBlockTransformations,
      canRemove,
      hasBlockStyles,
      icon,
      patterns
    } = useSelect((select2) => {
      const {
        getBlockRootClientId: getBlockRootClientId2,
        getBlockTransformItems: getBlockTransformItems2,
        __experimentalGetPatternTransformItems: __experimentalGetPatternTransformItems2
      } = select2(store3);
      const {
        getBlockStyles: getBlockStyles2,
        getBlockType: getBlockType3
      } = select2(store);
      const {
        canRemoveBlocks: canRemoveBlocks2
      } = select2(store3);
      const rootClientId = getBlockRootClientId2(Array.isArray(clientIds) ? clientIds[0] : clientIds);
      const [{
        name: firstBlockName
      }] = blocks2;
      const _isSingleBlockSelected = blocks2.length === 1;
      const styles = _isSingleBlockSelected && getBlockStyles2(firstBlockName);
      let _icon;
      if (_isSingleBlockSelected) {
        _icon = blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon;
      } else {
        var _getBlockType;
        const isSelectionOfSameType = new Set(blocks2.map((_ref22) => {
          let {
            name
          } = _ref22;
          return name;
        })).size === 1;
        _icon = isSelectionOfSameType ? (_getBlockType = getBlockType3(firstBlockName)) === null || _getBlockType === void 0 ? void 0 : _getBlockType.icon : copy_default;
      }
      return {
        possibleBlockTransformations: getBlockTransformItems2(blocks2, rootClientId),
        canRemove: canRemoveBlocks2(clientIds, rootClientId),
        hasBlockStyles: !!(styles !== null && styles !== void 0 && styles.length),
        icon: _icon,
        patterns: __experimentalGetPatternTransformItems2(blocks2, rootClientId)
      };
    }, [clientIds, blocks2, blockInformation === null || blockInformation === void 0 ? void 0 : blockInformation.icon]);
    const blockTitle = useBlockDisplayTitle({
      clientId: Array.isArray(clientIds) ? clientIds[0] : clientIds,
      maximumLength: 35
    });
    const isReusable = blocks2.length === 1 && isReusableBlock(blocks2[0]);
    const isTemplate = blocks2.length === 1 && isTemplatePart(blocks2[0]);
    const onBlockTransform = (name) => replaceBlocks2(clientIds, switchToBlockType(blocks2, name));
    const onPatternTransform = (transformedBlocks) => replaceBlocks2(clientIds, transformedBlocks);
    const hasPossibleBlockTransformations = !!possibleBlockTransformations.length && canRemove && !isTemplate;
    const hasPatternTransformation = !!(patterns !== null && patterns !== void 0 && patterns.length) && canRemove;
    if (!hasBlockStyles && !hasPossibleBlockTransformations) {
      return (0, import_react.createElement)(toolbar_group_default, null, (0, import_react.createElement)(toolbar_button_default, {
        disabled: true,
        className: "block-editor-block-switcher__no-switcher-icon",
        title: blockTitle,
        icon: (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(block_icon_default, {
          icon,
          showColors: true
        }), (isReusable || isTemplate) && (0, import_react.createElement)("span", {
          className: "block-editor-block-switcher__toggle-text"
        }, blockTitle))
      }));
    }
    const blockSwitcherLabel = blockTitle;
    const blockSwitcherDescription = 1 === blocks2.length ? sprintf(
      __("%s: Change block type or style"),
      blockTitle
    ) : sprintf(
      _n("Change type of %d block", "Change type of %d blocks", blocks2.length),
      blocks2.length
    );
    const showDropDown = hasBlockStyles || hasPossibleBlockTransformations || hasPatternTransformation;
    return (0, import_react.createElement)(toolbar_group_default, null, (0, import_react.createElement)(toolbar_item_default, null, (toggleProps) => (0, import_react.createElement)(dropdown_menu_default, {
      className: "block-editor-block-switcher",
      label: blockSwitcherLabel,
      popoverProps: {
        position: "bottom right",
        variant: "toolbar",
        className: "block-editor-block-switcher__popover"
      },
      icon: (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(block_icon_default, {
        icon,
        className: "block-editor-block-switcher__toggle",
        showColors: true
      }), (isReusable || isTemplate) && (0, import_react.createElement)("span", {
        className: "block-editor-block-switcher__toggle-text"
      }, blockTitle)),
      toggleProps: {
        describedBy: blockSwitcherDescription,
        ...toggleProps
      },
      menuProps: {
        orientation: "both"
      }
    }, (_ref32) => {
      let {
        onClose
      } = _ref32;
      return showDropDown && (0, import_react.createElement)("div", {
        className: "block-editor-block-switcher__container"
      }, hasPatternTransformation && (0, import_react.createElement)(pattern_transformations_menu_default, {
        blocks: blocks2,
        patterns,
        onSelect: (transformedBlocks) => {
          onPatternTransform(transformedBlocks);
          onClose();
        }
      }), hasPossibleBlockTransformations && (0, import_react.createElement)(block_transformations_menu_default, {
        className: "block-editor-block-switcher__transforms__menugroup",
        possibleBlockTransformations,
        blocks: blocks2,
        onSelect: (name) => {
          onBlockTransform(name);
          onClose();
        }
      }), hasBlockStyles && (0, import_react.createElement)(BlockStylesMenu, {
        hoveredBlock: blocks2[0],
        onSwitch: onClose
      }));
    })));
  };
  var BlockSwitcher = (_ref42) => {
    let {
      clientIds
    } = _ref42;
    const blocks2 = useSelect((select2) => select2(store3).getBlocksByClientId(clientIds), [clientIds]);
    if (!blocks2.length || blocks2.some((block4) => !block4)) {
      return null;
    }
    return (0, import_react.createElement)(BlockSwitcherDropdownMenu, {
      clientIds,
      blocks: blocks2
    });
  };
  var block_switcher_default = BlockSwitcher;

  // node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-toolbar-last-item.js
  var {
    Fill: __unstableBlockToolbarLastItem,
    Slot: Slot7
  } = createSlotFill("__unstableBlockToolbarLastItem");
  __unstableBlockToolbarLastItem.Slot = Slot7;
  var block_toolbar_last_item_default = __unstableBlockToolbarLastItem;

  // node_modules/@wordpress/block-editor/build-module/components/block-settings-menu/index.js
  function BlockSettingsMenu(_ref8) {
    let {
      clientIds,
      ...props
    } = _ref8;
    return (0, import_react.createElement)(toolbar_group_default, null, (0, import_react.createElement)(toolbar_item_default, null, (toggleProps) => (0, import_react.createElement)(block_settings_dropdown_default, _extends({
      clientIds,
      toggleProps
    }, props))));
  }
  var block_settings_menu_default = BlockSettingsMenu;

  // node_modules/@wordpress/block-editor/build-module/components/block-edit-visually-button/index.js
  function BlockEditVisuallyButton(_ref8) {
    let {
      clientIds
    } = _ref8;
    const clientId = clientIds.length === 1 ? clientIds[0] : void 0;
    const canEditVisually = useSelect((select2) => !!clientId && select2(store3).getBlockMode(clientId) === "html", [clientId]);
    const {
      toggleBlockMode: toggleBlockMode2
    } = use_dispatch_default(store3);
    if (!canEditVisually) {
      return null;
    }
    return (0, import_react.createElement)(toolbar_group_default, null, (0, import_react.createElement)(toolbar_button_default, {
      onClick: () => {
        toggleBlockMode2(clientId);
      }
    }, __("Edit visually")));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-toolbar/block-name-context.js
  var __unstableBlockNameContext = (0, import_react.createContext)("");
  var block_name_context_default = __unstableBlockNameContext;

  // node_modules/@wordpress/block-editor/build-module/components/block-toolbar/index.js
  var BlockToolbar = (_ref8) => {
    let {
      hideDragHandle
    } = _ref8;
    const {
      blockClientIds,
      blockClientId,
      blockType,
      hasFixedToolbar,
      isDistractionFree,
      isValid,
      isVisual,
      isContentLocked
    } = useSelect((select2) => {
      const {
        getBlockName: getBlockName2,
        getBlockMode: getBlockMode2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        isBlockValid: isBlockValid2,
        getBlockRootClientId: getBlockRootClientId2,
        getSettings: getSettings2,
        __unstableGetContentLockingParent: __unstableGetContentLockingParent2
      } = select2(store3);
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const selectedBlockClientId = selectedBlockClientIds[0];
      const blockRootClientId = getBlockRootClientId2(selectedBlockClientId);
      const settings2 = getSettings2();
      return {
        blockClientIds: selectedBlockClientIds,
        blockClientId: selectedBlockClientId,
        blockType: selectedBlockClientId && getBlockType(getBlockName2(selectedBlockClientId)),
        hasFixedToolbar: settings2.hasFixedToolbar,
        isDistractionFree: settings2.isDistractionFree,
        rootClientId: blockRootClientId,
        isValid: selectedBlockClientIds.every((id2) => isBlockValid2(id2)),
        isVisual: selectedBlockClientIds.every((id2) => getBlockMode2(id2) === "visual"),
        isContentLocked: !!__unstableGetContentLockingParent2(selectedBlockClientId)
      };
    }, []);
    const {
      toggleBlockHighlight: toggleBlockHighlight2
    } = use_dispatch_default(store3);
    const nodeRef = (0, import_react.useRef)();
    const {
      showMovers,
      gestures: showMoversGestures
    } = useShowMoversGestures({
      ref: nodeRef,
      onChange(isFocused) {
        if (isFocused && isDistractionFree) {
          return;
        }
        toggleBlockHighlight2(blockClientId, isFocused);
      }
    });
    const displayHeaderToolbar = use_viewport_match_default("medium", "<") || hasFixedToolbar;
    if (blockType) {
      if (!hasBlockSupport(blockType, "__experimentalToolbar", true)) {
        return null;
      }
    }
    const shouldShowMovers = displayHeaderToolbar || showMovers;
    if (blockClientIds.length === 0) {
      return null;
    }
    const shouldShowVisualToolbar = isValid && isVisual;
    const isMultiToolbar = blockClientIds.length > 1;
    const classes = (0, import_classnames42.default)("block-editor-block-toolbar", shouldShowMovers && "is-showing-movers");
    return (0, import_react.createElement)("div", {
      className: classes
    }, !isMultiToolbar && !displayHeaderToolbar && !isContentLocked && (0, import_react.createElement)(BlockParentSelector, null), (0, import_react.createElement)("div", _extends({
      ref: nodeRef
    }, showMoversGestures), (shouldShowVisualToolbar || isMultiToolbar) && !isContentLocked && (0, import_react.createElement)(toolbar_group_default, {
      className: "block-editor-block-toolbar__block-controls"
    }, (0, import_react.createElement)(block_switcher_default, {
      clientIds: blockClientIds
    }), !isMultiToolbar && (0, import_react.createElement)(BlockLockToolbar, {
      clientId: blockClientIds[0]
    }), (0, import_react.createElement)(block_mover_default, {
      clientIds: blockClientIds,
      hideDragHandle
    }))), shouldShowVisualToolbar && isMultiToolbar && (0, import_react.createElement)(toolbar_default2, null), shouldShowVisualToolbar && (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)(block_controls_default.Slot, {
      group: "parent",
      className: "block-editor-block-toolbar__slot"
    }), (0, import_react.createElement)(block_controls_default.Slot, {
      group: "block",
      className: "block-editor-block-toolbar__slot"
    }), (0, import_react.createElement)(block_controls_default.Slot, {
      className: "block-editor-block-toolbar__slot"
    }), (0, import_react.createElement)(block_controls_default.Slot, {
      group: "inline",
      className: "block-editor-block-toolbar__slot"
    }), (0, import_react.createElement)(block_controls_default.Slot, {
      group: "other",
      className: "block-editor-block-toolbar__slot"
    }), (0, import_react.createElement)(block_name_context_default.Provider, {
      value: blockType === null || blockType === void 0 ? void 0 : blockType.name
    }, (0, import_react.createElement)(block_toolbar_last_item_default.Slot, null))), (0, import_react.createElement)(BlockEditVisuallyButton, {
      clientIds: blockClientIds
    }), !isContentLocked && (0, import_react.createElement)(block_settings_menu_default, {
      clientIds: blockClientIds
    }));
  };
  var block_toolbar_default = BlockToolbar;

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/block-contextual-toolbar.js
  function BlockContextualToolbar(_ref8) {
    let {
      focusOnMount,
      isFixed,
      ...props
    } = _ref8;
    const {
      blockType,
      hasParents,
      showParentSelector
    } = useSelect((select2) => {
      const {
        getBlockName: getBlockName2,
        getBlockParents: getBlockParents2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        __unstableGetContentLockingParent: __unstableGetContentLockingParent2
      } = select2(store3);
      const {
        getBlockType: getBlockType3
      } = select2(store);
      const selectedBlockClientIds = getSelectedBlockClientIds2();
      const selectedBlockClientId = selectedBlockClientIds[0];
      const parents = getBlockParents2(selectedBlockClientId);
      const firstParentClientId = parents[parents.length - 1];
      const parentBlockName = getBlockName2(firstParentClientId);
      const parentBlockType = getBlockType3(parentBlockName);
      return {
        blockType: selectedBlockClientId && getBlockType3(getBlockName2(selectedBlockClientId)),
        hasParents: parents.length,
        showParentSelector: parentBlockType && hasBlockSupport(parentBlockType, "__experimentalParentSelector", true) && selectedBlockClientIds.length <= 1 && !__unstableGetContentLockingParent2(selectedBlockClientId)
      };
    }, []);
    if (blockType) {
      if (!hasBlockSupport(blockType, "__experimentalToolbar", true)) {
        return null;
      }
    }
    const classes = (0, import_classnames43.default)("block-editor-block-contextual-toolbar", {
      "has-parent": hasParents && showParentSelector,
      "is-fixed": isFixed
    });
    return (0, import_react.createElement)(navigable_toolbar_default, _extends({
      focusOnMount,
      className: classes,
      "aria-label": __("Block tools")
    }, props), (0, import_react.createElement)(block_toolbar_default, {
      hideDragHandle: isFixed
    }));
  }
  var block_contextual_toolbar_default = BlockContextualToolbar;

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/use-block-toolbar-popover-props.js
  var COMMON_PROPS = {
    placement: "top-start"
  };
  var DEFAULT_PROPS2 = {
    ...COMMON_PROPS,
    flip: false,
    shift: true
  };
  var RESTRICTED_HEIGHT_PROPS = {
    ...COMMON_PROPS,
    flip: true,
    shift: false
  };
  function getProps(contentElement, selectedBlockElement, toolbarHeight) {
    if (!contentElement || !selectedBlockElement) {
      return DEFAULT_PROPS2;
    }
    const blockRect = selectedBlockElement.getBoundingClientRect();
    const contentRect = contentElement.getBoundingClientRect();
    const viewportHeight = contentElement.ownerDocument.documentElement.clientHeight;
    const hasSpaceForToolbarAbove = blockRect.top - contentRect.top > toolbarHeight;
    const isBlockTallerThanViewport = blockRect.height > viewportHeight - toolbarHeight;
    if (hasSpaceForToolbarAbove || isBlockTallerThanViewport) {
      return DEFAULT_PROPS2;
    }
    return RESTRICTED_HEIGHT_PROPS;
  }
  function useBlockToolbarPopoverProps(_ref8) {
    let {
      contentElement,
      clientId
    } = _ref8;
    const selectedBlockElement = useBlockElement(clientId);
    const [toolbarHeight, setToolbarHeight] = (0, import_react.useState)(0);
    const [props, setProps] = (0, import_react.useState)(() => getProps(contentElement, selectedBlockElement, toolbarHeight));
    const blockIndex = useSelect((select2) => select2(store3).getBlockIndex(clientId), [clientId]);
    const popoverRef = useRefEffect((popoverNode) => {
      setToolbarHeight(popoverNode.offsetHeight);
    }, []);
    const updateProps = (0, import_react.useCallback)(() => setProps(getProps(contentElement, selectedBlockElement, toolbarHeight)), [contentElement, selectedBlockElement, toolbarHeight]);
    (0, import_react.useLayoutEffect)(updateProps, [blockIndex, updateProps]);
    (0, import_react.useLayoutEffect)(() => {
      var _contentElement$owner, _contentView$addEvent, _selectedBlockElement;
      if (!contentElement || !selectedBlockElement) {
        return;
      }
      const contentView = contentElement === null || contentElement === void 0 ? void 0 : (_contentElement$owner = contentElement.ownerDocument) === null || _contentElement$owner === void 0 ? void 0 : _contentElement$owner.defaultView;
      contentView === null || contentView === void 0 ? void 0 : (_contentView$addEvent = contentView.addEventHandler) === null || _contentView$addEvent === void 0 ? void 0 : _contentView$addEvent.call(contentView, "resize", updateProps);
      let resizeObserver;
      const blockView = selectedBlockElement === null || selectedBlockElement === void 0 ? void 0 : (_selectedBlockElement = selectedBlockElement.ownerDocument) === null || _selectedBlockElement === void 0 ? void 0 : _selectedBlockElement.defaultView;
      if (blockView.ResizeObserver) {
        resizeObserver = new blockView.ResizeObserver(updateProps);
        resizeObserver.observe(selectedBlockElement);
      }
      return () => {
        var _contentView$removeEv;
        contentView === null || contentView === void 0 ? void 0 : (_contentView$removeEv = contentView.removeEventHandler) === null || _contentView$removeEv === void 0 ? void 0 : _contentView$removeEv.call(contentView, "resize", updateProps);
        if (resizeObserver) {
          resizeObserver.disconnect();
        }
      };
    }, [updateProps, contentElement, selectedBlockElement]);
    return {
      ...props,
      ref: popoverRef
    };
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/selected-block-popover.js
  function selector2(select2) {
    const {
      __unstableGetEditorMode: __unstableGetEditorMode2,
      isMultiSelecting: isMultiSelecting3,
      hasMultiSelection: hasMultiSelection2,
      isTyping: isTyping3,
      getSettings: getSettings2,
      getLastMultiSelectedBlockClientId: getLastMultiSelectedBlockClientId2
    } = select2(store3);
    return {
      editorMode: __unstableGetEditorMode2(),
      isMultiSelecting: isMultiSelecting3(),
      isTyping: isTyping3(),
      hasFixedToolbar: getSettings2().hasFixedToolbar,
      isDistractionFree: getSettings2().isDistractionFree,
      lastClientId: hasMultiSelection2() ? getLastMultiSelectedBlockClientId2() : null
    };
  }
  function SelectedBlockPopover(_ref8) {
    let {
      clientId,
      rootClientId,
      isEmptyDefaultBlock,
      showContents,
      capturingClientId,
      __unstablePopoverSlot,
      __unstableContentRef
    } = _ref8;
    const {
      editorMode: editorMode2,
      isMultiSelecting: isMultiSelecting3,
      isTyping: isTyping3,
      hasFixedToolbar,
      isDistractionFree,
      lastClientId
    } = useSelect(selector2, []);
    const isInsertionPointVisible = useSelect((select2) => {
      const {
        isBlockInsertionPointVisible: isBlockInsertionPointVisible2,
        getBlockInsertionPoint: getBlockInsertionPoint2,
        getBlockOrder: getBlockOrder2
      } = select2(store3);
      if (!isBlockInsertionPointVisible2()) {
        return false;
      }
      const insertionPoint2 = getBlockInsertionPoint2();
      const order2 = getBlockOrder2(insertionPoint2.rootClientId);
      return order2[insertionPoint2.index] === clientId;
    }, [clientId]);
    const isLargeViewport = use_viewport_match_default("medium");
    const isToolbarForced = (0, import_react.useRef)(false);
    const {
      stopTyping: stopTyping2
    } = use_dispatch_default(store3);
    const showEmptyBlockSideInserter = !isTyping3 && editorMode2 === "edit" && isEmptyDefaultBlock;
    const shouldShowBreadcrumb = editorMode2 === "navigation" || editorMode2 === "zoom-out";
    const shouldShowContextualToolbar = editorMode2 === "edit" && !hasFixedToolbar && isLargeViewport && !isMultiSelecting3 && !showEmptyBlockSideInserter && !isTyping3;
    const canFocusHiddenToolbar = editorMode2 === "edit" && !shouldShowContextualToolbar && !hasFixedToolbar && !isDistractionFree && !isEmptyDefaultBlock;
    useShortcut("core/block-editor/focus-toolbar", () => {
      isToolbarForced.current = true;
      stopTyping2(true);
    }, {
      isDisabled: !canFocusHiddenToolbar
    });
    (0, import_react.useEffect)(() => {
      isToolbarForced.current = false;
    });
    const initialToolbarItemIndexRef = (0, import_react.useRef)();
    const popoverProps = useBlockToolbarPopoverProps({
      contentElement: __unstableContentRef === null || __unstableContentRef === void 0 ? void 0 : __unstableContentRef.current,
      clientId
    });
    if (!shouldShowBreadcrumb && !shouldShowContextualToolbar) {
      return null;
    }
    return (0, import_react.createElement)(block_popover_default, _extends({
      clientId: capturingClientId || clientId,
      bottomClientId: lastClientId,
      className: (0, import_classnames44.default)("block-editor-block-list__block-popover", {
        "is-insertion-point-visible": isInsertionPointVisible
      }),
      __unstablePopoverSlot,
      __unstableContentRef,
      resize: false
    }, popoverProps), shouldShowContextualToolbar && showContents && (0, import_react.createElement)(
      block_contextual_toolbar_default,
      {
        focusOnMount: isToolbarForced.current,
        __experimentalInitialIndex: initialToolbarItemIndexRef.current,
        __experimentalOnIndexChange: (index2) => {
          initialToolbarItemIndexRef.current = index2;
        },
        key: clientId
      }
    ), shouldShowBreadcrumb && (0, import_react.createElement)(block_selection_button_default, {
      clientId,
      rootClientId
    }));
  }
  function wrapperSelector(select2) {
    const {
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getFirstMultiSelectedBlockClientId: getFirstMultiSelectedBlockClientId2,
      getBlockRootClientId: getBlockRootClientId2,
      getBlock: getBlock2,
      getBlockParents: getBlockParents2,
      getSettings: getSettings2,
      isNavigationMode: _isNavigationMode,
      __experimentalGetBlockListSettingsForBlocks: __experimentalGetBlockListSettingsForBlocks2
    } = select2(store3);
    const clientId = getSelectedBlockClientId2() || getFirstMultiSelectedBlockClientId2();
    if (!clientId) {
      return;
    }
    const {
      name,
      attributes = {}
    } = getBlock2(clientId) || {};
    const blockParentsClientIds = getBlockParents2(clientId);
    const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks2(blockParentsClientIds);
    const capturingClientId = (0, import_lodash33.find)(blockParentsClientIds, (parentClientId) => {
      var _parentBlockListSetti;
      return (_parentBlockListSetti = parentBlockListSettings[parentClientId]) === null || _parentBlockListSetti === void 0 ? void 0 : _parentBlockListSetti.__experimentalCaptureToolbars;
    });
    const settings2 = getSettings2();
    return {
      clientId,
      rootClientId: getBlockRootClientId2(clientId),
      name,
      isDistractionFree: settings2.isDistractionFree,
      isNavigationMode: _isNavigationMode(),
      isEmptyDefaultBlock: name && isUnmodifiedDefaultBlock({
        name,
        attributes
      }),
      capturingClientId
    };
  }
  function WrappedBlockPopover(_ref22) {
    let {
      __unstablePopoverSlot,
      __unstableContentRef
    } = _ref22;
    const selected = useSelect(wrapperSelector, []);
    if (!selected) {
      return null;
    }
    const {
      clientId,
      rootClientId,
      name,
      isEmptyDefaultBlock,
      capturingClientId,
      isDistractionFree,
      isNavigationMode: isNavigationMode2
    } = selected;
    if (!name) {
      return null;
    }
    return (0, import_react.createElement)(SelectedBlockPopover, {
      clientId,
      rootClientId,
      isEmptyDefaultBlock,
      showContents: !isDistractionFree || isNavigationMode2,
      capturingClientId,
      __unstablePopoverSlot,
      __unstableContentRef
    });
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-tools/back-compat.js
  function BlockToolsBackCompat(_ref8) {
    let {
      children
    } = _ref8;
    const openRef = (0, import_react.useContext)(InsertionPointOpenRef2);
    const isDisabled = (0, import_react.useContext)(disabled_default.Context);
    if (openRef || isDisabled) {
      return children;
    }
    deprecated('wp.components.Popover.Slot name="block-toolbar"', {
      alternative: "wp.blockEditor.BlockTools",
      since: "5.8",
      version: "6.3"
    });
    return (0, import_react.createElement)(InsertionPoint, {
      __unstablePopoverSlot: "block-toolbar"
    }, (0, import_react.createElement)(WrappedBlockPopover, {
      __unstablePopoverSlot: "block-toolbar"
    }), children);
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-selection-clearer/index.js
  function useBlockSelectionClearer() {
    const {
      getSettings: getSettings2,
      hasSelectedBlock: hasSelectedBlock2,
      hasMultiSelection: hasMultiSelection2
    } = useSelect(store3);
    const {
      clearSelectedBlock: clearSelectedBlock2
    } = use_dispatch_default(store3);
    const {
      __experimentalClearBlockSelection: isEnabled
    } = getSettings2();
    return useRefEffect((node) => {
      if (!isEnabled) {
        return;
      }
      function onMouseDown(event) {
        if (!hasSelectedBlock2() && !hasMultiSelection2()) {
          return;
        }
        if (event.target !== node) {
          return;
        }
        clearSelectedBlock2();
      }
      node.addEventListener("mousedown", onMouseDown);
      return () => {
        node.removeEventListener("mousedown", onMouseDown);
      };
    }, [hasSelectedBlock2, hasMultiSelection2, clearSelectedBlock2, isEnabled]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js
  var import_classnames46 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js
  var import_classnames45 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/with-client-id.js
  var withClientId = createHigherOrderComponent((WrappedComponent) => (props) => {
    const {
      clientId
    } = useBlockEditContext();
    return (0, import_react.createElement)(WrappedComponent, _extends({}, props, {
      clientId
    }));
  }, "withClientId");
  var with_client_id_default = withClientId;

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/button-block-appender.js
  var ButtonBlockAppender2 = (_ref8) => {
    let {
      clientId,
      showSeparator,
      isFloating,
      onAddBlock,
      isToggle
    } = _ref8;
    return (0, import_react.createElement)(button_block_appender_default, {
      className: (0, import_classnames45.default)({
        "block-list-appender__toggle": isToggle
      }),
      rootClientId: clientId,
      showSeparator,
      isFloating,
      onAddBlock
    });
  };
  var button_block_appender_default2 = with_client_id_default(ButtonBlockAppender2);

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/default-block-appender.js
  var DefaultBlockAppender2 = (_ref8) => {
    let {
      clientId
    } = _ref8;
    return (0, import_react.createElement)(default_block_appender_default, {
      rootClientId: clientId
    });
  };
  var default_block_appender_default2 = compose_default([with_client_id_default, with_select_default((select2, _ref22) => {
    let {
      clientId
    } = _ref22;
    const {
      getBlockOrder: getBlockOrder2
    } = select2(store3);
    const blockClientIds = getBlockOrder2(clientId);
    return {
      lastBlockClientId: blockClientIds[blockClientIds.length - 1]
    };
  })])(DefaultBlockAppender2);

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-nested-settings-update.js
  var pendingSettingsUpdates = /* @__PURE__ */ new WeakMap();
  function useNestedSettingsUpdate(clientId, allowedBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, layout) {
    const {
      updateBlockListSettings: updateBlockListSettings2
    } = use_dispatch_default(store3);
    const registry = useRegistry();
    const {
      blockListSettings: blockListSettings2,
      parentLock
    } = useSelect((select2) => {
      const rootClientId = select2(store3).getBlockRootClientId(clientId);
      return {
        blockListSettings: select2(store3).getBlockListSettings(clientId),
        parentLock: select2(store3).getTemplateLock(rootClientId)
      };
    }, [clientId]);
    const _allowedBlocks = (0, import_react.useMemo)(() => allowedBlocks, allowedBlocks);
    (0, import_react.useLayoutEffect)(() => {
      const newSettings = {
        allowedBlocks: _allowedBlocks,
        templateLock: templateLock === void 0 || parentLock === "contentOnly" ? parentLock : templateLock
      };
      if (captureToolbars !== void 0) {
        newSettings.__experimentalCaptureToolbars = captureToolbars;
      }
      if (orientation !== void 0) {
        newSettings.orientation = orientation;
      } else {
        const layoutType = getLayoutType(layout === null || layout === void 0 ? void 0 : layout.type);
        newSettings.orientation = layoutType.getOrientation(layout);
      }
      if (__experimentalDefaultBlock !== void 0) {
        newSettings.__experimentalDefaultBlock = __experimentalDefaultBlock;
      }
      if (__experimentalDirectInsert !== void 0) {
        newSettings.__experimentalDirectInsert = __experimentalDirectInsert;
      }
      if (!isShallowEqual(blockListSettings2, newSettings)) {
        if (!pendingSettingsUpdates.get(registry)) {
          pendingSettingsUpdates.set(registry, []);
        }
        pendingSettingsUpdates.get(registry).push([clientId, newSettings]);
        window.queueMicrotask(() => {
          var _pendingSettingsUpdat;
          if ((_pendingSettingsUpdat = pendingSettingsUpdates.get(registry)) !== null && _pendingSettingsUpdat !== void 0 && _pendingSettingsUpdat.length) {
            registry.batch(() => {
              pendingSettingsUpdates.get(registry).forEach((args) => {
                updateBlockListSettings2(...args);
              });
              pendingSettingsUpdates.set(registry, []);
            });
          }
        });
      }
    }, [clientId, blockListSettings2, _allowedBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, parentLock, captureToolbars, orientation, updateBlockListSettings2, layout, registry]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/use-inner-block-template-sync.js
  var import_lodash34 = __toESM(require_lodash());
  function useInnerBlockTemplateSync(clientId, template2, templateLock, templateInsertUpdatesSelection) {
    const {
      getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
      isBlockSelected: isBlockSelected2
    } = useSelect(store3);
    const {
      replaceInnerBlocks: replaceInnerBlocks2
    } = use_dispatch_default(store3);
    const innerBlocks = useSelect((select2) => select2(store3).getBlocks(clientId), [clientId]);
    const {
      getBlocks: getBlocks2
    } = useSelect(store3);
    const existingTemplate = (0, import_react.useRef)(null);
    (0, import_react.useLayoutEffect)(() => {
      window.queueMicrotask(() => {
        const currentInnerBlocks = getBlocks2(clientId);
        const shouldApplyTemplate = currentInnerBlocks.length === 0 || templateLock === "all" || templateLock === "contentOnly";
        const hasTemplateChanged = !(0, import_lodash34.isEqual)(template2, existingTemplate.current);
        if (!shouldApplyTemplate || !hasTemplateChanged) {
          return;
        }
        existingTemplate.current = template2;
        const nextBlocks = synchronizeBlocksWithTemplate(currentInnerBlocks, template2);
        if (!(0, import_lodash34.isEqual)(nextBlocks, currentInnerBlocks)) {
          replaceInnerBlocks2(
            clientId,
            nextBlocks,
            currentInnerBlocks.length === 0 && templateInsertUpdatesSelection && nextBlocks.length !== 0 && isBlockSelected2(clientId),
            getSelectedBlocksInitialCaretPosition2()
          );
        }
      });
    }, [innerBlocks, template2, templateLock, clientId]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/get-block-context.js
  var import_lodash35 = __toESM(require_lodash());
  var BLOCK_CONTEXT_CACHE = /* @__PURE__ */ new WeakMap();
  function getBlockContext(attributes, blockType) {
    if (!BLOCK_CONTEXT_CACHE.has(blockType)) {
      BLOCK_CONTEXT_CACHE.set(blockType, /* @__PURE__ */ new WeakMap());
    }
    const blockTypeCache = BLOCK_CONTEXT_CACHE.get(blockType);
    if (!blockTypeCache.has(attributes)) {
      const context2 = (0, import_lodash35.mapValues)(blockType.providesContext, (attributeName) => attributes[attributeName]);
      blockTypeCache.set(attributes, context2);
    }
    return blockTypeCache.get(attributes);
  }

  // node_modules/@wordpress/block-editor/build-module/components/use-block-drop-zone/index.js
  function getDropTargetPosition(blocksData, position) {
    var _blocksData$nearestIn, _blocksData$adjacentI;
    let orientation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertical";
    const allowedEdges = orientation === "horizontal" ? ["left", "right"] : ["top", "bottom"];
    const isRightToLeft = isRTL();
    let nearestIndex = 0;
    let insertPosition = "before";
    let minDistance = Infinity;
    blocksData.forEach((_ref8) => {
      let {
        isUnmodifiedDefaultBlock: isUnmodifiedDefaultBlock2,
        getBoundingClientRect,
        blockIndex
      } = _ref8;
      const rect = getBoundingClientRect();
      let [distance2, edge] = getDistanceToNearestEdge(position, rect, allowedEdges);
      if (isUnmodifiedDefaultBlock2 && isPointContainedByRect(position, rect)) {
        distance2 = 0;
      }
      if (distance2 < minDistance) {
        insertPosition = edge === "bottom" || !isRightToLeft && edge === "right" || isRightToLeft && edge === "left" ? "after" : "before";
        minDistance = distance2;
        nearestIndex = blockIndex;
      }
    });
    const adjacentIndex = nearestIndex + (insertPosition === "after" ? 1 : -1);
    const isNearestBlockUnmodifiedDefaultBlock = !!((_blocksData$nearestIn = blocksData[nearestIndex]) !== null && _blocksData$nearestIn !== void 0 && _blocksData$nearestIn.isUnmodifiedDefaultBlock);
    const isAdjacentBlockUnmodifiedDefaultBlock = !!((_blocksData$adjacentI = blocksData[adjacentIndex]) !== null && _blocksData$adjacentI !== void 0 && _blocksData$adjacentI.isUnmodifiedDefaultBlock);
    if (!isNearestBlockUnmodifiedDefaultBlock && !isAdjacentBlockUnmodifiedDefaultBlock) {
      const insertionIndex = insertPosition === "after" ? nearestIndex + 1 : nearestIndex;
      return [insertionIndex, "insert"];
    }
    return [isNearestBlockUnmodifiedDefaultBlock ? nearestIndex : adjacentIndex, "replace"];
  }
  function useBlockDropZone() {
    let {
      rootClientId: targetRootClientId = ""
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const [dropTarget, setDropTarget] = (0, import_react.useState)({
      index: null,
      operation: "insert"
    });
    const isDisabled = useSelect((select2) => {
      const {
        getTemplateLock: getTemplateLock2,
        __unstableIsWithinBlockOverlay: __unstableIsWithinBlockOverlay2,
        __unstableHasActiveBlockOverlayActive: __unstableHasActiveBlockOverlayActive2
      } = select2(store3);
      const templateLock = getTemplateLock2(targetRootClientId);
      return ["all", "contentOnly"].some((lock2) => lock2 === templateLock) || __unstableHasActiveBlockOverlayActive2(targetRootClientId) || __unstableIsWithinBlockOverlay2(targetRootClientId);
    }, [targetRootClientId]);
    const {
      getBlockListSettings: getBlockListSettings2,
      getBlocks: getBlocks2,
      getBlockIndex: getBlockIndex2
    } = useSelect(store3);
    const {
      showInsertionPoint: showInsertionPoint2,
      hideInsertionPoint: hideInsertionPoint2
    } = use_dispatch_default(store3);
    const onBlockDrop2 = useOnBlockDrop(targetRootClientId, dropTarget.index, {
      operation: dropTarget.operation
    });
    const throttled = useThrottle((0, import_react.useCallback)((event, ownerDocument) => {
      var _getBlockListSettings;
      const blocks2 = getBlocks2(targetRootClientId);
      if (blocks2.length === 0) {
        setDropTarget({
          index: 0,
          operation: "insert"
        });
        return;
      }
      const blocksData = blocks2.map((block4) => {
        const clientId = block4.clientId;
        return {
          isUnmodifiedDefaultBlock: isUnmodifiedDefaultBlock(block4),
          getBoundingClientRect: () => ownerDocument.getElementById(`block-${clientId}`).getBoundingClientRect(),
          blockIndex: getBlockIndex2(clientId)
        };
      });
      const [targetIndex, operation] = getDropTargetPosition(blocksData, {
        x: event.clientX,
        y: event.clientY
      }, (_getBlockListSettings = getBlockListSettings2(targetRootClientId)) === null || _getBlockListSettings === void 0 ? void 0 : _getBlockListSettings.orientation);
      setDropTarget({
        index: targetIndex,
        operation
      });
      showInsertionPoint2(targetRootClientId, targetIndex, {
        operation
      });
    }, [targetRootClientId]), 200);
    return useDropZone({
      isDisabled,
      onDrop: onBlockDrop2,
      onDragOver(event) {
        throttled(event, event.currentTarget.ownerDocument);
      },
      onDragLeave() {
        throttled.cancel();
        hideInsertionPoint2();
      },
      onDragEnd() {
        throttled.cancel();
        hideInsertionPoint2();
      }
    });
  }

  // node_modules/@wordpress/block-editor/build-module/components/inner-blocks/index.js
  function UncontrolledInnerBlocks(props) {
    const {
      clientId,
      allowedBlocks,
      __experimentalDefaultBlock,
      __experimentalDirectInsert,
      template: template2,
      templateLock,
      wrapperRef,
      templateInsertUpdatesSelection,
      __experimentalCaptureToolbars: captureToolbars,
      __experimentalAppenderTagName,
      renderAppender,
      orientation,
      placeholder,
      __experimentalLayout
    } = props;
    useNestedSettingsUpdate(clientId, allowedBlocks, __experimentalDefaultBlock, __experimentalDirectInsert, templateLock, captureToolbars, orientation, __experimentalLayout);
    useInnerBlockTemplateSync(clientId, template2, templateLock, templateInsertUpdatesSelection);
    const context2 = useSelect((select2) => {
      const block4 = select2(store3).getBlock(clientId);
      if (!block4) {
        return;
      }
      const blockType = getBlockType(block4.name);
      if (!blockType || !blockType.providesContext) {
        return;
      }
      return getBlockContext(block4.attributes, blockType);
    }, [clientId]);
    return (0, import_react.createElement)(BlockContextProvider, {
      value: context2
    }, (0, import_react.createElement)(BlockListItems, {
      rootClientId: clientId,
      renderAppender,
      __experimentalAppenderTagName,
      __experimentalLayout,
      wrapperRef,
      placeholder
    }));
  }
  function ControlledInnerBlocks(props) {
    useBlockSync(props);
    return (0, import_react.createElement)(UncontrolledInnerBlocks, props);
  }
  var ForwardedInnerBlocks = (0, import_react.forwardRef)((props, ref2) => {
    const innerBlocksProps = useInnerBlocksProps({
      ref: ref2
    }, props);
    return (0, import_react.createElement)("div", {
      className: "block-editor-inner-blocks"
    }, (0, import_react.createElement)("div", innerBlocksProps));
  });
  function useInnerBlocksProps() {
    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      __unstableDisableLayoutClassNames
    } = options;
    const {
      clientId,
      __unstableLayoutClassNames: layoutClassNames = ""
    } = useBlockEditContext();
    const isSmallScreen = use_viewport_match_default("medium", "<");
    const {
      __experimentalCaptureToolbars,
      hasOverlay
    } = useSelect((select2) => {
      if (!clientId) {
        return {};
      }
      const {
        getBlockName: getBlockName2,
        isBlockSelected: isBlockSelected2,
        hasSelectedInnerBlock: hasSelectedInnerBlock2,
        __unstableGetEditorMode: __unstableGetEditorMode2
      } = select2(store3);
      const blockName = getBlockName2(clientId);
      const enableClickThrough = __unstableGetEditorMode2() === "navigation" || isSmallScreen;
      return {
        __experimentalCaptureToolbars: select2(store).hasBlockSupport(blockName, "__experimentalExposeControlsToChildren", false),
        hasOverlay: blockName !== "core/template" && !isBlockSelected2(clientId) && !hasSelectedInnerBlock2(clientId, true) && enableClickThrough
      };
    }, [clientId, isSmallScreen]);
    const ref2 = useMergeRefs([props.ref, useBlockDropZone({
      rootClientId: clientId
    })]);
    const innerBlocksProps = {
      __experimentalCaptureToolbars,
      ...options
    };
    const InnerBlocks = innerBlocksProps.value && innerBlocksProps.onChange ? ControlledInnerBlocks : UncontrolledInnerBlocks;
    return {
      ...props,
      ref: ref2,
      className: (0, import_classnames46.default)(props.className, "block-editor-block-list__layout", __unstableDisableLayoutClassNames ? "" : layoutClassNames, {
        "has-overlay": hasOverlay
      }),
      children: clientId ? (0, import_react.createElement)(InnerBlocks, _extends({}, innerBlocksProps, {
        clientId
      })) : (0, import_react.createElement)(BlockListItems, options)
    };
  }
  useInnerBlocksProps.save = getInnerBlocksProps;
  ForwardedInnerBlocks.DefaultBlockAppender = default_block_appender_default2;
  ForwardedInnerBlocks.ButtonBlockAppender = button_block_appender_default2;
  ForwardedInnerBlocks.Content = () => useInnerBlocksProps.save().children;
  var inner_blocks_default = ForwardedInnerBlocks;

  // node_modules/@wordpress/block-editor/build-module/components/block-list/index.js
  var elementContext = (0, import_react.createContext)();
  var IntersectionObserver2 = (0, import_react.createContext)();
  var pendingBlockVisibilityUpdatesPerRegistry = /* @__PURE__ */ new WeakMap();
  function Root2(_ref8) {
    let {
      className,
      ...settings2
    } = _ref8;
    const [element, setElement] = (0, import_react.useState)();
    const isLargeViewport = use_viewport_match_default("medium");
    const {
      isOutlineMode,
      isFocusMode,
      editorMode: editorMode2
    } = useSelect((select2) => {
      const {
        getSettings: getSettings2,
        __unstableGetEditorMode: __unstableGetEditorMode2
      } = select2(store3);
      const {
        outlineMode,
        focusMode
      } = getSettings2();
      return {
        isOutlineMode: outlineMode,
        isFocusMode: focusMode,
        editorMode: __unstableGetEditorMode2()
      };
    }, []);
    const registry = useRegistry();
    const {
      setBlockVisibility: setBlockVisibility2
    } = use_dispatch_default(store3);
    const delayedBlockVisibilityUpdates = useDebounce((0, import_react.useCallback)(() => {
      const updates = {};
      pendingBlockVisibilityUpdatesPerRegistry.get(registry).forEach((_ref22) => {
        let [id2, isIntersecting] = _ref22;
        updates[id2] = isIntersecting;
      });
      setBlockVisibility2(updates);
    }, [registry]), 300, {
      trailing: true
    });
    const intersectionObserver = (0, import_react.useMemo)(() => {
      const {
        IntersectionObserver: Observer
      } = window;
      if (!Observer) {
        return;
      }
      return new Observer((entries) => {
        if (!pendingBlockVisibilityUpdatesPerRegistry.get(registry)) {
          pendingBlockVisibilityUpdatesPerRegistry.set(registry, []);
        }
        for (const entry of entries) {
          const clientId = entry.target.getAttribute("data-block");
          pendingBlockVisibilityUpdatesPerRegistry.get(registry).push([clientId, entry.isIntersecting]);
        }
        delayedBlockVisibilityUpdates();
      });
    }, []);
    const innerBlocksProps = useInnerBlocksProps({
      ref: useMergeRefs([useBlockSelectionClearer(), useInBetweenInserter(), setElement]),
      className: (0, import_classnames47.default)("is-root-container", className, {
        "is-outline-mode": isOutlineMode,
        "is-focus-mode": isFocusMode && isLargeViewport,
        "is-navigate-mode": editorMode2 === "navigation"
      })
    }, settings2);
    return (0, import_react.createElement)(elementContext.Provider, {
      value: element
    }, (0, import_react.createElement)(IntersectionObserver2.Provider, {
      value: intersectionObserver
    }, (0, import_react.createElement)("div", innerBlocksProps)));
  }
  function BlockList(settings2) {
    usePreParsePatterns();
    return (0, import_react.createElement)(BlockToolsBackCompat, null, (0, import_react.createElement)(Provider6, {
      value: DEFAULT_BLOCK_EDIT_CONTEXT
    }, (0, import_react.createElement)(Root2, settings2)));
  }
  BlockList.__unstableElementContext = elementContext;
  function Items(_ref32) {
    let {
      placeholder,
      rootClientId,
      renderAppender,
      __experimentalAppenderTagName,
      __experimentalLayout: layout = defaultLayout
    } = _ref32;
    const {
      order: order2,
      selectedBlocks,
      visibleBlocks
    } = useSelect((select2) => {
      const {
        getBlockOrder: getBlockOrder2,
        getSelectedBlockClientIds: getSelectedBlockClientIds2,
        __unstableGetVisibleBlocks: __unstableGetVisibleBlocks2
      } = select2(store3);
      return {
        order: getBlockOrder2(rootClientId),
        selectedBlocks: getSelectedBlockClientIds2(),
        visibleBlocks: __unstableGetVisibleBlocks2()
      };
    }, [rootClientId]);
    return (0, import_react.createElement)(LayoutProvider, {
      value: layout
    }, order2.map((clientId) => (0, import_react.createElement)(context_default2, {
      key: clientId,
      value: !visibleBlocks.has(clientId) && !selectedBlocks.includes(clientId)
    }, (0, import_react.createElement)(block_default, {
      rootClientId,
      clientId
    }))), order2.length < 1 && placeholder, (0, import_react.createElement)(block_list_appender_default, {
      tagName: __experimentalAppenderTagName,
      rootClientId,
      renderAppender
    }));
  }
  function BlockListItems(props) {
    return (0, import_react.createElement)(context_default2, {
      value: false
    }, (0, import_react.createElement)(Items, props));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-preview/live.js
  function LiveBlockPreview(_ref8) {
    let {
      onClick
    } = _ref8;
    return (0, import_react.createElement)("div", {
      tabIndex: 0,
      role: "button",
      onClick,
      onKeyPress: onClick
    }, (0, import_react.createElement)("div", {
      inert: "true"
    }, (0, import_react.createElement)(BlockList, null)));
  }

  // node_modules/@wordpress/block-editor/build-module/components/iframe/index.js
  var import_classnames49 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js
  var import_classnames48 = __toESM(require_classnames());

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-multi-selection.js
  function selector3(select2) {
    const {
      isMultiSelecting: isMultiSelecting3,
      getMultiSelectedBlockClientIds: getMultiSelectedBlockClientIds2,
      hasMultiSelection: hasMultiSelection2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getSelectedBlocksInitialCaretPosition: getSelectedBlocksInitialCaretPosition2,
      __unstableIsFullySelected: __unstableIsFullySelected2
    } = select2(store3);
    return {
      isMultiSelecting: isMultiSelecting3(),
      multiSelectedBlockClientIds: getMultiSelectedBlockClientIds2(),
      hasMultiSelection: hasMultiSelection2(),
      selectedBlockClientId: getSelectedBlockClientId2(),
      initialPosition: getSelectedBlocksInitialCaretPosition2(),
      isFullSelection: __unstableIsFullySelected2()
    };
  }
  function useMultiSelection() {
    const {
      initialPosition: initialPosition2,
      isMultiSelecting: isMultiSelecting3,
      multiSelectedBlockClientIds,
      hasMultiSelection: hasMultiSelection2,
      selectedBlockClientId,
      isFullSelection
    } = useSelect(selector3, []);
    return useRefEffect((node) => {
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;
      if (initialPosition2 === void 0 || initialPosition2 === null) {
        return;
      }
      if (!hasMultiSelection2 || isMultiSelecting3) {
        return;
      }
      const {
        length
      } = multiSelectedBlockClientIds;
      if (length < 2) {
        return;
      }
      if (!isFullSelection) {
        return;
      }
      node.contentEditable = true;
      node.focus();
      defaultView.getSelection().removeAllRanges();
    }, [hasMultiSelection2, isMultiSelecting3, multiSelectedBlockClientIds, selectedBlockClientId, initialPosition2, isFullSelection]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-tab-nav.js
  function useTabNav() {
    const container = (0, import_react.useRef)();
    const focusCaptureBeforeRef = (0, import_react.useRef)();
    const focusCaptureAfterRef = (0, import_react.useRef)();
    const lastFocus = (0, import_react.useRef)();
    const {
      hasMultiSelection: hasMultiSelection2,
      getSelectedBlockClientId: getSelectedBlockClientId2,
      getBlockCount: getBlockCount2
    } = useSelect(store3);
    const {
      setNavigationMode: setNavigationMode2
    } = use_dispatch_default(store3);
    const isNavigationMode2 = useSelect((select2) => select2(store3).isNavigationMode(), []);
    const focusCaptureTabIndex = !isNavigationMode2 ? "0" : void 0;
    const noCapture = (0, import_react.useRef)();
    function onFocusCapture(event) {
      if (noCapture.current) {
        noCapture.current = null;
      } else if (hasMultiSelection2()) {
        container.current.focus();
      } else if (getSelectedBlockClientId2()) {
        lastFocus.current.focus();
      } else {
        setNavigationMode2(true);
        const isBefore = event.target.compareDocumentPosition(container.current) & event.target.DOCUMENT_POSITION_FOLLOWING;
        const action = isBefore ? "findNext" : "findPrevious";
        focus.tabbable[action](event.target).focus();
      }
    }
    const before = (0, import_react.createElement)("div", {
      ref: focusCaptureBeforeRef,
      tabIndex: focusCaptureTabIndex,
      onFocus: onFocusCapture
    });
    const after = (0, import_react.createElement)("div", {
      ref: focusCaptureAfterRef,
      tabIndex: focusCaptureTabIndex,
      onFocus: onFocusCapture
    });
    const ref2 = useRefEffect((node) => {
      function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.keyCode === ESCAPE) {
          event.preventDefault();
          setNavigationMode2(true);
          return;
        }
        if (event.keyCode !== TAB) {
          return;
        }
        const isShift = event.shiftKey;
        const direction = isShift ? "findPrevious" : "findNext";
        if (!hasMultiSelection2() && !getSelectedBlockClientId2()) {
          if (event.target === node)
            setNavigationMode2(true);
          return;
        }
        if ((isFormElement(event.target) || event.target.getAttribute("data-block") === getSelectedBlockClientId2()) && isFormElement(focus.tabbable[direction](event.target))) {
          return;
        }
        const next2 = isShift ? focusCaptureBeforeRef : focusCaptureAfterRef;
        noCapture.current = true;
        next2.current.focus({
          preventScroll: true
        });
      }
      function onFocusOut(event) {
        lastFocus.current = event.target;
        const {
          ownerDocument: ownerDocument2
        } = node;
        if (!event.relatedTarget && ownerDocument2.activeElement === ownerDocument2.body && getBlockCount2() === 0) {
          node.focus();
        }
      }
      function preventScrollOnTab(event) {
        var _event$target;
        if (event.keyCode !== TAB) {
          return;
        }
        if (((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.getAttribute("role")) === "region") {
          return;
        }
        if (container.current === event.target) {
          return;
        }
        const isShift = event.shiftKey;
        const direction = isShift ? "findPrevious" : "findNext";
        const target = focus.tabbable[direction](event.target);
        if (target === focusCaptureBeforeRef.current || target === focusCaptureAfterRef.current) {
          event.preventDefault();
          target.focus({
            preventScroll: true
          });
        }
      }
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;
      defaultView.addEventListener("keydown", preventScrollOnTab);
      node.addEventListener("keydown", onKeyDown);
      node.addEventListener("focusout", onFocusOut);
      return () => {
        defaultView.removeEventListener("keydown", preventScrollOnTab);
        node.removeEventListener("keydown", onKeyDown);
        node.removeEventListener("focusout", onFocusOut);
      };
    }, []);
    const mergedRefs = useMergeRefs([container, ref2]);
    return [before, mergedRefs, after];
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-arrow-nav.js
  function isNavigationCandidate(element, keyCode, hasModifier) {
    const isVertical = keyCode === UP || keyCode === DOWN;
    if (isVertical && !hasModifier) {
      return true;
    }
    const {
      tagName
    } = element;
    if (tagName === "INPUT") {
      const simpleInputTypes = ["button", "checkbox", "color", "file", "image", "radio", "reset", "submit"];
      return simpleInputTypes.includes(element.getAttribute("type"));
    }
    return tagName !== "TEXTAREA";
  }
  function getClosestTabbable(target, isReverse, containerElement, onlyVertical) {
    let focusableNodes = focus.focusable.find(containerElement);
    if (isReverse) {
      focusableNodes.reverse();
    }
    focusableNodes = focusableNodes.slice(focusableNodes.indexOf(target) + 1);
    let targetRect;
    if (onlyVertical) {
      targetRect = target.getBoundingClientRect();
    }
    function isTabCandidate(node) {
      if (node.children.length === 1 && isInSameBlock(node, node.firstElementChild) && node.firstElementChild.getAttribute("contenteditable") === "true") {
        return;
      }
      if (!focus.tabbable.isTabbableIndex(node)) {
        return false;
      }
      if (node.isContentEditable && node.contentEditable !== "true") {
        return false;
      }
      if (onlyVertical) {
        const nodeRect = node.getBoundingClientRect();
        if (nodeRect.left >= targetRect.right || nodeRect.right <= targetRect.left) {
          return false;
        }
      }
      return true;
    }
    return focusableNodes.find(isTabCandidate);
  }
  function useArrowNav() {
    const {
      getMultiSelectedBlocksStartClientId: getMultiSelectedBlocksStartClientId2,
      getMultiSelectedBlocksEndClientId: getMultiSelectedBlocksEndClientId2,
      getSettings: getSettings2,
      hasMultiSelection: hasMultiSelection2,
      __unstableIsFullySelected: __unstableIsFullySelected2
    } = useSelect(store3);
    const {
      selectBlock: selectBlock2
    } = use_dispatch_default(store3);
    return useRefEffect((node) => {
      let verticalRect;
      function onMouseDown() {
        verticalRect = null;
      }
      function isClosestTabbableABlock(target, isReverse) {
        const closestTabbable = getClosestTabbable(target, isReverse, node);
        return closestTabbable && getBlockClientId(closestTabbable);
      }
      function onKeyDown(event) {
        const {
          keyCode,
          target,
          shiftKey,
          ctrlKey,
          altKey,
          metaKey
        } = event;
        const isUp = keyCode === UP;
        const isDown = keyCode === DOWN;
        const isLeft = keyCode === LEFT;
        const isRight = keyCode === RIGHT;
        const isReverse = isUp || isLeft;
        const isHorizontal = isLeft || isRight;
        const isVertical = isUp || isDown;
        const isNav = isHorizontal || isVertical;
        const hasModifier = shiftKey || ctrlKey || altKey || metaKey;
        const isNavEdge = isVertical ? isVerticalEdge : isHorizontalEdge;
        const {
          ownerDocument
        } = node;
        const {
          defaultView
        } = ownerDocument;
        if (hasMultiSelection2()) {
          if (!__unstableIsFullySelected2()) {
            return;
          }
          if (event.defaultPrevented) {
            return;
          }
          if (!isNav) {
            return;
          }
          if (shiftKey) {
            return;
          }
          event.preventDefault();
          if (isReverse) {
            selectBlock2(getMultiSelectedBlocksStartClientId2());
          } else {
            selectBlock2(getMultiSelectedBlocksEndClientId2(), -1);
          }
          return;
        }
        if (!isVertical) {
          verticalRect = null;
        } else if (!verticalRect) {
          verticalRect = computeCaretRect(defaultView);
        }
        if (event.defaultPrevented) {
          return;
        }
        if (!isNav) {
          return;
        }
        if (!isNavigationCandidate(target, keyCode, hasModifier)) {
          return;
        }
        const isReverseDir = isRTL2(target) ? !isReverse : isReverse;
        const {
          keepCaretInsideBlock
        } = getSettings2();
        if (shiftKey) {
          if (isClosestTabbableABlock(target, isReverse) && isNavEdge(target, isReverse)) {
            node.contentEditable = true;
            node.focus();
          }
        } else if (isVertical && isVerticalEdge(target, isReverse) && (altKey ? isHorizontalEdge(target, isReverseDir) : true) && !keepCaretInsideBlock) {
          const closestTabbable = getClosestTabbable(target, isReverse, node, true);
          if (closestTabbable) {
            placeCaretAtVerticalEdge(
              closestTabbable,
              altKey ? !isReverse : isReverse,
              altKey ? void 0 : verticalRect
            );
            event.preventDefault();
          }
        } else if (isHorizontal && defaultView.getSelection().isCollapsed && isHorizontalEdge(target, isReverseDir) && !keepCaretInsideBlock) {
          const closestTabbable = getClosestTabbable(target, isReverseDir, node);
          placeCaretAtHorizontalEdge(closestTabbable, isReverse);
          event.preventDefault();
        }
      }
      node.addEventListener("mousedown", onMouseDown);
      node.addEventListener("keydown", onKeyDown);
      return () => {
        node.removeEventListener("mousedown", onMouseDown);
        node.removeEventListener("keydown", onKeyDown);
      };
    }, []);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-select-all.js
  function useSelectAll() {
    const {
      getBlockOrder: getBlockOrder2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      getBlockRootClientId: getBlockRootClientId2
    } = useSelect(store3);
    const {
      multiSelect: multiSelect2,
      selectBlock: selectBlock2
    } = use_dispatch_default(store3);
    const isMatch = useShortcutEventMatch();
    return useRefEffect((node) => {
      function onKeyDown(event) {
        if (!isMatch("core/block-editor/select-all", event)) {
          return;
        }
        const selectedClientIds = getSelectedBlockClientIds2();
        if (selectedClientIds.length < 2 && !isEntirelySelected(event.target)) {
          return;
        }
        event.preventDefault();
        const [firstSelectedClientId] = selectedClientIds;
        const rootClientId = getBlockRootClientId2(firstSelectedClientId);
        const blockClientIds = getBlockOrder2(rootClientId);
        if (selectedClientIds.length === blockClientIds.length) {
          if (rootClientId) {
            node.ownerDocument.defaultView.getSelection().removeAllRanges();
            selectBlock2(rootClientId);
          }
          return;
        }
        multiSelect2(blockClientIds[0], blockClientIds[blockClientIds.length - 1]);
      }
      node.addEventListener("keydown", onKeyDown);
      return () => {
        node.removeEventListener("keydown", onKeyDown);
      };
    }, []);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-drag-selection.js
  function setContentEditableWrapper(node, value) {
    node.contentEditable = value;
    if (value)
      node.focus();
  }
  function useDragSelection() {
    const {
      startMultiSelect: startMultiSelect2,
      stopMultiSelect: stopMultiSelect2
    } = use_dispatch_default(store3);
    const {
      isSelectionEnabled: isSelectionEnabled3,
      hasMultiSelection: hasMultiSelection2,
      isDraggingBlocks: isDraggingBlocks2
    } = useSelect(store3);
    return useRefEffect((node) => {
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;
      let anchorElement;
      let rafId;
      function onMouseUp() {
        stopMultiSelect2();
        defaultView.removeEventListener("mouseup", onMouseUp);
        rafId = defaultView.requestAnimationFrame(() => {
          if (hasMultiSelection2()) {
            return;
          }
          setContentEditableWrapper(node, false);
          const selection2 = defaultView.getSelection();
          if (selection2.rangeCount) {
            const {
              commonAncestorContainer
            } = selection2.getRangeAt(0);
            if (anchorElement.contains(commonAncestorContainer)) {
              anchorElement.focus();
            }
          }
        });
      }
      function onMouseLeave(_ref8) {
        let {
          buttons,
          target
        } = _ref8;
        if (isDraggingBlocks2()) {
          return;
        }
        if (buttons !== 1) {
          return;
        }
        if (!target.getAttribute("contenteditable")) {
          return;
        }
        if (!isSelectionEnabled3()) {
          return;
        }
        anchorElement = ownerDocument.activeElement;
        startMultiSelect2();
        defaultView.addEventListener("mouseup", onMouseUp);
        setContentEditableWrapper(node, true);
      }
      node.addEventListener("mouseout", onMouseLeave);
      return () => {
        node.removeEventListener("mouseout", onMouseLeave);
        defaultView.removeEventListener("mouseup", onMouseUp);
        defaultView.cancelAnimationFrame(rafId);
      };
    }, [startMultiSelect2, stopMultiSelect2, isSelectionEnabled3, hasMultiSelection2]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-selection-observer.js
  function extractSelectionStartNode(selection2) {
    const {
      anchorNode,
      anchorOffset
    } = selection2;
    if (anchorNode.nodeType === anchorNode.TEXT_NODE) {
      return anchorNode;
    }
    if (anchorOffset === 0) {
      return anchorNode;
    }
    return anchorNode.childNodes[anchorOffset - 1];
  }
  function extractSelectionEndNode(selection2) {
    const {
      focusNode,
      focusOffset
    } = selection2;
    if (focusNode.nodeType === focusNode.TEXT_NODE) {
      return focusNode;
    }
    if (focusOffset === focusNode.childNodes.length) {
      return focusNode;
    }
    return focusNode.childNodes[focusOffset];
  }
  function findDepth(a6, b6) {
    let depth = 0;
    while (a6[depth] === b6[depth]) {
      depth++;
    }
    return depth;
  }
  function setContentEditableWrapper2(node, value) {
    node.contentEditable = value;
    if (value)
      node.focus();
  }
  function useSelectionObserver() {
    const {
      multiSelect: multiSelect2,
      selectBlock: selectBlock2,
      selectionChange: selectionChange2
    } = use_dispatch_default(store3);
    const {
      getBlockParents: getBlockParents2,
      getBlockSelectionStart: getBlockSelectionStart2
    } = useSelect(store3);
    return useRefEffect((node) => {
      const {
        ownerDocument
      } = node;
      const {
        defaultView
      } = ownerDocument;
      function onSelectionChange(event) {
        const selection2 = defaultView.getSelection();
        if (!selection2.rangeCount) {
          return;
        }
        const isClickShift = event.shiftKey && event.type === "mouseup";
        if (selection2.isCollapsed && !isClickShift) {
          setContentEditableWrapper2(node, false);
          return;
        }
        let startClientId = getBlockClientId(extractSelectionStartNode(selection2));
        let endClientId = getBlockClientId(extractSelectionEndNode(selection2));
        if (isClickShift) {
          const selectedClientId = getBlockSelectionStart2();
          const clickedClientId = getBlockClientId(event.target);
          const focusNodeIsNonSelectable = clickedClientId !== endClientId;
          if (startClientId === endClientId && selection2.isCollapsed || !endClientId || focusNodeIsNonSelectable) {
            endClientId = clickedClientId;
          }
          if (startClientId !== selectedClientId) {
            startClientId = selectedClientId;
          }
        }
        if (startClientId === void 0 && endClientId === void 0) {
          setContentEditableWrapper2(node, false);
          return;
        }
        const isSingularSelection = startClientId === endClientId;
        if (isSingularSelection) {
          selectBlock2(startClientId);
        } else {
          const startPath = [...getBlockParents2(startClientId), startClientId];
          const endPath = [...getBlockParents2(endClientId), endClientId];
          const depth = findDepth(startPath, endPath);
          multiSelect2(startPath[depth], endPath[depth]);
        }
      }
      function addListeners() {
        ownerDocument.addEventListener("selectionchange", onSelectionChange);
        defaultView.addEventListener("mouseup", onSelectionChange);
      }
      function removeListeners() {
        ownerDocument.removeEventListener("selectionchange", onSelectionChange);
        defaultView.removeEventListener("mouseup", onSelectionChange);
      }
      function resetListeners() {
        removeListeners();
        addListeners();
      }
      addListeners();
      node.addEventListener("focusin", resetListeners);
      return () => {
        removeListeners();
        node.removeEventListener("focusin", resetListeners);
      };
    }, [multiSelect2, selectBlock2, selectionChange2, getBlockParents2]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-click-selection.js
  function useClickSelection() {
    const {
      selectBlock: selectBlock2
    } = use_dispatch_default(store3);
    const {
      isSelectionEnabled: isSelectionEnabled3,
      getBlockSelectionStart: getBlockSelectionStart2,
      hasMultiSelection: hasMultiSelection2
    } = useSelect(store3);
    return useRefEffect((node) => {
      function onMouseDown(event) {
        if (!isSelectionEnabled3() || event.button !== 0) {
          return;
        }
        const startClientId = getBlockSelectionStart2();
        const clickedClientId = getBlockClientId(event.target);
        if (event.shiftKey) {
          if (startClientId !== clickedClientId) {
            node.contentEditable = true;
            node.focus();
          }
        } else if (hasMultiSelection2()) {
          selectBlock2(clickedClientId);
        }
      }
      node.addEventListener("mousedown", onMouseDown);
      return () => {
        node.removeEventListener("mousedown", onMouseDown);
      };
    }, [selectBlock2, isSelectionEnabled3, getBlockSelectionStart2, hasMultiSelection2]);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/use-input.js
  function useInput() {
    const {
      __unstableIsFullySelected: __unstableIsFullySelected2,
      getSelectedBlockClientIds: getSelectedBlockClientIds2,
      __unstableIsSelectionMergeable: __unstableIsSelectionMergeable2,
      hasMultiSelection: hasMultiSelection2
    } = useSelect(store3);
    const {
      replaceBlocks: replaceBlocks2,
      __unstableSplitSelection: __unstableSplitSelection2,
      removeBlocks: removeBlocks2,
      __unstableDeleteSelection: __unstableDeleteSelection2,
      __unstableExpandSelection: __unstableExpandSelection2
    } = use_dispatch_default(store3);
    return useRefEffect((node) => {
      function onBeforeInput(event) {
        var _event$inputType;
        if (!hasMultiSelection2()) {
          return;
        }
        if ((_event$inputType = event.inputType) !== null && _event$inputType !== void 0 && _event$inputType.startsWith("format")) {
          event.preventDefault();
        }
      }
      function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (!hasMultiSelection2()) {
          return;
        }
        if (event.keyCode === ENTER) {
          node.contentEditable = false;
          event.preventDefault();
          if (__unstableIsFullySelected2()) {
            replaceBlocks2(getSelectedBlockClientIds2(), createBlock(getDefaultBlockName()));
          } else {
            __unstableSplitSelection2();
          }
        } else if (event.keyCode === BACKSPACE || event.keyCode === DELETE) {
          node.contentEditable = false;
          event.preventDefault();
          if (__unstableIsFullySelected2()) {
            removeBlocks2(getSelectedBlockClientIds2());
          } else if (__unstableIsSelectionMergeable2()) {
            __unstableDeleteSelection2(event.keyCode === DELETE);
          } else {
            __unstableExpandSelection2();
          }
        } else if (event.key.length === 1 && !(event.metaKey || event.ctrlKey)) {
          node.contentEditable = false;
          if (__unstableIsSelectionMergeable2()) {
            __unstableDeleteSelection2(event.keyCode === DELETE);
          } else {
            event.preventDefault();
            node.ownerDocument.defaultView.getSelection().removeAllRanges();
          }
        }
      }
      function onCompositionStart(event) {
        if (!hasMultiSelection2()) {
          return;
        }
        node.contentEditable = false;
        if (__unstableIsSelectionMergeable2()) {
          __unstableDeleteSelection2();
        } else {
          event.preventDefault();
          node.ownerDocument.defaultView.getSelection().removeAllRanges();
        }
      }
      node.addEventListener("beforeinput", onBeforeInput);
      node.addEventListener("keydown", onKeyDown);
      node.addEventListener("compositionstart", onCompositionStart);
      return () => {
        node.removeEventListener("beforeinput", onBeforeInput);
        node.removeEventListener("keydown", onKeyDown);
        node.removeEventListener("compositionstart", onCompositionStart);
      };
    }, []);
  }

  // node_modules/@wordpress/block-editor/build-module/components/writing-flow/index.js
  function useWritingFlow() {
    const [before, ref2, after] = useTabNav();
    const hasMultiSelection2 = useSelect((select2) => select2(store3).hasMultiSelection(), []);
    return [before, useMergeRefs([ref2, useInput(), useDragSelection(), useSelectionObserver(), useClickSelection(), useMultiSelection(), useSelectAll(), useArrowNav(), useRefEffect((node) => {
      node.tabIndex = -1;
      node.contentEditable = hasMultiSelection2;
      if (!hasMultiSelection2) {
        return;
      }
      node.classList.add("has-multi-selection");
      node.setAttribute("aria-label", __("Multiple selected blocks"));
      return () => {
        node.classList.remove("has-multi-selection");
        node.removeAttribute("aria-label");
      };
    }, [hasMultiSelection2])]), after];
  }
  function WritingFlow(_ref8, forwardedRef) {
    let {
      children,
      ...props
    } = _ref8;
    const [before, ref2, after] = useWritingFlow();
    return (0, import_react.createElement)(import_react.Fragment, null, before, (0, import_react.createElement)("div", _extends({}, props, {
      ref: useMergeRefs([ref2, forwardedRef]),
      className: (0, import_classnames48.default)(props.className, "block-editor-writing-flow")
    }), children), after);
  }
  var writing_flow_default = (0, import_react.forwardRef)(WritingFlow);

  // node_modules/@wordpress/block-editor/build-module/components/iframe/index.js
  var BODY_CLASS_NAME = "editor-styles-wrapper";
  var BLOCK_PREFIX = "wp-block";
  function useStylesCompatibility() {
    return useRefEffect((node) => {
      Array.from(document.styleSheets).forEach((styleSheet) => {
        try {
          styleSheet.cssRules;
        } catch (e4) {
          return;
        }
        const {
          ownerNode,
          cssRules
        } = styleSheet;
        if (!cssRules) {
          return;
        }
        if (ownerNode.tagName !== "LINK") {
          return;
        }
        if (ownerNode.id === "wp-reset-editor-styles-css") {
          return;
        }
        function matchFromRules(_cssRules) {
          return Array.from(_cssRules).find((_ref8) => {
            let {
              selectorText,
              conditionText,
              cssRules: __cssRules
            } = _ref8;
            if (conditionText) {
              return matchFromRules(__cssRules);
            }
            return selectorText && (selectorText.includes(`.${BODY_CLASS_NAME}`) || selectorText.includes(`.${BLOCK_PREFIX}`));
          });
        }
        const isMatch = matchFromRules(cssRules);
        if (isMatch && !node.ownerDocument.getElementById(ownerNode.id)) {
          node.appendChild(ownerNode.cloneNode(true));
          const inlineCssId = ownerNode.id.replace("-css", "-inline-css");
          const inlineCssElement = document.getElementById(inlineCssId);
          if (inlineCssElement) {
            node.appendChild(inlineCssElement.cloneNode(true));
          }
        }
      });
    }, []);
  }
  function bubbleEvents(doc) {
    const {
      defaultView
    } = doc;
    const {
      frameElement
    } = defaultView;
    function bubbleEvent(event) {
      const prototype = Object.getPrototypeOf(event);
      const constructorName = prototype.constructor.name;
      const Constructor = window[constructorName];
      const init = {};
      for (const key in event) {
        init[key] = event[key];
      }
      if (event instanceof defaultView.MouseEvent) {
        const rect = frameElement.getBoundingClientRect();
        init.clientX += rect.left;
        init.clientY += rect.top;
      }
      const newEvent = new Constructor(event.type, init);
      const cancelled = !frameElement.dispatchEvent(newEvent);
      if (cancelled) {
        event.preventDefault();
      }
    }
    const eventTypes = ["dragover"];
    for (const name of eventTypes) {
      doc.addEventListener(name, bubbleEvent);
    }
  }
  function useParsedAssets(html2) {
    return (0, import_react.useMemo)(() => {
      const doc = document.implementation.createHTMLDocument("");
      doc.body.innerHTML = html2;
      return Array.from(doc.body.children);
    }, [html2]);
  }
  async function loadScript(head, _ref22) {
    let {
      id: id2,
      src
    } = _ref22;
    return new Promise((resolve, reject) => {
      const script = head.ownerDocument.createElement("script");
      script.id = id2;
      if (src) {
        script.src = src;
        script.onload = () => resolve();
        script.onerror = () => reject();
      } else {
        resolve();
      }
      head.appendChild(script);
    });
  }
  function Iframe(_ref32, ref2) {
    let {
      contentRef,
      children,
      head,
      tabIndex = 0,
      assets,
      isZoomedOut,
      ...props
    } = _ref32;
    const [, forceRender] = (0, import_react.useReducer)(() => ({}));
    const [iframeDocument, setIframeDocument] = (0, import_react.useState)();
    const [bodyClasses, setBodyClasses] = (0, import_react.useState)([]);
    const styles = useParsedAssets(assets === null || assets === void 0 ? void 0 : assets.styles);
    const scripts = useParsedAssets(assets === null || assets === void 0 ? void 0 : assets.scripts);
    const clearerRef = useBlockSelectionClearer();
    const [before, writingFlowRef, after] = useWritingFlow();
    const [contentResizeListener, {
      height: contentHeight
    }] = useResizeAware();
    const setRef2 = useRefEffect((node) => {
      let iFrameDocument;
      function preventFileDropDefault(event) {
        event.preventDefault();
      }
      function setDocumentIfReady() {
        const {
          contentDocument,
          ownerDocument
        } = node;
        const {
          readyState,
          documentElement
        } = contentDocument;
        iFrameDocument = contentDocument;
        if (readyState !== "interactive" && readyState !== "complete") {
          return false;
        }
        bubbleEvents(contentDocument);
        setIframeDocument(contentDocument);
        clearerRef(documentElement);
        setBodyClasses(Array.from(ownerDocument.body.classList).filter((name) => name.startsWith("admin-color-") || name.startsWith("post-type-") || name === "wp-embed-responsive"));
        contentDocument.dir = ownerDocument.dir;
        documentElement.removeChild(contentDocument.head);
        documentElement.removeChild(contentDocument.body);
        iFrameDocument.addEventListener("dragover", preventFileDropDefault, false);
        iFrameDocument.addEventListener("drop", preventFileDropDefault, false);
        return true;
      }
      node.addEventListener("load", setDocumentIfReady);
      return () => {
        var _iFrameDocument, _iFrameDocument2;
        node.removeEventListener("load", setDocumentIfReady);
        (_iFrameDocument = iFrameDocument) === null || _iFrameDocument === void 0 ? void 0 : _iFrameDocument.removeEventListener("dragover", preventFileDropDefault);
        (_iFrameDocument2 = iFrameDocument) === null || _iFrameDocument2 === void 0 ? void 0 : _iFrameDocument2.removeEventListener("drop", preventFileDropDefault);
      };
    }, []);
    const headRef = useRefEffect((element) => {
      scripts.reduce((promise, script) => promise.then(() => loadScript(element, script)), Promise.resolve()).finally(() => {
        forceRender();
      });
    }, []);
    const bodyRef = useMergeRefs([contentRef, clearerRef, writingFlowRef]);
    const styleCompatibilityRef = useStylesCompatibility();
    head = (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("style", null, "html{height:auto!important;}body{margin:0}"), styles.map((_ref42) => {
      let {
        tagName,
        href,
        id: id2,
        rel,
        media,
        textContent
      } = _ref42;
      const TagName = tagName.toLowerCase();
      if (TagName === "style") {
        return (0, import_react.createElement)(TagName, {
          id: id2,
          key: id2
        }, textContent);
      }
      return (0, import_react.createElement)(TagName, {
        href,
        id: id2,
        rel,
        media,
        key: id2
      });
    }), head);
    return (0, import_react.createElement)(import_react.Fragment, null, tabIndex >= 0 && before, (0, import_react.createElement)("iframe", _extends({}, props, {
      ref: useMergeRefs([ref2, setRef2]),
      tabIndex,
      srcDoc: "<!doctype html>",
      title: __("Editor canvas")
    }), iframeDocument && (0, import_react_dom.createPortal)((0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("head", {
      ref: headRef
    }, head, (0, import_react.createElement)("style", null, `html { transition: background 5s; ${isZoomedOut ? "background: #2f2f2f; transition: background 0s;" : ""} }`)), (0, import_react.createElement)("body", {
      ref: bodyRef,
      className: (0, import_classnames49.default)("block-editor-iframe__body", BODY_CLASS_NAME, ...bodyClasses, {
        "is-zoomed-out": isZoomedOut
      }),
      style: isZoomedOut ? {
        marginBottom: `-${contentHeight * 0.55 - 100}px`
      } : {}
    }, contentResizeListener, (0, import_react.createElement)("div", {
      style: {
        display: "none"
      },
      ref: styleCompatibilityRef
    }), (0, import_react.createElement)(style_provider_default, {
      document: iframeDocument
    }, children))), iframeDocument.documentElement)), tabIndex >= 0 && after);
  }
  var iframe_default = (0, import_react.forwardRef)(Iframe);

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js
  var import_lodash36 = __toESM(require_lodash());

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/traverse.js
  var import_traverse = __toESM(require_traverse());

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/parse.js
  var commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
  function parse_default(css16, options) {
    options = options || {};
    let lineno = 1;
    let column = 1;
    function updatePosition(str) {
      const lines = str.match(/\n/g);
      if (lines) {
        lineno += lines.length;
      }
      const i5 = str.lastIndexOf("\n");
      column = ~i5 ? str.length - i5 : column + str.length;
    }
    function position() {
      const start2 = {
        line: lineno,
        column
      };
      return function(node) {
        node.position = new Position(start2);
        whitespace();
        return node;
      };
    }
    function Position(start2) {
      this.start = start2;
      this.end = {
        line: lineno,
        column
      };
      this.source = options.source;
    }
    Position.prototype.content = css16;
    const errorsList = [];
    function error2(msg) {
      const err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
      err.reason = msg;
      err.filename = options.source;
      err.line = lineno;
      err.column = column;
      err.source = css16;
      if (options.silent) {
        errorsList.push(err);
      } else {
        throw err;
      }
    }
    function stylesheet() {
      const rulesList = rules();
      return {
        type: "stylesheet",
        stylesheet: {
          source: options.source,
          rules: rulesList,
          parsingErrors: errorsList
        }
      };
    }
    function open() {
      return match(/^{\s*/);
    }
    function close2() {
      return match(/^}/);
    }
    function rules() {
      let node;
      const accumulator = [];
      whitespace();
      comments(accumulator);
      while (css16.length && css16.charAt(0) !== "}" && (node = atrule() || rule())) {
        if (node !== false) {
          accumulator.push(node);
          comments(accumulator);
        }
      }
      return accumulator;
    }
    function match(re) {
      const m4 = re.exec(css16);
      if (!m4) {
        return;
      }
      const str = m4[0];
      updatePosition(str);
      css16 = css16.slice(str.length);
      return m4;
    }
    function whitespace() {
      match(/^\s*/);
    }
    function comments(accumulator) {
      let c6;
      accumulator = accumulator || [];
      while (c6 = comment()) {
        if (c6 !== false) {
          accumulator.push(c6);
        }
      }
      return accumulator;
    }
    function comment() {
      const pos = position();
      if ("/" !== css16.charAt(0) || "*" !== css16.charAt(1)) {
        return;
      }
      let i5 = 2;
      while ("" !== css16.charAt(i5) && ("*" !== css16.charAt(i5) || "/" !== css16.charAt(i5 + 1))) {
        ++i5;
      }
      i5 += 2;
      if ("" === css16.charAt(i5 - 1)) {
        return error2("End of comment missing");
      }
      const str = css16.slice(2, i5 - 2);
      column += 2;
      updatePosition(str);
      css16 = css16.slice(i5);
      column += 2;
      return pos({
        type: "comment",
        comment: str
      });
    }
    function selector4() {
      const m4 = match(/^([^{]+)/);
      if (!m4) {
        return;
      }
      return trim(m4[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(matched) {
        return matched.replace(/,/g, "\u200C");
      }).split(/\s*(?![^(]*\)),\s*/).map(function(s5) {
        return s5.replace(/\u200C/g, ",");
      });
    }
    function declaration() {
      const pos = position();
      let prop2 = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
      if (!prop2) {
        return;
      }
      prop2 = trim(prop2[0]);
      if (!match(/^:\s*/)) {
        return error2("property missing ':'");
      }
      const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
      const ret = pos({
        type: "declaration",
        property: prop2.replace(commentre, ""),
        value: val ? trim(val[0]).replace(commentre, "") : ""
      });
      match(/^[;\s]*/);
      return ret;
    }
    function declarations() {
      const decls = [];
      if (!open()) {
        return error2("missing '{'");
      }
      comments(decls);
      let decl;
      while (decl = declaration()) {
        if (decl !== false) {
          decls.push(decl);
          comments(decls);
        }
      }
      if (!close2()) {
        return error2("missing '}'");
      }
      return decls;
    }
    function keyframe() {
      let m4;
      const vals = [];
      const pos = position();
      while (m4 = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
        vals.push(m4[1]);
        match(/^,\s*/);
      }
      if (!vals.length) {
        return;
      }
      return pos({
        type: "keyframe",
        values: vals,
        declarations: declarations()
      });
    }
    function atkeyframes() {
      const pos = position();
      let m4 = match(/^@([-\w]+)?keyframes\s*/);
      if (!m4) {
        return;
      }
      const vendor = m4[1];
      m4 = match(/^([-\w]+)\s*/);
      if (!m4) {
        return error2("@keyframes missing name");
      }
      const name = m4[1];
      if (!open()) {
        return error2("@keyframes missing '{'");
      }
      let frame2;
      let frames = comments();
      while (frame2 = keyframe()) {
        frames.push(frame2);
        frames = frames.concat(comments());
      }
      if (!close2()) {
        return error2("@keyframes missing '}'");
      }
      return pos({
        type: "keyframes",
        name,
        vendor,
        keyframes: frames
      });
    }
    function atsupports() {
      const pos = position();
      const m4 = match(/^@supports *([^{]+)/);
      if (!m4) {
        return;
      }
      const supports = trim(m4[1]);
      if (!open()) {
        return error2("@supports missing '{'");
      }
      const style = comments().concat(rules());
      if (!close2()) {
        return error2("@supports missing '}'");
      }
      return pos({
        type: "supports",
        supports,
        rules: style
      });
    }
    function athost() {
      const pos = position();
      const m4 = match(/^@host\s*/);
      if (!m4) {
        return;
      }
      if (!open()) {
        return error2("@host missing '{'");
      }
      const style = comments().concat(rules());
      if (!close2()) {
        return error2("@host missing '}'");
      }
      return pos({
        type: "host",
        rules: style
      });
    }
    function atmedia() {
      const pos = position();
      const m4 = match(/^@media *([^{]+)/);
      if (!m4) {
        return;
      }
      const media = trim(m4[1]);
      if (!open()) {
        return error2("@media missing '{'");
      }
      const style = comments().concat(rules());
      if (!close2()) {
        return error2("@media missing '}'");
      }
      return pos({
        type: "media",
        media,
        rules: style
      });
    }
    function atcustommedia() {
      const pos = position();
      const m4 = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
      if (!m4) {
        return;
      }
      return pos({
        type: "custom-media",
        name: trim(m4[1]),
        media: trim(m4[2])
      });
    }
    function atpage() {
      const pos = position();
      const m4 = match(/^@page */);
      if (!m4) {
        return;
      }
      const sel = selector4() || [];
      if (!open()) {
        return error2("@page missing '{'");
      }
      let decls = comments();
      let decl;
      while (decl = declaration()) {
        decls.push(decl);
        decls = decls.concat(comments());
      }
      if (!close2()) {
        return error2("@page missing '}'");
      }
      return pos({
        type: "page",
        selectors: sel,
        declarations: decls
      });
    }
    function atdocument() {
      const pos = position();
      const m4 = match(/^@([-\w]+)?document *([^{]+)/);
      if (!m4) {
        return;
      }
      const vendor = trim(m4[1]);
      const doc = trim(m4[2]);
      if (!open()) {
        return error2("@document missing '{'");
      }
      const style = comments().concat(rules());
      if (!close2()) {
        return error2("@document missing '}'");
      }
      return pos({
        type: "document",
        document: doc,
        vendor,
        rules: style
      });
    }
    function atfontface() {
      const pos = position();
      const m4 = match(/^@font-face\s*/);
      if (!m4) {
        return;
      }
      if (!open()) {
        return error2("@font-face missing '{'");
      }
      let decls = comments();
      let decl;
      while (decl = declaration()) {
        decls.push(decl);
        decls = decls.concat(comments());
      }
      if (!close2()) {
        return error2("@font-face missing '}'");
      }
      return pos({
        type: "font-face",
        declarations: decls
      });
    }
    const atimport = _compileAtrule("import");
    const atcharset = _compileAtrule("charset");
    const atnamespace = _compileAtrule("namespace");
    function _compileAtrule(name) {
      const re = new RegExp("^@" + name + "\\s*([^;]+);");
      return function() {
        const pos = position();
        const m4 = match(re);
        if (!m4) {
          return;
        }
        const ret = {
          type: name
        };
        ret[name] = m4[1].trim();
        return pos(ret);
      };
    }
    function atrule() {
      if (css16[0] !== "@") {
        return;
      }
      return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
    }
    function rule() {
      const pos = position();
      const sel = selector4();
      if (!sel) {
        return error2("selector missing");
      }
      comments();
      return pos({
        type: "rule",
        selectors: sel,
        declarations: declarations()
      });
    }
    return addParent(stylesheet());
  }
  function trim(str) {
    return str ? str.replace(/^\s+|\s+$/g, "") : "";
  }
  function addParent(obj, parent) {
    const isNode = obj && typeof obj.type === "string";
    const childParent = isNode ? obj : parent;
    for (const k3 in obj) {
      const value = obj[k3];
      if (Array.isArray(value)) {
        value.forEach(function(v5) {
          addParent(v5, childParent);
        });
      } else if (value && typeof value === "object") {
        addParent(value, childParent);
      }
    }
    if (isNode) {
      Object.defineProperty(obj, "parent", {
        configurable: true,
        writable: true,
        enumerable: false,
        value: parent || null
      });
    }
    return obj;
  }

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compress.js
  var import_inherits = __toESM(require_inherits_browser());

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compiler.js
  var compiler_default = Compiler;
  function Compiler(opts) {
    this.options = opts || {};
  }
  Compiler.prototype.emit = function(str) {
    return str;
  };
  Compiler.prototype.visit = function(node) {
    return this[node.type](node);
  };
  Compiler.prototype.mapVisit = function(nodes, delim) {
    let buf = "";
    delim = delim || "";
    for (let i5 = 0, length = nodes.length; i5 < length; i5++) {
      buf += this.visit(nodes[i5]);
      if (delim && i5 < length - 1) {
        buf += this.emit(delim);
      }
    }
    return buf;
  };

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compress.js
  var compress_default = Compiler2;
  function Compiler2(options) {
    compiler_default.call(this, options);
  }
  (0, import_inherits.default)(Compiler2, compiler_default);
  Compiler2.prototype.compile = function(node) {
    return node.stylesheet.rules.map(this.visit, this).join("");
  };
  Compiler2.prototype.comment = function(node) {
    return this.emit("", node.position);
  };
  Compiler2.prototype.import = function(node) {
    return this.emit("@import " + node.import + ";", node.position);
  };
  Compiler2.prototype.media = function(node) {
    return this.emit("@media " + node.media, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler2.prototype.document = function(node) {
    const doc = "@" + (node.vendor || "") + "document " + node.document;
    return this.emit(doc, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler2.prototype.charset = function(node) {
    return this.emit("@charset " + node.charset + ";", node.position);
  };
  Compiler2.prototype.namespace = function(node) {
    return this.emit("@namespace " + node.namespace + ";", node.position);
  };
  Compiler2.prototype.supports = function(node) {
    return this.emit("@supports " + node.supports, node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler2.prototype.keyframes = function(node) {
    return this.emit("@" + (node.vendor || "") + "keyframes " + node.name, node.position) + this.emit("{") + this.mapVisit(node.keyframes) + this.emit("}");
  };
  Compiler2.prototype.keyframe = function(node) {
    const decls = node.declarations;
    return this.emit(node.values.join(","), node.position) + this.emit("{") + this.mapVisit(decls) + this.emit("}");
  };
  Compiler2.prototype.page = function(node) {
    const sel = node.selectors.length ? node.selectors.join(", ") : "";
    return this.emit("@page " + sel, node.position) + this.emit("{") + this.mapVisit(node.declarations) + this.emit("}");
  };
  Compiler2.prototype["font-face"] = function(node) {
    return this.emit("@font-face", node.position) + this.emit("{") + this.mapVisit(node.declarations) + this.emit("}");
  };
  Compiler2.prototype.host = function(node) {
    return this.emit("@host", node.position) + this.emit("{") + this.mapVisit(node.rules) + this.emit("}");
  };
  Compiler2.prototype["custom-media"] = function(node) {
    return this.emit("@custom-media " + node.name + " " + node.media + ";", node.position);
  };
  Compiler2.prototype.rule = function(node) {
    const decls = node.declarations;
    if (!decls.length) {
      return "";
    }
    return this.emit(node.selectors.join(","), node.position) + this.emit("{") + this.mapVisit(decls) + this.emit("}");
  };
  Compiler2.prototype.declaration = function(node) {
    return this.emit(node.property + ":" + node.value, node.position) + this.emit(";");
  };

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/identity.js
  var import_inherits2 = __toESM(require_inherits_browser());
  var identity_default = Compiler3;
  function Compiler3(options) {
    options = options || {};
    compiler_default.call(this, options);
    this.indentation = options.indent;
  }
  (0, import_inherits2.default)(Compiler3, compiler_default);
  Compiler3.prototype.compile = function(node) {
    return this.stylesheet(node);
  };
  Compiler3.prototype.stylesheet = function(node) {
    return this.mapVisit(node.stylesheet.rules, "\n\n");
  };
  Compiler3.prototype.comment = function(node) {
    return this.emit(this.indent() + "/*" + node.comment + "*/", node.position);
  };
  Compiler3.prototype.import = function(node) {
    return this.emit("@import " + node.import + ";", node.position);
  };
  Compiler3.prototype.media = function(node) {
    return this.emit("@media " + node.media, node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler3.prototype.document = function(node) {
    const doc = "@" + (node.vendor || "") + "document " + node.document;
    return this.emit(doc, node.position) + this.emit("  {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler3.prototype.charset = function(node) {
    return this.emit("@charset " + node.charset + ";", node.position);
  };
  Compiler3.prototype.namespace = function(node) {
    return this.emit("@namespace " + node.namespace + ";", node.position);
  };
  Compiler3.prototype.supports = function(node) {
    return this.emit("@supports " + node.supports, node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler3.prototype.keyframes = function(node) {
    return this.emit("@" + (node.vendor || "") + "keyframes " + node.name, node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.keyframes, "\n") + this.emit(this.indent(-1) + "}");
  };
  Compiler3.prototype.keyframe = function(node) {
    const decls = node.declarations;
    return this.emit(this.indent()) + this.emit(node.values.join(", "), node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(decls, "\n") + this.emit(this.indent(-1) + "\n" + this.indent() + "}\n");
  };
  Compiler3.prototype.page = function(node) {
    const sel = node.selectors.length ? node.selectors.join(", ") + " " : "";
    return this.emit("@page " + sel, node.position) + this.emit("{\n") + this.emit(this.indent(1)) + this.mapVisit(node.declarations, "\n") + this.emit(this.indent(-1)) + this.emit("\n}");
  };
  Compiler3.prototype["font-face"] = function(node) {
    return this.emit("@font-face ", node.position) + this.emit("{\n") + this.emit(this.indent(1)) + this.mapVisit(node.declarations, "\n") + this.emit(this.indent(-1)) + this.emit("\n}");
  };
  Compiler3.prototype.host = function(node) {
    return this.emit("@host", node.position) + this.emit(" {\n" + this.indent(1)) + this.mapVisit(node.rules, "\n\n") + this.emit(this.indent(-1) + "\n}");
  };
  Compiler3.prototype["custom-media"] = function(node) {
    return this.emit("@custom-media " + node.name + " " + node.media + ";", node.position);
  };
  Compiler3.prototype.rule = function(node) {
    const indent = this.indent();
    const decls = node.declarations;
    if (!decls.length) {
      return "";
    }
    return this.emit(node.selectors.map(function(s5) {
      return indent + s5;
    }).join(",\n"), node.position) + this.emit(" {\n") + this.emit(this.indent(1)) + this.mapVisit(decls, "\n") + this.emit(this.indent(-1)) + this.emit("\n" + this.indent() + "}");
  };
  Compiler3.prototype.declaration = function(node) {
    return this.emit(this.indent()) + this.emit(node.property + ": " + node.value, node.position) + this.emit(";");
  };
  Compiler3.prototype.indent = function(level) {
    this.level = this.level || 1;
    if (null !== level) {
      this.level += level;
      return "";
    }
    return Array(this.level).join(this.indentation || "  ");
  };

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/index.js
  function stringify_default2(node, options) {
    options = options || {};
    const compiler = options.compress ? new compress_default(options) : new identity_default(options);
    const code = compiler.compile(node);
    return code;
  }

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/traverse.js
  function traverseCSS(css16, callback) {
    try {
      const parsed = parse_default(css16);
      const updated = import_traverse.default.map(parsed, function(node) {
        if (!node) {
          return node;
        }
        const updatedNode = callback(node);
        return this.update(updatedNode);
      });
      return stringify_default2(updated);
    } catch (err) {
      console.warn("Error while traversing the CSS: " + err);
      return null;
    }
  }
  var traverse_default = traverseCSS;

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/url-rewrite.js
  function isRemotePath(filePath) {
    return /^(?:https?:)?\/\//.test(filePath);
  }
  function isAbsolutePath(filePath) {
    return /^\/(?!\/)/.test(filePath);
  }
  function isValidURL(meta) {
    if (meta.value.indexOf("data:") === 0 || meta.value.indexOf("#") === 0) {
      return false;
    }
    if (isAbsolutePath(meta.value)) {
      return false;
    }
    if (isRemotePath(meta.value)) {
      return false;
    }
    return true;
  }
  function getResourcePath(str, baseURL) {
    return new URL(str, baseURL).toString();
  }
  function processURL(baseURL) {
    return (meta) => ({
      ...meta,
      newUrl: "url(" + meta.before + meta.quote + getResourcePath(meta.value, baseURL) + meta.quote + meta.after + ")"
    });
  }
  function getURLs(value) {
    const reg = /url\((\s*)(['"]?)(.+?)\2(\s*)\)/g;
    let match;
    const URLs = [];
    while ((match = reg.exec(value)) !== null) {
      const meta = {
        source: match[0],
        before: match[1],
        quote: match[2],
        value: match[3],
        after: match[4]
      };
      if (isValidURL(meta)) {
        URLs.push(meta);
      }
    }
    return URLs;
  }
  function replaceURLs(raw, URLs) {
    URLs.forEach((item2) => {
      raw = raw.replace(item2.source, item2.newUrl);
    });
    return raw;
  }
  var rewrite = (rootURL) => (node) => {
    if (node.type === "declaration") {
      const updatedURLs = getURLs(node.value).map(processURL(rootURL));
      return {
        ...node,
        value: replaceURLs(node.value, updatedURLs)
      };
    }
    return node;
  };
  var url_rewrite_default = rewrite;

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/wrap.js
  var IS_ROOT_TAG = /^(body|html|:root).*$/;
  var wrap2 = function(namespace) {
    let ignore = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return (node) => {
      const updateSelector = (selector4) => {
        if (ignore.includes(selector4.trim())) {
          return selector4;
        }
        {
          if (!selector4.match(IS_ROOT_TAG)) {
            return namespace + " " + selector4;
          }
        }
        return selector4.replace(/^(body|html|:root)/, namespace);
      };
      if (node.type === "rule") {
        return {
          ...node,
          selectors: node.selectors.map(updateSelector)
        };
      }
      return node;
    };
  };
  var wrap_default = wrap2;

  // node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js
  var transformStyles = function(styles) {
    let wrapperClassName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return (0, import_lodash36.map)(styles, (_ref8) => {
      let {
        css: css16,
        baseURL
      } = _ref8;
      const transforms = [];
      if (wrapperClassName) {
        transforms.push(wrap_default(wrapperClassName));
      }
      if (baseURL) {
        transforms.push(url_rewrite_default(baseURL));
      }
      if (transforms.length) {
        return traverse_default(css16, compose_default(transforms));
      }
      return css16;
    });
  };
  var transform_styles_default = transformStyles;

  // node_modules/@wordpress/block-editor/build-module/components/editor-styles/index.js
  var EDITOR_STYLES_SELECTOR = ".editor-styles-wrapper";
  k([names_default, a11y_default]);
  function useDarkThemeBodyClassName(styles) {
    return (0, import_react.useCallback)((node) => {
      if (!node) {
        return;
      }
      const {
        ownerDocument
      } = node;
      const {
        defaultView,
        body
      } = ownerDocument;
      const canvas = ownerDocument.querySelector(EDITOR_STYLES_SELECTOR);
      let backgroundColor;
      if (!canvas) {
        const tempCanvas = ownerDocument.createElement("div");
        tempCanvas.classList.add("editor-styles-wrapper");
        body.appendChild(tempCanvas);
        backgroundColor = defaultView.getComputedStyle(tempCanvas, null).getPropertyValue("background-color");
        body.removeChild(tempCanvas);
      } else {
        backgroundColor = defaultView.getComputedStyle(canvas, null).getPropertyValue("background-color");
      }
      const colordBackgroundColor = w(backgroundColor);
      if (colordBackgroundColor.luminance() > 0.5 || colordBackgroundColor.alpha() === 0) {
        body.classList.remove("is-dark-theme");
      } else {
        body.classList.add("is-dark-theme");
      }
    }, [styles]);
  }
  function EditorStyles(_ref8) {
    let {
      styles
    } = _ref8;
    const transformedStyles = (0, import_react.useMemo)(() => transform_styles_default(styles, EDITOR_STYLES_SELECTOR), [styles]);
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("style", {
      ref: useDarkThemeBodyClassName(styles)
    }), transformedStyles.map((css16, index2) => (0, import_react.createElement)("style", {
      key: index2
    }, css16)));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-preview/auto.js
  var MemoizedBlockList;
  var MAX_HEIGHT = 2e3;
  function ScaledBlockPreview(_ref8) {
    let {
      viewportWidth,
      containerWidth,
      __experimentalPadding,
      __experimentalMinHeight
    } = _ref8;
    const [contentResizeListener, {
      height: contentHeight
    }] = useResizeAware();
    const {
      styles,
      assets,
      duotone
    } = useSelect((select2) => {
      var _settings$__experimen, _settings$__experimen2;
      const settings2 = select2(store3).getSettings();
      return {
        styles: settings2.styles,
        assets: settings2.__unstableResolvedAssets,
        duotone: (_settings$__experimen = settings2.__experimentalFeatures) === null || _settings$__experimen === void 0 ? void 0 : (_settings$__experimen2 = _settings$__experimen.color) === null || _settings$__experimen2 === void 0 ? void 0 : _settings$__experimen2.duotone
      };
    }, []);
    const editorStyles = (0, import_react.useMemo)(() => {
      if (styles) {
        return [...styles, {
          css: "body{height:auto;overflow:hidden;}",
          __unstableType: "presets"
        }];
      }
      return styles;
    }, [styles]);
    const svgFilters = (0, import_react.useMemo)(() => {
      var _duotone$default, _duotone$theme;
      return [...(_duotone$default = duotone === null || duotone === void 0 ? void 0 : duotone.default) !== null && _duotone$default !== void 0 ? _duotone$default : [], ...(_duotone$theme = duotone === null || duotone === void 0 ? void 0 : duotone.theme) !== null && _duotone$theme !== void 0 ? _duotone$theme : []];
    }, [duotone]);
    MemoizedBlockList = MemoizedBlockList || pure_default(BlockList);
    const scale2 = containerWidth / viewportWidth;
    return (0, import_react.createElement)(disabled_default, {
      className: "block-editor-block-preview__content",
      style: {
        transform: `scale(${scale2})`,
        height: contentHeight * scale2,
        maxHeight: contentHeight > MAX_HEIGHT ? MAX_HEIGHT * scale2 : void 0,
        minHeight: __experimentalMinHeight
      }
    }, (0, import_react.createElement)(
      iframe_default,
      {
        head: (0, import_react.createElement)(EditorStyles, {
          styles: editorStyles
        }),
        assets,
        contentRef: useRefEffect((bodyElement) => {
          const {
            ownerDocument: {
              documentElement
            }
          } = bodyElement;
          documentElement.classList.add("block-editor-block-preview__content-iframe");
          documentElement.style.position = "absolute";
          documentElement.style.width = "100%";
          bodyElement.style.padding = __experimentalPadding + "px";
          bodyElement.style.boxSizing = "border-box";
          bodyElement.style.position = "absolute";
          bodyElement.style.width = "100%";
        }, []),
        "aria-hidden": true,
        tabIndex: -1,
        style: {
          position: "absolute",
          width: viewportWidth,
          height: contentHeight,
          pointerEvents: "none",
          maxHeight: MAX_HEIGHT,
          minHeight: scale2 !== 0 && scale2 < 1 && __experimentalMinHeight ? __experimentalMinHeight / scale2 : __experimentalMinHeight
        }
      },
      contentResizeListener,
      svgFilters.map((preset) => (0, import_react.createElement)(PresetDuotoneFilter, {
        preset,
        key: preset.slug
      })),
      (0, import_react.createElement)(MemoizedBlockList, {
        renderAppender: false
      })
    ));
  }
  function AutoBlockPreview(props) {
    const [containerResizeListener, {
      width: containerWidth
    }] = useResizeAware();
    return (0, import_react.createElement)(import_react.Fragment, null, (0, import_react.createElement)("div", {
      style: {
        position: "relative",
        width: "100%",
        height: 0
      }
    }, containerResizeListener), (0, import_react.createElement)("div", {
      className: "block-editor-block-preview__container"
    }, !!containerWidth && (0, import_react.createElement)(ScaledBlockPreview, _extends({}, props, {
      containerWidth
    }))));
  }

  // node_modules/@wordpress/block-editor/build-module/components/block-preview/index.js
  function BlockPreview(_ref8) {
    let {
      blocks: blocks2,
      __experimentalPadding = 0,
      viewportWidth = 1200,
      __experimentalLive = false,
      __experimentalOnClick,
      __experimentalMinHeight
    } = _ref8;
    const originalSettings = useSelect((select2) => select2(store3).getSettings(), []);
    const settings2 = (0, import_react.useMemo)(() => ({
      ...originalSettings,
      __unstableIsPreviewMode: true
    }), [originalSettings]);
    const renderedBlocks = (0, import_react.useMemo)(() => Array.isArray(blocks2) ? blocks2 : [blocks2], [blocks2]);
    if (!blocks2 || blocks2.length === 0) {
      return null;
    }
    return (0, import_react.createElement)(provider_default, {
      value: renderedBlocks,
      settings: settings2
    }, __experimentalLive ? (0, import_react.createElement)(LiveBlockPreview, {
      onClick: __experimentalOnClick
    }) : (0, import_react.createElement)(AutoBlockPreview, {
      viewportWidth,
      __experimentalPadding,
      __experimentalMinHeight
    }));
  }
  var block_preview_default = (0, import_react.memo)(BlockPreview);

  // node_modules/@wordpress/block-editor/build-module/components/inserter/preview-panel.js
  function InserterPreviewPanel(_ref8) {
    var _example$viewportWidt;
    let {
      item: item2
    } = _ref8;
    const {
      name,
      title,
      icon,
      description,
      initialAttributes,
      example
    } = item2;
    const isReusable = isReusableBlock(item2);
    return (0, import_react.createElement)("div", {
      className: "block-editor-inserter__preview-container"
    }, (0, import_react.createElement)("div", {
      className: "block-editor-inserter__preview"
    }, isReusable || example ? (0, import_react.createElement)("div", {
      className: "block-editor-inserter__preview-content"
    }, (0, import_react.createElement)(block_preview_default, {
      __experimentalPadding: 16,
      viewportWidth: (_example$viewportWidt = example === null || example === void 0 ? void 0 : example.viewportWidth) !== null && _example$viewportWidt !== void 0 ? _example$viewportWidt : 500,
      blocks: example ? getBlockFromExample(name, {
        attributes: {
          ...example.attributes,
          ...initialAttributes
        },
        innerBlocks: example.innerBlocks
      }) : createBlock(name, initialAttributes)
    })) : (0, import_react.createElement)("div", {
      className: "block-editor-inserter__preview-content-missing"
    }, __("No Preview Available."))), !isReusable && (0, import_react.createElement)(block_card_default, {
      title,
      icon,
      description
    }));
  }
  var preview_panel_default = InserterPreviewPanel;

  // node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/icons.js
  var alignBottom = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z"
  }));
  var alignCenter = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z"
  }));
  var alignTop = (0, import_react.createElement)(SVG, {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, (0, import_react.createElement)(Path, {
    d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z"
  }));

  // node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/ui.js
  var BLOCK_ALIGNMENTS_CONTROLS = {
    top: {
      icon: alignTop,
      title: _x("Align top", "Block vertical alignment setting")
    },
    center: {
      icon: alignCenter,
      title: _x("Align middle", "Block vertical alignment setting")
    },
    bottom: {
      icon: alignBottom,
      title: _x("Align bottom", "Block vertical alignment setting")
    }
  };
  var DEFAULT_CONTROLS = ["top", "center", "bottom"];
  var DEFAULT_CONTROL = "top";
  var POPOVER_PROPS2 = {
    variant: "toolbar"
  };
  function BlockVerticalAlignmentUI(_ref8) {
    let {
      value,
      onChange,
      controls = DEFAULT_CONTROLS,
      isCollapsed = true,
      isToolbar
    } = _ref8;
    function applyOrUnset(align) {
      return () => onChange(value === align ? void 0 : align);
    }
    const activeAlignment = BLOCK_ALIGNMENTS_CONTROLS[value];
    const defaultAlignmentControl = BLOCK_ALIGNMENTS_CONTROLS[DEFAULT_CONTROL];
    const UIComponent = isToolbar ? toolbar_group_default : toolbar_dropdown_menu_default;
    const extraProps = isToolbar ? {
      isCollapsed
    } : {
      popoverProps: {
        POPOVER_PROPS: POPOVER_PROPS2
      }
    };
    return (0, import_react.createElement)(UIComponent, _extends({
      icon: activeAlignment ? activeAlignment.icon : defaultAlignmentControl.icon,
      label: _x("Change vertical alignment", "Block vertical alignment setting label"),
      controls: controls.map((control) => {
        return {
          ...BLOCK_ALIGNMENTS_CONTROLS[control],
          isActive: value === control,
          role: isCollapsed ? "menuitemradio" : void 0,
          onClick: applyOrUnset(control)
        };
      })
    }, extraProps));
  }
  var ui_default = BlockVerticalAlignmentUI;

  // node_modules/@wordpress/block-editor/build-module/components/block-vertical-alignment-control/index.js
  var BlockVerticalAlignmentControl = (props) => {
    return (0, import_react.createElement)(ui_default, _extends({}, props, {
      isToolbar: false
    }));
  };

  // node_modules/@wordpress/block-editor/build-module/components/justify-content-control/ui.js
  var icons = {
    left: justify_left_default,
    center: justify_center_default,
    right: justify_right_default,
    "space-between": justify_space_between_default
  };
  function JustifyContentUI(_ref8) {
    let {
      allowedControls = ["left", "center", "right", "space-between"],
      isCollapsed = true,
      onChange,
      value,
      popoverProps,
      isToolbar
    } = _ref8;
    const handleClick = (next2) => {
      if (next2 === value) {
        onChange(void 0);
      } else {
        onChange(next2);
      }
    };
    const icon = value ? icons[value] : icons.left;
    const allControls = [{
      name: "left",
      icon: justify_left_default,
      title: __("Justify items left"),
      isActive: "left" === value,
      onClick: () => handleClick("left")
    }, {
      name: "center",
      icon: justify_center_default,
      title: __("Justify items center"),
      isActive: "center" === value,
      onClick: () => handleClick("center")
    }, {
      name: "right",
      icon: justify_right_default,
      title: __("Justify items right"),
      isActive: "right" === value,
      onClick: () => handleClick("right")
    }, {
      name: "space-between",
      icon: justify_space_between_default,
      title: __("Space between items"),
      isActive: "space-between" === value,
      onClick: () => handleClick("space-between")
    }];
    const UIComponent = isToolbar ? toolbar_group_default : toolbar_dropdown_menu_default;
    const extraProps = isToolbar ? {
      isCollapsed
    } : {};
    return (0, import_react.createElement)(UIComponent, _extends({
      icon,
      popoverProps,
      label: __("Change items justification"),
      controls: allControls.filter((elem) => allowedControls.includes(elem.name))
    }, extraProps));
  }
  var ui_default2 = JustifyContentUI;

  // node_modules/@wordpress/block-editor/build-module/components/justify-content-control/index.js
  var JustifyContentControl = (props) => {
    return (0, import_react.createElement)(ui_default2, _extends({}, props, {
      isToolbar: false
    }));
  };

  // blocks.js
  var blockProps = useBlockProps2();
  var blocks_default = () => {
    const ALLOWED_BLOCKS = ["core/image", "core/paragraph"];
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      ...blockProps
    }, /* @__PURE__ */ React.createElement(inner_blocks_default, {
      allowedBlocks: ALLOWED_BLOCKS
    })));
  };

  // gutenfleet.js
  var { registerBlockType: registerBlockType2 } = wp.blocks;
  registerBlockType2("gutenfleet/container-block", {
    title: "gutenfleet flex container",
    icon: "image-rotate-left",
    category: "design",
    attributes: {},
    edit(props) {
      const blockProps2 = useBlockProps();
      const ALLOWED_BLOCKS = ["core/image", "core/paragraph"];
      return blocks_default();
    },
    save(props) {
    }
  });
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/
/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT  Zeno Rocha
 */
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! showdown v 1.9.1 - 02-11-2019 */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
